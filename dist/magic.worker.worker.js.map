{"version":3,"file":"magic.worker.worker.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,uCAAuC;AACvC,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kCAAkC;AAClC,iCAAiC;AACjC;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kCAAkC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iBAAiB,KAAK,cAAc;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,0CAA0C;AAC1C;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,oCAAoC,cAAc;AAClD,kBAAkB;AAClB;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qCAAqC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,wCAAwC;AACxC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,sGAAsG;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,kFAAkF;AAClF,+CAA+C;AAC/C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qEAAe;;AC9pB6B;AAC5C;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB,oDAAoD;AAC7E;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA,4BAA4B,8BAAc;AAC1C;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yBAAyB;AAC9D;AACA,UAAU;AACV;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2BAA2B;AACzE,yDAAyD;AACzD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,cAAc;AACd;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,kBAAkB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,wCAAwC;AACxC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,sGAAsG;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,kFAAkF;AAClF,+CAA+C;AAC/C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uEAAe;;ACllBf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEC;AAEO,MAAMC,MAAN,CAAa;AAChBC,EAAAA,WAAW,CAACC,OAAO,GAACC,SAAT,EAAoB;AAE3B,SAAKC,KAAL,GAAa,IAAIL,YAAJ,CAAiB,EAAjB,EAAoBI,SAApB,EAA8B,KAA9B,CAAb,CAF2B,CAEwB;;AACnD,SAAKD,OAAL,GAAeA,OAAf;;AAEA,QAAGA,OAAO,KAAKC,SAAf,EAA0B;AAAE;AACzB,UAAIE,KAAK,GAAGH,OAAO,CAACI,SAAR,CAAkBC,IAAlB,CAAwBC,GAAD,IAAS;AACxC,YAAGA,GAAG,CAACC,IAAJ,KAAa,cAAhB,EAAgC,OAAO,IAAP;AACnC,OAFW,CAAZ;;AAGA,UAAG,CAACJ,KAAJ,EAAW;AACPH,QAAAA,OAAO,CAACQ,WAAR,CAAoB,cAApB,EAAmC,KAAKC,QAAxC;AACH;AACH;AAEJ,GAfe,CAiBhB;;;AACAC,EAAAA,QAAQ,CAACC,SAAD,EAAYC,QAAQ,GAAEC,MAAD,IAAU;AAACC,IAAAA,OAAO,CAACC,GAAR,CAAYJ,SAAZ,EAAsBE,MAAtB;AAA+B,GAA/D,EAAiE;AACrE,WAAO,KAAKX,KAAL,CAAWc,gBAAX,CAA4BL,SAA5B,EAAsCC,QAAtC,CAAP;AACH;;AAEDK,EAAAA,UAAU,CAACN,SAAD,EAAYO,GAAZ,EAAiB;AACvB,WAAO,KAAKhB,KAAL,CAAWiB,kBAAX,CAA8BR,SAA9B,EAAwCO,GAAxC,CAAP;AACH,GAxBe,CA0BhB;;;AACc,QAARE,QAAQ,CAACT,SAAD,EAAWU,QAAQ,GAACpB,SAApB,EAA8BqB,YAAY,GAACrB,SAA3C,EAAqDsB,MAAM,GAACtB,SAA5D,EAAuE;AACjF,SAAKC,KAAL,CAAWsB,QAAX,CAAoB;AAAC,OAACb,SAAD,GAAYV;AAAb,KAApB;;AACA,QAAG,KAAKD,OAAL,KAAiBC,SAApB,EAA+B;AAC3B,UAAGsB,MAAM,KAAKtB,SAAX,IAAwBqB,YAAY,KAAKrB,SAA5C,EAAuD;AACnD,YAAGoB,QAAQ,KAAKpB,SAAhB,EAA2B;AACxB,iBAAO,MAAM,KAAKD,OAAL,CAAayB,IAAb,CAAkB;AAACF,YAAAA,MAAM,EAACA,MAAR;AAAejB,YAAAA,GAAG,EAAC,UAAnB;AAA8BoB,YAAAA,KAAK,EAAC,CAACf,SAAD,EAAWW,YAAX;AAApC,WAAlB,EAAgFD,QAAhF,CAAb;AACF,SAFD,MAEO;AACJ,eAAKrB,OAAL,CAAa2B,OAAb,CAAqBC,OAArB,CAA8BC,CAAD,IAAK;AAC9B,iBAAK7B,OAAL,CAAayB,IAAb,CAAkB;AAACF,cAAAA,MAAM,EAACA,MAAR;AAAejB,cAAAA,GAAG,EAAC,UAAnB;AAA8BoB,cAAAA,KAAK,EAAC,CAACf,SAAD,EAAWW,YAAX;AAApC,aAAlB,EAAgFO,CAAC,CAACC,EAAlF,EAD8B,CACyD;AAC1F,WAFD;AAGA,iBAAO,IAAP;AACF;AACJ;AACJ;AACJ,GAzCe,CA2ChB;;;AACAC,EAAAA,aAAa,CAACpB,SAAD,EAAY;AACrB,SAAKT,KAAL,CAAW8B,sBAAX,CAAkCrB,SAAlC;AACH,GA9Ce,CAgDhB;;;AACAsB,EAAAA,IAAI,GAAG,CAACtB,SAAD,EAAYe,KAAZ,EAAmBL,QAAQ,GAACpB,SAA5B,EAAsCiC,QAAQ,GAACjC,SAA/C,EAAyDkC,IAAI,GAAClC,SAA9D,KAA4E;AAChF,QAAIY,MAAM,GAAG;AAACF,MAAAA,SAAS,EAACA,SAAX;AAAsBE,MAAAA,MAAM,EAACa;AAA7B,KAAb;AAEA,QAAG,CAACA,KAAD,IAAU,CAACf,SAAd,EAAyB;;AACzB,QAAI,KAAKX,OAAL,KAAiBC,SAArB,EAAgC;AAAE;AAC9B,UAAGoB,QAAQ,KAAKpB,SAAhB,EAA2B,KAAKD,OAAL,CAAayB,IAAb,CAAkBZ,MAAlB,EAAyBQ,QAAzB,EAAkCa,QAAlC,EAA3B,KACK;AAAC,aAAKlC,OAAL,CAAa2B,OAAb,CAAqBC,OAArB,CAA8BC,CAAD,IAAK;AAAC,eAAK7B,OAAL,CAAayB,IAAb,CAAkBZ,MAAlB,EAAyBgB,CAAC,CAACC,EAA3B,EAA8BI,QAA9B;AAAyC,SAA5E;AAA+E;AACxF,KAHD,MAGO,IAAI,OAAOE,iBAAP,KAA6B,WAA7B,IAA4CC,IAAI,YAAYD,iBAAhE,EAAmF;AACtF;AACA;AACA,UAAGD,IAAH,EAASA,IAAI,CAACG,WAAL,CAAiBzB,MAAjB,EAAwBZ,SAAxB,EAAkCiC,QAAlC,EAAT,KACKK,UAAU,CAACD,WAAX,CAAuBzB,MAAvB,EAA8BZ,SAA9B,EAAwCiC,QAAxC,EAJiF,CAI9B;AAC3D;;AACD,SAAKhC,KAAL,CAAWsB,QAAX,CAAoB;AAAC,OAACb,SAAD,GAAYe;AAAb,KAApB,EAbgF,CAatC;AAC5C,GAdG;AAgBLjB,EAAAA,QAAQ,GAAI+B,GAAD,IAAS;AAChB,QAAG,OAAOA,GAAP,KAAe,QAAlB,EAA4B;AACxB,UAAGA,GAAG,CAAC7B,SAAJ,KAAkBV,SAAlB,IAA+BuC,GAAG,CAAC3B,MAAJ,KAAeZ,SAAjD,EAA4D;AACxD,aAAKC,KAAL,CAAWsB,QAAX,CAAoB;AAAC,WAACgB,GAAG,CAAC7B,SAAL,GAAgB6B,GAAG,CAAC3B;AAArB,SAApB;AACH;AACJ;AACJ,GANO;AAQR4B,EAAAA,MAAM,GAAG,MAAM;AACX,WAAO,IAAP;AACH,GAFK;AAzEW;;;;;;;;;;;;;ACfZ,IAAIC,aAAa,GAAG,MAAOC,GAAP,IAAe;AACxC,MAAIC,MAAM,GAAG,MAAM,yBAAOD,GAAP,CAAnB;AACA,SAAOC,MAAP;AACD,CAHM,EAKP;;AACO,SAASC,eAAT,CAAyBC,YAAzB,EAAuC;AAC5C,SAAOA,YAAY,CAACC,QAAb,GAAwBC,OAAxB,CAAgC,yEAAhC,EAA2G,QAA3G,CAAP;AACD;AAEM,SAASC,eAAT,CAAyBH,YAAzB,EAAuC;AAC5C,MAAII,QAAQ,GAAGJ,YAAY,CAACC,QAAb,EAAf;AACA,SAAOG,QAAQ,CAACC,KAAT,CAAe,CAAf,EAAkBD,QAAQ,CAACE,OAAT,CAAiB,GAAjB,IAAwB,CAA1C,CAAP;AACD;AAEM,SAASC,gBAAT,CAA0BC,IAA1B,EAAgCC,IAAhC,EAAsC;AAC3C,MAAIC,OAAO,GAAGC,IAAI,CAACH,IAAI,GAAGC,IAAP,GAAc,GAAf,CAAlB;AACA,SAAOC,OAAP;AACD;AAEM,SAASE,UAAT,CAAoBC,MAApB,EAA4B;AACjC,MAAIC,KAAK,GAAG,IAAIC,MAAJ,CAAW,uDAAX,CAAZ;AACA,MAAIC,IAAI,GAAI,OAAOH,MAAP,KAAkB,QAAnB,GAA+BA,MAAM,CAACI,SAAP,CAAiB,CAAjB,EAAmB,EAAnB,EAAuBC,QAAvB,CAAgC,UAAhC,CAA/B,GAA6E,KAAxF;AACA,MAAIC,KAAK,GAAI,OAAON,MAAP,KAAkB,QAAnB,GAA+BC,KAAK,CAACM,IAAN,CAAWP,MAAX,CAA/B,GAAoD,KAAhE;AACA,MAAGG,IAAI,IAAIG,KAAX,EAAkB,OAAO,IAAP,CAAlB,KACK,OAAO,KAAP;AACN;AAEM,SAASE,qBAAT,CAA+BC,MAA/B,EAAuC;AAC5C;AACA,MAAIvB,eAAe,GAAIC,YAAD,IAAkB;AACtC,WAAOA,YAAY,CAACE,OAAb,CAAqB,yEAArB,EAAgG,QAAhG,CAAP;AACD,GAFD;;AAIA,MAAIC,eAAe,GAAIH,YAAD,IAAkB;AACtC,QAAIuB,UAAU,GAAGvB,YAAY,CAACM,OAAb,CAAqB,GAArB,CAAjB;AACA,WAAON,YAAY,CAACK,KAAb,CAAmB,CAAnB,EAAsBL,YAAY,CAACM,OAAb,CAAqB,GAArB,EAAyBiB,UAAzB,IAAuC,CAA7D,CAAP;AACD,GAHD;;AAKA,MAAIC,WAAW,GAAGrB,eAAe,CAACmB,MAAD,CAAjC;AACA,MAAIG,WAAW,GAAG1B,eAAe,CAACuB,MAAD,CAAjC;AAEA,MAAIZ,OAAJ;;AACA,MAAIc,WAAW,CAACN,QAAZ,CAAqB,WAArB,CAAJ,EAAuC;AACrC,QAAIQ,OAAO,GAAGF,WAAW,CAACG,KAAZ,CAAkB,GAAlB,EAAuB,CAAvB,EAA0BA,KAA1B,CAAgC,GAAhC,EAAqC,CAArC,CAAd;AACAjB,IAAAA,OAAO,GAAG,IAAIkB,QAAJ,CAAaF,OAAb,EAAsBD,WAAtB,CAAV;AACD,GAHD,MAGO;AACL,QAAGD,WAAW,CAACP,SAAZ,CAAsB,CAAtB,EAAwB,CAAxB,MAA+BQ,WAAW,CAACR,SAAZ,CAAsB,CAAtB,EAAwB,CAAxB,CAAlC,EAA8D;AAC5D;AACA,UAAIS,OAAO,GAAGF,WAAW,CAACG,KAAZ,CAAkB,GAAlB,EAAuB,CAAvB,EAA0BA,KAA1B,CAAgC,GAAhC,EAAqC,CAArC,CAAd,CAF4D,CAG5D;;AACAjB,MAAAA,OAAO,GAAG,IAAIkB,QAAJ,CAAaF,OAAb,EAAsBD,WAAW,CAACR,SAAZ,CAAsBQ,WAAW,CAACnB,OAAZ,CAAoB,GAApB,IAAyB,CAA/C,EAAiDmB,WAAW,CAACI,MAAZ,GAAmB,CAApE,CAAtB,CAAV;AACD,KALD,MAMKnB,OAAO,GAAGC,IAAI,CAACa,WAAW,GAAGC,WAAd,GAA4B,GAA7B,CAAd;AACN;;AAED,SAAOf,OAAP;AAED;;;;;;;;;;;;AC1DH;AAEA;AAEO,MAAMqB,SAAN,CAAgB;AAEnB9E,EAAAA,WAAW,CAAC+E,eAAD,EAAkB;AAEzB,SAAKA,eAAL,GAAuBA,eAAvB;AAEAA,IAAAA,eAAe,CAACF,KAAhB,GAAwBA,6DAAxB,CAJyB,CAIM;;AAE/B,SAAKG,SAAL,GAAiB,CACb;AACIC,MAAAA,IAAI,EAAE,MADV;AACkBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAC9C,eAAOqD,+FAAA,CAAuB,GAAGK,IAA1B,CAAP;AACD;AAHL,KADa,EAMb;AACID,MAAAA,IAAI,EAAE,SADV;AACqBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AACjD,eAAOqD,6FAAA,CAAsBK,IAAtB,CAAP;AACD;AAHL,KANa,EAWb;AACID,MAAAA,IAAI,EAAE,OADV;AACmBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAC/C,eAAOqD,yEAAA,CAAY,GAAGK,IAAf,CAAP;AACD;AAHL,KAXa,EAgBb;AACID,MAAAA,IAAI,EAAE,OADV;AACmBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAC/C,eAAOqD,yEAAA,CAAYK,IAAZ,CAAP;AACD;AAHL,KAhBa,EAqBb;AACID,MAAAA,IAAI,EAAE,KADV;AACiBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAC7C,eAAOqD,qEAAA,CAAU,GAAGK,IAAb,CAAP;AACD;AAHL,KArBa,CAyBX;AAzBW,KAAjB;AA4BA,SAAKM,YAAL;AAEH;;AAEDA,EAAAA,YAAY,CAACR,SAAS,GAAG,KAAKA,SAAlB,EAA6B;AACrCA,IAAAA,SAAS,CAACnD,OAAV,CAAmB4D,EAAD,IAAQ;AACtB,WAAKV,eAAL,CAAqBtE,WAArB,CAAiCgF,EAAE,CAACR,IAApC,EAA0CQ,EAAE,CAAC/E,QAA7C;;AACA,UAAG+E,EAAE,CAACC,OAAN,EAAe;AACXD,QAAAA,EAAE,CAACC,OAAH,CAAW7D,OAAX,CAAoB8D,CAAD,IAAO;AACtB,eAAKZ,eAAL,CAAqBtE,WAArB,CAAiCkF,CAAjC,EAAoCF,EAAE,CAAC/E,QAAvC;AACH,SAFD;AAGH;AACJ,KAPD;AAQH;;AAjDkB;;;;;;;;;;;;;;;;ACJvB;CAIA;;AACA;AACA;AACA;AAEO,MAAMoF,eAAN,CAAsB;AAE3BC,EAAAA,MAAM;AACNC,EAAAA,GAAG;AACHC,EAAAA,OAAO;;AAEPjG,EAAAA,WAAW,CACTkG,OAAO,GAAC;AACNC,IAAAA,GAAG,EAAC,IADE;AAENC,IAAAA,GAAG,EAAC,IAFE;AAGNC,IAAAA,QAAQ,EAAC;AAHH,GADC,EAMT;AAEA,SAAKC,MAAL,GAAc,IAAIvG,4DAAJ,EAAd;AACA,SAAKwG,aAAL,GAAqB,EAArB;AAGA,SAAKC,EAAL,GAAUC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAc,IAAzB,CAAV,CANA,CAM0C;AAG1C;AACA;AACA;;AAEA,SAAKC,gBAAL,GAAwB,CACtB;AAAE;AACA3B,MAAAA,IAAI,EAAE,MADR;AACgBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAC9C,eAAO,MAAP;AACD;AAHH,KADsB,EAMtB;AAAE;AACAyD,MAAAA,IAAI,EAAE,MADR;AACgBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAC9C,YAAIqF,IAAI,GAAG,EAAX;AACA,aAAK7B,SAAL,CAAenD,OAAf,CAAuB,CAACnB,QAAD,EAAUF,IAAV,KAAmB;AACxCqG,UAAAA,IAAI,CAACC,IAAL,CAAUtG,IAAV;AACD,SAFD;AAGA,eAAOqG,IAAP;AACD;AAPH,KANsB,EAetB;AAAE;AACA5B,MAAAA,IAAI,EAAE,SADR;AACmBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAAE;AACnD,YAAG,CAAC0D,IAAI,CAAC,CAAD,CAAL,IAAY,CAACA,IAAI,CAAC,CAAD,CAApB,EAAyB,OAAO,KAAP;AACzB,YAAIzB,OAAO,GAAGW,kFAAqB,CAACc,IAAI,CAAC,CAAD,CAAL,CAAnC;;AAEA,YAAGA,IAAI,CAAC,CAAD,CAAJ,KAAY,IAAf,EAAqB;AAAE;AACrB,cAAI6B,QAAQ,GAAG,OAAOzE,IAAP,EAAY4C,IAAZ,EAAiB1D,MAAjB,KAA4B;AACzC,gBAAG;AACD,kBAAIwF,MAAM,GAAG,MAAMvD,OAAO,CAACnB,IAAD,EAAM4C,IAAN,EAAW1D,MAAX,CAA1B;AACA,qBAAOwF,MAAP;AACD,aAHD,CAGE,OAAMC,GAAN,EAAW;AACXlG,cAAAA,OAAO,CAACmG,KAAR,CAAcD,GAAd;AACD;AACF,WAPD;;AAQA3E,UAAAA,IAAI,CAAC0C,SAAL,CAAemC,GAAf,CAAmBjC,IAAI,CAAC,CAAD,CAAvB,EAA4B6B,QAA5B;AACD,SAVD,MAYEzE,IAAI,CAAC0C,SAAL,CAAemC,GAAf,CAAmBjC,IAAI,CAAC,CAAD,CAAvB,EAA4BzB,OAA5B;;AAEF,eAAO,IAAP;AACD;AApBH,KAfsB,EAqCtB;AAAEwB,MAAAA,IAAI,EAAC,YAAP;AAAqBvE,MAAAA,QAAQ,EAAC,CAAC4B,IAAD,EAAM4C,IAAN,EAAW1D,MAAX,KAAsB;AAChD,YAAG0D,IAAI,CAAC,CAAD,CAAP,EAAY,OAAO,KAAKkC,cAAL,CAAoBlC,IAAI,CAAC,CAAD,CAAxB,CAAP,CAAZ,KACK,OAAOhF,SAAP;AACN;AAHH,KArCsB,EA0CtB;AAAE;AACA+E,MAAAA,IAAI,EAAE,WADR;AACqBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AACnD,YAAI,OAAO0D,IAAP,KAAgB,QAApB,EAA8B;AAC5BmC,UAAAA,MAAM,CAACC,IAAP,CAAYpC,IAAZ,EAAkBrD,OAAlB,CAA2B0F,GAAD,IAAS;AACjCjF,YAAAA,IAAI,CAACiF,GAAD,CAAJ,GAAYrC,IAAI,CAACqC,GAAD,CAAhB,CADiC,CACV;;AACvB,gBAAIjF,IAAI,CAACkF,SAAT,EAAoBlF,IAAI,CAACkF,SAAL,CAAeD,GAAf,IAAsBrC,IAAI,CAACqC,GAAD,CAA1B;AACrB,WAHD;AAIA,iBAAO,IAAP;AACD,SAND,MAMO,OAAO,KAAP;AACR;AATH,KA1CsB,EAqDtB;AAAE;AACAtC,MAAAA,IAAI,EAAE,cADR;AACwBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AACtD,YAAI,OAAO0D,IAAP,KAAgB,QAApB,EAA8B;AAC5BmC,UAAAA,MAAM,CAACC,IAAP,CAAYpC,IAAZ,EAAkBrD,OAAlB,CAA2B0F,GAAD,IAAS;AACjC,gBAAG,CAACjF,IAAI,CAACiF,GAAD,CAAR,EAAejF,IAAI,CAACiF,GAAD,CAAJ,GAAYrC,IAAI,CAACqC,GAAD,CAAhB,CAAf,KACK,IAAIE,KAAK,CAACC,OAAN,CAAcxC,IAAI,CAACqC,GAAD,CAAlB,CAAJ,EAA8BjF,IAAI,CAACiF,GAAD,CAAJ,CAAUT,IAAV,CAAe5B,IAAI,CAACqC,GAAD,CAAnB,EAA9B,CAAyD;AAAzD,iBACAjF,IAAI,CAACiF,GAAD,CAAJ,GAAYrC,IAAI,CAACqC,GAAD,CAAhB;AACN,WAJD;AAKA,iBAAO,IAAP;AACD,SAPD,MAOO,OAAO,KAAP;AACR;AAVH,KArDsB,EAiEtB;AAAE;AACAtC,MAAAA,IAAI,EAAE,2BADR;AACqCvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AACnE,YAAI,OAAO0D,IAAP,KAAgB,QAApB,EAA8B;AAC5BmC,UAAAA,MAAM,CAACC,IAAP,CAAYpC,IAAZ,EAAkBrD,OAAlB,CAA2B0F,GAAD,IAAS;AACjC,gBAAGrC,IAAI,CAACqC,GAAD,CAAJ,CAAUI,SAAV,CAAoBA,SAApB,CAA8B3H,WAA9B,CAA0CQ,IAA1C,KAAmD,YAAtD,EAAoE8B,IAAI,CAACiF,GAAD,CAAJ,GAAYE,KAAK,CAACG,IAAN,CAAW1C,IAAI,CAACqC,GAAD,CAAf,CAAZ,CAApE,KACKjF,IAAI,CAACiF,GAAD,CAAJ,GAAYrC,IAAI,CAACqC,GAAD,CAAhB;AACN,WAHD;AAIA,iBAAO,IAAP;AACD,SAND,MAMO,OAAO,KAAP;AACR;AATH,KAjEsB,EA4EtB;AAAE;AACAtC,MAAAA,IAAI,EAAE,8BADR;AACwCvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AACtE,YAAI,OAAO0D,IAAP,KAAgB,QAApB,EAA8B;AAC5BmC,UAAAA,MAAM,CAACC,IAAP,CAAYpC,IAAZ,EAAkBrD,OAAlB,CAA2B0F,GAAD,IAAS;AACjC,gBAAG,CAACjF,IAAI,CAACiF,GAAD,CAAL,IAAcrC,IAAI,CAACqC,GAAD,CAAJ,CAAUI,SAAV,CAAoBA,SAApB,CAA8B3H,WAA9B,CAA0CQ,IAA1C,KAAmD,YAApE,EAAkF8B,IAAI,CAACiF,GAAD,CAAJ,GAAYE,KAAK,CAACG,IAAN,CAAW1C,IAAI,CAACqC,GAAD,CAAf,CAAZ,CAAlF,KACK,IAAG,CAACjF,IAAI,CAACiF,GAAD,CAAR,EAAejF,IAAI,CAACiF,GAAD,CAAJ,GAAYrC,IAAI,CAACqC,GAAD,CAAhB,CAAf,KACA,IAAGrC,IAAI,CAACqC,GAAD,CAAJ,CAAUI,SAAV,CAAoBA,SAApB,CAA8B3H,WAA9B,CAA0CQ,IAA1C,KAAmD,YAAtD,EAAoE8B,IAAI,CAACiF,GAAD,CAAJ,CAAUT,IAAV,CAAeW,KAAK,CAACG,IAAN,CAAW1C,IAAI,CAACqC,GAAD,CAAf,CAAf,EAApE,KACA,IAAGE,KAAK,CAACC,OAAN,CAAcxC,IAAI,CAACqC,GAAD,CAAlB,CAAH,EAA6BjF,IAAI,CAACiF,GAAD,CAAJ,CAAUT,IAAV,CAAe5B,IAAI,CAACqC,GAAD,CAAnB,EAA7B,CAAwD;AAAxD,iBACAjF,IAAI,CAACiF,GAAD,CAAJ,GAAYrC,IAAI,CAACqC,GAAD,CAAhB;AACN,WAND;AAOA,iBAAO,IAAP;AACD,SATD,MASO,OAAO,KAAP;AACR;AAZH,KA5EsB,EA0FtB;AAAE;AACAtC,MAAAA,IAAI,EAAE,qBADR;AAC+BvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAC7D,YAAI,OAAO0D,IAAP,KAAgB,QAApB,EAA8B;AAC5BmC,UAAAA,MAAM,CAACC,IAAP,CAAYpC,IAAZ,EAAkBrD,OAAlB,CAA2B0F,GAAD,IAAS;AACjC,gBAAG,OAAOrC,IAAI,CAACqC,GAAD,CAAX,KAAqB,QAAxB,EAAkC;AAChC,kBAAIM,GAAG,GAAG3C,IAAI,CAACqC,GAAD,CAAd;AACA,kBAAGrC,IAAI,CAACqC,GAAD,CAAJ,CAAUlE,OAAV,CAAkB,OAAlB,MAA+B,CAAlC,EAAqCwE,GAAG,GAAGnE,IAAI,CAAC,MAAIwB,IAAI,CAACqC,GAAD,CAAR,GAAc,GAAf,CAAV;AACrCjF,cAAAA,IAAI,CAACiF,GAAD,CAAJ,GAAYM,GAAZ,CAHgC,CAGf;AACjB;;AACA,kBAAIvF,IAAI,CAACkF,SAAT,EAAoBlF,IAAI,CAACkF,SAAL,CAAeD,GAAf,IAAsBM,GAAtB;AACrB;AACF,WARD;AASA,iBAAO,IAAP;AACD,SAXD,MAWO,OAAO,KAAP;AACR;AAdH,KA1FsB,EA0GtB;AAAE;AACA5C,MAAAA,IAAI,EAAE,SADR;AACmBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAAE;AACnD,YAAIY,IAAI,GAAG8C,IAAI,CAAC,CAAD,CAAf;AACA9C,QAAAA,IAAI,CAAC0F,SAAL,GAAiBA,SAAjB,CAFiD,CAErB;;AAC5B,aAAK5C,IAAI,CAAC,CAAD,CAAT,IAAgB9C,IAAhB,CAHiD,CAG3B;AACvB;AALH,KA1GsB,EAiHtB;AAAE;AACA6C,MAAAA,IAAI,EAAE,UADR;AACoBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAAE;AACpDc,QAAAA,IAAI,CAACiE,aAAL,CAAmBO,IAAnB,CAAwB;AAAElG,UAAAA,SAAS,EAAEsE,IAAI,CAAC,CAAD,CAAjB;AAAsBD,UAAAA,IAAI,EAAEC,IAAI,CAAC,CAAD,CAAhC;AAAqC9C,UAAAA,IAAI,EAAC8C,IAAI,CAAC,CAAD,CAA9C;AAAmD1D,UAAAA,MAAM,EAAEA;AAA3D,SAAxB,EADkD,CAElD;;AACA,YAAG0D,IAAI,CAAC,CAAD,CAAP,EAAW;AACT,cAAI9C,IAAI,GAAG8C,IAAI,CAAC,CAAD,CAAf;AACA9C,UAAAA,IAAI,CAAC0F,SAAL,GAAiBA,SAAjB,CAFS,CAEmB;;AAC5B,eAAK5C,IAAI,CAAC,CAAD,CAAJ,GAAQ,MAAb,IAAuB9C,IAAvB;AACD;;AACD,eAAO,IAAP;AACD;AAVH,KAjHsB,EA6HtB;AAAE;AACA6C,MAAAA,IAAI,EAAE,UADR;AACoBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAAE;AACpD,YAAG,OAAO0D,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAtB,EAAgC,OAAO,KAAP;AAEhC,YAAIrE,QAAQ,GAAGuD,kFAAqB,CAACc,IAAI,CAAC,CAAD,CAAL,CAApC;AACA,YAAI6C,YAAY,GAAG,KAAKC,WAAL,CAAiB9C,IAAI,CAAC,CAAD,CAArB,CAAnB,CAJkD,CAIJ;AAC9C;;AACA,eAAO5C,IAAI,CAACgE,MAAL,CAAY3F,QAAZ,CAAqBuE,IAAI,CAAC,CAAD,CAAzB,EAA+BpE,MAAD,IAAY;AAC/CD,UAAAA,QAAQ,CAACyB,IAAD,EAAMxB,MAAN,EAAaU,MAAb,EAAoBuG,YAAY,EAAE3F,IAAlC,EAAuC2F,YAAY,EAAEnH,SAArD,CAAR,CAD+C,CAC0B;AAC1E,SAFM,CAAP;AAGD;AAVH,KA7HsB,EAyItB;AAAE;AACAqE,MAAAA,IAAI,EAAE,YADR;AACsBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAAE;AACtD,eAAOc,IAAI,CAACgE,MAAL,CAAYpF,UAAZ,CAAuBgE,IAAI,CAAC,CAAD,CAA3B,EAAgCA,IAAI,CAAC,CAAD,CAApC,CAAP;AACD;AAHH,KAzIsB,CAAxB;AAiJA,SAAKF,SAAL,GAAiB,IAAIiD,GAAJ,EAAjB;AACArB,IAAAA,gBAAgB,CAAC/E,OAAjB,CAA0BqG,CAAD,IAAO;AAC9B,UAAGA,CAAC,CAACjD,IAAL,EAAW,KAAKD,SAAL,CAAemC,GAAf,CAAmBe,CAAC,CAACjD,IAArB,EAA0BiD,CAAC,CAACxH,QAA5B;AACX,UAAGwH,CAAC,CAACxC,OAAL,EAAcwC,CAAC,CAACxC,OAAF,CAAU7D,OAAV,CAAmBsG,KAAD,IAAW,KAAKnD,SAAL,CAAemC,GAAf,CAAmBgB,KAAnB,EAAyBD,CAAC,CAACxH,QAA3B,CAA7B;AACf,KAHD;;AAMA,QAAGwF,OAAO,CAACC,GAAX,EAAgB;AACZ,UAAG;AACD,YAAGrB,uEAAH,EAAc;AACZ,eAAKA,SAAL,GAAiB,IAAIA,uEAAJ,CAAc,IAAd,CAAjB;AACD;AACF,OAJD,CAIE,OAAMmC,GAAN,EAAW;AAAClG,QAAAA,OAAO,CAACmG,KAAR,CAAcD,GAAd;AAAoB;AACrC;;AAED,QAAIf,OAAO,CAACE,GAAZ,EAAiB;AACf,UAAI;AACF,YAAGR,uEAAH,EAAc;AACZ,eAAKA,SAAL,GAAiB,IAAIA,uEAAJ,CAAc,IAAd,CAAjB;AACD;AACF,OAJD,CAIE,OAAMqB,GAAN,EAAW;AAAClG,QAAAA,OAAO,CAACmG,KAAR,CAAcD,GAAd;AAAoB;AACnC;;AAED,QAAGf,OAAO,CAACG,QAAX,EAAqB;AACnB,UAAG;AACD,YAAGR,mFAAH,EAAmB;AACjB,eAAKA,cAAL,GAAsB,IAAIA,mFAAJ,CAAmB,IAAnB,CAAtB;AACD;AACF,OAJD,CAIE,OAAMoB,GAAN,EAAW;AAAClG,QAAAA,OAAO,CAACmG,KAAR,CAAcD,GAAd;AAAoB;AACnC;AAEF;;AAGDxG,EAAAA,WAAW,GAAG,CAACc,YAAD,EAAcb,QAAQ,GAAC,CAAC4B,IAAD,EAAM4C,IAAN,EAAW1D,MAAX,KAAoB,CAAE,CAA7C,KAAkD;AAC9D,QAAG,CAACD,YAAD,IAAiB,CAACb,QAArB,EAA+B,OAAO,KAAP,CAD+B,CAE9D;;AACA,SAAKsE,SAAL,CAAemC,GAAf,CAAmB5F,YAAnB,EAAgCb,QAAhC;AACA,WAAO,IAAP;AACD,GALU;AAOX0G,EAAAA,cAAc,GAAI7F,YAAD,IAAkB;AAC/B,QAAInB,KAAK,GAAG,KAAK4E,SAAL,CAAeoD,GAAf,CAAmB7G,YAAnB,CAAZ;;AACA,QAAGnB,KAAH,EAAU;AACR,WAAK4E,SAAL,CAAeqD,MAAf,CAAsB9G,YAAtB;AACA,aAAO,IAAP;AACD;;AACD,WAAO,KAAP;AACH,GAPa;AASd+G,EAAAA,WAAW,GAAG,OAAO/G,YAAP,EAAoB2D,IAAI,GAAC,EAAzB,EAA4B1D,MAA5B,KAAuC;AACnD,QAAIV,MAAM,GAAGZ,SAAb;AACA,QAAIQ,QAAQ,GAAG,KAAKsE,SAAL,CAAeoD,GAAf,CAAmB7G,YAAnB,CAAf;;AACA,QAAGb,QAAH,EAAa;AACXI,MAAAA,MAAM,GAAG,MAAMJ,QAAQ,CAAC,IAAD,EAAOwE,IAAP,EAAa1D,MAAb,CAAvB;AACD;;AACD,WAAOV,MAAP;AACD,GAPU;AASXkH,EAAAA,WAAW,GAAG,CAACzG,YAAD,EAAeC,MAAf,KAA0B;AACtC,QAAIpB,KAAK,GAAG,KAAKmG,aAAL,CAAmBjG,IAAnB,CAAyB4H,CAAD,IAAO;AACzC,UAAKA,CAAC,CAAC1G,MAAF,IAAYA,MAAZ,IAAsB0G,CAAC,CAACjD,IAAxB,IAAgC1D,YAArC,EAAoD;AAClD,YAAI2G,CAAC,CAAC1G,MAAF,KAAaA,MAAb,IAAuB0G,CAAC,CAACjD,IAAF,KAAW1D,YAAtC,EAAoD,OAAO,IAAP,CAApD,KACK,OAAO,KAAP;AACN,OAHD,MAGO,IAAI2G,CAAC,CAACjD,IAAF,IAAU1D,YAAd,EAA4B;AACjC,YAAI2G,CAAC,CAACjD,IAAF,KAAW1D,YAAf,EAA6B,OAAO,IAAP,CAA7B,KACK,OAAO,KAAP;AACN,OAHM,MAGA,IAAI2G,CAAC,CAAC1G,MAAF,IAAYA,MAAhB,EAAwB;AAC7B,YAAG0G,CAAC,CAAC1G,MAAF,KAAaA,MAAhB,EAAwB,OAAO,IAAP,CAAxB,KACK,OAAO,KAAP;AACN,OAHM,MAIF,OAAO,KAAP;AACN,KAZW,CAAZ,CADsC,CActC;;AACA,WAAOpB,KAAP;AACD,GAhBU;AAkBXmI,EAAAA,cAAc,GAAG,MAAOC,KAAP,IAAiB;AAChC;AACA,QAAI1H,MAAM,GAAGZ,SAAb;AACA,QAAG,CAACsI,KAAK,CAACC,IAAV,EAAgB,OAAO3H,MAAP;AAChB,QAAIJ,QAAJ,CAJgC,CAMhC;;AACA,QAAG8H,KAAK,CAACC,IAAN,CAAWxD,IAAd,EAAoBvE,QAAQ,GAAC,KAAKsE,SAAL,CAAeoD,GAAf,CAAmBI,KAAK,CAACC,IAAN,CAAWxD,IAA9B,CAAT,CAApB,KACK,IAAIuD,KAAK,CAACC,IAAN,CAAWlI,GAAf,EAAoBG,QAAQ,GAAC,KAAKsE,SAAL,CAAeoD,GAAf,CAAmBI,KAAK,CAACC,IAAN,CAAWlI,GAA9B,CAAT,CAApB,KACA,IAAIiI,KAAK,CAACC,IAAN,CAAWC,OAAf,EAAwBhI,QAAQ,GAAC,KAAKsE,SAAL,CAAeoD,GAAf,CAAmBI,KAAK,CAACC,IAAN,CAAWC,OAA9B,CAAT,CAAxB,KACA,IAAIF,KAAK,CAACC,IAAN,CAAWE,GAAf,EAAoBjI,QAAQ,GAAC,KAAKsE,SAAL,CAAeoD,GAAf,CAAmBI,KAAK,CAACC,IAAN,CAAWE,GAA9B,CAAT;;AAEzB,QAAGjI,QAAH,EAAa;AACT,UAAI8H,KAAK,CAACC,IAAN,CAAW9G,KAAf,EAAsBb,MAAM,GAAG,MAAMJ,QAAQ,CAAC,IAAD,EAAO8H,KAAK,CAACC,IAAN,CAAW9G,KAAlB,EAAyB6G,KAAK,CAACC,IAAN,CAAWjH,MAApC,CAAvB,CAAtB,KACK,IAAIgH,KAAK,CAACC,IAAN,CAAWvD,IAAf,EAAqBpE,MAAM,GAAG,MAAMJ,QAAQ,CAAC,IAAD,EAAO8H,KAAK,CAACC,IAAN,CAAWvD,IAAlB,EAAwBsD,KAAK,CAACC,IAAN,CAAWjH,MAAnC,CAAvB,CAArB,KACAV,MAAM,GAAG,MAAMJ,QAAQ,CAAC,IAAD,EAAOR,SAAP,EAAkBsI,KAAK,CAACC,IAAN,CAAWjH,MAA7B,CAAvB,CAHI,CAGyD;AACrE;;AACD,WAAOV,MAAP;AACD,GAlBa;AAvPa;;;;;;;;;;;;;;;;;ACT7B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AC9kB6B;AACiD;AAC9E;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACO;AACP;AACA;AACA;AACA,8BAA8B,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI,uBAAuB;AAC3B;AACA,2CAA2C,iCAAqB;AAChE,6CAA6C,mCAAuB;AACpE,kCAAkC,wBAAY;AAC9C,mCAAmC,yBAAa;AAChD,2CAA2C,iCAAqB;AAChE,4CAA4C,kCAAsB;AAClE,kCAAkC,wBAAY;AAC9C,mCAAmC,yBAAa;AAChD,2CAA2C,iCAAqB;AAChE,4CAA4C,kCAAsB;AAClE,wCAAwC,8BAAkB;AAC1D,wCAAwC,8BAAkB;AAC1D,iDAAiD,uCAA2B;AAC5E,wCAAwC,8BAAkB;AAC1D,iDAAiD,uCAA2B;AAC5E,kDAAkD,wCAA4B;AAC9E,kDAAkD,wCAA4B;AAC9E,2CAA2C,iCAAqB;AAChE;AACA;AACA,OAAO,4CAA4C;AACnD,OAAO,iDAAiD;AACxD,OAAO,0BAA0B;AACjC,OAAO,4BAA4B;AACnC,OAAO,6CAA6C;AACpD,OAAO,0BAA0B;AACjC,OAAO,4BAA4B;AACnC,OAAO,4CAA4C;AACnD,OAAO,8CAA8C;AACrD,OAAO,sCAAsC;AAC7C,OAAO,sCAAsC;AAC7C,OAAO,wDAAwD;AAC/D,OAAO,sCAAsC;AAC7C,OAAO,wDAAwD;AAC/D,OAAO,0DAA0D;AACjE,OAAO,0DAA0D;AACjE,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qFAAqF,gBAAgB;AACrG;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kCAAkC;AACvD;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,sEAAsE;AACtE;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kCAAkC;AACvD;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,sEAAsE;AACtE;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,2BAA2B;AAC3B;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kCAAkC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uCAAuC;AACvC,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA,2CAA2C,2BAA2B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;AC3pBD;AACA;CAGA;;AACO,MAAM8E,SAAN,CAAgB;AACnB5F,EAAAA,WAAW,CAAC+E,eAAD,EAAkB;AAE3B,QAAG;AACD,WAAKqB,GAAL,GAAW,IAAIwC,QAAJ,EAAX;AACD,KAFD,CAGA,OAAM3B,GAAN,EAAW;AACT,aAAO/G,SAAP;AACD;;AACC,SAAK6E,eAAL,GAAuBA,eAAvB;AACAA,IAAAA,eAAe,CAACqB,GAAhB,GAAsB,KAAKA,GAA3B;AAEA,SAAKpB,SAAL,GAAiB,CACb;AAAE;AACEC,MAAAA,IAAI,EAAE,YADV;AACwBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAAE;AACtD,eAAOc,IAAI,CAAC8D,GAAL,CAASyC,WAAT,CAAqBzE,yCAAqB,CAACc,IAAI,CAAC,CAAD,CAAL,CAA1C,CAAP;AACD;AAHL,KADa,EAMX;AAAE;AACAD,MAAAA,IAAI,EAAE,WADR;AACqBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAAE;AACrD,eAAOc,IAAI,CAAC8D,GAAL,CAAS0C,SAAT,CAAmB5D,IAAI,CAAC,CAAD,CAAvB,EAA4Bd,yCAAqB,CAACc,IAAI,CAAC,CAAD,CAAL,CAAjD,CAAP;AACD;AAHH,KANW,EAWX;AAAE;AACAD,MAAAA,IAAI,EAAE,YADR;AACsBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAAE;AACtD,eAAOc,IAAI,CAAC8D,GAAL,CAAS2C,UAAT,CAAoB7D,IAAI,CAAC,CAAD,CAAxB,EAA6BA,IAAI,CAAC9B,KAAL,CAAW,CAAX,CAA7B,CAAP,CADoD,CACA;AACrD;AAHH,KAXW,EAgBX;AACE6B,MAAAA,IAAI,EAAE,KADR;AACevE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAC7C,YAAI0D,IAAI,CAAC,CAAD,CAAJ,IAAWhF,SAAf,EAA0BgF,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAV;AAC1B,eAAO5C,IAAI,CAAC8D,GAAL,CAAS4C,MAAT,CAAgB,GAAG9D,IAAnB,CAAP;AACD;AAJH,KAhBW,EAsBX;AACED,MAAAA,IAAI,EAAE,UADR;AACoBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAClD,YAAI0D,IAAI,CAAC,CAAD,CAAJ,IAAWhF,SAAf,EAA0BgF,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAV;AAC1B,eAAO5C,IAAI,CAAC8D,GAAL,CAAS6C,eAAT,CAAyB,GAAG/D,IAA5B,CAAP;AACD;AAJH,KAtBW,EA4BX;AACED,MAAAA,IAAI,EAAE,kBADR;AAC4BvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAC1D,YAAI0D,IAAI,CAAC,CAAD,CAAJ,IAAWhF,SAAf,EAA0BgF,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAV;AAC1B,eAAO5C,IAAI,CAAC8D,GAAL,CAAS8C,wBAAT,CAAkC,GAAGhE,IAArC,CAAP;AACD;AAJH,KA5BW,EAkCX;AACED,MAAAA,IAAI,EAAE,KADR;AACevE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAC7C,YAAI0D,IAAI,CAAC,CAAD,CAAJ,IAAWhF,SAAf,EAA0BgF,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAV;AAC1B,eAAO5C,IAAI,CAAC8D,GAAL,CAAS+C,MAAT,CAAgB,GAAGjE,IAAnB,CAAP;AACD;AAJH,KAlCW,EAwCX;AACED,MAAAA,IAAI,EAAE,UADR;AACoBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAClD,YAAI0D,IAAI,CAAC,CAAD,CAAJ,IAAWhF,SAAf,EAA0BgF,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAV;AAC1B,eAAO5C,IAAI,CAAC8D,GAAL,CAASgD,eAAT,CAAyB,GAAGlE,IAA5B,CAAP;AACD;AAJH,KAxCW,EA8CX;AACED,MAAAA,IAAI,EAAE,kBADR;AAC4BvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAC1D,YAAI0D,IAAI,CAAC,CAAD,CAAJ,IAAWhF,SAAf,EAA0BgF,IAAI,CAAC,CAAD,CAAJ,GAAU,CAAV;AAC1B,eAAO5C,IAAI,CAAC8D,GAAL,CAASiD,wBAAT,CAAkC,GAAGnE,IAArC,CAAP;AACD;AAJH,KA9CW,EAoDX;AACED,MAAAA,IAAI,EAAE,QADR;AACkBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAChD,eAAOc,IAAI,CAAC8D,GAAL,CAASkD,YAAT,CAAsB,GAAGpE,IAAzB,CAAP;AAAwC;AAF5C,KApDW,EAwDX;AACED,MAAAA,IAAI,EAAE,WADR;AACqBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AACnD,cAAM+H,YAAY,GAAG1E,wDAAA,CAAmBK,IAAI,CAAC,CAAD,CAAvB,CAArB,CADmD,CACD;;AAClD,cAAMsE,MAAM,GAAG,CAAC,GAAGtE,IAAI,CAAC,CAAD,CAAR,EAAa,GAAGqE,YAAhB,CAAf,CAFmD,CAGnD;;AACA,YAAIE,IAAJ;AAEA,YAAIC,MAAM,GAAG,CAAb,CANmD,CAOnD;AACA;;AACAD,QAAAA,IAAI,GAAGnH,IAAI,CAAC8D,GAAL,CAAS8C,wBAAT,CAAkCM,MAAlC,EAA0CtE,IAAI,CAAC,CAAD,CAA9C,EAAmDA,IAAI,CAAC,CAAD,CAAvD,EAA4DA,IAAI,CAAC,CAAD,CAAhE,EAAqEwE,MAArE,CAAP,CATmD,CAUnD;;AACA,cAAMC,OAAO,GAAGF,IAAI,CAAC,CAAD,CAAJ,CAAQG,MAAR,CAAe1E,IAAI,CAAC,CAAD,CAAJ,CAAQN,MAAvB,EAA+B4E,MAAM,CAAC5E,MAAP,GAAgBM,IAAI,CAAC,CAAD,CAAJ,CAAQN,MAAvD,CAAhB,CAXmD,CAYnD;;AAEA,cAAMiF,gBAAgB,GAAG,EAAzB;AACA,cAAMC,SAAS,GAAG5E,IAAI,CAAC,CAAD,CAAJ,CAAQN,MAA1B,CAfmD,CAiBnD;;AACA,YAAImF,CAAC,GAAG,CAAR;AACA,YAAIC,CAAC,GAAG,CAAR;AACAL,QAAAA,OAAO,CAAC9H,OAAR,CAAgB,CAACoI,GAAD,EAAMC,CAAN,KAAY;AAAE;AAC5B,cAAIF,CAAC,GAAGD,CAAJ,KAAUD,SAAd,EAAyB;AACvB,gBAAIK,IAAI,GAAGR,OAAO,CAACC,MAAR,CAAeM,CAAf,EAAkB,CAAlB,CAAX;AACAH,YAAAA,CAAC;AACDJ,YAAAA,OAAO,CAACC,MAAR,CAAeG,CAAf,EAAkB,CAAlB,EAAqB,GAAGI,IAAxB;AACAH,YAAAA,CAAC,GAAG,CAAJ,CAJuB,CAKvB;AACD;;AACDA,UAAAA,CAAC;AACF,SATD,EApBmD,CA8BnD;AAEA;;AAEA,YAAII,eAAe,GAAG,EAAtB;AACAL,QAAAA,CAAC,GAAG,CAAJ;AACAC,QAAAA,CAAC,GAAG,CAAJ;AACAL,QAAAA,OAAO,CAAC9H,OAAR,CAAgB,CAACwI,GAAD,EAAMH,CAAN,KAAY;AAC1B,cAAII,MAAM,GAAG,IAAI7C,KAAJ,CAAU4C,GAAG,CAACzF,MAAd,EAAsB2F,IAAtB,CAA2B,CAA3B,CAAb;;AACA,cAAIL,CAAC,GAAGJ,SAAR,EAAmB;AAAE;AACnBO,YAAAA,GAAG,CAACxI,OAAJ,CAAY,CAAC2I,GAAD,EAAMC,CAAN,KAAY;AACtBH,cAAAA,MAAM,CAACG,CAAD,CAAN,GAAYD,GAAZ,CADsB,CACP;AAChB,aAFD;AAGAJ,YAAAA,eAAe,CAACtD,IAAhB,CAAqBwD,MAArB;AACD,WALD,MAMK;AAAE;AACLD,YAAAA,GAAG,CAACxI,OAAJ,CAAY,CAAC2I,GAAD,EAAMC,CAAN,KAAY;AACtBH,cAAAA,MAAM,CAACG,CAAD,CAAN,GAAYD,GAAG,GAAGA,GAAN,IAAaJ,eAAe,CAACL,CAAD,CAAf,CAAmBU,CAAnB,IAAwBL,eAAe,CAACL,CAAC,GAAGC,CAAL,CAAf,CAAuBS,CAAvB,CAArC,CAAZ,CADsB,CACsD;;AAC5E,kBAAIH,MAAM,CAACG,CAAD,CAAN,GAAY,CAAhB,EAAmB;AAAEH,gBAAAA,MAAM,CAACG,CAAD,CAAN,GAAY,CAAZ;AAAgB,eAFf,CAEgB;AACtC;;AACD,aAJD;AAKAT,YAAAA,CAAC;;AACD,gBAAKA,CAAC,GAAGD,CAAL,KAAYD,SAAhB,EAA2B;AACzBC,cAAAA,CAAC;AACDC,cAAAA,CAAC,GAAG,CAAJ;AACD;;AACDH,YAAAA,gBAAgB,CAAC/C,IAAjB,CAAsBwD,MAAtB;AACD;AACF,SArBD;AAsBA,eAAO,CAACb,IAAI,CAAC,CAAD,CAAL,EAAUA,IAAI,CAAC,CAAD,CAAd,EAAmBI,gBAAnB,CAAP;AACD;AA7DH,KAxDW,CAAjB;AAyHA,SAAKrE,YAAL;AACH;;AAEDA,EAAAA,YAAY,CAACR,SAAS,GAAC,KAAKA,SAAhB,EAA2B;AACrCA,IAAAA,SAAS,CAACnD,OAAV,CAAmB4D,EAAD,IAAQ;AACtB,WAAKV,eAAL,CAAqBtE,WAArB,CAAiCgF,EAAE,CAACR,IAApC,EAA0CQ,EAAE,CAAC/E,QAA7C;;AACA,UAAG+E,EAAE,CAACC,OAAN,EAAe;AACXD,QAAAA,EAAE,CAACC,OAAH,CAAW7D,OAAX,CAAoB8D,CAAD,IAAO;AACtB,eAAKZ,eAAL,CAAqBtE,WAArB,CAAiCkF,CAAjC,EAAoCF,EAAE,CAAC/E,QAAvC;AACH,SAFD;AAGH;AACJ,KAPD;AAQD;;AAjJkB;;;;;;;;;;;;;;;ACLvB;AAGA,SAASgK,IAAT,GAAgB,CACf,EAED;;;AAEO,MAAMC,eAAN,CAAsB;AAC5BC,EAAAA,gBAAgB,CAAEC,IAAF,EAAQC,QAAR,EAAmB;AAClC,QAAK,KAAKC,UAAL,KAAoB7K,SAAzB,EAAqC,KAAK6K,UAAL,GAAkB,EAAlB;AACrC,UAAMC,SAAS,GAAG,KAAKD,UAAvB;;AACA,QAAKC,SAAS,CAAEH,IAAF,CAAT,KAAsB3K,SAA3B,EAAuC;AACtC8K,MAAAA,SAAS,CAAEH,IAAF,CAAT,GAAoB,EAApB;AACA;;AAED,QAAKG,SAAS,CAAEH,IAAF,CAAT,CAAkBxH,OAAlB,CAA2ByH,QAA3B,MAA0C,CAAE,CAAjD,EAAqD;AACpDE,MAAAA,SAAS,CAAEH,IAAF,CAAT,CAAkB/D,IAAlB,CAAwBgE,QAAxB;AACA;AAED;;AAEDG,EAAAA,gBAAgB,CAAEJ,IAAF,EAAQC,QAAR,EAAmB;AAClC,QAAK,KAAKC,UAAL,KAAoB7K,SAAzB,EAAqC,OAAO,KAAP;AACrC,UAAM8K,SAAS,GAAG,KAAKD,UAAvB;AACA,WAAOC,SAAS,CAAEH,IAAF,CAAT,KAAsB3K,SAAtB,IAAmC8K,SAAS,CAAEH,IAAF,CAAT,CAAkBxH,OAAlB,CAA2ByH,QAA3B,MAA0C,CAAE,CAAtF;AACA;;AAEDI,EAAAA,mBAAmB,CAAEL,IAAF,EAAQC,QAAR,EAAmB;AACrC,QAAK,KAAKC,UAAL,KAAoB7K,SAAzB,EAAqC;AACrC,UAAM8K,SAAS,GAAG,KAAKD,UAAvB;AACA,UAAMI,aAAa,GAAGH,SAAS,CAAEH,IAAF,CAA/B;;AACA,QAAKM,aAAa,KAAKjL,SAAvB,EAAmC;AAClC,YAAMkL,KAAK,GAAGD,aAAa,CAAC9H,OAAd,CAAuByH,QAAvB,CAAd;;AACA,UAAKM,KAAK,KAAK,CAAE,CAAjB,EAAqB;AACpBD,QAAAA,aAAa,CAACvB,MAAd,CAAsBwB,KAAtB,EAA6B,CAA7B;AACA;AACD;AACD;;AAEDC,EAAAA,aAAa,CAAE7C,KAAF,EAAU;AACtB,QAAK,KAAKuC,UAAL,KAAoB7K,SAAzB,EAAqC;AACrC,UAAM8K,SAAS,GAAG,KAAKD,UAAvB;AACA,UAAMI,aAAa,GAAGH,SAAS,CAAExC,KAAK,CAACqC,IAAR,CAA/B;;AACA,QAAKM,aAAa,KAAKjL,SAAvB,EAAmC;AAClCsI,MAAAA,KAAK,CAAC8C,MAAN,GAAe,IAAf,CADkC,CAElC;;AACA,YAAMC,KAAK,GAAGJ,aAAa,CAAC/H,KAAd,CAAqB,CAArB,CAAd;;AACA,WAAM,IAAI8G,CAAC,GAAG,CAAR,EAAWF,CAAC,GAAGuB,KAAK,CAAC3G,MAA3B,EAAmCsF,CAAC,GAAGF,CAAvC,EAA0CE,CAAC,EAA3C,EAAiD;AAChDqB,QAAAA,KAAK,CAAErB,CAAF,CAAL,CAAWsB,IAAX,CAAiB,IAAjB,EAAuBhD,KAAvB;AACA;;AACDA,MAAAA,KAAK,CAAC8C,MAAN,GAAe,IAAf;AACA;AACD;;AA7C2B,EAgD7B;;AACO,MAAMG,oBAAN,SAAmCd,eAAnC,CAAmD;AACtD3K,EAAAA,WAAW,GAAG;AACV,YADU,CAEV;;AACA,SAAK0L,KAAL,GAAa,EAAb;AACH;;AACc,MAAXC,WAAW,GAAG;AACd,WAAO,KAAKC,KAAZ;AACH;;AACe,MAAZC,YAAY,GAAG;AACf,WAAO,KAAKC,MAAZ;AACH,GAXqD,CAYtD;;;AACAC,EAAAA,iBAAiB,GAAG,CAAE;;AAEtBC,EAAAA,qBAAqB,GAAG,CAAE;;AAE1BC,EAAAA,qBAAqB,GAAG;AACpB,WAAO;AACHC,MAAAA,IAAI,EAAE,KAAKA,IADR;AAEHC,MAAAA,GAAG,EAAE,KAAKA,GAFP;AAGHP,MAAAA,KAAK,EAAE,KAAKA,KAHT;AAIHE,MAAAA,MAAM,EAAE,KAAKA,MAJV;AAKHM,MAAAA,KAAK,EAAE,KAAKF,IAAL,GAAY,KAAKN,KALrB;AAMHS,MAAAA,MAAM,EAAE,KAAKF,GAAL,GAAW,KAAKL;AANrB,KAAP;AAQH;;AAEDQ,EAAAA,WAAW,CAAC7D,IAAD,EAAO;AACd,QAAIA,IAAI,CAACoC,IAAL,KAAc,MAAlB,EAA0B;AACtB,WAAKqB,IAAL,GAAYzD,IAAI,CAACyD,IAAjB;AACA,WAAKC,GAAL,GAAW1D,IAAI,CAAC0D,GAAhB;AACA,WAAKP,KAAL,GAAanD,IAAI,CAACmD,KAAlB;AACA,WAAKE,MAAL,GAAcrD,IAAI,CAACqD,MAAnB;AACA;AACH;;AACDrD,IAAAA,IAAI,CAAC8D,cAAL,GAAsB7B,IAAtB;AACAjC,IAAAA,IAAI,CAAC+D,eAAL,GAAuB9B,IAAvB;AACA,SAAKW,aAAL,CAAmB5C,IAAnB;AACH;;AAEDgE,EAAAA,KAAK,GAAG,CAAE;;AAzC4C,EA4C1D;;AACO,MAAMC,YAAN,CAAmB;AACtB1M,EAAAA,WAAW,GAAG;AACZ,SAAK+B,EAAL,GAAU,UAAQ0E,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAc,KAAzB,CAAlB;AACA,SAAKgG,OAAL,GAAe,EAAf;AACA,SAAKL,WAAL,GAAmB,KAAKA,WAAL,CAAiBM,IAAjB,CAAsB,IAAtB,CAAnB;AACD;;AAEDC,EAAAA,SAAS,CAACpE,IAAD,EAAO;AACd,UAAM;AAAC1G,MAAAA;AAAD,QAAO0G,IAAb;AACA,UAAMqE,KAAK,GAAG,IAAIrB,oBAAJ,EAAd;AACA,SAAKkB,OAAL,CAAa5K,EAAb,IAAmB+K,KAAnB;AACD;;AAEDC,EAAAA,QAAQ,CAAChL,EAAD,EAAK;AACX,WAAO,KAAK4K,OAAL,CAAa5K,EAAb,CAAP;AACD;;AAEDuK,EAAAA,WAAW,CAAC7D,IAAD,EAAO;AAChB,SAAKkE,OAAL,CAAalE,IAAI,CAAC1G,EAAlB,EAAsBuK,WAAtB,CAAkC7D,IAAI,CAACA,IAAvC;AACD;;AAnBqB;;;;ACtG1B;AACA;AAEA;AAEO,MAAM5C,cAAN,CAAqB;AACxB7F,EAAAA,WAAW,CAAC+E,eAAD,EAAkB;AAGzB,SAAKA,eAAL,GAAuBA,eAAvB;AACAA,IAAAA,eAAe,CAACgB,MAAhB,GAAyB,IAAIiH,eAAJ,CAAoB,GAApB,EAAyB,GAAzB,CAAzB,CAJyB,CAI+B;;AACxDjI,IAAAA,eAAe,CAACkI,SAAhB,GAA4B/M,SAA5B;AACA6E,IAAAA,eAAe,CAACmI,aAAhB,GAAgChN,SAAhC;AACA6E,IAAAA,eAAe,CAACoI,SAAhB,GAA4B,KAA5B;AACApI,IAAAA,eAAe,CAACqI,aAAhB,GAAgCC,WAAW,CAACC,GAAZ,EAAhC,CARyB,CAQ0B;;AACnDvI,IAAAA,eAAe,CAACyC,SAAhB,GAA4BtH,SAA5B;AACA6E,IAAAA,eAAe,CAACwI,YAAhB,GAA+B,IAAIb,YAAJ,EAA/B;;AAEA,QAAG;AACD,UAAGc,MAAH,EAAWzM,OAAO,CAACC,GAAR,CAAY,mBAAZ;AACZ,KAFD,CAEE,OAAMiG,GAAN,EAAW;AACX3E,MAAAA,IAAI,CAACmL,QAAL,GAAgB,EAAhB,CADW,CACS;AACrB;;AAGD,SAAKzI,SAAL,GAAiB,CACX;AAAE;AACAC,MAAAA,IAAI,EAAE,cADR;AACwBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AACtDc,QAAAA,IAAI,CAACyD,MAAL,CAAY6F,KAAZ,GAAoB1G,IAAI,CAAC,CAAD,CAAxB;AACA5C,QAAAA,IAAI,CAACyD,MAAL,CAAY+F,MAAZ,GAAqB5G,IAAI,CAAC,CAAD,CAAzB;AACA,eAAO,IAAP;AACD;AALH,KADW,EAQX;AAAE;AACAD,MAAAA,IAAI,EAAC,cADP;AACuBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAErD,YAAG0D,IAAI,CAAC2F,IAAL,KAAc,WAAjB,EAA8B;AAC5BvI,UAAAA,IAAI,CAACiL,YAAL,CAAkBV,SAAlB,CAA4B3H,IAA5B;AAEA,gBAAM4H,KAAK,GAAGxK,IAAI,CAACiL,YAAL,CAAkBR,QAAlB,CAA2B7H,IAAI,CAACnD,EAAhC,CAAd;AACA+K,UAAAA,KAAK,CAACY,aAAN,GAAsBZ,KAAtB,CAJ4B,CAIC;;AAC7BxK,UAAAA,IAAI,CAAC4C,IAAI,CAACnD,EAAN,CAAJ,GAAgB+K,KAAhB;AACD,SAND,MAMO,IAAI5H,IAAI,CAAC2F,IAAL,KAAc,OAAlB,EAA2B;AAChCvI,UAAAA,IAAI,CAACiL,YAAL,CAAkBjB,WAAlB,CAA8BpH,IAA9B;AACD,SAFM,MAGF,OAAO,KAAP;;AAEL,eAAO,IAAP;AACD;AAfH,KARW,EAyBX;AACED,MAAAA,IAAI,EAAE,WADR;AACqBvE,MAAAA,QAAQ,EAAE,OAAO4B,IAAP,EAAa4C,IAAb,EAAmB1D,MAAnB,KAA8B;AACzD,YAAIc,IAAI,CAAC6K,SAAT,EAAoB;AAClB7K,UAAAA,IAAI,CAAC6K,SAAL,GAAiB,KAAjB;AACAQ,UAAAA,oBAAoB,CAACrL,IAAI,CAAC2K,SAAN,CAApB;AACD;;AACD,YAAI,CAAC3K,IAAI,CAACkF,SAAV,EAAqB;AACnB,cAAI3E,MAAM,GAAG,MAAMF,iCAAa,CAAC,0CAAD,CAAhC;AACAL,UAAAA,IAAI,CAACkF,SAAL,GAAiB,IAAI3E,MAAM,CAAC2E,SAAX,CAAqBlF,IAAI,CAACyD,MAA1B,EAAiCzD,IAAjC,EAAsCA,IAAI,CAACiL,YAAL,CAAkBR,QAAlB,CAA2B7H,IAAI,CAAC,CAAD,CAA/B,CAAtC,CAAjB;AACA5C,UAAAA,IAAI,CAACsL,KAAL,GAAatL,IAAI,CAACkF,SAAL,CAAeoG,KAA5B,CAHmB,CAGgB;AACpC;;AACD,YAAI,OAAO1I,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAvB,EAAiC;AAAE;AACjC,gBAAM5C,IAAI,CAACgG,WAAL,CAAiB,WAAjB,EAA6BpD,IAAI,CAAC,CAAD,CAAjC,CAAN;AACD,SAZwD,CAazD;;;AACA,YAAIA,IAAI,CAAC,CAAD,CAAR,EAAa;AAAE;AACb5C,UAAAA,IAAI,CAACkF,SAAL,CAAeqG,KAAf,GAAuBzJ,yCAAqB,CAACc,IAAI,CAAC,CAAD,CAAL,CAA5C;AACD;;AACD,YAAIA,IAAI,CAAC,CAAD,CAAR,EAAa;AAAE;AACb5C,UAAAA,IAAI,CAACkF,SAAL,CAAesG,IAAf,GAAsB1J,yCAAqB,CAACc,IAAI,CAAC,CAAD,CAAL,CAA3C;AACD;;AACD,YAAIA,IAAI,CAAC,CAAD,CAAR,EAAa;AACX5C,UAAAA,IAAI,CAACkF,SAAL,CAAeuG,KAAf,GAAuB3J,yCAAqB,CAACc,IAAI,CAAC,CAAD,CAAL,CAA5C;AACD;;AACD5C,QAAAA,IAAI,CAACkF,SAAL,CAAeuG,KAAf,CAAqBzL,IAArB,EAA2B4C,IAA3B,EAAiC1D,MAAjC;AACAc,QAAAA,IAAI,CAACkF,SAAL,CAAeqG,KAAf,CAAqBvL,IAArB,EAA2B4C,IAA3B,EAAiC1D,MAAjC,EAxByD,CAyBzD;;AACA,eAAO,IAAP;AACD;AA5BH,KAzBW,EAuDX;AACEyD,MAAAA,IAAI,EAAE,YADR;AACsBvE,MAAAA,QAAQ,EAAE,OAAO4B,IAAP,EAAa4C,IAAb,EAAmB1D,MAAnB,KAA8B;AAAE;AAC5D,YAAIc,IAAI,CAAC6K,SAAT,EAAoB;AAClB7K,UAAAA,IAAI,CAAC6K,SAAL,GAAiB,KAAjB;AACAQ,UAAAA,oBAAoB,CAACrL,IAAI,CAAC2K,SAAN,CAApB;AACD;;AACD,YAAI,CAAC3K,IAAI,CAACkF,SAAV,EAAqB;AACnB,cAAI3E,MAAM,GAAG,MAAMF,iCAAa,CAAC,0CAAD,CAAhC,CADmB,CAC2D;AAC9E;;AACAL,UAAAA,IAAI,CAACkF,SAAL,GAAiB,IAAI3E,MAAM,CAAC2E,SAAX,CAAqBlF,IAAI,CAACyD,MAA1B,EAAiCzD,IAAjC,EAAsCA,IAAI,CAACiL,YAAL,CAAkBR,QAAlB,CAA2B7H,IAAI,CAAC,CAAD,CAA/B,CAAtC,CAAjB;AACD;;AACD,YAAI5C,IAAI,CAACkF,SAAT,EAAoB;AAClBlF,UAAAA,IAAI,CAACkF,SAAL,CAAeuG,KAAf,CAAqBzL,IAArB,EAA2B4C,IAA3B,EAAiC1D,MAAjC;AACAc,UAAAA,IAAI,CAACkF,SAAL,CAAeqG,KAAf,CAAqBvL,IAArB,EAA2B4C,IAA3B,EAAiC1D,MAAjC;AACD;;AACD,eAAO,IAAP;AACD;AAhBH,KAvDW,EAyEX;AACEyD,MAAAA,IAAI,EAAE,YADR;AACsBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAAE;AACtD,YAAIc,IAAI,CAACkF,SAAT,EAAoB;AAClBlF,UAAAA,IAAI,CAACkF,SAAL,CAAeuG,KAAf,CAAqBzL,IAArB,EAA2B4C,IAA3B,EAAiC1D,MAAjC;AACD;;AACD,eAAO,IAAP;AACD;AANH,KAzEW,EAiFX;AAACyD,MAAAA,IAAI,EAAE,cAAP;AAAuBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAAE;AACvDc,QAAAA,IAAI,CAAC0L,aAAL,GAAqB5J,yCAAqB,CAACc,IAAI,CAAC,CAAD,CAAL,CAA1C;AACA,eAAO,IAAP;AACD;AAHH,KAjFW,EAsFX;AACED,MAAAA,IAAI,EAAE,gBADR;AAC0BvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AACxD;AACA,YAAIyM,IAAI,GAAG,MAAM;AACf,cAAI3L,IAAI,CAAC6K,SAAT,EAAoB;AAClB7K,YAAAA,IAAI,CAAC0L,aAAL,CAAmB1L,IAAnB,EAAyB4C,IAAzB,EAA+B1D,MAA/B;AACAc,YAAAA,IAAI,CAAC8K,aAAL,GAAqBC,WAAW,CAACC,GAAZ,KAAoBhL,IAAI,CAAC8K,aAA9C;AACA,gBAAIc,SAAS,GAAG5L,IAAI,CAAC0F,WAAL,CAAiB,QAAjB,EAA2BxG,MAA3B,CAAhB;AACA,gBAAI2M,IAAI,GAAG;AAAE5N,cAAAA,GAAG,EAAE,QAAP;AAAiBO,cAAAA,MAAM,EAAEwB,IAAI,CAAC8K,aAA9B;AAA6C5L,cAAAA,MAAM,EAAEA;AAArD,aAAX;AACAc,YAAAA,IAAI,CAAC8K,aAAL,GAAqBC,WAAW,CAACC,GAAZ,EAArB;;AACA,gBAAIY,SAAJ,EAAe;AACb5L,cAAAA,IAAI,CAACgE,MAAL,CAAYpE,IAAZ,CAAiB,QAAjB,EAA2BiM,IAA3B;AACD,aAFD,MAGK;AACH5L,cAAAA,WAAW,CAAC4L,IAAD,CAAX;AACD;;AACDC,YAAAA,qBAAqB,CAACH,IAAD,CAArB;AACD;AACF,SAfD;;AAiBA,YAAI,KAAKd,SAAT,EAAoB;AAClB7K,UAAAA,IAAI,CAAC6K,SAAL,GAAiB,KAAjB;AACAQ,UAAAA,oBAAoB,CAACrL,IAAI,CAAC2K,SAAN,CAApB;AACAoB,UAAAA,UAAU,CAAC,MAAM;AACf/L,YAAAA,IAAI,CAAC6K,SAAL,GAAiB,IAAjB;AACA7K,YAAAA,IAAI,CAAC2K,SAAL,GAAiBmB,qBAAqB,CAACH,IAAD,CAAtC;AACD,WAHS,EAGP,GAHO,CAAV;AAID,SAPD,MAOO;AACL3L,UAAAA,IAAI,CAAC6K,SAAL,GAAiB,IAAjB;AACApM,UAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AACAsB,UAAAA,IAAI,CAAC2K,SAAL,GAAiBmB,qBAAqB,CAACH,IAAD,CAAtC;AACD;;AACD,eAAO,IAAP;AACD;AAjCH,KAtFW,EAyHX;AACEhJ,MAAAA,IAAI,EAAE,eADR;AACyBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AACvD,YAAIc,IAAI,CAAC6K,SAAT,EAAoB;AAClB7K,UAAAA,IAAI,CAAC6K,SAAL,GAAiB,KAAjB;AACAQ,UAAAA,oBAAoB,CAACrL,IAAI,CAAC2K,SAAN,CAApB;AACA,iBAAO,IAAP;AACD,SAJD,MAIO,OAAO,KAAP;AACR;AAPH,KAzHW,EAkIX;AACEhI,MAAAA,IAAI,EAAE,QADR;AACkBvE,MAAAA,QAAQ,EAAE,CAAC4B,IAAD,EAAO4C,IAAP,EAAa1D,MAAb,KAAwB;AAAE;AAClDc,QAAAA,IAAI,CAAC0L,aAAL,CAAmB1L,IAAnB,EAAyB4C,IAAzB,EAA+B1D,MAA/B;AACA,YAAI8M,IAAI,GAAGjB,WAAW,CAACC,GAAZ,KAAoBhL,IAAI,CAAC8K,aAApC;AACAmB,QAAAA,QAAQ,CAACnB,aAAT,GAAyBC,WAAW,CAACC,GAAZ,EAAzB;AACA,eAAOgB,IAAP;AACD;AANH,KAlIW,CAAjB;AA4IA,SAAK9I,YAAL;AACH;;AAEDA,EAAAA,YAAY,CAACR,SAAS,GAAC,KAAKA,SAAhB,EAA2B;AACrCA,IAAAA,SAAS,CAACnD,OAAV,CAAmB4D,EAAD,IAAQ;AACtB,WAAKV,eAAL,CAAqBtE,WAArB,CAAiCgF,EAAE,CAACR,IAApC,EAA0CQ,EAAE,CAAC/E,QAA7C;;AACA,UAAG+E,EAAE,CAACC,OAAN,EAAe;AACXD,QAAAA,EAAE,CAACC,OAAH,CAAW7D,OAAX,CAAoB8D,CAAD,IAAO;AACtB,eAAKZ,eAAL,CAAqBtE,WAArB,CAAiCkF,CAAjC,EAAoCF,EAAE,CAAC/E,QAAvC;AACH,SAFD;AAGH;AACJ,KAPD;AAQD;;AA5KuB;;;;;;;;;;;;;;;ACL5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,2BAA2B;AAC3B,4BAA4B;AAC5B,+BAA+B;AAC/B,2BAA2B;AAC3B,uBAAuB;AACvB,uBAAuB;AACvB,kCAAkC;AAClC,8BAA8B;AAC9B,+BAA+B;AAC/B,iCAAiC;AACjC,kCAAkC;AAClC,kCAAkC;AAClC,4BAA4B;AAC5B,yBAAyB;AACzB,yBAAyB;AACzB,8BAA8B;AAC9B,wBAAwB;AACxB,2BAA2B;AAC3B,0BAA0B;AAC1B,2BAA2B;AAC3B,0BAA0B;AAC1B,wBAAwB;AACxB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,mBAAmB,WAAW;AAC9B;AACA,uDAAuD;AACvD;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,iBAAiB,KAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS,UAAU;AACtD;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa,UAAU;AAC7D;AACA,uCAAuC,eAAe;AACtD,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,aAAa,UAAU;AAC/D;AACA,uCAAuC,eAAe;AACtD,2CAA2C,eAAe;AAC1D,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS,WAAW;AACxD;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,kBAAkB,cAAc;AAChC,gCAAgC;AAChC,oBAAoB,cAAc;AAClC,4BAA4B;AAC5B,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa,GAAG;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,8CAA8C;AAC9C;AACA,qBAAqB,SAAS;AAC9B;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,iDAAiD;AACjD;AACA,sDAAsD;AACtD,0DAA0D;AAC1D;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,kBAAkB,cAAc;AAChC,gCAAgC;AAChC,oBAAoB,cAAc;AAClC,4BAA4B;AAC5B,mBAAmB,cAAc;AACjC,uFAAuF;AACvF;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH,uBAAuB;AACvB;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2CAA2C;AACrF;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ,IAAI;AACJ;AACA;AACA;;;;;;;;;;AE1pCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAsD,EAAE;AAChE,UAAU,UAML,CAAC;AACN;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C,2BAA2B,SAAmC,CAAC,gBAAgB,OAAC,OAAO,oBAAoB,8CAA8C,kCAAkC,YAAY,YAAY,mCAAmC,iBAAiB,eAAe,sBAAsB,oBAAoB,UAAU,SAAmC,KAAK,WAAW,YAAY,SAAS,SAAS,KAAK;AACha;AACA;AACA;AACA,2DAA2D;AAC3D,OAAO,4BAA4B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA,8BAA8B;AAC9B;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B;AAC5B,gCAAgC;AAChC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B;AAC5B,gCAAgC;AAChC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8BAA8B;AACpE;AACA,0BAA0B,iBAAiB,gBAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mCAAmC;AAC3E;AACA,kCAAkC,IAAI,mCAAmC;AACzE,kCAAkC;AAClC,sCAAsC,mCAAmC;AACzE;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,IAAI,mCAAmC;AAChF;AACA;AACA,kCAAkC,iCAAiC;AACnE,uCAAuC,iCAAiC;AACxE,0CAA0C,8CAA8C;AACxF,wCAAwC,iDAAiD;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,2DAA2D;AACpG;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2BAA2B;AACpD,yCAAyC,2BAA2B;AACpE,iCAAiC,iDAAiD;AAClF,6BAA6B,iDAAiD;AAC9E,iCAAiC,iDAAiD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,gBAAgB,mCAAmC;AACnD,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc,oBAAoB,gBAAgB,oBAAoB,YAAY,oBAAoB,eAAe,oBAAoB,qBAAqB,oBAAoB,wBAAwB;AAC7O;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,2DAA2D;AAC3D,uDAAuD;AACvD,0DAA0D;AAC1D,gEAAgE;AAChE,mEAAmE;AACnE;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0BAA0B;AAC1B,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,wCAAwC;AACxC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,cAAc;AACd;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,2BAA2B;AAC3B;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,cAAc,2DAA2D,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa,iBAAiB;AACvD;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA,+BAA+B;AAC/B,yBAAyB;AACzB;AACA,gCAAgC;AAChC;AACA;AACA,yEAAyE;AACzE;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H;AAC1H;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA,0EAA0E;AAC1E,2CAA2C;AAC3C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,gEAAgE;AAChE,iBAAiB,wCAAwC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,kCAAkC;AAClC;AACA;AACA;AACA;AACA,cAAc;AACd,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,4BAA4B,wDAAwD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,kGAAkG;AAClG,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,+BAA+B;AAC/B,2BAA2B;AAC3B;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,YAAY;AACZ;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,gDAAgD;AAChD;AACA,cAAc;AACd,sDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc,uCAAuC,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yCAAyC,qBAAqB;AAC5E;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,0BAA0B;AAC1B,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mEAAmE;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,sDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,mBAAmB;AACnB;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,oDAAoD,iBAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,qBAAqB;AAC3E;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,8CAA8C;AAC9C,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,gBAAgB;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,YAAY;AACZ,0CAA0C;AAC1C;AACA,qCAAqC;AACrC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,gBAAgB;AAChB,mBAAmB;AACnB;AACA,YAAY;AACZ;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,8EAA8E;AAC9E,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,iDAAiD;AACjD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,iEAAiE,mBAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F,cAAc,OAAO;AACrB;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,YAAY;AACZ,6BAA6B;AAC7B;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB,cAAc;AACd;AACA,kBAAkB;AAClB;AACA,YAAY;AACZ,0CAA0C;AAC1C;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA,kBAAkB;AAClB;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E,cAAc,OAAO;AACrB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,iEAAiE;AACjE;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,YAAY;AACZ,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,+CAA+C;AAC/C;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA,iEAAiE,kCAAkC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,wCAAwC;AACxC,+CAA+C;AAC/C;AACA,qCAAqC;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,gCAAgC;AAChC,gCAAgC;AAChC,+BAA+B;AAC/B,+BAA+B;AAC/B;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,iDAAiD;AACjD,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iDAAiD;AACjD;AACA,sCAAsC;AACtC;AACA,gCAAgC;AAChC,gDAAgD;AAChD,iDAAiD;AACjD;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,iDAAiD,6CAA6C;AAC9F;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA,8BAA8B;AAC9B,mCAAmC;AACnC,iDAAiD;AACjD,mBAAmB;AACnB,gCAAgC;AAChC;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,YAAY,wDAAwD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,6CAA6C;AAC7C;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA,yDAAyD;AACzD;AACA,mCAAmC;AACnC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iDAAiD;AACjD;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,cAAc;AACd,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA,0CAA0C,2BAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,aAAa;AACpE;AACA,OAAO;AACP;AACA,OAAO,GAAG;AACV;AACA,OAAO,GAAG;AACV,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,UAAU;AACV,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO,MAAM,YAAY,kBAAkB,YAAY,gCAAgC;AAC7H,oBAAoB;AACpB,sCAAsC,OAAO,EAAE,YAAY,YAAY;AACvE;AACA;AACA;AACA,0CAA0C,YAAY,WAAW,wBAAwB;AACzF,oCAAoC,OAAO,QAAQ,cAAc,IAAI,YAAY,iBAAiB,aAAa,GAAG;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO,EAAE,aAAa;AAC9D,sBAAsB;AACtB,8CAA8C,YAAY,UAAU,wBAAwB;AAC5F;AACA,wCAAwC,OAAO,QAAQ,oBAAoB,QAAQ,8BAA8B,GAAG,oBAAoB,EAAE;AAC1I;AACA,oBAAoB;AACpB,4CAA4C,YAAY,UAAU,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,EAAE,YAAY,cAAc,6BAA6B,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,EAAE,YAAY,gBAAgB,kCAAkC,iGAAiG,EAAE,GAAG;AACjN;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,EAAE,yCAAyC;AACtF;AACA;AACA;AACA;AACA,sCAAsC,OAAO,QAAQ,YAAY,UAAU,yBAAyB,IAAI,yCAAyC;AACjJ;AACA;AACA;AACA;AACA;AACA,sCAAsC,yCAAyC;AAC/E,oBAAoB;AACpB,sCAAsC,OAAO,QAAQ,YAAY,UAAU,yBAAyB,IAAI,yCAAyC;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY,UAAU,wBAAwB;AAChF,4BAA4B,OAAO,QAAQ,cAAc,IAAI,QAAQ;AACrE;AACA;AACA;AACA;AACA,oCAAoC,YAAY,UAAU,wBAAwB;AAClF,6CAA6C,WAAW;AACxD,4BAA4B,OAAO,MAAM,eAAe,aAAa,eAAe,YAAY,MAAM,SAAS,OAAO,wBAAwB;AAC9I,4BAA4B,OAAO,gBAAgB,MAAM,cAAc,SAAS,SAAS;AACzF,4BAA4B,SAAS,EAAE,eAAe,KAAK,eAAe,cAAc,eAAe,kBAAkB,eAAe,cAAc;AACtJ,4BAA4B,QAAQ;AACpC,4BAA4B,OAAO,qCAAqC;AACxE,4BAA4B,SAAS,iCAAiC,eAAe,SAAS,cAAc,EAAE;AAC9G,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA,4BAA4B,OAAO,KAAK,MAAM;AAC9C;AACA;AACA,4BAA4B,OAAO;AACnC,QAAQ,OAAO,gBAAgB,YAAY;AAC3C,QAAQ,OAAO,gBAAgB,YAAY;AAC3C,QAAQ,SAAS;AACjB,QAAQ,SAAS,gBAAgB,kBAAkB;AACnD,QAAQ,WAAW;AACnB,QAAQ,WAAW,MAAM,YAAY;AACrC,QAAQ,aAAa,mBAAmB,aAAa;AACrD,QAAQ;AACR,QAAQ;AACR,QAAQ;AACR,QAAQ,QAAQ,IAAI;AACpB;AACA;AACA,oBAAoB,YAAY,GAAG,OAAO,GAAG,0BAA0B,gGAAgG,EAAE;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,UAAU,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,EAAE,YAAY,qBAAqB,kCAAkC,oHAAoH,EAAE,GAAG;AACzO;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,EAAE,yCAAyC;AACtF;AACA;AACA;AACA;AACA,sCAAsC,OAAO,QAAQ,YAAY,UAAU,yBAAyB,IAAI,yCAAyC;AACjJ;AACA,oBAAoB;AACpB,sCAAsC,OAAO,QAAQ,YAAY,UAAU,yBAAyB,IAAI,yCAAyC;AACjJ;AACA;AACA;AACA;AACA;AACA,sCAAsC,yCAAyC;AAC/E,oBAAoB;AACpB,sCAAsC,OAAO,QAAQ,YAAY,UAAU,yBAAyB,IAAI,yCAAyC;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,GAAG,4BAA4B;AACjE;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,GAAG,OAAO,GAAG,0BAA0B,oHAAoH,EAAE;AAC7L;AACA;AACA;AACA,kCAAkC,YAAY,UAAU,wBAAwB;AAChF;AACA,4BAA4B,OAAO,QAAQ,cAAc,IAAI,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sFAAsF;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,UAAU,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,2CAA2C,qBAAqB,IAAI,0BAA0B;AAC9F;AACA;AACA;AACA;AACA,2CAA2C,qBAAqB,GAAG,gCAAgC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qBAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,0BAA0B,mBAAmB;AAC7C;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,YAAY;AACZ;AACA,uBAAuB;AACvB,YAAY;AACZ;AACA,uBAAuB;AACvB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV,cAAc,QAAQ;AACtB;AACA;AACA;AACA,gDAAgD,OAAO,IAAI,uDAAuD;AAClH,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,cAAc;AACvB,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,kCAAkC;AAClC,YAAY;AACZ,4CAA4C,YAAY;AACxD;AACA,0BAA0B;AAC1B,mDAAmD,YAAY;AAC/D,YAAY;AACZ;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE;AAC7F;AACA,0BAA0B;AAC1B,YAAY;AACZ;AACA;AACA,8CAA8C;AAC9C;AACA,oCAAoC,cAAc,GAAG,EAAE,cAAc,UAAU,EAAE,cAAc,IAAI;AACnG;AACA,kCAAkC,iBAAiB,QAAQ;AAC3D;AACA;AACA,6BAA6B,oBAAoB;AACjD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc,MAAM;AAC3D;AACA;AACA,0BAA0B;AAC1B;AACA,yBAAyB,MAAM;AAC/B,6BAA6B;AAC7B,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc,MAAM;AAC3D;AACA;AACA;AACA,0BAA0B;AAC1B,6BAA6B;AAC7B,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA,YAAY;AACZ,0BAA0B;AAC1B,4BAA4B,uBAAuB;AACnD;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C,kBAAkB,eAAe;AACjC,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,2BAA2B;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,6BAA6B;AAC7B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA,0BAA0B;AAC1B,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,GAAG,KAAK;AAC9C;AACA;AACA;AACA;AACA,gCAAgC,OAAO,GAAG,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA,mCAAmC,mEAAmE;AACtG;AACA,mCAAmC,6CAA6C;AAChF;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mCAAmC,6CAA6C;AAChF;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA,+CAA+C,oBAAoB;AACnE;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,sBAAsB;AAC/B,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,GAAG,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,OAAO,0BAA0B,GAAG,qCAAqC;AAC5G;AACA;AACA;AACA,kBAAkB,GAAG,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAgD,WAAW;AAChF,6CAA6C,6CAA6C,EAAE;AAC5F,sCAAsC,yCAAyC;AAC/E,kCAAkC,iEAAiE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,sEAAsE,oBAAoB,IAAI,oBAAoB,EAAE;AACpH,oEAAoE,qBAAqB,IAAI,qBAAqB,KAAK;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,SAAS;AACT,mBAAmB,EAAE,4BAA4B;AACjD,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kBAAkB;AAC3B,cAAc,SAAS;AACvB,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,cAAc,QAAQ;AACtB,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,UAAU;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA,gBAAgB;AAChB,iFAAiF,MAAM,yBAAyB,OAAO,iBAAiB,MAAM,yBAAyB,OAAO;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA,6DAA6D;AAC7D,WAAW;AACX;AACA,WAAW;AACX,WAAW;AACX,mBAAmB,2EAA2E;AAC9F,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAmC;AACpD,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,GAAG,wCAAwC,EAAE,EAAE;AAClG;AACA;AACA,mDAAmD,GAAG,wCAAwC,EAAE,EAAE;AAClG;AACA;AACA,mDAAmD,GAAG,mBAAmB,EAAE,OAAO;AAClF;AACA;AACA,mDAAmD,GAAG,mBAAmB,GAAG;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2BAA2B;AACrD;AACA,6EAA6E,cAAc,aAAa,eAAe;AACvH,gCAAgC,cAAc,YAAY,yBAAyB,gBAAgB,OAAO;AAC1G;AACA,wBAAwB,oBAAoB,uFAAuF;AACnI;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B;AACzD,yCAAyC,sBAAsB;AAC/D;AACA;AACA;AACA;AACA,mCAAmC,cAAc,yBAAyB,aAAa,EAAE;AACzF;AACA;AACA,mCAAmC,cAAc,yBAAyB,aAAa,EAAE;AACzF;AACA;AACA,mCAAmC,cAAc,IAAI,aAAa,OAAO;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA,8DAA8D,aAAa;AAC3E;AACA,gBAAgB,cAAc;AAC9B,cAAc;AACd,wCAAwC,aAAa;AACrD,gBAAgB,cAAc,IAAI,aAAa;AAC/C,sCAAsC,aAAa;AACnD;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iBAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD,aAAa,kDAAkD,iBAAiB,QAAQ,kBAAkB,UAAU;AACpH,aAAa,yDAAyD,iBAAiB;AACvF,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD,aAAa,kDAAkD,iBAAiB,QAAQ,kBAAkB,UAAU;AACpH,aAAa,yDAAyD,iBAAiB,mBAAmB;AAC1G;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAkD,iBAAiB,qBAAqB;AACrG,aAAa,yDAAyD,iBAAiB;AACvF,0BAA0B,aAAa;AACvC;AACA;AACA,8CAA8C,kBAAkB;AAChE,eAAe,mDAAmD,iBAAiB,WAAW,eAAe,YAAY,kBAAkB,UAAU;AACrJ,4BAA4B,aAAa;AACzC;AACA,iBAAiB;AACjB;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAkD,iBAAiB,qBAAqB;AACrG,aAAa,yDAAyD,iBAAiB;AACvF,0BAA0B,aAAa;AACvC,8CAA8C,kBAAkB;AAChE,eAAe,mDAAmD,iBAAiB,WAAW,eAAe,YAAY,kBAAkB,UAAU;AACrJ,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,eAAe,mDAAmD,iBAAiB,WAAW,eAAe,YAAY,kBAAkB,UAAU;AACrJ,4BAA4B,aAAa;AACzC;AACA,iBAAiB;AACjB;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA,4BAA4B,aAAa;AACzC;AACA,iBAAiB;AACjB;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAkD,iBAAiB,qBAAqB;AACrG,aAAa,yDAAyD,iBAAiB;AACvF,0BAA0B,aAAa;AACvC;AACA;AACA,eAAe,mDAAmD,iBAAiB,WAAW,eAAe,yBAAyB;AACtI,4BAA4B,aAAa;AACzC;AACA,iDAAiD,kBAAkB;AACnE,iBAAiB,mDAAmD,iBAAiB,YAAY,eAAe,YAAY,kBAAkB,UAAU;AACxJ,8BAA8B,aAAa;AAC3C;AACA,mBAAmB;AACnB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAkD,iBAAiB,qBAAqB;AACrG,aAAa,yDAAyD,iBAAiB;AACvF,0BAA0B,aAAa;AACvC;AACA,eAAe,mDAAmD,iBAAiB,WAAW,eAAe,yBAAyB;AACtI,4BAA4B,aAAa;AACzC,iDAAiD,kBAAkB;AACnE,iBAAiB,mDAAmD,iBAAiB,YAAY,eAAe,YAAY,kBAAkB,UAAU;AACxJ;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA,mBAAmB;AACnB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,eAAe,qCAAqC,oBAAoB,YAAY,gBAAgB;AACpG,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,iGAAiG;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC,8DAA8D;AAC9D;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yCAAyC;AACvE;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd,2CAA2C,OAAO;AAClD;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,0BAA0B,8BAA8B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,UAAU;AACxF;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd,8BAA8B,6BAA6B;AAC3D;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iCAAiC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc,uCAAuC,aAAa;AAC1G;AACA;AACA;AACA,sDAAsD,cAAc,wBAAwB,aAAa;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,cAAc,cAAc,aAAa;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,wDAAwD;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,4BAA4B,WAAW,2BAA2B;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ,WAAW,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,YAAY,KAAK,cAAc;AACnG;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gEAAgE;AAClF;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA,oBAAoB,oCAAoC;AACxD,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA,0BAA0B,6BAA6B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,UAAU;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,UAAU;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA,oEAAoE,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB,kEAAkE,SAAS;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,WAAW,mBAAmB,cAAc,mBAAmB,OAAO,aAAa;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA,0BAA0B,wBAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd,8BAA8B,mBAAmB;AACjD;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU,EAAE,UAAU,EAAE,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,gDAAgD;AACzD,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,gEAAgE,MAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C,6BAA6B;AAC1E;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAA0D;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,eAAe;AACxB,cAAc,YAAY;AAC1B,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU,uCAAuC;AACvG;AACA,gBAAgB;AAChB;AACA,6CAA6C,uCAAuC,SAAS,IAAI,IAAI,qCAAqC;AAC1I;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,4CAA4C,qCAAqC;AACjF,cAAc;AACd,+CAA+C;AAC/C;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oBAAoB;AACxE;AACA;AACA,uCAAuC,6BAA6B;AACpE;AACA,sDAAsD,oBAAoB,GAAG,WAAW;AACxF;AACA;AACA;AACA,oDAAoD,oBAAoB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oBAAoB;AACxE;AACA;AACA,8FAA8F,oBAAoB;AAClH;AACA,SAAS;AACT;AACA,gCAAgC,sCAAsC;AACtE,gCAAgC,6CAA6C;AAC7E,gCAAgC,6CAA6C;AAC7E,gCAAgC,6CAA6C;AAC7E,gCAAgC,oCAAoC;AACpE;AACA;AACA,+CAA+C,2CAA2C;AAC1F;AACA;AACA;AACA,uDAAuD,gFAAgF,GAAG;AAC1I;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC,wBAAwB,qBAAqB;AAC7C,0BAA0B;AAC1B,aAAa;AACb,oBAAoB,6BAA6B;AACjD,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC,0BAA0B,sBAAsB;AAChD,wBAAwB,sBAAsB;AAC9C,0BAA0B;AAC1B,aAAa;AACb;AACA,+BAA+B;AAC/B,YAAY;AACZ;AACA;AACA;AACA,0BAA0B,aAAa;AACvC,wBAAwB,eAAe;AACvC,0BAA0B;AAC1B,cAAc;AACd;AACA;AACA,2BAA2B,gEAAgE;AAC3F;AACA,yBAAyB;AACzB;AACA;AACA,2DAA2D;AAC3D;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,kCAAkC,uCAAuC;AACzE,SAAS;AACT;AACA,gBAAgB,qBAAqB;AACrC,UAAU;AACV,UAAU;AACV,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA,+FAA+F,WAAW;AAC1G;AACA,iCAAiC,cAAc,IAAI,iBAAiB,IAAI,iBAAiB,IAAI,iBAAiB;AAC9G;AACA;AACA,iCAAiC,cAAc,IAAI,iBAAiB,IAAI,iBAAiB;AACzF;AACA;AACA,+BAA+B,cAAc,IAAI,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA,gDAAgD,sCAAsC,GAAG,WAAW;AACpG;AACA;AACA,8BAA8B,MAAM,IAAI,wBAAwB;AAChE;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oEAAoE,sCAAsC,GAAG,SAAS;AACtH;AACA;AACA,8BAA8B,MAAM,IAAI,wBAAwB;AAChE,cAAc;AACd;AACA;AACA;AACA,wBAAwB,sCAAsC,EAAE,8BAA8B;AAC9F,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA,SAAS;AACT;AACA,iCAAiC,SAAS;AAC1C,UAAU;AACV;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA,gDAAgD,iBAAiB,GAAG,cAAc;AAClF;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,iCAAiC;AAC1C,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,uBAAuB;AACrC,cAAc,yBAAyB;AACvC,cAAc,yBAAyB;AACvC,cAAc,uBAAuB;AACrC,cAAc,yBAAyB;AACvC,cAAc,yBAAyB;AACvC,cAAc,uBAAuB;AACrC,cAAc,yBAAyB;AACvC,cAAc,yBAAyB;AACvC,cAAc,iBAAiB;AAC/B,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,2BAA2B;AACzC,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,oBAAoB;AAClC,cAAc,sBAAsB;AACpC,cAAc,sBAAsB;AACpC,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA,6CAA6C,gBAAgB,GAAG,gBAAgB,uDAAuD,wBAAwB,GAAG,wBAAwB;AAC1L;AACA;AACA;AACA;AACA,8DAA8D,sBAAsB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,uDAAuD,eAAe;AACtE;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB,MAAM;AACvD;AACA;AACA;AACA,8BAA8B,kEAAkE,IAAI;AACpG;AACA;AACA;AACA,8BAA8B,4DAA4D,UAAU;AACpG;AACA;AACA;AACA,8BAA8B,4DAA4D,eAAe;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA,YAAY;AACZ,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,oBAAoB,iBAAiB;AACrC,4BAA4B,2BAA2B;AACvD;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,0kBAA0kB;AACnlB,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,gBAAgB;AACzB,cAAc,UAAU;AACxB;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,OAAO,EAAE,uBAAuB;AAChC,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,qCAAqC;AAC9C,cAAc,QAAQ;AACtB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,qCAAqC;AAC9C,cAAc,QAAQ;AACtB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C;AACA,cAAc,cAAc;AAC5B,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF,4DAA4D,uDAAuD;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,sDAAsD;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,QAAQ;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,GAAG,KAAK;AACxC;AACA;AACA;AACA,yDAAyD,uBAAuB;AAChF;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA,mEAAmE,WAAW;AAC9E;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,uBAAuB;AAC5E;AACA;AACA;AACA,mDAAmD,uBAAuB;AAC1E;AACA;AACA;AACA,0DAA0D,uBAAuB;AACjF;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA,yCAAyC;AACzC;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,YAAY;AACZ,4BAA4B,+BAA+B;AAC3D;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,oFAAoF,GAAG;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,uBAAuB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uBAAuB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,uBAAuB;AAC3E;AACA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA,kCAAkC,uBAAuB,WAAW,GAAG,8BAA8B,gBAAgB;AACrH;AACA;AACA;AACA;AACA;AACA,wDAAwD,uBAAuB;AAC/E;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,WAAW;AAC3E;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,8BAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,aAAa,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,aAAa,OAAO;AACjD;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV,cAAc,QAAQ;AACtB,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,0BAA0B;AAC1B,2BAA2B,MAAM;AACjC;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA,cAAc;AACd;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM,OAAO,KAAK,cAAc,KAAK,kBAAkB,KAAK;AAC3F,gBAAgB;AAChB,+BAA+B,MAAM,OAAO,KAAK;AACjD;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D,gCAAgC;AAChC,YAAY;AACZ,4CAA4C,YAAY,KAAK,kBAAkB;AAC/E,mDAAmD,YAAY;AAC/D,YAAY;AACZ,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC,cAAc;AACd;AACA,6BAA6B,UAAU;AACvC,cAAc;AACd;AACA,6BAA6B,UAAU;AACvC;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,IAAI;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,uCAAuC,KAAK;AAC5C,cAAc;AACd,kCAAkC,KAAK;AACvC;AACA,YAAY;AACZ,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E,gCAAgC,WAAW,EAAE,uBAAuB,OAAO,EAAE,kBAAkB,EAAE,mBAAmB,EAAE;AACtH;AACA,0BAA0B;AAC1B,YAAY;AACZ;AACA;AACA;AACA;AACA,oCAAoC,cAAc,GAAG,EAAE,cAAc,UAAU,EAAE,cAAc,IAAI;AACnG;AACA,kCAAkC,iBAAiB,QAAQ;AAC3D;AACA;AACA,6BAA6B,oBAAoB;AACjD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc,GAAG,EAAE,cAAc,UAAU,EAAE,cAAc,IAAI;AACjG;AACA;AACA,+BAA+B;AAC/B;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc,GAAG,EAAE,cAAc,UAAU,EAAE,cAAc,IAAI;AACjG;AACA;AACA;AACA,+BAA+B;AAC/B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA,YAAY;AACZ,0BAA0B;AAC1B,4BAA4B,uBAAuB;AACnD;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,6CAA6C,wCAAwC;AACrF;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,0CAA0C,YAAY;AACtD,gBAAgB;AAChB;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA,6CAA6C,wCAAwC;AACrF;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,2BAA2B;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,6BAA6B;AAC7B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA,+CAA+C,sBAAsB;AACrE;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA,4BAA4B;AAC5B;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,oCAAoC;AACpC;AACA,cAAc;AACd;AACA;AACA,mCAAmC,SAAS;AAC5C,gBAAgB;AAChB;AACA,iCAAiC,SAAS;AAC1C;AACA,kBAAkB;AAClB,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,gCAAgC;AAChC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0BAA0B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,GAAG,yBAAyB;AAClE;AACA;AACA;AACA;AACA,gCAAgC,OAAO,GAAG,yBAAyB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY,KAAK,YAAY,SAAS,YAAY;AAC3F;AACA;AACA;AACA;AACA,oDAAoD,YAAY,KAAK,YAAY,SAAS,YAAY;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY,KAAK,YAAY,SAAS,YAAY;AACvG;AACA;AACA;AACA;AACA,mDAAmD,YAAY,KAAK,YAAY,SAAS,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY,KAAK,YAAY,SAAS,YAAY;AACvG;AACA;AACA;AACA;AACA,mDAAmD,YAAY,KAAK,YAAY,SAAS,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY,KAAK,YAAY,SAAS,YAAY;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY,KAAK,YAAY,SAAS,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,WAAW,IAAI,WAAW,QAAQ,WAAW;AACjG;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW,IAAI,WAAW,QAAQ,WAAW;AACrF;AACA;AACA,yCAAyC,WAAW,IAAI,WAAW,QAAQ,WAAW;AACtF;AACA;AACA;AACA,yCAAyC,WAAW,IAAI,WAAW,QAAQ,WAAW;AACtF;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY,KAAK,YAAY,SAAS,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,GAAG,+CAA+C;AAC1F;AACA,gCAAgC,+CAA+C;AAC/E;AACA;AACA;AACA,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kCAAkC;AAC5E,sBAAsB;AACtB;AACA,sBAAsB;AACtB,4EAA4E,eAAe;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,eAAe;AAC7H;AACA;AACA,wCAAwC,KAAK,QAAQ,KAAK,YAAY,KAAK;AAC3E;AACA;AACA;AACA;AACA,8EAA8E,eAAe,OAAO,aAAa,uBAAuB,eAAe;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA,gCAAgC,OAAO;AACvC;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,wCAAwC;AACjD,cAAc,0BAA0B;AACxC,cAAc,wBAAwB;AACtC,cAAc,0BAA0B;AACxC;AACA,cAAc,4BAA4B;AAC1C,cAAc,mCAAmC;AACjD;AACA,cAAc,4BAA4B;AAC1C,cAAc,mCAAmC;AACjD;AACA,cAAc,8BAA8B;AAC5C,cAAc,qCAAqC;AACnD;AACA,cAAc,gCAAgC;AAC9C,cAAc,uCAAuC;AACrD;AACA,cAAc,+CAA+C;AAC7D,cAAc,sDAAsD;AACpE;AACA,cAAc,gCAAgC;AAC9C,cAAc,uCAAuC;AACrD;AACA,cAAc,8BAA8B;AAC5C,cAAc,qCAAqC;AACnD;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA,cAAc,+BAA+B;AAC7C,cAAc,+BAA+B;AAC7C,cAAc,+BAA+B;AAC7C;AACA,cAAc,gCAAgC;AAC9C,cAAc,uCAAuC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,wiCAAwiC;AACjjC,cAAc,mBAAmB;AACjC,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA,2DAA2D,OAAO,8BAA8B,gBAAgB;AAChH,cAAc;AACd,4DAA4D,QAAQ,8BAA8B,gBAAgB;AAClH,cAAc;AACd,sEAAsE,QAAQ,8BAA8B,gBAAgB;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,IAAI,OAAO;AACrD;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,uCAAuC;AAChD,cAAc,mCAAmC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,0BAA0B;AACnC,cAAc,QAAQ;AACtB,cAAc,+CAA+C;AAC7D;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,4DAA4D;AACrE,cAAc,QAAQ;AACtB,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,2CAA2C;AACpD,cAAc,QAAQ;AACtB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,yCAAyC;AAClD,cAAc,QAAQ;AACtB,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,yCAAyC;AAClD,cAAc,QAAQ;AACtB,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,2CAA2C;AACpD,cAAc,QAAQ;AACtB,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,2CAA2C;AACpD,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA,oCAAoC,SAAS,IAAI,MAAM,GAAG;AAC1D;AACA,kCAAkC,SAAS,IAAI,OAAO;AACtD;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kBAAkB;AAC3B,cAAc,QAAQ;AACtB,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,GAAG,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,sBAAsB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA,gCAAgC,SAAS,KAAK,kBAAkB;AAChE;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,aAAa,SAAS;AAC3E;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW,GAAG,UAAU;AAC7D;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB;AAChB,wBAAwB,iBAAiB;AACzC,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,aAAa,SAAS;AAC3E;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW,GAAG,UAAU;AAC7D;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB;AAChB,wBAAwB,iBAAiB;AACzC,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,yEAAyE;AAClF,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,qBAAqB,uBAAuB;AACxF,yBAAyB,aAAa,gBAAgB,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,qBAAqB,uBAAuB;AACxF,yBAAyB,aAAa,gBAAgB,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,SAAS,SAAS,GAAG,SAAS,EAAE;AAC1E;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,qBAAqB,uBAAuB;AACxF,yBAAyB,aAAa,gBAAgB,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,SAAS,SAAS,GAAG,SAAS,GAAG,SAAS,EAAE;AACtF;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,qBAAqB,uBAAuB;AACxF,yBAAyB,aAAa,gBAAgB,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,SAAS,SAAS,GAAG,SAAS,GAAG,SAAS,GAAG,SAAS,EAAE;AAClG;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,qBAAqB,uBAAuB;AACxF,yBAAyB,aAAa,sBAAsB,UAAU;AACtE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW,QAAQ,2BAA2B,GAAG,uBAAuB;AAC5G,iCAAiC,WAAW,kCAAkC,UAAU;AACxF,yBAAyB,aAAa,mBAAmB,UAAU;AACnE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW,QAAQ,2BAA2B,GAAG,uBAAuB;AAC5G,iCAAiC,WAAW,kCAAkC,UAAU;AACxF,yBAAyB,aAAa,yBAAyB,UAAU;AACzE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,WAAW;AACzB,cAAc,kBAAkB;AAChC,cAAc,oBAAoB;AAClC,cAAc,QAAQ;AACtB;AACA,cAAc,iBAAiB;AAC/B,cAAc,eAAe;AAC7B,cAAc,iBAAiB;AAC/B,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAoE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uCAAuC;AACjE;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,0CAA0C,aAAa,IAAI,aAAa,IAAI,aAAa;AACzF,wCAAwC,WAAW,IAAI,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,YAAY;AACZ,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,8DAA8D,iBAAiB;AAC/E;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gBAAgB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sDAAsD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,iCAAiC,MAAM,MAAM,sDAAsD,yBAAyB,wBAAwB;AACpJ;AACA,cAAc;AACd;AACA,iCAAiC,MAAM,MAAM,sDAAsD,mBAAmB,wBAAwB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,iBAAiB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,iCAAiC,MAAM,IAAI,SAAS,0BAA0B,wBAAwB;AACtG;AACA,cAAc;AACd;AACA,iCAAiC,MAAM,IAAI,SAAS,oBAAoB,wBAAwB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,iCAAiC,MAAM,+BAA+B,eAAe;AACrF;AACA,cAAc;AACd;AACA,iCAAiC,MAAM,yBAAyB,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA,+BAA+B,MAAM,yBAAyB,wBAAwB;AACtF,+BAA+B,MAAM,yBAAyB,wBAAwB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA,+BAA+B,MAAM,yBAAyB,wBAAwB;AACtF,+BAA+B,MAAM,yBAAyB,wBAAwB;AACtF,+BAA+B,MAAM,yBAAyB,wBAAwB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA,qCAAqC,MAAM,4BAA4B,wBAAwB;AAC/F;AACA,kBAAkB;AAClB;AACA,qCAAqC,MAAM,sBAAsB,wBAAwB;AACzF;AACA;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,wCAAwC,SAAS;AACjD,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,qOAAqO;AAC9O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV,cAAc,QAAQ;AACtB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,uCAAuC,KAAK;AAC5C,cAAc;AACd,kCAAkC,KAAK;AACvC;AACA,YAAY;AACZ,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,+CAA+C;AACxD,cAAc,2BAA2B;AACzC,cAAc,yBAAyB;AACvC,cAAc,2BAA2B;AACzC;AACA,cAAc,6BAA6B;AAC3C,cAAc,oCAAoC;AAClD;AACA,cAAc,kCAAkC;AAChD,cAAc,yCAAyC;AACvD;AACA,cAAc,6BAA6B;AAC3C,cAAc,oCAAoC;AAClD;AACA,cAAc,+BAA+B;AAC7C,cAAc,sCAAsC;AACpD;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA,cAAc,gDAAgD;AAC9D,cAAc,uDAAuD;AACrE;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA,cAAc,+BAA+B;AAC7C,cAAc,sCAAsC;AACpD;AACA,cAAc,kCAAkC;AAChD,cAAc,yCAAyC;AACvD;AACA,cAAc,kCAAkC;AAChD,cAAc,yCAAyC;AACvD;AACA,cAAc,kCAAkC;AAChD,cAAc,yCAAyC;AACvD;AACA,cAAc,gCAAgC;AAC9C,cAAc,gCAAgC;AAC9C,cAAc,gCAAgC;AAC9C;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,+nCAA+nC;AACxoC,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,uCAAuC;AAChD,cAAc,QAAQ;AACtB,cAAc,kCAAkC;AAChD;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,iBAAiB,QAAQ;AACrE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAAwB,oBAAoB,QAAQ,kBAAkB;AACtE;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,mCAAmC;AACjD;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAAwB,oBAAoB,QAAQ,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,uEAAuE;AAChF,cAAc,QAAQ;AACtB,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,+CAA+C;AACxD,cAAc,QAAQ;AACtB,cAAc,sDAAsD;AACpE;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,4FAA4F;AACrG,cAAc,QAAQ;AACtB,cAAc,uCAAuC;AACrD;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAAwB,oBAAoB,QAAQ,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,2EAA2E;AACpF,cAAc,QAAQ;AACtB,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAAwB,oBAAoB,QAAQ,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kEAAkE;AAC3E,cAAc,QAAQ;AACtB,cAAc,kCAAkC;AAChD;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAAwB,oBAAoB,QAAQ,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,sEAAsE;AAC/E,cAAc,QAAQ;AACtB,cAAc,kCAAkC;AAChD;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAAwB,oBAAoB,QAAQ,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,sEAAsE;AAC/E,cAAc,QAAQ;AACtB,cAAc,kCAAkC;AAChD;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAAwB,oBAAoB,QAAQ,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,uEAAuE;AAChF,cAAc,QAAQ;AACtB,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAAwB,oBAAoB,QAAQ,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,mEAAmE;AAC5E,cAAc,QAAQ;AACtB,cAAc,uCAAuC;AACrD;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAAwB,oBAAoB,QAAQ,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,2EAA2E;AACpF,cAAc,QAAQ;AACtB,cAAc,uCAAuC;AACrD;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAAwB,oBAAoB,QAAQ,kBAAkB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,2EAA2E;AACpF,cAAc,QAAQ;AACtB,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,0DAA0D;AACnE,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,iBAAiB,QAAQ;AACrE,gBAAgB,oBAAoB,QAAQ,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AAC/G,gBAAgB,oBAAoB,QAAQ,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AAC1I;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,0DAA0D;AACnE,cAAc,QAAQ;AACtB,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,gBAAgB,oBAAoB,QAAQ,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AAC/G,gBAAgB,oBAAoB,QAAQ,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,+DAA+D;AACxE,cAAc,QAAQ;AACtB,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,uCAAuC;AAChD,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA,6BAA6B,oBAAoB,MAAM,SAAS,KAAK,kBAAkB;AACvF;AACA,6BAA6B,oBAAoB,MAAM,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,uCAAuC;AAChD,cAAc,QAAQ;AACtB,cAAc,+CAA+C;AAC7D;AACA;AACA;AACA,kBAAkB,oDAAoD;AACtE;AACA;AACA,iCAAiC,GAAG;AACpC,gBAAgB,oBAAoB,QAAQ,QAAQ,UAAU,eAAe,IAAI,eAAe;AAChG,gBAAgB,oBAAoB,QAAQ,cAAc,UAAU,cAAc,IAAI,cAAc,IAAI,cAAc;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,oFAAoF;AAC7F,cAAc,QAAQ;AACtB,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA,kBAAkB,oDAAoD;AACtE;AACA;AACA,wBAAwB,oBAAoB,YAAY,GAAG;AAC3D,gBAAgB,oBAAoB,QAAQ,QAAQ,UAAU,eAAe,IAAI,eAAe;AAChG,gBAAgB,oBAAoB,QAAQ,cAAc,UAAU,cAAc,IAAI,cAAc,IAAI,cAAc;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,mEAAmE;AAC5E,cAAc,QAAQ;AACtB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,gBAAgB,oBAAoB,QAAQ,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AAC/G,gBAAgB,oBAAoB,QAAQ,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,iEAAiE;AAC1E,cAAc,QAAQ;AACtB,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,qEAAqE;AAC9E,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,qEAAqE;AAC9E,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,qEAAqE;AAC9E,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,gBAAgB,oBAAoB,QAAQ,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AAC/G,gBAAgB,oBAAoB,QAAQ,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AAC1I;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,iEAAiE;AAC1E,cAAc,QAAQ;AACtB,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,gBAAgB,oBAAoB,QAAQ,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AAC/G,gBAAgB,oBAAoB,QAAQ,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,mEAAmE;AAC5E,cAAc,QAAQ;AACtB,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,gBAAgB,oBAAoB,QAAQ,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AAC/G,gBAAgB,oBAAoB,QAAQ,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AAC1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,mEAAmE;AAC5E,cAAc,cAAc;AAC5B,cAAc,qBAAqB;AACnC,cAAc,kBAAkB;AAChC,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B,cAAc,eAAe;AAC7B,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB,eAAe;AAC7D,YAAY;AACZ,2BAA2B,oBAAoB,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D,8CAA8C,iBAAiB;AAC/D,0CAA0C,OAAO,kBAAkB,OAAO;AAC1E;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE,0CAA0C,OAAO,kBAAkB,OAAO;AAC1E;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE,0CAA0C,OAAO,kBAAkB,OAAO;AAC1E;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE,0CAA0C,OAAO,kBAAkB,OAAO;AAC1E;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gBAAgB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAsD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,yBAAyB,OAAO,IAAI,sDAAsD,yBAAyB,wBAAwB;AAC3I;AACA,cAAc;AACd;AACA,yBAAyB,OAAO,IAAI,sDAAsD,mBAAmB,wBAAwB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,yBAAyB,MAAM,GAAG,SAAS,0BAA0B,eAAe;AACpF;AACA,cAAc;AACd;AACA,yBAAyB,MAAM,GAAG,SAAS,oBAAoB,eAAe;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,yBAAyB,MAAM,8BAA8B,eAAe;AAC5E;AACA,cAAc;AACd;AACA,yBAAyB,MAAM,wBAAwB,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA,uBAAuB,MAAM,wBAAwB,eAAe;AACpE,uBAAuB,MAAM,wBAAwB,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA,uBAAuB,MAAM,wBAAwB,eAAe;AACpE,uBAAuB,MAAM,wBAAwB,eAAe;AACpE,uBAAuB,MAAM,wBAAwB,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA,uBAAuB,OAAO,oBAAoB,wBAAwB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,2JAA2J;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO,EAAE,cAAc;AACvB,cAAc,UAAU;AACxB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB,cAAc,YAAY;AAC1B,cAAc,mBAAmB;AACjC,cAAc,eAAe;AAC7B,cAAc,cAAc;AAC5B,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA,iDAAiD,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,cAAc;AACd,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA,YAAY;AACZ,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iBAAiB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,uMAAuM;AAChN,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,eAAe;AAC7B,cAAc,UAAU;AACxB,cAAc,kBAAkB;AAChC,cAAc,eAAe;AAC7B,cAAc,kBAAkB;AAChC,cAAc,YAAY;AAC1B;AACA,cAAc,mBAAmB;AACjC;AACA,cAAc,oBAAoB;AAClC,cAAc,cAAc;AAC5B,cAAc,wCAAwC;AACtD;AACA,cAAc,qBAAqB;AACnC,cAAc,eAAe;AAC7B,cAAc,yCAAyC;AACvD;AACA,cAAc,WAAW;AACzB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,ijBAAijB;AAC1jB;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB,iBAAiB,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,YAAY;AACjH;AACA,YAAY;AACZ;AACA,4CAA4C,mBAAmB,iBAAiB,GAAG,IAAI,GAAG,IAAI,QAAQ;AACtG;AACA,YAAY;AACZ;AACA,4CAA4C,mBAAmB,iBAAiB,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,cAAc;AACvB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,cAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA,cAAc,QAAQ;AACtB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qDAAqD,8BAA8B;AACnF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ,qDAAqD,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C,4BAA4B,qBAAqB;AACjD,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,SAAS;AACzC,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA,wDAAwD,OAAO,IAAI,SAAS,iCAAiC,SAAS;AACtH,YAAY;AACZ,wDAAwD,OAAO,IAAI,SAAS;AAC5E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,0CAA0C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA,mCAAmC,YAAY,GAAG,mCAAmC,KAAK,mBAAmB;AAC7G;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,yBAAyB,IAAI,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,4BAA4B,UAAU,EAAE,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa,IAAI,kBAAkB;AACnE,sBAAsB;AACtB;AACA;AACA,oBAAoB;AACpB,8BAA8B,aAAa,IAAI,kBAAkB;AACjE;AACA;AACA;AACA,gCAAgC,2BAA2B,GAAG,6BAA6B,GAAG,sDAAsD;AACpJ;AACA;AACA,gCAAgC,2BAA2B,GAAG,6BAA6B,GAAG,sDAAsD;AACpJ;AACA;AACA;AACA,gCAAgC,yBAAyB,GAAG,sDAAsD;AAClH,sBAAsB;AACtB;AACA;AACA,kCAAkC,uBAAuB,GAAG,yBAAyB,GAAG,sDAAsD;AAC9I,wBAAwB;AACxB;AACA,kCAAkC,yBAAyB,GAAG,sDAAsD;AACpH;AACA,sBAAsB;AACtB,gCAAgC,2BAA2B,GAAG,yBAAyB,GAAG,sDAAsD;AAChJ,sBAAsB;AACtB;AACA;AACA;AACA;AACA,qCAAqC,sBAAsB;AAC3D;AACA,+BAA+B,kBAAkB,EAAE,aAAa,EAAE,mBAAmB;AACrF;AACA;AACA,gCAAgC,cAAc,EAAE,sBAAsB;AACtE,sBAAsB;AACtB,gCAAgC,uBAAuB,EAAE,aAAa;AACtE;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA,iCAAiC,yBAAyB;AAC1D;AACA,iCAAiC,mCAAmC,OAAO,kBAAkB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB,GAAG,sBAAsB;AAC/E;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB,GAAG,sDAAsD;AACjH;AACA,qCAAqC,mBAAmB,EAAE,mBAAmB,EAAE,oBAAoB,IAAI,kBAAkB;AACzH;AACA,gCAAgC,kBAAkB,EAAE,aAAa,EAAE,mBAAmB;AACtF;AACA,gCAAgC,sBAAsB,EAAE,aAAa;AACrE;AACA,oCAAoC,kBAAkB,IAAI,wBAAwB;AAClF;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,gCAAgC,kBAAkB,GAAG,wBAAwB,GAAG,uBAAuB;AACvG;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yCAAyC,4CAA4C;AACrF;AACA;AACA,sBAAsB,aAAa;AACnC,0CAA0C,mCAAmC;AAC7E;AACA;AACA,iDAAiD,qDAAqD;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,uBAAuB;AACvB,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd,sBAAsB,WAAW;AACjC,yCAAyC,gCAAgC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B,gBAAgB;AAC7C,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B,gBAAgB;AAC7C,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B,gBAAgB;AAC7C,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B,gBAAgB;AAC7C,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B;AAC7B,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B;AAC7B,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B;AAC7B,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B;AAC7B,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qDAAqD,cAAc;AACnE,oBAAoB,OAAO;AAC3B;AACA,YAAY;AACZ,sHAAsH,kCAAkC;AACxJ;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,wCAAwC,EAAE,GAAG;AACtD,OAAO;;;;;;;AC1hmBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;;;;;UCZA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;;;;;ACCA;AAEA,IAAIT,OAAO,GAAG,IAAI6F,6EAAJ,EAAd;AACA,IAAI/D,EAAE,GAAI,UAAS0E,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAc,WAAzB,CAAsC,EAAzD;AACA,IAAI6H,OAAO,GAAG,CAAd;;AAEAlM,IAAI,CAACwF,SAAL,GAAiB,MAAOU,KAAP,IAAiB;AAChC,MAAI7G,KAAJ;AACA,MAAG6G,KAAK,CAACC,IAAN,CAAW3H,MAAd,EAAsBa,KAAK,GAAG6G,KAAK,CAACC,IAAN,CAAW3H,MAAnB,CAAtB,CAAiD;AAAjD,OACKa,KAAK,GAAG6G,KAAK,CAACC,IAAd,CAH2B,CAIhC;;AAEA,MAAI0F,IAAJ;AACA,MAAIrN,MAAM,GAAGZ,SAAb;;AACA,MAAGsI,KAAK,CAACC,IAAN,EAAY7H,SAAf,EAA0B;AAAE;AAC1BX,IAAAA,OAAO,CAACqG,MAAR,CAAe5F,QAAf,CAAwB8H,KAAK,CAACC,IAA9B;AACD,GAFD,MAGK,IAAG,OAAO9G,KAAP,KAAiB,QAApB,EAA6B;AAChC,QAAGA,KAAK,CAACoE,MAAN,KAAiB7F,SAApB,EAA+B;AAAE;AAC/BD,MAAAA,OAAO,CAAC8F,MAAR,GAAiBpE,KAAK,CAACoE,MAAvB;AACD;;AACD,QAAGpE,KAAK,CAACsE,OAAN,KAAkB/F,SAArB,EAAiC;AAAE;AACjCD,MAAAA,OAAO,CAAC+F,GAAR,GAAc/F,OAAO,CAAC8F,MAAR,CAAe0I,UAAf,CAA0B9M,KAAK,CAACsE,OAAhC,CAAd;AACAhG,MAAAA,OAAO,CAACgG,OAAR,GAAkBhG,OAAO,CAAC+F,GAA1B,CAF+B,CAEA;AAChC;;AAED,QAAI+B,YAAY,GAAG9H,OAAO,CAAC+H,WAAR,CAAoBrG,KAAK,CAACpB,GAA1B,EAA8BoB,KAAK,CAACH,MAApC,CAAnB,CATgC,CAUhC;;AAEAV,IAAAA,MAAM,GAAG,MAAMb,OAAO,CAACsI,cAAR,CAAuBC,KAAvB,CAAf,CAZgC,CAYe;;AAC/CgG,IAAAA,OAAO,GAbyB,CAarB;AAEX;;AACA,QAAIrM,QAAQ,GAAGjC,SAAf;;AACA,QAAGY,MAAH,EAAW;AACT,UAAGA,MAAM,CAAC6G,SAAP,EAAkBA,SAAlB,EAA6B3H,WAA7B,CAAyCQ,IAAzC,KAAkD,YAArD,EAAmE;AACjE2B,QAAAA,QAAQ,GAAG,CAACrB,MAAM,CAAC0I,MAAR,CAAX;AACD,OAFD,MAEO,IAAI1I,MAAM,CAACd,WAAP,EAAoBQ,IAApB,KAA6B,QAAjC,EAA2C;AAC9C,aAAI,MAAM+G,GAAV,IAAiBzG,MAAjB,EAAyB;AACrB,cAAGA,MAAM,CAACyG,GAAD,CAAN,CAAYI,SAAZ,EAAuBA,SAAvB,EAAkC3H,WAAlC,CAA8CQ,IAA9C,KAAuD,YAA1D,EAAwE;AACpE,gBAAG,CAAC2B,QAAJ,EAAcA,QAAQ,GAAGrB,MAAM,CAACyG,GAAD,CAAN,CAAYiC,MAAvB,CAAd,KACKrH,QAAQ,CAAC2E,IAAT,CAAchG,MAAM,CAACyG,GAAD,CAAN,CAAYiC,MAA1B;AACR;AACJ;AACJ;AACF,KA5B+B,CA6BhC;;;AAEA2E,IAAAA,IAAI,GAAG;AAACrN,MAAAA,MAAM,EAAEA,MAAT;AAAiBP,MAAAA,GAAG,EAAEoB,KAAK,CAACpB,GAA5B;AAAiCiB,MAAAA,MAAM,EAAEG,KAAK,CAACH,MAA/C;AAAuDkN,MAAAA,UAAU,EAAE/M,KAAK,CAAC+M,UAAzE;AAAqFF,MAAAA,OAAO,EAACA;AAA7F,KAAP;;AACA,QAAGzG,YAAH,EAAiB;AAAC9H,MAAAA,OAAO,CAACqG,MAAR,CAAepE,IAAf,CAAoB6F,YAAY,CAACnH,SAAjC,EAA2CuN,IAA3C,EAAgDjO,SAAhD,EAA0DiC,QAA1D,EAAmE4F,YAAY,CAAC3F,IAAhF;AAAuF,KAAzG,CAA0G;AAA1G,SACK,IAAI,OAAOC,iBAAP,KAA6B,WAA7B,IAA4CC,IAAI,YAAYD,iBAAhE,EAAmF;AACpFC,MAAAA,IAAI,CAACC,WAAL,CAAiB4L,IAAjB,EAAsBhM,QAAtB,EADoF,CACnD;AACpC;AACF;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEE;;;AACA,SAAOgM,IAAP;AACD,CA5DD;;AA8DAlO,OAAO,CAACqG,MAAR,CAAepE,IAAf,CAAoB,WAApB,EAAgCH,EAAhC;AAEA,sEAAeO,IAAf,E","sources":["webpack://magic/./node_modules/objectlisteners/ObjectListener.js","webpack://magic/./node_modules/anotherstatemanager/StateManager.js","webpack://magic/./src/lib/utils/Event.js","webpack://magic/./src/lib/utils/Parsing.js","webpack://magic/./src/lib/workerCPU/workerCPU.js","webpack://magic/./src/lib/workerCallbacks.js","webpack://magic/./node_modules/gpujsutils/src/gpuUtils-functs.js","webpack://magic/./node_modules/gpujsutils/src/gpuUtils.js","webpack://magic/./src/lib/workerGPU/workerGPU.js","webpack://magic/./src/lib/workerRenderer/ProxyListener.js","webpack://magic/./src/lib/workerRenderer/workerRenderer.js","webpack://magic/./node_modules/brainsatplay-math/Math2.js","webpack://magic/./node_modules/brainsatplay-math/index.js","webpack://magic/./node_modules/gpujsutils/src/gpu-browser.min.js","webpack://magic/./src/lib/utils|lazy|groupOptions: {}|namespace object","webpack://magic/webpack/bootstrap","webpack://magic/webpack/runtime/define property getters","webpack://magic/webpack/runtime/hasOwnProperty shorthand","webpack://magic/./src/magic.worker.js"],"sourcesContent":["\r\n/*\r\n//Example:\r\nlet events = new ObjectListener();\r\nlet x = { y: 1, z: { w: 2 }}\r\n\r\n\r\nevents.addListener(\"y\",x,\"y\");\r\nevents.addListener(\"z\",x,\"z\");\r\n\r\nx.z.w = 3;\r\nx.y = 2;\r\n//See console\r\n\r\n*/\r\n\r\n//By Joshua Brewster (AGPL v3.0 License)\r\n\r\n//Create instance and then call instance.addListener(listenerName,objectToListenTo,propToListenTo,onchange,interval).\r\n//name, propToListenTo, onchange, and interval are optional (leave or set as undefined). Onchange is a custom callback just like for other event listeners. Set a name to make it easier to start and stop or edit each listener.\r\nexport class ObjectListener {\r\n    constructor(debug=false, synchronous=false) {\r\n        this.debug = debug;\r\n        this.listeners = [];\r\n        this.synchronous = synchronous;//check all listeners simulatenously instead of on individual loops. use startSync() to trigger\r\n        this.syncInterval = 'FRAMERATE'; //interval\r\n        this.syncAnim = undefined;\r\n        if(synchronous === true) this.startSync();\r\n    }\r\n\r\n    //add a new object listener with specified props (or none to watch the whole object), and onchange functions, with optional interval\r\n    addListener(listenerKey=null,objectToListenTo,propToListenTo=undefined,onchange=undefined,interval=undefined,debug=this.debug,startRunning=true) {\r\n        if(objectToListenTo === undefined) {\r\n            console.error(\"You must assign an object\");\r\n            return;\r\n        }\r\n\r\n        var key = listenerKey;\r\n        if(key == null) {\r\n            key = Math.floor(Math.random()*100000);\r\n        }\r\n        if(this.synchronous === true) startRunning = false; //negate this in case of synchronous runtime\r\n        var listener = {key:key, listener: new ObjectListenerInstance(objectToListenTo,propToListenTo,onchange,interval,debug,startRunning)};\r\n        this.listeners.push(listener);\r\n    }\r\n\r\n    getListener(key) {\r\n        let found = this.listeners.find((item,i) =>{\r\n            if(item.key === key) return true;\r\n        });\r\n        return found;\r\n    }\r\n\r\n    hasKey(key) {\r\n        var found = false;\r\n        this.listeners.forEach((item,i) =>{\r\n            if(item.key === key) {found = true; return true;}\r\n        });\r\n        return found;\r\n    }\r\n\r\n    getKeyIndices(key) {\r\n        var indices = [];\r\n        this.listeners.find((o,i) => {\r\n            if(o.key === key) {\r\n                indices.push(i);\r\n            }\r\n        });\r\n        return indices;\r\n    }\r\n\r\n    onchange(key=null,newCallback=null){\r\n        if(key == null) {\r\n            this.listeners.forEach((obj,i) => {\r\n                obj.listener.onchange = newCallback;\r\n            });\r\n        }\r\n        else {\r\n            var found = this.listeners.find((o,i) => {\r\n                if(o.name === key) {\r\n                    o.listener.onchange = newCallback;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    //Add extra onchange functions\r\n    addFunc = (key=null,newCallback=null, start=true) => {\r\n        var callbackIdx = null;\r\n        if(newCallback !== null){\r\n            if(key == null) {\r\n                this.listeners.forEach((obj,i) => {\r\n                    callbackIdx = obj.listener.addFunc(newCallback);\r\n                    if(obj.listener.running == false && start == true)\r\n                        obj.listener.start();\r\n                });\r\n            }\r\n            else {\r\n                var found = this.listeners.find((obj,i) => {\r\n                    if(obj.key === key) {\r\n                        callbackIdx = obj.listener.addFunc(newCallback);\r\n                        if(obj.listener.running == false && start == true)\r\n                            obj.listener.start();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return callbackIdx;\r\n    }\r\n\r\n    //get the array of secondary onchange functions\r\n    getFuncs = (key=undefined) => {\r\n        if(key) {\r\n            var found = this.listeners.find((o,i) => {\r\n                if(o.key === key) {\r\n                    return true;\r\n                }\r\n            });\r\n            return found.onchangeFuncs;\r\n        } else return undefined;\r\n    }\r\n\r\n    //Remove extra onchange functions\r\n    removeFuncs = (key = null, idx = null, stop=false) => {\r\n        if(key == null) {\r\n            this.listeners.forEach((obj,i) => {\r\n                obj.listener.removeFuncs(idx);\r\n            });\r\n        }\r\n        else {\r\n            var found = this.listeners.find((o,i) => {\r\n                if(o.key === key) {\r\n                    o.listener.removeFuncs(idx);\r\n                    if(o.listener.onchangeFuncs.length === 0 || stop === true) {\r\n                        o.listener.stop()\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    //Stop all or named listeners\r\n    stop(key=null) {\r\n        if(this.synchronous) this.stopSync();\r\n        if(key == null) {\r\n            this.listeners.forEach((obj,i) => {\r\n                obj.listener.stop();\r\n            });\r\n        }\r\n        else {\r\n            var found = this.listeners.find((o,i) => {\r\n                if(o.name === key) {\r\n                    o.listener.stop();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    //Restart all or named listeners\r\n    start(key=null) {\r\n        if(this.synchronous) this.stopSync();\r\n        if(key == null) {\r\n            this.listeners.forEach((obj,i) => {\r\n                obj.listener.start();\r\n            });\r\n        }\r\n        else {\r\n            var found = this.listeners.find((o,i) => {\r\n                if(o.name === key) {\r\n                    o.listener.start();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    //run listeners synchronously instead of on their own individual loops\r\n    startSync() {\r\n        if(this.synchronous === false) {\r\n            this.synchronous = true;\r\n            this.stop(); //stop the async calls\r\n            let runChecks = () => {\r\n                if(this.synchronous === true) {\r\n                    this.listeners.forEach((l)=>{\r\n                        l.listener.check();\r\n                    });\r\n                    if(this.syncInterval === 'FRAMERATE') {\r\n                        this.syncAnim = requestAnimationFrame(runChecks);\r\n                    } else if (typeof this.syncInterval === 'number') {\r\n                        setTimeout(runChecks, this.syncInterval);\r\n                    }\r\n                }\r\n            }\r\n            runChecks();\r\n        }\r\n    }\r\n\r\n    //stop the synchronous checking\r\n    stopSync() {\r\n        this.synchronous = false;\r\n        if(this.syncAnim) cancelAnimationFrame(this.syncAnim);\r\n    }   \r\n\r\n    remove(key=null){\r\n        if(key == null) {\r\n            this.listeners.forEach((o) => {\r\n                o.listener.stop();\r\n            });\r\n            this.listeners.splice(0,this.listeners.length);\r\n        }\r\n        else {\r\n            var indices = [];\r\n            var found = this.listeners.forEach((o,i) => {\r\n                if(o.key === key) {\r\n                    indices.push(i);\r\n                }\r\n            });\r\n            indices.reverse().forEach((idx) => {\r\n                this.listeners[idx].listener.stop();\r\n                this.listeners.splice(idx,1);\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n//Instance of an object listener. This will subscribe to object properties (or whole objects) and run attached functions when a change is detected.\r\nexport class ObjectListenerInstance {\r\n    constructor(object,propName=\"__ANY__\",onchange=this.onchange,interval=\"FRAMERATE\",debug=false,startRunning=true) {\r\n        this.debug=debug;\r\n\r\n        this.onchange = onchange; //Main onchange function\r\n        this.onchangeFuncs = []; //Execute extra functions pushed to this array\r\n\r\n        this.object = object; //Objects are always passed by reference\r\n        this.propName = propName;\r\n        this.propOld = undefined;\r\n        this.setListenerRef(propName);\r\n\r\n        this.running = startRunning;\r\n        this.funcs = 0;\r\n\r\n        this.interval;\r\n        if(interval < 10) {\r\n            this.interval = 10; console.log(\"Min recommended interval set: 10ms\");}\r\n        else {\r\n            this.interval = interval;\r\n        }\r\n\r\n        if(startRunning === true) {\r\n            if (typeof window === 'undefined') {\r\n                setTimeout(()=>{this.check();}, 60)\r\n            } else {\r\n                this.checker = requestAnimationFrame(this.check);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Main onchange execution\r\n    onchange = (newData) => {\r\n        console.log(this.propName,\" changed from: \", this.propOld,\" to: \", this.object[this.propName]);\r\n    }\r\n\r\n    //Add extra onchange functions for execution\r\n    addFunc = (onchange=null) => {\r\n        let sub = 0;\r\n        if(onchange !== null){\r\n            this.onchangeFuncs.push({idx:this.funcs, onchange:onchange});\r\n            sub=this.funcs;\r\n            this.funcs++;\r\n        }\r\n        return sub;\r\n    }\r\n\r\n    //Remove extra onchange functions\r\n    removeFuncs(idx = null) {\r\n        let i = 0;\r\n        if(idx === null) {\r\n            this.onchangeFuncs = [];\r\n        }\r\n        else if(this.onchangeFuncs.find((o,j)=>{if(o.idx===idx){ i=j; return true;}}) !== undefined) {\r\n            this.onchangeFuncs.splice(i,1);\r\n        }\r\n    }\r\n\r\n    //Execute extra onchange functions\r\n    onchangeMulti = (newData) => {\r\n        let onChangeCache = [...this.onchangeFuncs]\r\n        onChangeCache.forEach((func,i) => {\r\n            if(this.debug === true) { console.log(func.onchange); }\r\n            func.onchange(newData);\r\n        });\r\n    }\r\n\r\n    //Update listener reference copy.\r\n    setListenerRef = (propName) => {\r\n        if(propName === \"__ANY__\" || propName === null || propName === undefined) {\r\n            this.propOld = JSON.stringifyFast(this.object);\r\n        }\r\n        else if(Array.isArray(this.object[propName])) {\r\n            this.propOld = JSON.stringifyFast(this.object[propName].slice(this.object[propName].length-20));\r\n        }\r\n        else if(typeof this.object[propName] === \"object\"){\r\n            this.propOld = JSON.stringifyFast(this.object[propName]);\r\n        }\r\n        else if(typeof this.object[propName] === \"function\"){\r\n            this.propOld = this.object[propName].toString();\r\n        }\r\n        else{\r\n            this.propOld = this.object[propName]; //usually a number, bool, or string;\r\n        }\r\n        \r\n        if(this.debug === true) { console.log(\"propname\", propName, \", new assignment: \", this.propOld); }\r\n    }\r\n\r\n    check = () => {\r\n        let changed = false;\r\n        if(this.propName === \"__ANY__\" || this.propName === null || this.propName === undefined){\r\n            if(this.propOld !== JSON.stringifyFast(this.object)){\r\n                if(this.debug === true) { console.log(\"onchange: \", this.onchange); }\r\n                this.onchange(this.object);\r\n                if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object); }\r\n                this.setListenerRef(this.propName);\r\n                changed = true;\r\n            }\r\n        }\r\n        else if(Array.isArray(this.object[this.propName])) { //cut arrays down for speed\r\n            if(this.propOld !== JSON.stringifyFast(this.object[this.propName].slice(this.object[this.propName].length-20))){\r\n                if(this.debug === true) { console.log(\"onchange: \", this.onchange); }\r\n                this.onchange(this.object[this.propName]);\r\n                if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object[this.propName]); }\r\n                this.setListenerRef(this.propName);\r\n                changed = true;\r\n            }\r\n        }\r\n        else if(typeof this.object[this.propName] === \"object\") {\r\n            let string = JSON.stringifyFast(this.object[this.propName]);\r\n            if(this.propOld !== string){\r\n                if(this.debug === true) { console.log(\"onchange: \", this.onchange); }\r\n                this.onchange(this.object[this.propName]);\r\n                if(this.onchangeFuncs.length > 0) { \r\n                    this.onchangeMulti(this.object[this.propName]); \r\n                }\r\n                this.setListenerRef(this.propName);\r\n                changed = true;\r\n            }\r\n        }\r\n        else if(typeof this.object[this.propName] === \"function\") {\r\n            if(this.propOld !== this.object[this.propName].toString()){\r\n                if(this.debug === true) { console.log(\"onchange: \", this.onchange); }\r\n                this.onchange(this.object[this.propName].toString());\r\n                if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object[this.propName].toString()); }\r\n                this.setListenerRef(this.propName);\r\n                changed = true;\r\n            }\r\n        }\r\n        else if(this.object[this.propName] !== this.propOld) {\r\n            if(this.debug === true) { console.log(\"onchange: \", this.onchange); }\r\n            this.onchange(this.object[this.propName]);\r\n            if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object[this.propName]); }\r\n            this.setListenerRef(this.propName);\r\n            changed = true;\r\n        }\r\n        \r\n        if(this.running === true) {\r\n            if(this.debug === true) {console.log(\"checking\", this.object, this.propName);}\r\n            if(this.interval === \"FRAMERATE\"){\r\n                if (typeof window === 'undefined') {\r\n                    setTimeout(()=>{this.check();}, 16)\r\n                } else {\r\n                    this.checker = requestAnimationFrame(this.check);\r\n                }\r\n            }\r\n            else {\r\n                setTimeout(()=>{this.check();},this.interval);\r\n            }\r\n        };\r\n\r\n        return changed;\r\n    }\r\n\r\n    start() {\r\n        this.running = true;\r\n        if (typeof window === 'undefined') {\r\n            setTimeout(()=>{this.check();}, 16);\r\n        } else {\r\n            this.checker = requestAnimationFrame(this.check);\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        this.running = false;\r\n        cancelAnimationFrame(this.checker);\r\n    }\r\n\r\n}\r\n\r\n\r\n//This only really matters in Chrome and one other browser\r\nexport function sortObjectByValue(object) { //Sorts number and string objects by numeric value. Strings have charcodes summed for comparison. Objects and functions are stringified.\r\n    var sortable = [];\r\n    for(var prop in object) {\r\n        sortable.push([prop, object[prop]]);\r\n    }\r\n\r\n    sortable.sort(function(a,b) {\r\n        var prop1 = a;\r\n        var prop2 = b;\r\n        if(typeof prop1[1] === \"function\"){\r\n            prop1[1] = prop1[1].toString();\r\n        }\r\n        else if(typeof prop1[1] === \"object\"){\r\n            prop1[1] = JSON.stringifyFast(prop1[1]);\r\n        }\r\n        if(typeof prop2[1] === \"function\"){\r\n            prop2[1] = prop2[1].toString();\r\n        }\r\n        else if(typeof prop2[1] === \"object\"){\r\n            prop2[1] = JSON.stringifyFast(prop2[1]);\r\n        }\r\n        \r\n        if(typeof prop1[1] === \"string\") {\r\n            var temp = 0;\r\n            prop1.forEach((char,i) => {\r\n                temp += prop1.charCodeAt(i);\r\n            });\r\n            prop1 = temp;\r\n        }\r\n        if(typeof prop2[1] === \"string\") {\r\n            var temp = 0;\r\n            prop2.forEach((char,i) => {\r\n                temp += prop2.charCodeAt(i);\r\n            });\r\n            prop2 = temp;\r\n        }\r\n        return prop1[1]-prop2[1];\r\n    });\r\n\r\n    var sorted = {};\r\n\r\n    sortable.forEach((item) => {\r\n       sorted[item[0]]=item[1];\r\n    });\r\n\r\n    return sorted;\r\n\r\n}\r\n\r\nexport function sortObjectByPropName(object) {\r\n\r\n    var sortable = [];\r\n\r\n    for(var prop in object) {\r\n        sortable.push([prop, object[prop]]);\r\n    }\r\n\r\n    sortable.sort(function(a,b) {\r\n        return a[0] > b[0];\r\n    });\r\n\r\n    var sorted = {};\r\n\r\n    sortable.forEach((item) => {\r\n        sorted[item[0]]=item[1];\r\n    });\r\n\r\n    return sorted;\r\n\r\n}\r\n\r\n//modified to also cut down the size arrays for faster looping\r\nif(JSON.stringifyFast === undefined) {\r\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\r\n    JSON.stringifyFast = (function() {\r\n        const refs = new Map();\r\n        const parents = [];\r\n        const path = [\"this\"];\r\n\r\n        function clear() {\r\n            refs.clear();\r\n            parents.length = 0;\r\n            path.length = 1;\r\n        }\r\n\r\n        function updateParents(key, value) {\r\n            var idx = parents.length - 1;\r\n            if(parents[idx]){\r\n                var prev = parents[idx];\r\n                if (prev[key] === value || idx === 0) {\r\n                    path.push(key);\r\n                    parents.push(value.pushed);\r\n                } else {\r\n                    while (idx-- >= 0) {\r\n                    prev = parents[idx];\r\n                    if (prev[key] === value) {\r\n                        idx += 2;\r\n                        parents.length = idx;\r\n                        path.length = idx;\r\n                        --idx;\r\n                        parents[idx] = value;\r\n                        path[idx] = key;\r\n                        break;\r\n                    }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkValues(key, value) {\r\n            let val;\r\n            if (value != null) {\r\n                if (typeof value === \"object\") {\r\n                    //if (key) { updateParents(key, value); }\r\n                    let c = value.constructor.name;\r\n                    if (key && c === 'Object') {updateParents(key, value); }\r\n\r\n                    let other = refs.get(value);\r\n                    if (other) {\r\n                        return '[Circular Reference]' + other;\r\n                    } else {\r\n                        refs.set(value, path.join('.'));\r\n                    }\r\n                    if(c === \"Array\") { //Cut arrays down to 100 samples for referencing\r\n                        if(value.length > 20) {\r\n                            val = value.slice(value.length-20);\r\n                        } else val = value;\r\n                       // refs.set(val, path.join('.'));\r\n                    }  \r\n                    else if (c.includes(\"Set\")) {\r\n                        val = Array.from(value)\r\n                    }  \r\n                    else if (c !== \"Object\" && c !== \"Number\" && c !== \"String\" && c !== \"Boolean\") { //simplify classes, objects, and functions, point to nested objects for the state manager to monitor those properly\r\n                        val = \"instanceof_\"+c;\r\n                    }\r\n                    else if (c === 'Object') {\r\n                        let obj = {};\r\n                        for(const prop in value) {\r\n                            if (value[prop] == null){\r\n                                obj[prop] = value[prop]; \r\n                            }\r\n                            else if(Array.isArray(value[prop])) { \r\n                                if(value[prop].length>20)\r\n                                    obj[prop] = value[prop].slice(value[prop].length-20); \r\n                                else obj[prop] = value[prop];\r\n                            } //deal with arrays in nested objects (e.g. means, slices)\r\n                            else if (value[prop].constructor.name === 'Object') { //additional layer of recursion for 3 object-deep array checks\r\n                                obj[prop] = {};\r\n                                for(const p in value[prop]) {\r\n                                    if(Array.isArray(value[prop][p])) {\r\n                                        if(value[prop][p].length>20)\r\n                                            obj[prop][p] = value[prop][p].slice(value[prop][p].length-20); \r\n                                        else obj[prop][p] = value[prop][p];\r\n                                    }\r\n                                    else { \r\n                                        if (value[prop][p] != null){\r\n                                            let con = value[prop][p].constructor.name;\r\n                                            if (con.includes(\"Set\")) {\r\n                                                obj[prop][p] = Array.from(value[prop][p])\r\n                                            } else if(con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\r\n                                                obj[prop][p] = \"instanceof_\"+con; //3-deep nested objects are cut off\r\n                                            }  else {\r\n                                                obj[prop][p] = value[prop][p]; \r\n                                            }\r\n                                        } else {\r\n                                            obj[prop][p] = value[prop][p]; \r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else { \r\n                                let con = value[prop].constructor.name;\r\n                                if (con.includes(\"Set\")) {\r\n                                    obj[prop] = Array.from(value[prop])\r\n                                } else if(con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\r\n                                    obj[prop] = \"instanceof_\"+con;\r\n                                } else {\r\n                                    obj[prop] = value[prop]; \r\n                                }\r\n                            }\r\n                        }\r\n                        //console.log(obj, value)\r\n                        val = obj;\r\n                        //refs.set(val, path.join('.'));\r\n                    }\r\n                    else {\r\n                        val = value;\r\n                    }\r\n                } else {\r\n                    val = value;\r\n                }\r\n            }\r\n            //console.log(value, val)\r\n            return val;\r\n        }\r\n\r\n        return function stringifyFast(obj, space) {\r\n            try {\r\n                parents.push(obj);\r\n                return JSON.stringify(obj, checkValues, space);\r\n            } catch(er) {\r\n                console.error(obj, er);\r\n            } finally {\r\n                clear();\r\n            } \r\n        }\r\n    })();\r\n}\r\n\r\n\r\n\r\nif(JSON.stringifyWithCircularRefs === undefined) {\r\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\r\n    JSON.stringifyWithCircularRefs = (function() {\r\n        const refs = new Map();\r\n        const parents = [];\r\n        const path = [\"this\"];\r\n\r\n        function clear() {\r\n        refs.clear();\r\n        parents.length = 0;\r\n        path.length = 1;\r\n        }\r\n\r\n        function updateParents(key, value) {\r\n        var idx = parents.length - 1;\r\n        var prev = parents[idx];\r\n        if (prev[key] === value || idx === 0) {\r\n            path.push(key);\r\n            parents.push(value);\r\n        } else {\r\n            while (idx-- >= 0) {\r\n            prev = parents[idx];\r\n            if (prev[key] === value) {\r\n                idx += 2;\r\n                parents.length = idx;\r\n                path.length = idx;\r\n                --idx;\r\n                parents[idx] = value;\r\n                path[idx] = key;\r\n                break;\r\n            }\r\n            }\r\n        }\r\n        }\r\n\r\n        function checkCircular(key, value) {\r\n        if (value != null) {\r\n            if (typeof value === \"object\") {\r\n            if (key) { updateParents(key, value); }\r\n\r\n            let other = refs.get(value);\r\n            if (other) {\r\n                return '[Circular Reference]' + other;\r\n            } else {\r\n                refs.set(value, path.join('.'));\r\n            }\r\n            }\r\n        }\r\n        return value;\r\n        }\r\n\r\n        return function stringifyWithCircularRefs(obj, space) {\r\n        try {\r\n            parents.push(obj);\r\n            return JSON.stringify(obj, checkCircular, space);\r\n        } finally {\r\n            clear();\r\n        }\r\n        }\r\n    })();\r\n}\r\n\r\nexport default ObjectListener","import ObjectListener from 'objectlisteners'\r\n\r\n//By Joshua Brewster (MIT License)\r\n//Simple state manager.\r\n//Set key responses to have functions fire when keyed values change\r\n//add variables to state with addToState(key, value, keyonchange (optional))\r\nexport class StateManager {\r\n    constructor(init = {}, interval=\"FRAMERATE\", defaultKeyEventLoop=true) { //Default interval is at the browser framerate\r\n        this.data = init;\r\n        this.interval = interval;\r\n        this.pushToState={};\r\n        this.pushRecord={pushed:[]}; //all setStates between frames\r\n        this.pushCallbacks = {};\r\n        this.triggers = {};\r\n\r\n        this.listener = new ObjectListener();\r\n        this.defaultStartListenerEventLoop = defaultKeyEventLoop;\r\n\r\n        /*\r\n        this.prev = Object.assign({},this.data);\r\n         \r\n        const onStateChanged = () => {\r\n            this.prev = Object.assign({},this.data);\r\n            //this.prev=JSON.parse(JSON.stringifyFast(this.data));\r\n        }\r\n\r\n        //Causes app to be stuck on startup\r\n        this.listener.addListener(\r\n            \"state\",\r\n            this.data,\r\n            \"__ANY__\",\r\n            onStateChanged,\r\n            interval,\r\n        );\r\n        */\r\n    }\r\n\r\n    setInterval(interval=\"FRAMERATE\") {\r\n        this.interval = interval;\r\n        this.listener.listeners.forEach((obj,i) => {\r\n            obj.interval = this.interval;\r\n        });\r\n    }\r\n\r\n\r\n    // Managed State Updates. Must Still Clean Event Listeners\r\n    updateState(key, value){\r\n        if (this.data[key] == null){\r\n            this.addToState(key,value)\r\n        } else {\r\n            this.data[key] = value\r\n        }    \r\n    }\r\n\r\n    setupSynchronousUpdates = () => {\r\n        if(!this.listener.hasKey('pushToState')) {\r\n            //we won't add this listener unless we use this function\r\n            const pushToStateResponse = () => {\r\n                if(Object.keys(this.pushToState).length > 0) {\r\n                    //Object.assign(this.prev,this.data);//Temp fix until the global state listener function works as expected\r\n                    Object.assign(this.data,this.pushToState);\r\n\r\n                    //console.log(\"new state: \", this.data); console.log(\"props set: \", this.pushToState);\r\n                    for (const prop of Object.getOwnPropertyNames(this.pushToState)) {\r\n                        delete this.pushToState[prop];\r\n                    }\r\n                }\r\n            }\r\n    \r\n            this.listener.addListener(\r\n                \"pushToState\",\r\n                this.pushToState,\r\n                \"__ANY__\",\r\n                pushToStateResponse,\r\n                this.interval\r\n            );\r\n\r\n            this.addToState('pushRecord',this.pushRecord,(record)=>{\r\n\r\n                let l = record.pushed.length;\r\n                for (let i = 0; i < l; i++){\r\n                    let updateObj = record.pushed[i];\r\n                    for(const prop in updateObj) {\r\n                        if(this.pushCallbacks[prop]) {\r\n                            this.pushCallbacks[prop].forEach((o) =>{\r\n                                o.onchange(updateObj[prop]);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                this.pushRecord.pushed.splice(0,l);\r\n            });\r\n\r\n            this.data.pushCallbacks = this.pushCallbacks;\r\n\r\n        }\r\n    }\r\n\r\n    //Alternatively just add to the state by doing this.state[key] = value with the state manager instance\r\n    addToState(key, value, onchange=null, startRunning=this.defaultStartListenerEventLoop, debug=false) {\r\n        if(!this.listener.hasKey('pushToState') && this.defaultStartListenerEventLoop) {\r\n            this.setupSynchronousUpdates();\r\n        }\r\n\r\n        this.data[key] = value;\r\n\r\n        // Log Update\r\n        this.setSequentialState({stateAdded: key})\r\n\r\n        if(onchange !== null){\r\n            return this.addSecondaryKeyResponse(key,onchange,debug,startRunning);\r\n        }\r\n    }\r\n\r\n    getState() { //Return a hard copy of the latest state with reduced values. Otherwise just use this.state.data\r\n        return JSON.parse(JSON.stringifyFast(this.data));\r\n    }\r\n\r\n    //Synchronous set-state, only updates main state on interval. Can set to trigger now instead of waiting on interval. Also can append arrays in state instead of replacing them\r\n    setState(updateObj={}, appendArrs=false){ //Pass object with keys in. Undefined keys in state will be added automatically. State only notifies of change based on update interval\r\n        //console.log(\"setting state\");\r\n        if(!this.listener.hasKey('pushToState') && this.defaultStartListenerEventLoop) {\r\n            this.setupSynchronousUpdates();\r\n            this.pushRecord.pushed.push(JSON.parse(JSON.stringifyWithCircularRefs(updateObj)));\r\n        }\r\n\r\n        updateObj.stateUpdateTimeStamp = Date.now();\r\n        \r\n        if(appendArrs) {\r\n            for(const prop in updateObj) { //3 object-deep array checks to buffer values instead of overwriting\r\n                if(this.pushToState[prop]) {\r\n                    if(Array.isArray(this.pushToState[prop]) && Array.isArray(updateObj[prop])) {\r\n                        updateObj[prop] = this.pushToState[prop].push(...updateObj[prop]);\r\n                    } else if (typeof this.pushToState[prop] === 'object' && typeof updateObj[prop] === 'object') {\r\n                        for(const p in updateObj[prop]) {\r\n                            if(this.pushToState[prop][p]) {\r\n                                if(Array.isArray(this.pushToState[prop][p]) && Array.isArray(updateObj[prop][p])) {\r\n                                    updateObj[prop][p] = this.pushToState[prop][p].push(...updateObj[prop][p]);\r\n                                }\r\n                                else if (typeof this.pushToState[prop][p] === 'object' && typeof updateObj[prop][p] === 'object') {\r\n                                    for(const p2 in updateObj[prop][p]) {\r\n                                        if(this.pushToState[prop][p][p2]) {\r\n                                            if(Array.isArray(this.pushToState[prop][p][p2]) && Array.isArray(updateObj[prop][p][p2])) {\r\n                                                updateObj[prop][p][p2] = this.pushToState[prop][p][p2].push(...updateObj[prop][p][p2]);\r\n                                            }\r\n                                        }\r\n                                        else if (typeof this.pushToState[prop][p][p2] === 'object' && typeof updateObj[prop][p][p2] === 'object') {\r\n                                            for(const p3 in updateObj[prop][p][p2]) {\r\n                                                if(this.pushToState[prop][p][p2][p3]) {\r\n                                                    if(Array.isArray(this.pushToState[prop][p][p2][p3]) && Array.isArray(updateObj[prop][p][p2][p3])) {\r\n                                                        updateObj[prop][p][p2][p3] = this.pushToState[prop][p][p2][p3].push(...updateObj[prop][p][p2][p3]);\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Object.assign(this.pushToState,updateObj);\r\n        \r\n        if(Object.keys(this.triggers).length > 0) {\r\n            // Object.assign(this.data,this.pushToState);\r\n            for (const prop of Object.getOwnPropertyNames(this.triggers)) {\r\n                if(this.pushToState[prop]) {\r\n                    this.data[prop] = this.pushToState[prop]\r\n                    delete this.pushToState[prop];\r\n                    this.triggers[prop].forEach((obj)=>{\r\n                        obj.onchange(this.data[prop]);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.pushToState;\r\n    }\r\n\r\n    //Trigger-only functions on otherwise looping listeners\r\n    subscribeTrigger(key=undefined,onchange=(value)=>{}) {\r\n\r\n        // console.error('SUBSCRIBING')\r\n        if(key) {\r\n            if(!this.triggers[key]) {\r\n                this.triggers[key] = [];\r\n            }\r\n            let l = this.triggers[key].length;\r\n            this.triggers[key].push({idx:l, onchange:onchange});\r\n            return this.triggers[key].length-1;\r\n        } else return undefined;\r\n    }\r\n\r\n    //will remove the trigger after firing once\r\n    subscribeTriggerOnce(key=undefined,onchange=(value)=>{}) {\r\n        let sub;\r\n        let changed = (value) => {\r\n            onchange(value);\r\n            this.unsubscribeTrigger(key,sub);\r\n        }\r\n\r\n        sub = this.subscribeTrigger(key,changed);\r\n    }\r\n\r\n    //Delete specific trigger functions for a key\r\n    unsubscribeTrigger(key=undefined,sub=0) {\r\n        let idx = undefined;\r\n        let triggers = this.triggers[key]\r\n        if (triggers){\r\n            let obj = triggers.find((o)=>{\r\n                if(o.idx===sub) {return true;}\r\n            });\r\n            if(obj) triggers.splice(idx,1);\r\n        }\r\n    }\r\n\r\n    //Remove all triggers for a key\r\n    unsubscribeAllTriggers(key) {\r\n        if(key && this.triggers[key]) {\r\n            delete this.triggers[key];\r\n        }\r\n    }\r\n\r\n    //only push to an object that keeps the sequences of updates instead of synchronously updating the whole state.\r\n    setSequentialState(updateObj={}) {\r\n        //console.log(\"setting state\");\r\n        if(!this.listener.hasKey('pushToState')) {\r\n            this.setupSynchronousUpdates();\r\n        }\r\n        updateObj.stateUpdateTimeStamp = Date.now();\r\n        this.pushRecord.pushed.push(JSON.parse(JSON.stringify(updateObj)));\r\n    }\r\n\r\n    subscribeSequential(key=undefined,onchange=undefined) {\r\n        // console.error('SUBSCRIBING')\r\n\r\n        if(key) {\r\n            \r\n            if(this.data[key] === undefined) {this.addToState(key,null,undefined);}\r\n\r\n            if(!this.pushCallbacks[key])\r\n                this.pushCallbacks[key] = [];\r\n\r\n            if(onchange) {\r\n                let idx = this.pushCallbacks[key].length;\r\n                this.pushCallbacks[key].push({idx:idx, onchange:onchange});\r\n                return this.pushCallbacks[key].length-1; //get key sub index for unsubscribing\r\n            } \r\n            else return undefined;\r\n        } else return undefined;\r\n    }\r\n    \r\n    //will remove the sequence after firing once (e.g. between frames)\r\n    subscribeSequentialOnce(key=undefined,onchange=(value)=>{}) {\r\n        let sub;\r\n        let changed = (value) => {\r\n            onchange(value);\r\n            this.unsubscribeSequential(key,sub);\r\n        }\r\n\r\n        sub = this.subscribeSequential(key,changed);\r\n    }\r\n\r\n    unsubscribeSequential(key=undefined,sub=0) {\r\n        if(key){\r\n            if(this.pushCallbacks[key]) {\r\n                if(this.pushCallbacks[key].find((o,j)=>{\r\n                    if(o.idx === sub) {\r\n                        this.pushCallbacks[key].splice(j,1);\r\n                        return true;\r\n                    }\r\n                })) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    unsubscribeAllSequential(key) {\r\n        if(key) {\r\n            if(this.pushCallbacks[key]) {\r\n                if(this.pushCallbacks[key]) {\r\n                    delete this.pushCallbacks[key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //Set main onchange response for the property-specific object listener. Don't touch the state\r\n    setPrimaryKeyResponse(key=null, onchange=null, debug=false, startRunning=this.defaultStartListenerEventLoop) {\r\n        if(onchange !== null){\r\n            if(this.listener.hasKey(key)){\r\n                this.listener.onchange(key, onchange);\r\n            }\r\n            else if(key !== null){\r\n                this.listener.addListener(key, this.data, key, onchange, this.data[\"stateUpdateInterval\"], debug, startRunning);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Add extra onchange responses to the object listener for a set property. Use state key for state-wide change responses\r\n    addSecondaryKeyResponse(key=null, onchange=null, debug=false, startRunning=this.defaultStartListenerEventLoop) {\r\n        if(onchange !== null){\r\n            if(this.listener.hasKey(key)){\r\n                return this.listener.addFunc(key, onchange);\r\n            }\r\n            else if(key !== null){\r\n                this.listener.addListener(key, this.data,key,()=>{},this.data[\"stateUpdateInterval\"], debug, startRunning);\r\n                return this.listener.addFunc(key, onchange);\r\n            }\r\n            else { return this.listener.addFunc(\"state\", onchange);}\r\n        }\r\n    }\r\n\r\n    //removes all secondary responses if idx left null. use \"state\" key for state-wide change responses\r\n    removeSecondaryKeyResponse(key=null,responseIdx=null, stopIfEmpty=true) {\r\n        if(key !== null) {\r\n            if(this.listener.hasKey(key)){\r\n                this.listener.removeFuncs(key, responseIdx, stopIfEmpty);\r\n            } else {\r\n                console.error(\"key does not exist\")\r\n            }\r\n        }\r\n        else{console.error(\"provide key\")}\r\n    }\r\n\r\n    //Remove any extra object listeners for a key. Entering \"state\" will break the state manager's primary response\r\n    clearAllKeyResponses(key=null) {\r\n        if(key === null) this.listener.remove(null);\r\n        else if(this.listener.hasKey(key)) this.listener.remove(key);\r\n    }\r\n\r\n    //Get all of the onchange functions added via subscribe/addSecondaryKeyResponse\r\n    getKeySubCallbacks(key) {\r\n        let callbacks = this.listener.getFuncs(key);\r\n        return callbacks;\r\n    }\r\n\r\n    //Save the return value to provide as the responseIdx in unsubscribe\r\n    subscribe(key, onchange, startRunning=true) {\r\n        // console.error('SUBSCRIBING')\r\n\r\n        if(this.data[key] === undefined) {this.addToState(key,null,onchange,startRunning);}\r\n        else {return this.addSecondaryKeyResponse(key,onchange);}\r\n    }\r\n \r\n    //will remove the subscription after firing once\r\n    subscribeOnce(key=undefined,onchange=(value)=>{}) {\r\n        let sub;\r\n        let changed = (value) => {\r\n            onchange(value);\r\n            this.unsubscribe(key,sub);\r\n        }\r\n\r\n        sub = this.subscribe(key,changed);\r\n    }\r\n    \r\n    //Unsubscribe from the given key using the index of the response saved from the subscribe() function\r\n    unsubscribe(key, responseIdx=null) {\r\n        if(responseIdx !== null) this.removeSecondaryKeyResponse(key, responseIdx, true);\r\n        else console.error(\"Specify a subcription function index\");\r\n    }\r\n\r\n    unsubscribeAll(key) { // Removes all listeners for a key (including the animation loop)\r\n        this.unsubscribeAllSequential(key);\r\n        this.unsubscribeAllTriggers(key);\r\n        this.clearAllKeyResponses(key);\r\n        if(this.data[key]) delete this.data[key];\r\n\r\n        \r\n        if(this.listener.hasKey('pushToState')) this.setSequentialState({stateRemoved: key})\r\n    }\r\n   \r\n    removeState = this.unsubscribeAll;\r\n\r\n    //runs only one animation frame to check all state keys\r\n    runSynchronousListeners() {\r\n        this.defaultStartListenerEventLoop = false;\r\n        this.listener.startSync();\r\n    }\r\n\r\n    //stops the listener event loops without clearing the keys.\r\n    stop(key=null) {\r\n        this.listener.stop(key);\r\n    }\r\n\r\n}\r\n\r\n\r\n//modified to also cut down the size arrays for faster looping\r\nif(JSON.stringifyFast === undefined) {\r\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\r\n    JSON.stringifyFast = (function() {\r\n        const refs = new Map();\r\n        const parents = [];\r\n        const path = [\"this\"];\r\n\r\n        function clear() {\r\n            refs.clear();\r\n            parents.length = 0;\r\n            path.length = 1;\r\n        }\r\n\r\n        function updateParents(key, value) {\r\n            var idx = parents.length - 1;\r\n            //console.log(idx, parents[idx])\r\n            if(parents[idx]){\r\n                var prev = parents[idx];\r\n                //console.log(value); \r\n                if (prev[key] === value || idx === 0) {\r\n                    path.push(key);\r\n                    parents.push(value.pushed);\r\n                } else {\r\n                    while (idx-- >= 0) {\r\n                    prev = parents[idx];\r\n                    if (prev[key] === value) {\r\n                        idx += 2;\r\n                        parents.length = idx;\r\n                        path.length = idx;\r\n                        --idx;\r\n                        parents[idx] = value;\r\n                        path[idx] = key;\r\n                        break;\r\n                    }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkValues(key, value) {\r\n            let val;\r\n            if (value != null) {\r\n                if (typeof value === \"object\") {\r\n                    //if (key) { updateParents(key, value); }\r\n                    let c = value.constructor.name;\r\n                    if (key && c === 'Object') {updateParents(key, value); }\r\n\r\n                    let other = refs.get(value);\r\n                    if (other) {\r\n                        return '[Circular Reference]' + other;\r\n                    } else {\r\n                        refs.set(value, path.join('.'));\r\n                    }\r\n                    if(c === \"Array\") { //Cut arrays down to 100 samples for referencing\r\n                        if(value.length > 20) {\r\n                            val = value.slice(value.length-20);\r\n                        } else val = value;\r\n                       // refs.set(val, path.join('.'));\r\n                    }  \r\n                    else if (c.includes(\"Set\")) {\r\n                        val = Array.from(value)\r\n                    }  \r\n                    else if (c !== \"Object\" && c !== \"Number\" && c !== \"String\" && c !== \"Boolean\") { //simplify classes, objects, and functions, point to nested objects for the state manager to monitor those properly\r\n                        val = \"instanceof_\"+c;\r\n                    }\r\n                    else if (c === 'Object') {\r\n                        let obj = {};\r\n                        for(const prop in value) {\r\n                            if (value[prop] == null){\r\n                                obj[prop] = value[prop]; \r\n                            }\r\n                            else if(Array.isArray(value[prop])) { \r\n                                if(value[prop].length>20)\r\n                                    obj[prop] = value[prop].slice(value[prop].length-20); \r\n                                else obj[prop] = value[prop];\r\n                            } //deal with arrays in nested objects (e.g. means, slices)\r\n                            else if (value[prop].constructor.name === 'Object') { //additional layer of recursion for 3 object-deep array checks\r\n                                obj[prop] = {};\r\n                                for(const p in value[prop]) {\r\n                                    if(Array.isArray(value[prop][p])) {\r\n                                        if(value[prop][p].length>20)\r\n                                            obj[prop][p] = value[prop][p].slice(value[prop][p].length-20); \r\n                                        else obj[prop][p] = value[prop][p];\r\n                                    }\r\n                                    else { \r\n                                        if (value[prop][p] != null){\r\n                                            let con = value[prop][p].constructor.name;\r\n                                            if (con.includes(\"Set\")) {\r\n                                                obj[prop][p] = Array.from(value[prop][p])\r\n                                            } else if(con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\r\n                                                obj[prop][p] = \"instanceof_\"+con; //3-deep nested objects are cut off\r\n                                            }  else {\r\n                                                obj[prop][p] = value[prop][p]; \r\n                                            }\r\n                                        } else {\r\n                                            obj[prop][p] = value[prop][p]; \r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else { \r\n                                let con = value[prop].constructor.name;\r\n                                if (con.includes(\"Set\")) {\r\n                                    obj[prop] = Array.from(value[prop])\r\n                                } else if(con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\r\n                                    obj[prop] = \"instanceof_\"+con;\r\n                                } else {\r\n                                    obj[prop] = value[prop]; \r\n                                }\r\n                            }\r\n                        }\r\n                        //console.log(obj, value)\r\n                        val = obj;\r\n                        //refs.set(val, path.join('.'));\r\n                    }\r\n                    else {\r\n                        val = value;\r\n                    }\r\n                } else {\r\n                    val = value;\r\n                }\r\n            }\r\n            //console.log(value, val)\r\n            return val;\r\n        }\r\n\r\n        return function stringifyFast(obj, space) {\r\n            try {\r\n                parents.push(obj);\r\n                return JSON.stringify(obj, checkValues, space);\r\n            } catch(er) {\r\n                console.error(obj, er);\r\n            } finally {\r\n                clear();\r\n            } \r\n        }\r\n    })();\r\n}\r\n\r\n\r\n\r\nif(JSON.stringifyWithCircularRefs === undefined) {\r\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\r\n    JSON.stringifyWithCircularRefs = (function() {\r\n        const refs = new Map();\r\n        const parents = [];\r\n        const path = [\"this\"];\r\n\r\n        function clear() {\r\n        refs.clear();\r\n        parents.length = 0;\r\n        path.length = 1;\r\n        }\r\n\r\n        function updateParents(key, value) {\r\n        var idx = parents.length - 1;\r\n        var prev = parents[idx];\r\n        if (prev[key] === value || idx === 0) {\r\n            path.push(key);\r\n            parents.push(value);\r\n        } else {\r\n            while (idx-- >= 0) {\r\n            prev = parents[idx];\r\n            if (prev[key] === value) {\r\n                idx += 2;\r\n                parents.length = idx;\r\n                path.length = idx;\r\n                --idx;\r\n                parents[idx] = value;\r\n                path[idx] = key;\r\n                break;\r\n            }\r\n            }\r\n        }\r\n        }\r\n\r\n        function checkCircular(key, value) {\r\n        if (value != null) {\r\n            if (typeof value === \"object\") {\r\n            if (key) { updateParents(key, value); }\r\n\r\n            let other = refs.get(value);\r\n            if (other) {\r\n                return '[Circular Reference]' + other;\r\n            } else {\r\n                refs.set(value, path.join('.'));\r\n            }\r\n            }\r\n        }\r\n        return value;\r\n        }\r\n\r\n        return function stringifyWithCircularRefs(obj, space) {\r\n        try {\r\n            parents.push(obj);\r\n            return JSON.stringify(obj, checkCircular, space);\r\n        } finally {\r\n            clear();\r\n        }\r\n        }\r\n    })();\r\n}\r\n\r\nexport default StateManager","\r\n//multithreaded event manager, spawn one per thread and import a single instance elsewhere.\r\n\r\n/**\r\n * This is both a simple wrapper for a trigger-only state manager as well \r\n * as an interface for multithreaded events for simpler, more dynamic threading pipelines\r\n * \r\n * From any thread:\r\n * emit -> tx\r\n * rx -> run trigger \r\n * \r\n */\r\n\r\n import {StateManager} from 'anotherstatemanager'\r\n\r\n export class Events {\r\n     constructor(manager=undefined) {\r\n \r\n         this.state = new StateManager({},undefined,false); //trigger only state (no overhead)\r\n         this.manager = manager;\r\n \r\n         if(manager !== undefined) { //only in window\r\n            let found = manager.responses.find((foo) => {\r\n                if(foo.name === 'eventmanager') return true;\r\n            });\r\n            if(!found) {\r\n                manager.addCallback('eventmanager',this.callback);\r\n            }\r\n         } \r\n \r\n     }\r\n \r\n     //subscribe a to an event, default is the port reponse \r\n     subEvent(eventName, response=(output)=>{console.log(eventName,output);}) {\r\n         return this.state.subscribeTrigger(eventName,response);\r\n     }\r\n \r\n     unsubEvent(eventName, sub) {\r\n         return this.state.unsubscribeTrigger(eventName,sub);\r\n     }\r\n \r\n     //add an event name, can optionally add them to any threads too from the main thread\r\n     async addEvent(eventName,workerId=undefined,functionName=undefined,origin=undefined) {\r\n         this.state.setState({[eventName]:undefined});\r\n         if(this.manager !== undefined) {\r\n             if(origin !== undefined || functionName !== undefined) {\r\n                 if(workerId !== undefined) {\r\n                    return await this.manager.post({origin:origin,foo:'addevent',input:[eventName,functionName]},workerId);\r\n                 } else {\r\n                    this.manager.workers.forEach((w)=>{\r\n                        this.manager.post({origin:origin,foo:'addevent',input:[eventName,functionName]},w.id); //add it to all of them since we're assuming we're rotating threads\r\n                    });\r\n                    return true;\r\n                 }\r\n             }\r\n         }\r\n     }\r\n \r\n     //remove an event\r\n     removeEmitter(eventName) {\r\n         this.state.unsubscribeAllTriggers(eventName);\r\n     }\r\n \r\n     //use this to set values by event name, will post messages on threads too\r\n     emit = (eventName, input, workerId=undefined,transfer=undefined,port=undefined) => {\r\n        let output = {eventName:eventName, output:input};\r\n        \r\n        if(!input || !eventName) return;\r\n        if (this.manager !== undefined) { //when emitting values for workers, input should be an object like {input:0, foo'abc', origin:'here'} for correct worker callback usage\r\n            if(workerId !== undefined) this.manager.post(output,workerId,transfer);\r\n            else {this.manager.workers.forEach((w)=>{this.manager.post(output,w.id,transfer);});}\r\n        } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\r\n            // run this in global scope of window or worker. since window.self = window, we're ok\r\n            //if(port) console.log(port,output);\r\n            if(port) port.postMessage(output,undefined,transfer);\r\n            else globalThis.postMessage(output,undefined,transfer); //thread event \r\n        }\r\n        this.state.setState({[eventName]:input}); //local event \r\n     }\r\n \r\n    callback = (msg) => {\r\n        if(typeof msg === 'object') {\r\n            if(msg.eventName !== undefined && msg.output !== undefined) {\r\n                this.state.setState({[msg.eventName]:msg.output});\r\n            }\r\n        }\r\n    }\r\n\r\n    export = () => {\r\n        return this;\r\n    }\r\n\r\n }","  export let dynamicImport = async (url) => {\r\n    let module = await import(url);\r\n    return module;\r\n  }\r\n  \r\n  //Get the text inside of a function (regular or arrow);\r\n  export function getFunctionBody(methodString) {\r\n    return methodString.toString().replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i, '$2$3$4');\r\n  }\r\n  \r\n  export function getFunctionHead(methodString) {\r\n    let fnstring = methodString.toString();\r\n    return fnstring.slice(0, fnstring.indexOf('{') + 1);\r\n  }\r\n  \r\n  export function buildNewFunction(head, body) {\r\n    let newFunc = eval(head + body + '}');\r\n    return newFunc;\r\n  }\r\n  \r\n  export function isFunction(string) {\r\n    let regex = new RegExp('(|[a-zA-Z]\\w*|\\([a-zA-Z]\\w*(,\\s*[a-zA-Z]\\w*)*\\))\\s*=>')\r\n    let func = (typeof string === 'string') ? string.substring(0,10).includes('function') : false;\r\n    let arrow = (typeof string === 'string') ? regex.test(string) : false;\r\n    if(func || arrow) return true;\r\n    else return false;\r\n  }\r\n  \r\n  export function parseFunctionFromText(method) {\r\n    //Get the text inside of a function (regular or arrow);\r\n    let getFunctionBody = (methodString) => {\r\n      return methodString.replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i, '$2$3$4');\r\n    }\r\n  \r\n    let getFunctionHead = (methodString) => {\r\n      let startindex = methodString.indexOf(')');\r\n      return methodString.slice(0, methodString.indexOf('{',startindex) + 1);\r\n    }\r\n  \r\n    let newFuncHead = getFunctionHead(method);\r\n    let newFuncBody = getFunctionBody(method);\r\n  \r\n    let newFunc;\r\n    if (newFuncHead.includes('function ')) {\r\n      let varName = newFuncHead.split('(')[1].split(')')[0]\r\n      newFunc = new Function(varName, newFuncBody);\r\n    } else {\r\n      if(newFuncHead.substring(0,6) === newFuncBody.substring(0,6)) {\r\n        //newFuncBody = newFuncBody.substring(newFuncHead.length);\r\n        let varName = newFuncHead.split('(')[1].split(')')[0]\r\n        //console.log(varName, newFuncHead ,newFuncBody);\r\n        newFunc = new Function(varName, newFuncBody.substring(newFuncBody.indexOf('{')+1,newFuncBody.length-1));\r\n      }\r\n      else newFunc = eval(newFuncHead + newFuncBody + \"}\");\r\n    }\r\n  \r\n    return newFunc;\r\n  \r\n  }\r\n  \r\n  ","//Adds Math functions and stuff that are CPU-based. Not much here right now\r\n\r\nimport { Math2 } from \"brainsatplay-math\";\r\n\r\nexport class workerCPU {\r\n\r\n    constructor(callbackManager) {\r\n\r\n        this.callbackManager = callbackManager;\r\n\r\n        callbackManager.Math2 = Math2; //should be globally available anyway\r\n\r\n        this.callbacks = [\r\n            { \r\n                case: 'xcor', callback: (self, args, origin) => { \r\n                  return Math2.crosscorrelation(...args); \r\n                } \r\n            },\r\n            { \r\n                case: 'autocor', callback: (self, args, origin) => { \r\n                  return Math2.autocorrelation(args); \r\n                } \r\n            },\r\n            { \r\n                case: 'cov1d', callback: (self, args, origin) => { \r\n                  return Math2.cov1d(...args); \r\n                } \r\n            },\r\n            { \r\n                case: 'cov2d', callback: (self, args, origin) => { \r\n                  return Math2.cov2d(args); \r\n                } \r\n            },\r\n            { \r\n                case: 'sma', callback: (self, args, origin) => { \r\n                  return Math2.sma(...args); \r\n                } \r\n            } //etc...\r\n        ];\r\n\r\n        this.addCallbacks();\r\n\r\n    }\r\n \r\n    addCallbacks(callbacks = this.callbacks) {\r\n        callbacks.forEach((fn) => {\r\n            this.callbackManager.addCallback(fn.case, fn.callback);\r\n            if(fn.aliases) {\r\n                fn.aliases.forEach((c) => {\r\n                    this.callbackManager.addCallback(c, fn.callback);\r\n                })\r\n            }\r\n        });\r\n    }\r\n}","import { Events } from './utils/Event.js';\r\nimport { parseFunctionFromText, dynamicImport } from './utils/Parsing.js';\r\n\r\n\r\n//just comment these out if you don't want them\r\nimport { workerCPU } from './workerCPU/workerCPU.js';\r\nimport { workerGPU } from './workerGPU/workerGPU.js';\r\nimport { workerRenderer } from './workerRenderer/workerRenderer'\r\n\r\nexport class CallbackManager {\r\n\r\n  canvas;\r\n  ctx;\r\n  context; \r\n\r\n  constructor(\r\n    options={\r\n      cpu:true,\r\n      gpu:true,\r\n      renderer:true\r\n    }\r\n  ) {\r\n\r\n    this.EVENTS = new Events();\r\n    this.EVENTSETTINGS = [];\r\n\r\n\r\n    this.ID = Math.floor(Math.random()*1000); //just a reference for discerning threads \r\n    \r\n\r\n    //args = array of expected arguments\r\n    //origin = optional tag on input object\r\n    //self = this. scope for variables within the callbackmanager (including values set)\r\n\r\n    this.defaultFunctions = [\r\n      { //ping pong, just validates responsiveness\r\n        case: 'ping', callback: (self, args, origin) => {\r\n          return 'pong';\r\n        }\r\n      },\r\n      { //return a list of function calls available on the worker\r\n        case: 'list', callback: (self, args, origin) => {\r\n          let list = [];\r\n          this.callbacks.forEach((callback,name) => {\r\n            list.push(name);\r\n          });\r\n          return list;\r\n        }\r\n      },\r\n      { //add a local function, can implement whole algorithm pipelines on-the-fly\r\n        case: 'addfunc', callback: (self, args, origin) => { //arg0 = name, arg1 = function string (arrow or normal)\r\n          if(!args[0] || !args[1]) return false;\r\n          let newFunc = parseFunctionFromText(args[1]);\r\n\r\n          if(args[2] === true) { //adds try-catch safety\r\n            let safeFunc = async (self,args,origin) => {\r\n              try{\r\n                let result = await newFunc(self,args,origin);\r\n                return result;\r\n              } catch(err) {\r\n                console.error(err);\r\n              }\r\n            }\r\n            self.callbacks.set(args[0], safeFunc);     \r\n          }\r\n          else\r\n            self.callbacks.set(args[0], newFunc);  \r\n\r\n          return true;\r\n        }\r\n      },\r\n      { case:'removefunc', callback:(self,args,origin) => {\r\n          if(args[0]) return this.removeCallback(args[0]);\r\n          else return undefined;\r\n        }\r\n      },\r\n      { //set locally accessible values, just make sure not to overwrite the defaults in the callbackManager\r\n        case: 'setValues', callback: (self, args, origin) => {\r\n          if (typeof args === 'object') {\r\n            Object.keys(args).forEach((key) => {\r\n              self[key] = args[key]; //variables will be accessible in functions as this.x or this['x']\r\n              if (self.threeUtil) self.threeUtil[key] = args[key];\r\n            });\r\n            return true;\r\n          } else return false;\r\n        }\r\n      },\r\n      { //append array values\r\n        case: 'appendValues', callback: (self, args, origin) => {\r\n          if (typeof args === 'object') {\r\n            Object.keys(args).forEach((key) => {\r\n              if(!self[key]) self[key] = args[key];\r\n              else if (Array.isArray(args[key])) self[key].push(args[key]); //variables will be accessible in functions as this.x or this['x']\r\n              else self[key] = args[key];\r\n            });\r\n            return true;\r\n          } else return false;\r\n        }\r\n      },\r\n      { //for use with transfers\r\n        case: 'setValuesFromArrayBuffers', callback: (self, args, origin) => {\r\n          if (typeof args === 'object') {\r\n            Object.keys(args).forEach((key) => { \r\n              if(args[key].__proto__.__proto__.constructor.name === 'TypedArray') self[key] = Array.from(args[key]);\r\n              else self[key] = args[key];\r\n            });\r\n            return true;\r\n          } else return false;\r\n        }\r\n      },\r\n      { //for use with transfers\r\n        case: 'appendValuesFromArrayBuffers', callback: (self, args, origin) => {\r\n          if (typeof args === 'object') {\r\n            Object.keys(args).forEach((key) => {\r\n              if(!self[key] && args[key].__proto__.__proto__.constructor.name === 'TypedArray') self[key] = Array.from(args[key]);\r\n              else if(!self[key]) self[key] = args[key];\r\n              else if(args[key].__proto__.__proto__.constructor.name === 'TypedArray') self[key].push(Array.from(args[key]));\r\n              else if(Array.isArray(args[key])) self[key].push(args[key]); //variables will be accessible in functions as this.x or this['x']\r\n              else self[key] = args[key];\r\n            });\r\n            return true;\r\n          } else return false;\r\n        }\r\n      },\r\n      { //parses a stringified class prototype (class x{}.toString()) containing function methods for use on the worker\r\n        case: 'transferClassObject', callback: (self, args, origin) => {\r\n          if (typeof args === 'object') {\r\n            Object.keys(args).forEach((key) => {\r\n              if(typeof args[key] === 'string') {\r\n                let obj = args[key];\r\n                if(args[key].indexOf('class') === 0) obj = eval('('+args[key]+')');\r\n                self[key] = obj; //variables will be accessible in functions as this.x or this['x'] / self.x or self['x']\r\n                //console.log(self,key,obj);\r\n                if (self.threeUtil) self.threeUtil[key] = obj;\r\n              }\r\n            });\r\n            return true;\r\n          } else return false;\r\n        }\r\n      },\r\n      { //MessageChannel port, it just runs the whole callback system to keep it pain-free, while allowing messages from other workers\r\n        case: 'addport', callback: (self, args, origin) => { //args[0] = eventName, args[1] = case, only fires event if from specific same origin\r\n          let port = args[1];\r\n          port.onmessage = onmessage; //sets up a new receiver source (from other workers, perform addevent on the other worker)\r\n          this[args[0]] = port; //locally \r\n        }\r\n      },\r\n      { //add an event to the event manager, this helps building automated pipelines between threads\r\n        case: 'addevent', callback: (self, args, origin) => { //args[0] = eventName, args[1] = case, only fires event if from specific same origin\r\n          self.EVENTSETTINGS.push({ eventName: args[0], case: args[1], port:args[2], origin: origin });\r\n          //console.log(args);\r\n          if(args[2]){ \r\n            let port = args[2];\r\n            port.onmessage = onmessage; //attach the port onmessage event\r\n            this[args[0]+'port'] = port;\r\n          }\r\n          return true;\r\n        }\r\n      },\r\n      { //internal event subscription, look at Event.js for usage, its essentially a function trigger manager for creating algorithms\r\n        case: 'subevent', callback: (self, args, origin) => { //args[0] = eventName, args[1] = response function(self,args,origin) -> lets you reference self for setting variables\r\n          if(typeof args[0] !== 'string') return false;\r\n          \r\n          let response = parseFunctionFromText(args[1]);\r\n          let eventSetting = this.checkEvents(args[0]); //this will contain the port setting if there is any\r\n          //console.log(args, eventSetting)\r\n          return self.EVENTS.subEvent(args[0], (output) => {\r\n            response(self,output,origin,eventSetting?.port,eventSetting?.eventName); //function wrapper so you can access self from the event subscription\r\n          });\r\n        }\r\n      },\r\n      { //internal event unsubscribe\r\n        case: 'unsubevent', callback: (self, args, origin) => { //args[0] = eventName, args[1] = case, only fires event if from specific same origin\r\n          return self.EVENTS.unsubEvent(args[0], args[1]);\r\n        }\r\n      }   \r\n    ];\r\n\r\n\r\n    this.callbacks = new Map();\r\n    defaultFunctions.forEach((o) => {\r\n      if(o.case) this.callbacks.set(o.case,o.callback);\r\n      if(o.aliases) o.aliases.forEach((alias) => this.callbacks.set(alias,o.callback));\r\n    });\r\n\r\n\r\n    if(options.cpu) {\r\n        try{\r\n          if(workerCPU) {\r\n            this.workerCPU = new workerCPU(this);\r\n          }\r\n        } catch(err) {console.error(err);}\r\n    } \r\n    \r\n    if (options.gpu) {\r\n      try {\r\n        if(workerGPU) {\r\n          this.workerGPU = new workerGPU(this);\r\n        }\r\n      } catch(err) {console.error(err);}\r\n    }\r\n\r\n    if(options.renderer) {\r\n      try{\r\n        if(workerRenderer) {\r\n          this.workerRenderer = new workerRenderer(this);\r\n        }\r\n      } catch(err) {console.error(err);}\r\n    }\r\n  \r\n  }\r\n\r\n  \r\n  addCallback = (functionName,callback=(self,args,origin)=>{}) => {\r\n    if(!functionName || !callback) return false;\r\n    //this.removeCallback(functionName); //removes existing callback if it is there\r\n    this.callbacks.set(functionName,callback);\r\n    return true;\r\n  }\r\n\r\n  removeCallback = (functionName) => {\r\n      let found = this.callbacks.get(functionName);\r\n      if(found) {\r\n        this.callbacks.delete(functionName);\r\n        return true;\r\n      }\r\n      return false;\r\n  }\r\n\r\n  runCallback = async (functionName,args=[],origin) => {\r\n    let output = undefined;\r\n    let callback = this.callbacks.get(functionName);\r\n    if(callback) {\r\n      output = await callback(this, args, origin);\r\n    }\r\n    return output;\r\n  }\r\n\r\n  checkEvents = (functionName, origin) => {\r\n    let found = this.EVENTSETTINGS.find((o) => {\r\n      if ((o.origin && origin && o.case && functionName)) {\r\n        if (o.origin === origin && o.case === functionName) return true;\r\n        else return false;\r\n      } else if (o.case && functionName) {\r\n        if (o.case === functionName) return true;\r\n        else return false;\r\n      } else if (o.origin && origin) {\r\n        if(o.origin === origin) return true;\r\n        else return false;\r\n      }\r\n      else return false;\r\n    });\r\n    //console.log(functionName,origin,found)\r\n    return found;\r\n  }\r\n\r\n  checkCallbacks = async (event) => {\r\n    //console.log(event);\r\n    let output = undefined;\r\n    if(!event.data) return output;\r\n    let callback;\r\n\r\n    //different function name properties just for different sensibilities\r\n    if(event.data.case) callback=this.callbacks.get(event.data.case);\r\n    else if (event.data.foo) callback=this.callbacks.get(event.data.foo);\r\n    else if (event.data.command) callback=this.callbacks.get(event.data.command);\r\n    else if (event.data.cmd) callback=this.callbacks.get(event.data.cmd);\r\n\r\n    if(callback) {\r\n        if (event.data.input) output = await callback(this, event.data.input, event.data.origin);\r\n        else if (event.data.args) output = await callback(this, event.data.args, event.data.origin);\r\n        else output = await callback(this, undefined, event.data.origin); //no inputs\r\n    }\r\n    return output;\r\n  }\r\n}","//By Joshua Brewster, Dovydas Stirpeika (AGPL v3.0 License)\r\n//------------------------------------\r\n//---------GPU Utility Funcs---------- (gpu.addFunction())\r\n//------------------------------------\r\n\r\n\r\nfunction add(a, b) { return a + b; }\r\nfunction sub(a, b) { return a - b; }\r\nfunction mul(a, b) { return a * b; }\r\nfunction div(a, b) { return a / b; }\r\n\r\nfunction cadd(a_real, a_imag, b_real, b_imag) {\r\n    return [a_real + b_real, a_imag + b_imag];\r\n}\r\n\r\nfunction csub(a_real, a_imag, b_real, b_imag) {\r\n    return [a_real - b_real, a_imag - b_imag];\r\n}\r\n\r\nfunction cmul(a_real, a_imag, b_real, b_imag) {\r\n    return [a_real*b_real - a_imag*b_imag, a_real*b_imag + a_imag*b_real];\r\n}\r\n\r\nfunction cexp(a_real, a_imag) {\r\n    const er = Math.exp(a_real);\r\n    return [er * Math.cos(a_imag), er * Math.sin(a_imag)];\r\n}\r\n\r\nfunction mag(a, b) { // Returns magnitude\r\n    return Math.sqrt(a*a + b*b);\r\n}\r\n\r\nfunction conj(imag) { //Complex conjugate of x + iy is x - iy\r\n    return 0 - imag;\r\n}\r\n\r\nfunction lof(n) { //Lowest odd factor\r\n    const sqrt_n = Math.sqrt(n);\r\n    var factor = 3;\r\n\r\n    while(factor <= sqrt_n) {\r\n        if (n % factor === 0) return factor;\r\n        factor += 2;\r\n    }\r\n}\r\n\r\nfunction mean(arr, len) {\r\n    var mean = 0;\r\n    for (var i = 0; i < len; i++) {\r\n        mean += arr[i];\r\n    }\r\n    return mean/len;\r\n}\r\n\r\nfunction est(arr, mean, len) {\r\n    var est = 0;\r\n    for (var i=0; i<len;i++){\r\n        est += (arr[i]-mean)*(arr[i]-mean);\r\n    }\r\n    return Math.sqrt(est);\r\n}\r\n\r\nfunction mse(arr, mean, len) { //mean squared error\r\n    var est = 0;\r\n    var vari = 0;\r\n    for (var i = 0; i < len; i++) {\r\n        vari = arr[i]-mean;\r\n        est += vari*vari;\r\n    }\r\n    return est/len;\r\n}\r\n\r\nfunction rms(arr, mean, len) { //root mean square error\r\n    var est = 0;\r\n    var vari = 0;\r\n    for (var i = 0; i < len; i++) {\r\n        vari = arr[i]-mean;\r\n        est += vari*vari;\r\n    }\r\n    return Math.sqrt(est/len);\r\n}\r\n\r\nfunction xcor(arr1, arr1mean, arr1Est, arr2, arr2mean, arr2Est, len, delay) { //performs a single pass of a cross correlation equation, see correlogramsKern\r\n    var correlation = 0;\r\n    for (var i = 0; i < len; i++)  {\r\n        var j = i+delay;\r\n        var k = 0;\r\n        if(j < len) { k = arr2[j]; }\r\n        correlation += (arr1[i]-arr1mean)*(k-arr2mean);\r\n    }\r\n    return correlation/(arr1Est*arr2Est);\r\n}\r\n\r\nfunction softmax(array, len, i) { // Returns a single array value for a 1d softmax function.\r\n    var esum = 0;\r\n    for(var j = 0; j < len; j++){\r\n        esum+= Math.exp(array[j]);\r\n    }\r\n    return Math.exp(array[i])/esum;\r\n}\r\n\r\nfunction DFT(signal, len, freq){ //Extract a particular frequency\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    for(var i = 0; i<len; i++){\r\n      var sharedi = shared*i; //this.thread.x is the target frequency\r\n      real = real+signal[i]*Math.cos(sharedi);\r\n      imag = imag-signal[i]*Math.sin(sharedi);\r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real*_len,imag*_len]; //mag(real,imag)\r\n}\r\n\r\nfunction DFTlist(signals, len, freq, n) { //Extract a particular frequency\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n    for(var i = 0; i<len; i++){\r\n      var sharedi = shared*i; //this.thread.x is the target frequency\r\n      real = real+signals[i+(len-1)*n]*Math.cos(sharedi);\r\n      imag = imag-signals[i+(len-1)*n]*Math.sin(sharedi);  \r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real*_len,imag*_len]; //mag(real,imag)\r\n}\r\n\r\n//FFT, simply implements a nyquist frequency based index skip for frequencies <= sampleRate*.25.\r\n//Other optimization: could do 4 loops per thread and return a vec4, this is what you see in some other ultrafast libs\r\nfunction FFT(signal, len, freq, sr){ //Extract a particular frequency\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    var skip = 1;\r\n    var N = 0;\r\n    var factor = sr*.25;\r\n    if(freq <= factor){\r\n        while(freq <= factor){\r\n            factor=factor*.5;\r\n            skip+=1;\r\n        }\r\n    }\r\n\r\n    for(var i = 0; i<len; i+=skip){\r\n      var j = i;\r\n      if(j > len) { j = len; }\r\n      var sharedi = shared*j; //this.thread.x is the target frequency\r\n      real = real+signal[j]*Math.cos(sharedi);\r\n      imag = imag-signal[j]*Math.sin(sharedi);\r\n      N += 1;\r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real/N,imag/N]; //mag(real,imag)\r\n}\r\n\r\nfunction FFTlist(signals, len, freq, n, sr) { //Extract a particular frequency from a 1D list of equal sized signal arrays. Uses less samples for lower frequencies closer to nyquist threshold\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    var skip = 1;\r\n    var N = 0;\r\n    var factor = sr*.25;\r\n    if(freq <= factor){\r\n        while(freq <= factor){\r\n            factor=factor*.5;\r\n            skip+=1;\r\n        }\r\n    }\r\n\r\n    for(var i = 0; i<len; i+=skip){\r\n        var j = i;\r\n      if(j > len) { j = len; }\r\n      var sharedi = shared*j; //this.thread.x is the target frequency\r\n      real = real+signals[j+(len-1)*n]*Math.cos(sharedi);\r\n      imag = imag-signals[j+(len-1)*n]*Math.sin(sharedi);\r\n      N += 1;  \r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real/N,imag/N]; //mag(real,imag)\r\n}\r\n\r\n//Conjugated real and imaginary parts for iDFT (need to test still)\r\nfunction iDFT(fft, len, freq){ //inverse DFT to return time domain\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    for(var i = 0; i<len; i++){\r\n      var sharedi = shared*i; //this.thread.x is the target frequency\r\n      real = real+fft[i]*Math.cos(sharedi);\r\n      imag = fft[i]*Math.sin(sharedi)-imag;  \r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real*_len,imag*_len]; //mag(real,imag)\r\n}\r\n\r\nfunction iDFTlist(fft,len,freq,n){ //inverse DFT to return time domain \r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len\r\n    for (var i = 0; i<len; i++) {\r\n      var sharedi = shared*i; //this.thread.x is the target frequency\r\n      real = real+fft[i+(len-1)*n]*Math.cos(sharedi);\r\n      imag = fft[i+(len-1)*n]*Math.sin(sharedi)-imag;  \r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real*_len,imag*_len]; //mag(real,imag)\r\n}\r\n\r\nfunction iFFT(fft, len, freq, sr){ //inverse FFT to return time domain\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    var skip = 1;\r\n    var N = 0;\r\n    var factor = sr*.25;\r\n    if(freq <= factor){\r\n        while(freq <= factor){\r\n            factor=factor*.5;\r\n            skip+=1;\r\n        }\r\n    }\r\n\r\n    for(var i = 0; i<len; i+=skip){\r\n      var j = i;\r\n      if(j > len) { j = len; }\r\n      var sharedi = shared*j; //this.thread.x is the target frequency\r\n      real = real+fft[j]*Math.cos(sharedi);\r\n      imag = fft[j]*Math.sin(sharedi)-imag;  \r\n      N += 1;\r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real/N,imag/N]; //mag(real,imag)\r\n}\r\n\r\nfunction iFFTlist(signals, len, freq, n, sr) { //Extract a particular frequency from a 1D list of equal sized signal arrays. Uses less samples for lower frequencies closer to nyquist threshold\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    var skip = 1;\r\n    var N = 0;\r\n    var factor = sr*.25;\r\n    if(freq <= factor){\r\n        while(freq <= factor){\r\n            factor=factor*.5;\r\n            skip+=1;\r\n        }\r\n    }\r\n\r\n    for(var i = 0; i<len; i+=skip){\r\n        var j = i;\r\n      if(j > len) { j = len; }\r\n      var sharedi = shared*j; //this.thread.x is the target frequency\r\n      real = real+signals[j+(len-1)*n]*Math.cos(sharedi);\r\n      imag = signals[j+(len-1)*n]*Math.sin(sharedi)-imag;\r\n      N += 1;  \r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real/N,imag/N]; //mag(real,imag)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//------------------------------------\r\n//---------Kernel functions----------- (gpu.createKernel(func))\r\n//------------------------------------\r\n\r\n\r\nfunction correlogramsKern(arrays, len) { //Computes cross correlations of each pair of arrays given to the function. so xcor[0,1],xcor[2,3],etc\r\n\r\n    var k = Math.floor(this.thread.x/len)*2;\r\n    var delay = this.thread.x - Math.floor(this.thread.x/len)*len;\r\n    var arr1mean = mean(arrays[k],len);\r\n    var arr2mean = mean(arrays[k+1],len);\r\n    var arr1Est = est(arrays[k],arr1mean,len);\r\n    var arr2Est = est(arrays[k+1],arr2mean,len);\r\n\r\n    var y_x = xcor(arrays[k],arr1mean,arr1Est,arrays[k+1],arr2mean,arr2Est,len,delay);\r\n\r\n    return y_x;\r\n}\r\n\r\n//Computes cross correlations of each pair of arrays given to the function. so xcor[0,1],xcor[2,3],etc\r\n//Takes precomputed averages and estimators for each array for efficiency\r\nfunction correlogramsPCKern(arrays, len, means, estimators) { \r\n    var k = Math.floor(this.thread.x/len)*2;\r\n    var delay = this.thread.x - Math.floor(this.thread.x/len)*len;\r\n    var arr1mean = means[k];\r\n    var arr2mean = means[k+1];\r\n    var arr1Est = estimators[k];\r\n    var arr2Est = estimators[k+1];\r\n\r\n    var y_x = xcor(arrays[k],arr1mean,arr1Est,arrays[k+1],arr2mean,arr2Est,len,delay);\r\n\r\n    return y_x;\r\n}\r\n\r\n\r\n//Return frequency domain based on DFT\r\nfunction dftKern(signal, len, scalar) {\r\n    var result = DFT(signal,len, this.thread.x);\r\n    return mag(result[0], result[1])*scalar;\r\n}\r\n\r\nfunction idftKern(amplitudes, len, scalar) {\r\n    var result = iDFT(amplitudes, len, this.thread.x);\r\n    return mag(result[0], result[1])*scalar;\r\n}\r\n\r\nfunction fftKern(signal, len, scalar, sampleRate) {\r\n    var result = FFT(signal,len, this.thread.x, sampleRate);\r\n    return mag(result[0], result[1])*scalar;\r\n}\r\n\r\nfunction ifftKern(amplitudes, len, scalar, sampleRate) {\r\n    var result = iFFT(amplitudes, len, this.thread.x, sampleRate);\r\n    return mag(result[0], result[1])*scalar;\r\n}\r\n\r\n// Takes a 2D array input [signal1[],signal2[],signal3[]]; does not work atm\r\nfunction listdft2DKern(signals, scalar) {\r\n    var len = this.output.x;\r\n    var result = DFT(signals[this.thread.y],len,this.thread.x);\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return mag(result[0],result[1])*scalar; //mag(real,imag)\r\n}\r\n\r\n// [[signals1][signals2]]\r\n\r\n// More like a vertex buffer list to chunk through lists of signals\r\nfunction listdft1DKern(signals, len, scalar) {\r\n    var result = [0, 0];\r\n    if (this.thread.x <= len) {\r\n      result = DFT(signals,len,this.thread.x);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/len);\r\n      result = DFTlist(signals,len,this.thread.x-n*len,n);\r\n    }\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n} // [signals1,signasl2]\r\n\r\n// More like a vertex buffer list to chunk through lists of signals\r\nfunction listfft1DKern(signals, len, scalar, sps) {\r\n    var result = [0, 0];\r\n    if (this.thread.x <= len) {\r\n      result = FFT(signals,len,this.thread.x,sps);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/len);\r\n      result = FFTlist(signals,len,this.thread.x-n*len,n,sps);\r\n    }\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n} // [signals1,signasl2]\r\n\r\nfunction dft_windowedKern(signal, sampleRate, freqStart, freqEnd, scalar) {\r\n    var result = [0,0];\r\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n    result = DFT(signal,sampleRate,freq);\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n} \r\n\r\n\r\n//windowed functions should use a 1 second window for these hacky DFTs/FFTs to work right.\r\n\r\nfunction fft_windowedKern(signal, sampleRate, freqStart, freqEnd, scalar) {\r\n    var result = [0,0];\r\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n    result = FFT(signal,sampleRate,freq);\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n}\r\n\r\nfunction idft_windowedKern(amplitudes, sampleRate, freqStart, freqEnd, scalar) {\r\n    var result = [0,0];\r\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n    result = iDFT(amplitudes,sampleRate,freq);\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n}\r\n\r\nfunction ifft_windowedKern(amplitudes, sampleRate, freqStart, freqEnd, scalar) {\r\n    var result = [0,0];\r\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n    result = iFFT(amplitudes,sampleRate,freq);\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n}\r\n\r\nfunction listdft1D_windowedKern(signals, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\r\n    var result = [0, 0];\r\n    if (this.thread.x < sampleRate) {\r\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = DFT(signals,sampleRate,freq);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/sampleRate);\r\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = DFTlist(signals,sampleRate,freq-n*sampleRate,n);\r\n    }\r\n    //var mags = mag(result[0],result[1]);\r\n\r\n    return mag(result[0],result[1])*scalar; \r\n}\r\n\r\nfunction listfft1D_windowedKern(signals, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\r\n    var result = [0, 0];\r\n    if (this.thread.x < sampleRate) {\r\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = FFT(signals,sampleRate,freq,sampleRate);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/sampleRate);\r\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = FFTlist(signals,sampleRate,freq-n*sampleRate,n,sampleRate);\r\n    }\r\n    //var mags = mag(result[0],result[1]);\r\n\r\n    return mag(result[0],result[1])*scalar; \r\n}\r\n\r\nfunction listidft1D_windowedKern(ffts, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\r\n    var result = [0, 0];\r\n    if (this.thread.x < sampleRate) {\r\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = iDFT(ffts,sampleRate,freq);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/sampleRate);\r\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = iDFTlist(ffts,sampleRate,freq-n*sampleRate,n);\r\n    }\r\n    //var mags = mag(result[0],result[1]);\r\n\r\n    return mag(result[0]*2,result[1]*2)*scalar; //Multiply result by 2 since we are only getting the positive results and want to estimate the actual amplitudes (positive = half power, reflected in the negative axis)\r\n}\r\n\r\nfunction listifft1D_windowedKern(ffts, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\r\n    var result = [0, 0];\r\n    if (this.thread.x < sampleRate) {\r\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = iFFT(ffts,sampleRate,freq);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/sampleRate);\r\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = iFFTlist(ffts,sampleRate,freq-n*sampleRate,n);\r\n    }\r\n    //var mags = mag(result[0],result[1]);\r\n\r\n    return mag(result[0]*2,result[1]*2)*scalar; //Multiply result by 2 since we are only getting the positive results and want to estimate the actual amplitudes (positive = half power, reflected in the negative axis)\r\n}\r\n\r\n//e.g. arrays = [[arr1],[arr2],[arr3],[arr4],[arr5],[arr6]], len = 10, n = 2, scalar=1... return results of [arr1*arr2], [arr3*arr4], [arr5*arr6] as one long array that needs to be split\r\nfunction bulkArrayMulKern(arrays, len, n, scalar) {\r\n    var i = n*Math.floor(this.thread.x/len); //Jump forward in array buffer\r\n    var product = arrays[i][this.thread.x];\r\n    for (var j = 0; j < n; j++) {\r\n      product *= arrays[j][this.thread.x];\r\n    }\r\n    return product*scalar;\r\n}\r\n\r\nfunction ImgConv2DKern(img, width, height, kernel, kernelLength) {\r\n    let kernelRadius = (Math.sqrt(kernelLength) - 1) / 2;\r\n    const kSize = 2 * kernelRadius + 1;\r\n    let r = 0, g = 0, b = 0;\r\n\r\n    let i = -kernelRadius;\r\n    let kernelOffset = 0;\r\n    while (i <= kernelRadius) {\r\n        if (this.thread.x + i < 0 || this.thread.x + i >= width) {\r\n            i++;\r\n            continue;\r\n        }\r\n\r\n        let j = -kernelRadius;\r\n        while (j <= kernelRadius) {\r\n            if (this.thread.y + j < 0 || this.thread.y + j >= height) {\r\n                j++;\r\n                continue;\r\n            }\r\n\r\n            kernelOffset = (j + kernelRadius) * kSize + i + kernelRadius;\r\n            const weights = kernel[kernelOffset];\r\n            const pixel = img[this.thread.y + i][this.thread.x + j];\r\n            r += pixel.r * weights;\r\n            g += pixel.g * weights;\r\n            b += pixel.b * weights;\r\n            j++;\r\n        }\r\n        i++;\r\n    }\r\n\r\n    this.color(r, g, b);\r\n}\r\n\r\nfunction multiImgConv2DKern(img, width, height, kernels, kernelLengths, nKernels) {\r\n    \r\n    let r = 0, g = 0, b = 0;\r\n    for(var i = 0; i < nKernels; i++){\r\n\r\n        let kernelLength = kernelLengths[i];            \r\n        let kernelRadius = (Math.sqrt(kernelLength) - 1) / 2;\r\n        //(src, width, height, kernel, kernelRadius)\r\n        const kSize = 2 * kernelRadius + 1;\r\n        \r\n        let k = -kernelRadius;\r\n        let kernelOffset = 0;\r\n        while (k <= kernelRadius) {\r\n            if (this.thread.x + k < 0 || this.thread.x + k >= width) {\r\n                k++;\r\n                continue;\r\n            }\r\n\r\n            let j = -kernelRadius;\r\n            while (j <= kernelRadius) {\r\n                if (this.thread.y + j < 0 || this.thread.y + j >= height) {\r\n                j++;\r\n                continue;\r\n                }\r\n\r\n                kernelOffset = (j + kernelRadius) * kSize + k + kernelRadius;\r\n                const weights = kernels[i][kernelOffset];\r\n                const pixel = img[this.thread.y + k][this.thread.x + j];\r\n    \r\n                r += pixel.r * weights;\r\n                g += pixel.g * weights;\r\n                b += pixel.b * weights;\r\n            \r\n                //img[this.thread.y + k][this.thread.x + j] = pixel;      \r\n                    \r\n                j++;\r\n            }\r\n            k++;\r\n        }\r\n    }\r\n    this.color(r,g,b);\r\n}\r\n\r\nfunction transpose2DKern(mat2) { //Transpose a 2D matrix, meant to be combined\r\n    return mat2[this.thread.y][this.thread.x];\r\n}\r\n\r\n\r\n//function deferredPass(vPos, vNorm, vAlbedo, vDepth, vSpec) {  } //project geometry, light geometry\r\n\r\n/*\r\nScene drawing:\r\n(With depth testing enabled)\r\n1. Project object local spaces to world space based on geometry and world coordinates\r\n1.5 do some occlusion culling for which texture data to send to the gpu, requires last camera matrix\r\n2. Now send to lighting pass, with coloring properties defined by different texture maps. \r\n3. Project result to camera space based on camera position and aperture.\r\n4. Draw result\r\n*/\r\n\r\n\r\n//Note on pixel operations in gpujs: create kernel with setGraphical(true), render() to offscreencanvas, get render.getPixels() on each frame for pixel values which can be stored math operations\r\n\r\n\r\n//Exports\r\n\r\nexport const createGpuKernels = {\r\n    correlogramsKern, correlogramsPCKern, dftKern, idftKern, fftKern, ifftKern,\r\n    dft_windowedKern, idft_windowedKern, fft_windowedKern, ifft_windowedKern, \r\n    listdft2DKern, listdft1DKern, listfft1DKern, listfft1D_windowedKern, listdft1D_windowedKern, listidft1D_windowedKern, listifft1D_windowedKern,\r\n    bulkArrayMulKern, fftKern, ifftKern, multiImgConv2DKern,\r\n    ImgConv2DKern, transpose2DKern\r\n}\r\n\r\nexport const addGpuFunctions = [\r\n    add, sub, mul, div, cadd, csub,\r\n    cmul, cexp, mag, conj, lof, mean, est,\r\n    mse, rms, xcor, softmax, DFT, DFTlist,\r\n    iDFT, iDFTlist, FFT, iFFT, iFFTlist\r\n];","import './gpu-browser.min.js' // becomes a window variable\r\nimport { addGpuFunctions, createGpuKernels as krnl } from './gpuUtils-functs';\r\n\r\n//By Joshua Brewster, Dovydas Stirpeika (AGPL v3.0 License)\r\n\r\nexport function makeKrnl(gpu, f, opts = {\r\n  setDynamicOutput: true,\r\n  setDynamicArguments: true,\r\n  setPipeline: true,\r\n  setImmutable: true,\r\n  setGraphical: false\r\n}) {\r\n\r\n  const k = gpu.createKernel(f);\r\n\r\n  if (opts.setDynamicOutput)    k.setDynamicOutput(true);\r\n  if (opts.output)              k.setOutput(opts.output);\r\n  if (opts.setDynamicArguments) k.setDynamicArguments(true);\r\n  if (opts.setPipeline)         k.setPipeline(true);\r\n  if (opts.setImmutable)        k.setImmutable(true);\r\n  if (opts.setGraphical)        k.setGraphical(true);\r\n\r\n  //.setOutput([signal.length]) //Call before running the kernel\r\n  //.setLoopMaxIterations(signal.length);\r\n\r\n  return k;\r\n}\r\n\r\nexport function makeCanvasKrnl(gpu, f, opts = {\r\n  output: [300,300],\r\n  setDynamicArguments: true,\r\n  setDynamicOutput: true,\r\n  setPipeline: false,\r\n  setImmutable: true,\r\n  setGraphical: true\r\n}, divId) {\r\n\r\n  const k = makeKrnl(gpu,f,opts);\r\n\r\n  //k();\r\n\r\n  const canvas = k.canvas; \r\n\r\n  if (typeof divId === 'string') document.getElementById(toAppend).appendChild(canvas);\r\n  else if(divId) toAppend.appendChild(canvas);\r\n  else document.body.appendChild(canvas);\r\n\r\n  return k; //run k() with the input arguments in an animation loop, get graphical output.\r\n}\r\n\r\nexport class gpuUtils {\r\n  \r\n  constructor(gpu = new GPU()) {\r\n    this.gpu = gpu;\r\n    this.kernels = new Map(); // {name:\"\",f:foo(){}}\r\n\r\n    this.kernel;\r\n    this.PI = 3.141592653589793;\r\n    this.SQRT1_2 = 0.7071067811865476\r\n\r\n    this.addFunctions();\r\n\r\n    this.imgkernels = {\r\n      edgeDetection: [\r\n        -1, -1, -1,\r\n        -1,  8, -1,\r\n        -1, -1, -1\r\n      ], boxBlur: [\r\n        1/9, 1/9, 1/9,\r\n        1/9, 1/9, 1/9,\r\n        1/9, 1/9, 1/9\r\n      ], sobelLeft: [\r\n        1,  0, -1,\r\n        2,  0, -2,\r\n        1,  0, -1\r\n      ], sobelRight: [\r\n        -1, 0, 1,\r\n        -2, 0, 2,\r\n        -1, 0, 1\r\n      ], sobelTop: [\r\n        1,  2,  1,\r\n        0,  0,  0,\r\n        -1, -2, -1  \r\n      ], sobelBottom: [\r\n        -1, 2, 1,\r\n        0, 0, 0,\r\n        1, 2, 1\r\n      ], identity: [\r\n        0, 0, 0, \r\n        0, 1, 0, \r\n        0, 0, 0\r\n      ], gaussian3x3: [\r\n        1,  2,  1, \r\n        2,  4,  2, \r\n        1,  2,  1\r\n      ], guassian7x7: [\r\n        0, 0,  0,   5,   0,   0,  0,\r\n        0, 5,  18,  32,  18,  5,  0,\r\n        0, 18, 64,  100, 64,  18, 0,\r\n        5, 32, 100, 100, 100, 32, 5,\r\n        0, 18, 64,  100, 64,  18, 0,\r\n        0, 5,  18,  32,  18,  5,  0,\r\n        0, 0,  0,   5,   0,   0,  0,\r\n      ], emboss: [\r\n        -2, -1,  0, \r\n        -1,  1,  1, \r\n        0,  1,  2\r\n      ], sharpen: [\r\n        0, -1,  0,\r\n        -1,  5, -1,\r\n        0, -1,  0\r\n      ]\r\n    };\r\n  }\r\n\r\n  //adds math functions to use per-thread\r\n  addFunction(func = function f(){}) {\r\n    this.gpu.addFunction(func);\r\n  }\r\n\r\n  //add kernels to run based on input data. Input/Output sizes are dynamically allocated, functions are saved on the gpu to improve runtimes\r\n  addKernel(name=\"\", krnl=function foo(){}, opts) {\r\n    let found = this.kernels.get(name);\r\n    if(!found) {\r\n      this.kernels.set(name, makeKrnl(this.gpu,krnl,opts));\r\n      return true;\r\n    } else { \r\n      console.error('Kernel already exists'); \r\n      return false;\r\n    }\r\n    \r\n  }\r\n\r\n  addCanvasKernel(name, f,  opts, divId) {\r\n    let found = this.kernels.get(name);\r\n    if(!found) {\r\n      let krnl = makeCanvasKrnl(this.gpu,f,opts,divId);\r\n      this.kernels.set(name,krnl);\r\n      return krnl;\r\n    } else { \r\n      console.error('Kernel already exists'); \r\n      return false;\r\n    }\r\n    \r\n  }\r\n\r\n  //combine two or more kernels into a single function, this lets you run multiple kernels on the GPU (with appropriately varying inputs/output sizes) before returning to the CPU.\r\n  //Discount compute shaders? Not sure if this even works\r\n  combineKernels(name, fs=[], ckrnl=function foo() {}) {\r\n    let found = this.kernels.get(name);\r\n    if(!found) {\r\n      fs.forEach((f,i)=>{\r\n        if(typeof f === 'string') {\r\n          let found2 = this.kernels.get(f);\r\n          if(found2) fs[i] = found2;\r\n          else return false;\r\n        } else if (typeof f === 'function') {\r\n          if(this.kernels.get(f.name)) {\r\n            //all good\r\n          } else {\r\n            this.addKernel(f.name, f);\r\n          }\r\n        }\r\n      });\r\n      let krnl = this.gpu.combineKernels(...fs,ckrnl);\r\n      this.kernels.set(name, krnl);\r\n      return krnl;\r\n    } else { \r\n      console.error('Kernel already exists'); \r\n      return false;\r\n    }\r\n  }\r\n\r\n  callKernel(name=\"\",args=[]) {\r\n    let result;\r\n    let krnl = this.kernels.get(name);\r\n    if(!krnl) {\r\n      console.error('Kernel not found');\r\n      return false;\r\n    } \r\n    result = krnl(...args);\r\n    return result;\r\n  }\r\n\r\n  callCanvasKernel(name=\"\",args=[],outputDims=[]) {\r\n    let result;\r\n    let krnl = this.kernels.get(name);\r\n    if(!krnl) {\r\n      console.error('Kernel not found');\r\n      return false;\r\n    } else {\r\n      if (outputDims.length === 2) krnl.setOutput(outputDims);\r\n      result = krnl(...args);\r\n      return result;\r\n    }\r\n  }\r\n\r\n  hasKernel(name=\"\") {\r\n    let found = this.kernels.get(name);\r\n    if(!found) {\r\n      return false;\r\n    } else return true;\r\n  }\r\n\r\n  addFunctions() { \r\n    addGpuFunctions.forEach(f => this.gpu.addFunction(f));\r\n\r\n    this.correlograms = makeKrnl(this.gpu, krnl.correlogramsKern);\r\n    this.correlogramsPC = makeKrnl(this.gpu, krnl.correlogramsPCKern);\r\n    this.dft = makeKrnl(this.gpu, krnl.dftKern);\r\n    this.idft = makeKrnl(this.gpu, krnl.idftKern);\r\n    this.dft_windowed = makeKrnl(this.gpu, krnl.dft_windowedKern);\r\n    this.idft_windowed = makeKrnl(this.gpu, krnl.idft_windowedKern);\r\n    this.fft = makeKrnl(this.gpu, krnl.fftKern);\r\n    this.ifft = makeKrnl(this.gpu, krnl.ifftKern);\r\n    this.fft_windowed = makeKrnl(this.gpu, krnl.fft_windowedKern);\r\n    this.ifft_windowed = makeKrnl(this.gpu, krnl.ifft_windowedKern);\r\n    this.listdft2D = makeKrnl(this.gpu, krnl.listdft2DKern);\r\n    this.listdft1D = makeKrnl(this.gpu, krnl.listdft1DKern);\r\n    this.listdft1D_windowed = makeKrnl(this.gpu, krnl.listdft1D_windowedKern);\r\n    this.listfft1D = makeKrnl(this.gpu, krnl.listfft1DKern);\r\n    this.listfft1D_windowed = makeKrnl(this.gpu, krnl.listfft1D_windowedKern);\r\n    this.listidft1D_windowed = makeKrnl(this.gpu, krnl.listidft1D_windowedKern);\r\n    this.listifft1D_windowed = makeKrnl(this.gpu, krnl.listifft1D_windowedKern);\r\n    this.bulkArrayMul = makeKrnl(this.gpu, krnl.bulkArrayMulKern);\r\n\r\n    let kernels = [\r\n      {name:\"correlograms\", krnl:this.correlograms},\r\n      {name:\"correlogramsPC\", krnl: this.correlogramsPC},\r\n      {name:\"dft\", krnl:this.dft},\r\n      {name:\"idft\", krnl:this.idft},\r\n      {name:\"dft_windowed\", krnl:this.idft_windowed},\r\n      {name:\"fft\", krnl:this.fft},\r\n      {name:\"ifft\", krnl:this.ifft},\r\n      {name:\"fft_windowed\", krnl:this.fft_windowed},\r\n      {name:\"ifft_windowed\", krnl:this.ifft_windowed},\r\n      {name:\"listdft2D\", krnl:this.listdft2D},\r\n      {name:\"listdft1D\", krnl:this.listdft1D},\r\n      {name:\"listdft1D_windowed\", krnl:this.listdft1D_windowed},\r\n      {name:\"listfft1D\", krnl:this.listfft1D},\r\n      {name:\"listfft1D_windowed\", krnl:this.listfft1D_windowed},\r\n      {name:\"listidft1D_windowed\", krnl:this.listidft1D_windowed},\r\n      {name:\"listifft1D_windowed\", krnl:this.listifft1D_windowed},\r\n      {name:\"bulkArrayMul\", krnl:this.bulkArrayMul}\r\n    ];\r\n    \r\n    kernels.forEach((k) => {\r\n      this.kernels.set(k.name,k);\r\n    })\r\n\r\n    //----------------------------------- Easy gpu pipelining\r\n    //------------Combine Kernels-------- gpu.combineKernels(f1,f2,function(a,b,c) { f1(f2(a,b),c); });\r\n    //----------------------------------- TODO: Make this actually work (weird error)\r\n\r\n    //Bandpass FFT+iFFT to return a cleaned up waveform\r\n    const signalBandpass = (signal, sampleRate, freqStart, freqEnd, scalar) => { //Returns the signal wave with the bandpass filter applied\r\n      var dft = this.fft_windowed(signal, sampleRate, freqStart, freqEnd, scalar, 0);\r\n      var filtered_signal = this.ifft_windowed(dft, sampleRate, freqStart, freqEnd, scalar); \r\n      return filtered_signal;\r\n    }\r\n\r\n    //this.signalBandpass = this.gpu.combineKernels(this.dft_windowedKern,this.idft_windowedKern, signalBandpass);\r\n    \r\n    const signalBandpassMulti = (signals, sampleRate, freqStart, freqEnd, scalar) => {\r\n      var dfts = this.listdft1D_windowed(signals,sampleRate,freqStart,freqEnd,scalar, new Array(Math.ceil(signals/sampleRate)).fill(0));\r\n      var filtered_signals = this.listifft1D_windowed(dfts,sampleRate,freqStart,freqEnd,scalar);\r\n      return filtered_signals;\r\n    }\r\n\r\n    //this.signalBandpassMulti = this.gpu.combineKernels(this.listdft1D_windowed,this.listidft1D_windowed, signalBandpassMulti);\r\n\r\n    //TODO: automatic auto/cross correlation and ordering.\r\n    //Input signals like this : [signal1,signal2,autocor1,autocor2,crosscor,...repeat for desired coherence calculations] or any order of that.\r\n    this.gpuCoherence = (signals, sampleRate, freqStart, freqEnd, scalar) => { //Take FFTs of the signals, their autocorrelations, and cross correlation (5 FFTs per coherence), then multiply.\r\n      var xcors = this.correlograms(signals);\r\n      var dfts = this.listfft1D_windowed(xcors, sampleRate, freqStart, freqEnd, scalar, new Array(Math.ceil(signals/sampleRate)).fill(0) );\r\n      var products = this.bulkArrayMul(dfts, sampleRate, 5, 1);\r\n      return products;\r\n    }\r\n\r\n    //Need to get this working to be MUCH faster, the above method returns to the CPU each call, the below does not.\r\n    //this.gpuCoherence = this.gpu.combineKernels(this.listdft1D_windowedKern, this.bulkArrayMulKern, this.correlogramsKern, function gpuCoherence(signals,sampleRate,freqStart,freqEnd,scalar) {\r\n    //  var xcors = this.correlograms(signals);\r\n    //  var dfts = this.listdft1D_windowed(xcors, sampleRate, freqStart, freqEnd, scalar, new Array(Math.ceil(signals/sampleRate)).fill(0) );\r\n    //  var products = this.bulkArrayMul(dfts, sampleRate, 5, 1);\r\n    //  return products;\r\n    //});\r\n\r\n  }\r\n\r\n  gpuXCors(arrays, precompute=false, texOut = false) { //gpu implementation for bulk cross/auto correlations, outputs [[0:0],[0:1],...,[1:1],...[n:n]]\r\n \r\n    var outputTex;\r\n   \r\n    if(precompute === true) { //Precompute the means and estimators rather than in every single thread\r\n      var means = [];\r\n      var ests = [];\r\n      arrays.forEach((arr,i) => {\r\n        means.push(arr.reduce((prev,curr)=> curr += prev)/arr.length);\r\n        ests.push(Math.sqrt(means[i].reduce((sum,item) => sum += Math.pow(item-mean1,2))));\r\n      });\r\n\r\n      var meansbuf = [];\r\n      var estsbuf = [];\r\n      var buffer = [];\r\n      for(var i = 0; i < arrays.length; i++) {\r\n        for(var j = i; j < arrays.length; j++){\r\n          buffer.push(...arrays[i],...arrays[j]);\r\n          meansbuf.push(means[i],means[j]);\r\n          estsbuf.push(ests[i],ests[j]);\r\n        }\r\n      }\r\n\r\n      this.correlogramsPC.setOutput([buffer.length]);\r\n      this.correlogramsPC.setLoopMaxIterations(arrays[0].length*2);\r\n      outputTex = this.correlogramsPC(buffer, arrays[0].length, meansbuf, estsbuf)\r\n    }\r\n    else{\r\n      var buffer = [];\r\n      for(var i = 0; i < arrays.length; i++) {\r\n        for(var j = i; j < arrays.length; j++){\r\n          buffer.push(...arrays[i],...arrays[j]);\r\n        }\r\n      }\r\n\r\n      this.correlograms.setOutput([buffer.length]);\r\n      this.correlograms.setLoopMaxIterations(arrays[0].length*2);\r\n\r\n      outputTex = this.correlograms(buffer, arrays[0].length);\r\n    }\r\n\r\n    if(texOut === true) { return outputTex; }\r\n    var outputbuf = outputTex.toArray();\r\n    outputTex.delete();\r\n    var outputarrs = [];\r\n\r\n    for(var i = 0; i < arrays.length; i++){\r\n      outputarrs.push(outputbuf.splice(0, arrays[0].length));\r\n    }\r\n\r\n    return outputarrs;\r\n\r\n  } \r\n\r\n  //Input array buffer and the number of seconds of data\r\n  gpuDFT(signalBuffer, nSeconds, scalar=1, texOut = false){\r\n\r\n    var nSamples = signalBuffer.length;\r\n    var sampleRate = nSamples/nSeconds;\r\n\r\n    this.dft.setOutput([signalBuffer.length]);\r\n    this.dft.setLoopMaxIterations(nSamples);\r\n\r\n    var outputTex = this.dft(signalBuffer, nSamples, scalar);\r\n    var output = null;\r\n    if(texOut === false){\r\n      var freqDist = this.makeFrequencyDistribution(nSamples, sampleRate);\r\n      var signalBufferProcessed = outputTex.toArray();\r\n      //console.log(signalBufferProcessed);\r\n      outputTex.delete();\r\n      return [freqDist,this.orderMagnitudes(signalBufferProcessed)]; //Returns x (frequencies) and y axis (magnitudes)\r\n    }\r\n    else {\r\n      var tex = outputTex; \r\n      outputTex.delete(); \r\n      return tex;\r\n    }\r\n  }\r\n\r\n  //Input array of array buffers of the same length and the number of seconds recorded\r\n  MultiChannelDFT(signalBuffer, nSeconds, scalar=1, texOut=false) {\r\n    \r\n    var signalBufferProcessed = [];\r\n      \r\n    signalBuffer.forEach((row) => {\r\n      signalBufferProcessed.push(...row);\r\n    });\r\n    //console.log(signalBufferProcessed);\r\n  \r\n    var nSamplesPerChannel = signalBuffer[0].length;\r\n    var sampleRate = nSamplesPerChannel/nSeconds\r\n\r\n    this.listdft1D.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\r\n    this.listdft1D.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\r\n        \r\n    var outputTex = this.listdft1D(signalBufferProcessed,nSamplesPerChannel, scalar);\r\n    if(texOut === false){\r\n      var orderedMagsList = [];\r\n\r\n      var freqDist = this.makeFrequencyDistribution(nSamplesPerChannel, sampleRate);\r\n      signalBufferProcessed = outputTex.toArray();\r\n      //console.log(signalBufferProcessed);\r\n\r\n      for(var i = 0; i < signalBufferProcessed.length; i+=nSamplesPerChannel){\r\n        orderedMagsList.push(this.orderMagnitudes([...signalBufferProcessed.slice(i,i+nSamplesPerChannel)]));\r\n      }\r\n      //Now slice up the big buffer into individual arrays for each signal\r\n\r\n      outputTex.delete();\r\n      return [freqDist,orderedMagsList]; //Returns x (frequencies) and y axis (magnitudes)\r\n    }\r\n    else {\r\n      var tex = outputTex; \r\n      outputTex.delete(); \r\n      return tex;\r\n    }\r\n  }\r\n\r\n      \r\n  //Input buffer of signals [[channel 0],[channel 1],...,[channel n]] with the same number of samples for each signal. Returns arrays of the positive DFT results in the given window.\r\n  MultiChannelDFT_Bandpass(signalBuffer=[],nSeconds,freqStart,freqEnd, scalar=1, texOut = false) {\r\n\r\n    var signalBufferProcessed = [];\r\n      \r\n    signalBuffer.forEach((row) => {\r\n      signalBufferProcessed.push(...row);\r\n    });\r\n    //console.log(signalBufferProcessed);\r\n\r\n    var freqEnd_nyquist = freqEnd*2;\r\n    var nSamplesPerChannel = signalBuffer[0].length;\r\n    var sampleRate = nSamplesPerChannel/nSeconds;\r\n    \r\n    this.listdft1D_windowed.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\r\n    this.listdft1D_windowed.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\r\n        \r\n    var outputTex = this.listdft1D_windowed(signalBufferProcessed,sampleRate,freqStart,freqEnd_nyquist, scalar);\r\n    if(texOut === true) { return outputTex; }\r\n    \r\n    signalBufferProcessed = outputTex.toArray();\r\n    outputTex.delete();\r\n\r\n    //console.log(signalBufferProcessed)\r\n    //TODO: Optimize for SPEEEEEEED.. or just pass it str8 to a shader\r\n    var freqDist = this.bandPassWindow(freqStart,freqEnd,sampleRate);\r\n    return [freqDist, this.orderBPMagnitudes(signalBufferProcessed,nSeconds,sampleRate,nSamplesPerChannel)]; //Returns x (frequencies) and y axis (magnitudes)\r\n  \r\n  }\r\n\r\n  \r\n  //Input array buffer and the number of seconds of data\r\n  gpuFFT(signalBuffer, nSeconds, scalar=1, sampleRate, texOut = false){\r\n\r\n    var nSamples = signalBuffer.length;\r\n    var sampleRate = nSamples/nSeconds;\r\n\r\n    this.fft.setOutput([signalBuffer.length]);\r\n    this.fft.setLoopMaxIterations(nSamples);\r\n\r\n    var outputTex = this.fft(signalBuffer, nSamples, scalar, sampleRate);\r\n    var output = null;\r\n    if(texOut === false){\r\n      var freqDist = this.makeFrequencyDistribution(nSamples, sampleRate);\r\n      var signalBufferProcessed = outputTex.toArray();\r\n      //console.log(signalBufferProcessed);\r\n      outputTex.delete();\r\n      return [freqDist,this.orderMagnitudes(signalBufferProcessed)]; //Returns x (frequencies) and y axis (magnitudes)\r\n    }\r\n    else {\r\n      var tex = outputTex; \r\n      outputTex.delete(); \r\n      return tex;\r\n    }\r\n  }\r\n\r\n  //Input array of array buffers of the same length and the number of seconds recorded\r\n  MultiChannelFFT(signalBuffer, nSeconds, scalar=1, texOut=false) {\r\n    \r\n    var signalBufferProcessed = [];\r\n      \r\n    signalBuffer.forEach((row) => {\r\n      signalBufferProcessed.push(...row);\r\n    });\r\n    //console.log(signalBufferProcessed);\r\n  \r\n    var nSamplesPerChannel = signalBuffer[0].length;\r\n    var sampleRate = nSamplesPerChannel/nSeconds\r\n\r\n    this.listfft1D.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\r\n    this.listfft1D.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\r\n        \r\n    var outputTex = this.listfft1D(signalBufferProcessed,nSamplesPerChannel, scalar, sampleRate);\r\n    if(texOut === false){\r\n      var orderedMagsList = [];\r\n\r\n      var freqDist = this.makeFrequencyDistribution(nSamplesPerChannel, sampleRate);\r\n      signalBufferProcessed = outputTex.toArray();\r\n      //console.log(signalBufferProcessed);\r\n\r\n      for(var i = 0; i < signalBufferProcessed.length; i+=nSamplesPerChannel){\r\n        orderedMagsList.push(this.orderMagnitudes([...signalBufferProcessed.slice(i,i+nSamplesPerChannel)]));\r\n      }\r\n      //Now slice up the big buffer into individual arrays for each signal\r\n\r\n      outputTex.delete();\r\n      return [freqDist,orderedMagsList]; //Returns x (frequencies) and y axis (magnitudes)\r\n    }\r\n    else {\r\n      var tex = outputTex; \r\n      outputTex.delete(); \r\n      return tex;\r\n    }\r\n  }\r\n\r\n      \r\n  //Input buffer of signals [[channel 0],[channel 1],...,[channel n]] with the same number of samples for each signal. Returns arrays of the positive DFT results in the given window.\r\n  MultiChannelFFT_Bandpass(signalBuffer=[],nSeconds,freqStart,freqEnd, scalar=1, texOut = false) {\r\n\r\n    var signalBufferProcessed = [];\r\n      \r\n    signalBuffer.forEach((row) => {\r\n      signalBufferProcessed.push(...row);\r\n    });\r\n    //console.log(signalBufferProcessed);\r\n\r\n    var freqEnd_nyquist = freqEnd*2;\r\n    var nSamplesPerChannel = signalBuffer[0].length;\r\n    var sampleRate = nSamplesPerChannel/nSeconds;\r\n    \r\n    this.listfft1D_windowed.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\r\n    this.listfft1D_windowed.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\r\n        \r\n    var outputTex = this.listfft1D_windowed(signalBufferProcessed,sampleRate,freqStart,freqEnd_nyquist, scalar);\r\n    if(texOut === true) { return outputTex; }\r\n    \r\n    signalBufferProcessed = outputTex.toArray();\r\n    outputTex.delete();\r\n\r\n    //console.log(signalBufferProcessed)\r\n    //TODO: Optimize for SPEEEEEEED.. or just pass it str8 to a shader\r\n    var freqDist = this.bandPassWindow(freqStart,freqEnd,sampleRate);\r\n    return [freqDist, this.orderBPMagnitudes(signalBufferProcessed,nSeconds,sampleRate,nSamplesPerChannel)]; //Returns x (frequencies) and y axis (magnitudes)\r\n  \r\n  }\r\n\r\n  orderMagnitudes(unorderedMags){\r\n    return [...unorderedMags.slice(Math.ceil(unorderedMags.length*.5),unorderedMags.length),...unorderedMags.slice(0,Math.ceil(unorderedMags.length*.5))];  \r\n  }\r\n\r\n  makeFrequencyDistribution(FFTlength, sampleRate) {\r\n    var N = FFTlength; // FFT size\r\n    var df = sampleRate/N; // frequency resolution\r\n    \r\n    var freqDist = [];\r\n    for(var i=(-N/2); i<(N/2); i++) {\r\n      var freq = i*df;\r\n      freqDist.push(freq);\r\n    }\r\n    return freqDist;\r\n  }\r\n\r\n  //Order and sum positive magnitudes from bandpass DFT\r\n  orderBPMagnitudes(signalBufferProcessed,nSeconds,sampleRate,nSamplesPerChannel) {\r\n    var magList = [];\r\n\r\n      for(var i = 0; i < signalBufferProcessed.length; i+=nSamplesPerChannel){\r\n        magList.push([...signalBufferProcessed.slice(i,Math.ceil(nSamplesPerChannel*.5+i))]);\r\n      }\r\n\r\n\r\n    var summedMags = [];\r\n    var _sampleRate = 1/sampleRate;\r\n    if(nSeconds > 1) { //Need to sum results when sample time > 1 sec\r\n      magList.forEach((row, k) => {\r\n        summedMags.push([]);\r\n        var _max = 1/Math.max(...row); //uhh\r\n        for(var i = 0; i < row.length; i++ ){\r\n          if(i == 0){\r\n              summedMags[k]=row.slice(i,Math.floor(sampleRate));\r\n              i = Math.floor(sampleRate);\r\n          }\r\n          else {\r\n              var j = i-Math.floor(Math.floor(i*_sampleRate)*sampleRate)-1; //console.log(j);\r\n              summedMags[k][j] = summedMags[k][j] * row[i-1]*_max; \r\n          }\r\n        }\r\n        summedMags[k] = [...summedMags[k].slice(0,Math.ceil(summedMags[k].length*0.5))]\r\n\r\n      });\r\n      //console.log(summedMags);\r\n      return summedMags;  \r\n    }\r\n    \r\n    else {return magList;}\r\n  }\r\n\r\n  //Returns the x axis (frequencies) for the bandpass filter amplitudes. The window gets stretched or squeezed between the chosen frequencies based on the sample rate in my implementation.\r\n  bandPassWindow(freqStart,freqEnd,nSteps,posOnly=true) {\r\n \r\n    var freqEnd_nyquist = freqEnd*2;\r\n    let increment = (freqEnd_nyquist - freqStart)/nSteps;\r\n\r\n    var fftwindow = [];\r\n    if(posOnly === true){\r\n      for (var i = 0; i < Math.ceil(0.5*nSteps); i+=increment){\r\n          fftwindow.push(freqStart + (freqEnd_nyquist-freqStart)*i/(nSteps));\r\n      }\r\n    }\r\n    else{\r\n      for (var i = -Math.ceil(0.5*nSteps); i < Math.ceil(0.5*nSteps); i+=increment){\r\n        fftwindow.push(freqStart + (freqEnd_nyquist-freqStart)*i/(nSteps));\r\n      }\r\n    }\r\n    return fftwindow;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar mandebrotFrag = \r\n`\r\nuniform sampler1D tex;\r\nuniform vec2 center;\r\nuniform float scale;\r\nuniform int iter;\r\n\r\nvoid main() {\r\n    vec2 z, c;\r\n\r\n    c.x = 1.3333 * (gl_TexCoord[0].x - 0.5) * scale - center.x;\r\n    c.y = (gl_TexCoord[0].y - 0.5) * scale - center.y;\r\n\r\n    int i;\r\n    z = c;\r\n    for(i=0; i<iter; i++) {\r\n        float x = (z.x * z.x - z.y * z.y) + c.x;\r\n        float y = (z.y * z.x + z.x * z.y) + c.y;\r\n\r\n        if((x * x + y * y) > 4.0) break;\r\n        z.x = x;\r\n        z.y = y;\r\n    }\r\n\r\n    gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);\r\n}\r\n`;\r\n\r\nvar juliaSetFrag =\r\n`\r\nuniform sampler1D tex;\r\nuniform vec2 c;\r\nuniform int iter;\r\n\r\nvoid main() {\r\n    vec2 z;\r\n    z.x = 3.0 * (gl_TexCoord[0].x - 0.5);\r\n    z.y = 2.0 * (gl_TexCoord[0].y - 0.5);\r\n\r\n    int i;\r\n    for(i=0; i<iter; i++) {\r\n        float x = (z.x * z.x - z.y * z.y) + c.x;\r\n        float y = (z.y * z.x + z.x * z.y) + c.y;\r\n\r\n        if((x * x + y * y) > 4.0) break;\r\n        z.x = x;\r\n        z.y = y;\r\n    }\r\n\r\n    gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);\r\n}\r\n`;\r\n","import {gpuUtils} from 'gpujsutils'\r\nimport {Math2} from 'brainsatplay-math'\r\nimport { parseFunctionFromText } from '../utils/Parsing';\r\n\r\n//GPU.js utilities for the web worker callback manager\r\nexport class workerGPU {\r\n    constructor(callbackManager) {\r\n\r\n      try{\r\n        this.gpu = new gpuUtils();\r\n      }\r\n      catch(err) {\r\n        return undefined;\r\n      }\r\n        this.callbackManager = callbackManager;\r\n        callbackManager.gpu = this.gpu;\r\n\r\n        this.callbacks = [\r\n            { //add a gpu function call usable in kernels, follow gpujs's tutorials and pass stringified functions using their format\r\n                case: 'addgpufunc', callback: (self, args, origin) => { //arg0 = gpu in-thread function string\r\n                  return self.gpu.addFunction(parseFunctionFromText(args[0]));\r\n                }\r\n              },\r\n              { //add a gpu kernels, follow gpujs's tutorials and pass stringified functions using their format\r\n                case: 'addkernel', callback: (self, args, origin) => { //arg0 = kernel name, arg1 = kernel function string\r\n                  return self.gpu.addKernel(args[0], parseFunctionFromText(args[1]));\r\n                }\r\n              },\r\n              { //call a custom gpu kernel\r\n                case: 'callkernel', callback: (self, args, origin) => { //arg0 = kernel name, args.slice(1) = kernel input arguments\r\n                  return self.gpu.callKernel(args[0], args.slice(1)); //generalized gpu kernel calls\r\n                }\r\n              },\r\n              {\r\n                case: 'dft', callback: (self, args, origin) => {\r\n                  if (args[2] == undefined) args[2] = 1;\r\n                  return self.gpu.gpuDFT(...args);\r\n                }\r\n              },\r\n              {\r\n                case: 'multidft', callback: (self, args, origin) => {\r\n                  if (args[2] == undefined) args[2] = 1;\r\n                  return self.gpu.MultiChannelDFT(...args);\r\n                }\r\n              },\r\n              {\r\n                case: 'multidftbandpass', callback: (self, args, origin) => {\r\n                  if (args[4] == undefined) args[4] = 1;\r\n                  return self.gpu.MultiChannelDFT_Bandpass(...args);\r\n                }\r\n              },\r\n              {\r\n                case: 'fft', callback: (self, args, origin) => {\r\n                  if (args[2] == undefined) args[2] = 1;\r\n                  return self.gpu.gpuFFT(...args);\r\n                }\r\n              },\r\n              {\r\n                case: 'multifft', callback: (self, args, origin) => {\r\n                  if (args[2] == undefined) args[2] = 1;\r\n                  return self.gpu.MultiChannelFFT(...args);\r\n                }\r\n              },\r\n              {\r\n                case: 'multifftbandpass', callback: (self, args, origin) => {\r\n                  if (args[4] == undefined) args[4] = 1;\r\n                  return self.gpu.MultiChannelFFT_Bandpass(...args);\r\n                }\r\n              },\r\n              { \r\n                case: 'gpucoh', callback: (self, args, origin) => { \r\n                  return self.gpu.gpuCoherence(...args); } \r\n                },\r\n              {\r\n                case: 'coherence', callback: (self, args, origin) => {\r\n                  const correlograms = Math2.correlograms(args[0]); //should get this onto the GPU also, an untested function exists\r\n                  const buffer = [...args[0], ...correlograms];\r\n                  //console.log(buffer)\r\n                  var dfts;\r\n        \r\n                  var scalar = 1;\r\n                  //console.log(mins)\r\n                  //console.log(buffer);\r\n                  dfts = self.gpu.MultiChannelDFT_Bandpass(buffer, args[1], args[2], args[3], scalar);\r\n                  //console.log(dfts)\r\n                  const cordfts = dfts[1].splice(args[0].length, buffer.length - args[0].length);\r\n                  //console.log(cordfts)\r\n        \r\n                  const coherenceResults = [];\r\n                  const nChannels = args[0].length;\r\n        \r\n                  //cross-correlation dfts arranged like e.g. for 4 channels: [0:0, 0:1, 0:2, 0:3, 1:1, 1:2, 1:3, 2:2, 2:3, 3:3] etc.\r\n                  var k = 0;\r\n                  var l = 0;\r\n                  cordfts.forEach((row, i) => { //move autocorrelation results to front to save brain power\r\n                    if (l + k === nChannels) {\r\n                      var temp = cordfts.splice(i, 1);\r\n                      k++;\r\n                      cordfts.splice(k, 0, ...temp);\r\n                      l = 0;\r\n                      //console.log(i);\r\n                    }\r\n                    l++;\r\n                  });\r\n                  //Now arranged like [0:0,1:1,2:2,3:3,0:1,0:2,0:3,1:2,1:3,2:3]\r\n        \r\n                  //Outputs FFT coherence data in order of channel data inputted e.g. for 4 channels resulting DFTs = [0:1,0:2,0:3,1:2,1:3,2:3];\r\n        \r\n                  var autoFFTproducts = [];\r\n                  k = 0;\r\n                  l = 1;\r\n                  cordfts.forEach((dft, i) => {\r\n                    var newdft = new Array(dft.length).fill(0);\r\n                    if (i < nChannels) { //sort out autocorrelogram FFTs\r\n                      dft.forEach((amp, j) => {\r\n                        newdft[j] = amp//*dfts[1][i][j];\r\n                      });\r\n                      autoFFTproducts.push(newdft);\r\n                    }\r\n                    else { //now multiply cross correlogram ffts and divide by autocorrelogram ffts (magnitude squared coherence)\r\n                      dft.forEach((amp, j) => {\r\n                        newdft[j] = amp * amp / (autoFFTproducts[k][j] * autoFFTproducts[k + l][j]);//Magnitude squared coherence;\r\n                        if (newdft[j] > 1) { newdft[j] = 1; } //caps the values at 1\r\n                        //newdft[j] = Math.pow(newdft[j],.125)\r\n                      });\r\n                      l++;\r\n                      if ((l + k) === nChannels) {\r\n                        k++;\r\n                        l = 1;\r\n                      }\r\n                      coherenceResults.push(newdft);\r\n                    }\r\n                  });\r\n                  return [dfts[0], dfts[1], coherenceResults];\r\n                }\r\n              }\r\n        ];\r\n\r\n        this.addCallbacks();\r\n    }\r\n\r\n    addCallbacks(callbacks=this.callbacks) {\r\n      callbacks.forEach((fn) => {\r\n          this.callbackManager.addCallback(fn.case, fn.callback);\r\n          if(fn.aliases) {\r\n              fn.aliases.forEach((c) => {\r\n                  this.callbackManager.addCallback(c, fn.callback);\r\n              })\r\n          }\r\n      });\r\n    }\r\n}","//From Worker Thread\r\n\r\n\r\nfunction noop() {\r\n}\r\n\r\n/////////////https://threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html\r\n\r\nexport class EventDispatcher {\r\n\taddEventListener( type, listener ) {\r\n\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\t\tconst listeners = this._listeners;\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\t\t\tlisteners[ type ] = [];\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\t\t\tlisteners[ type ].push( listener );\r\n\t\t}\r\n\r\n\t}\r\n\r\n\thasEventListener( type, listener ) {\r\n\t\tif ( this._listeners === undefined ) return false;\r\n\t\tconst listeners = this._listeners;\r\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\r\n\t}\r\n\r\n\tremoveEventListener( type, listener ) {\r\n\t\tif ( this._listeners === undefined ) return;\r\n\t\tconst listeners = this._listeners;\r\n\t\tconst listenerArray = listeners[ type ];\r\n\t\tif ( listenerArray !== undefined ) {\r\n\t\t\tconst index = listenerArray.indexOf( listener );\r\n\t\t\tif ( index !== - 1 ) {\r\n\t\t\t\tlistenerArray.splice( index, 1 );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdispatchEvent( event ) {\r\n\t\tif ( this._listeners === undefined ) return;\r\n\t\tconst listeners = this._listeners;\r\n\t\tconst listenerArray = listeners[ event.type ];\r\n\t\tif ( listenerArray !== undefined ) {\r\n\t\t\tevent.target = this;\r\n\t\t\t// Make a copy, in case listeners are removed while iterating.\r\n\t\t\tconst array = listenerArray.slice( 0 );\r\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\r\n\t\t\t\tarray[ i ].call( this, event );\r\n\t\t\t}\r\n\t\t\tevent.target = null;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/////////////https://threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html\r\nexport class ElementProxyReceiver extends EventDispatcher {\r\n    constructor() {\r\n        super();\r\n        // because OrbitControls try to set style.touchAction;\r\n        this.style = {};\r\n    }\r\n    get clientWidth() {\r\n        return this.width;\r\n    }\r\n    get clientHeight() {\r\n        return this.height;\r\n    }\r\n    // OrbitControls call these as of r132. Maybe we should implement them\r\n    setPointerCapture() {}\r\n\r\n    releasePointerCapture() {}\r\n\r\n    getBoundingClientRect() {\r\n        return {\r\n            left: this.left,\r\n            top: this.top,\r\n            width: this.width,\r\n            height: this.height,\r\n            right: this.left + this.width,\r\n            bottom: this.top + this.height,\r\n        };\r\n    }\r\n\r\n    handleEvent(data) {\r\n        if (data.type === 'size') {\r\n            this.left = data.left;\r\n            this.top = data.top;\r\n            this.width = data.width;\r\n            this.height = data.height;\r\n            return;\r\n        }\r\n        data.preventDefault = noop;\r\n        data.stopPropagation = noop;\r\n        this.dispatchEvent(data);\r\n    }\r\n\r\n    focus() {}\r\n}\r\n\r\n/////////////https://threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html\r\nexport class ProxyManager {\r\n    constructor() {\r\n      this.id = 'proxy'+Math.floor(Math.random()*10000);\r\n      this.targets = {};\r\n      this.handleEvent = this.handleEvent.bind(this);\r\n    }\r\n\r\n    makeProxy(data) {        \r\n      const {id} = data;\r\n      const proxy = new ElementProxyReceiver();\r\n      this.targets[id] = proxy;\r\n    }\r\n\r\n    getProxy(id) {\r\n      return this.targets[id];\r\n    }\r\n\r\n    handleEvent(data) {\r\n      this.targets[data.id].handleEvent(data.data);\r\n    }\r\n}\r\n\r\n","//canvas and threejs rendering utilities on the worker\r\nimport { ProxyManager } from './ProxyListener';\r\n\r\nimport { parseFunctionFromText, dynamicImport } from '../utils/Parsing';\r\n\r\nexport class workerRenderer {\r\n    constructor(callbackManager) {\r\n\r\n\r\n        this.callbackManager = callbackManager;\r\n        callbackManager.canvas = new OffscreenCanvas(512, 512); //can add fnctions and refer to this.offscreen \r\n        callbackManager.ANIMATION = undefined;\r\n        callbackManager.ANIMATIONFUNC = undefined;\r\n        callbackManager.ANIMATING = false;\r\n        callbackManager.ANIMFRAMETIME = performance.now(); //ms based on UTC stamps\r\n        callbackManager.threeUtil = undefined;\r\n        callbackManager.PROXYMANAGER = new ProxyManager();\r\n\r\n        try{\r\n          if(window) console.log('worker in window!');\r\n        } catch(err) {\r\n          self.document = {}; //threejs hack\r\n        }\r\n\r\n\r\n        this.callbacks = [\r\n              { //resize an offscreen canvas\r\n                case: 'resizecanvas', callback: (self, args, origin) => {\r\n                  self.canvas.width = args[0];\r\n                  self.canvas.height = args[1];\r\n                  return true;\r\n                }\r\n              }, \r\n              { //args[0] = ProxyManager Id returned from startProxy, args[1] = event object\r\n                case:'proxyHandler', callback: (self, args, origin) => {\r\n        \r\n                  if(args.type === 'makeProxy') {\r\n                    self.PROXYMANAGER.makeProxy(args);\r\n        \r\n                    const proxy = self.PROXYMANAGER.getProxy(args.id); \r\n                    proxy.ownerDocument = proxy; // HACK!\r\n                    self[args.id] = proxy;\r\n                  } else if (args.type === 'event') {\r\n                    self.PROXYMANAGER.handleEvent(args);\r\n                  }\r\n                  else return false;\r\n        \r\n                  return true;\r\n                }\r\n              },\r\n              {\r\n                case: 'initThree', callback: async (self, args, origin) => {\r\n                  if (self.ANIMATING) {\r\n                    self.ANIMATING = false;\r\n                    cancelAnimationFrame(self.ANIMATION);\r\n                  }\r\n                  if (!self.threeUtil) {\r\n                    let module = await dynamicImport('./lib/workerRenderer/workerThreeUtils.js');\r\n                    self.threeUtil = new module.threeUtil(self.canvas,self,self.PROXYMANAGER.getProxy(args[0]));\r\n                    self.THREE = self.threeUtil.THREE; //add another reference for the hell of it\r\n                  }\r\n                  if (typeof args[1] === 'object') { //first is the setup function\r\n                    await self.runCallback('setValues',args[1]);\r\n                  }\r\n                  //console.log(args)\r\n                  if (args[2]) { //first is the setup function\r\n                    self.threeUtil.setup = parseFunctionFromText(args[2]);\r\n                  }\r\n                  if (args[3]) { //next is the draw function (for 1 frame)\r\n                    self.threeUtil.draw = parseFunctionFromText(args[3]);\r\n                  }\r\n                  if (args[4]) {\r\n                    self.threeUtil.clear = parseFunctionFromText(args[4]);\r\n                  }\r\n                  self.threeUtil.clear(self, args, origin);\r\n                  self.threeUtil.setup(self, args, origin);\r\n                  //console.log(self.threeUtil);\r\n                  return true;\r\n                }\r\n              },\r\n              {\r\n                case: 'startThree', callback: async (self, args, origin) => { //run the setup to start the three animation\r\n                  if (self.ANIMATING) {\r\n                    self.ANIMATING = false;\r\n                    cancelAnimationFrame(self.ANIMATION);\r\n                  }\r\n                  if (!self.threeUtil) {\r\n                    let module = await dynamicImport('./lib/workerRenderer/workerThreeUtils.js'); //not sure about right url till we test again\r\n                    //console.log(module);\r\n                    self.threeUtil = new module.threeUtil(self.canvas,self,self.PROXYMANAGER.getProxy(args[0]));\r\n                  }\r\n                  if (self.threeUtil) {\r\n                    self.threeUtil.clear(self, args, origin);\r\n                    self.threeUtil.setup(self, args, origin);\r\n                  }\r\n                  return true;\r\n                }\r\n              },\r\n              {\r\n                case: 'clearThree', callback: (self, args, origin) => { //run the clear function to stop three\r\n                  if (self.threeUtil) {\r\n                    self.threeUtil.clear(self, args, origin);\r\n                  }\r\n                  return true;\r\n                }\r\n              },\r\n              {case: 'setAnimation', callback: (self, args, origin) => { //pass a draw function to be run on an animation loop. Reference this.canvas and this.context or canvas and context. Reference values with this.x etc. and use setValues to set the values from another thread\r\n                  self.animationFunc = parseFunctionFromText(args[0]);\r\n                  return true;\r\n                }\r\n              },\r\n              {\r\n                case: 'startAnimation', callback: (self, args, origin) => {\r\n                  //console.log(this.animationFunc.toString(), this.canvas, this.angle, this.angleChange, this.bgColor)\r\n                  let anim = () => {\r\n                    if (self.ANIMATING) {\r\n                      self.animationFunc(self, args, origin);\r\n                      self.ANIMFRAMETIME = performance.now() - self.ANIMFRAMETIME;\r\n                      let emitevent = self.checkEvents('render', origin);\r\n                      let dict = { foo: 'render', output: self.ANIMFRAMETIME, origin: origin};\r\n                      self.ANIMFRAMETIME = performance.now();\r\n                      if (emitevent) {\r\n                        self.EVENTS.emit('render', dict);\r\n                      }\r\n                      else {\r\n                        postMessage(dict);\r\n                      }\r\n                      requestAnimationFrame(anim);\r\n                    }\r\n                  }\r\n        \r\n                  if (this.ANIMATING) {\r\n                    self.ANIMATING = false;\r\n                    cancelAnimationFrame(self.ANIMATION);\r\n                    setTimeout(() => {\r\n                      self.ANIMATING = true;\r\n                      self.ANIMATION = requestAnimationFrame(anim);\r\n                    }, 300);\r\n                  } else {\r\n                    self.ANIMATING = true;\r\n                    console.log('begin animation');\r\n                    self.ANIMATION = requestAnimationFrame(anim);\r\n                  }\r\n                  return true;\r\n                }\r\n              },\r\n              {\r\n                case: 'stopAnimation', callback: (self, args, origin) => {\r\n                  if (self.ANIMATING) {\r\n                    self.ANIMATING = false;\r\n                    cancelAnimationFrame(self.ANIMATION);\r\n                    return true;\r\n                  } else return false;\r\n                }\r\n              },\r\n              {\r\n                case: 'render', callback: (self, args, origin) => { //runs the animation function\r\n                  self.animationFunc(self, args, origin);\r\n                  let time = performance.now() - self.ANIMFRAMETIME\r\n                  tselfhis.ANIMFRAMETIME = performance.now();\r\n                  return time;\r\n                }\r\n              }\r\n        ];\r\n\r\n        this.addCallbacks();\r\n    }\r\n\r\n    addCallbacks(callbacks=this.callbacks) {\r\n      callbacks.forEach((fn) => {\r\n          this.callbackManager.addCallback(fn.case, fn.callback);\r\n          if(fn.aliases) {\r\n              fn.aliases.forEach((c) => {\r\n                  this.callbackManager.addCallback(c, fn.callback);\r\n              })\r\n          }\r\n      });\r\n    }\r\n}","//By Joshua Brewster (AGPL)\r\n\r\n\r\n/**\r\n * Math2 Contains All Static Methods\r\n * We'll add more useful static things like filter kernels etc. as we get to making them.\r\n * \r\n * //Just type these and the variable inputs that pop up should be easy to follow. Everything is commented otherwise till we document it\r\n * genSineWave() //generate a sine wave\r\n * getSineAmplitude() //get amplitude of a sine at time t\r\n * mean() //array mean\r\n * mode() //array mode\r\n * std() //standard dev\r\n * relError() //relative error\r\n * informationEntropy() //trying to build a maxent distribution off of this stuff\r\n * zscore() //array z score\r\n * variance() //variance\r\n * dot() //dot product\r\n * cross3D() //3d cross product\r\n * magnitude() //vector magnitude\r\n * distance() //distance function p1-p2\r\n * normalize() //array normalization\r\n * newtonsMethod() //root approximation\r\n * integral() //1d integral\r\n * dintegral() //2d integral\r\n * tintegral() //3d integral\r\n * pintegral() //2d path integral\r\n * makeVec() \r\n * transpose(mat) //2d mat transpose\r\n * matmul(a,b) \r\n * matscale(mat,scalar)\r\n * matadd(a,b)\r\n * matsub(a,b)\r\n * normalDistribution(samples=[], normalize=true) //create a norall (gaussian) distribution\r\n * expectedValue(samples=[],probabilities=this.normalDistribution(samples)) //get expected value of an array\r\n * originMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) //statistical moment about origin\r\n * centralMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) //statistical moment about mean\r\n * linearDiscriminantAnalysis(samples=[], classifier=[]) //LDA\r\n * conv1D(arr=[],kern=[],pad=0) //1d convolution //1d convolution\r\n * conv2D(mat=[[],[],[]],kern=[[],[],[]],pad=0) //2d convolution\r\n * cov2d(mat) //2d covariance\r\n * cov1d(arr1=[],arr2=[]) //1d covariance\r\n * cov3d(x=[],y=[],z=[]) //3d covariance\r\n * covNd(dimensionalData=[]) //nd covariance\r\n * eigens2x2(mat=[[1,2],[3,4]]) //fast 2x2 eigenvalue \r\n * eigenvectors2x2(mat=[[1,2],[3,4]], eigens=[1,2]) //fast 2x2 eigenvector \r\n * fastpca2d(xarr,yarr) //fast 2d pca\r\n * crosscorrelation(arr1,arr2) //crosscor\r\n * autocorrelation(arr1) //autocor\r\n * correlograms(dat=[[],[]]) //return cross correlations of many signals\r\n * sma(arr=[], window) //simple moving average \r\n * sum(arr=[]) //array sum\r\n * reduceArrByFactor(arr,factor=2) //reduce array sizes\r\n * makeArr(startValue, stopValue, nSteps) //linspace\r\n * interpolateArray(data, fitCount, scalar=1) \r\n * isExtrema(arr,critical='peak') //peak or valley\r\n * isCriticalPoint(arr,critical='peak') //peak, valley\r\n * peakDetect = (smoothedArray,type='peak',window=49) //wider window to find less peaks\r\n * getPeakThreshold(arr, peakIndices, thresholdVar)\r\n * \r\n * eigens(M=[[],[]], tolerance=0.0001, max_iterations=1000)\r\n * pca(mat=[[],[]],tolerance = 0.00001) //power iteration method PCA\r\n * eigenvalue_of_vector(mat, eigenvector)\r\n * power_iteration(mat, tolerance=0.00001, max_iterations=1000)\r\n * squared_difference(v1, v2)\r\n * flatten_vector(v) //column to row\r\n * column(mat, x) //row to column\r\n * \r\n */\r\n\r\n\r\n\r\nexport class Math2 {\r\n\tconstructor() {\r\n\r\n\t}\r\n\r\n\t//----------------------------------------------------------------\r\n\t//-------------------- Static Variables---------------------------\r\n\t//----------------------------------------------------------------\r\n\r\n\t//Throwing a bunch in here for the hell of it\r\n\tstatic TWO_PI = Math.PI*2; \t\t\t//2PI\r\n\tstatic C = 299792458; \t\t\t\t//speed of light m/s\r\n\tstatic G = 6.67430e-11; \t\t\t//Newton's gravitation constant N*m^2 / kg^2\r\n\tstatic h = 6.62607015e-34; \t\t\t//Planck constant J*s\r\n\tstatic R = 8.31432e3; \t\t\t\t//Universal gas constant J / kg*mol*K\r\n\tstatic Ra = 287; \t\t\t\t\t//Air gas constant J / kg*K\r\n\tstatic H = 69.3; \t\t\t\t\t//Hubble constant km/s/Mpc \r\n\tstatic kbar = 1.054571817e-34; \t\t//Dirac constant J*s\r\n\tstatic kB = 1.380649e-23; \t\t\t//Boltzmann constant J/K\r\n\tstatic ke = 8.9875517923e9; \t\t//Coulomb constant kg * m^3 * s^-2 * C^-2\r\n\tstatic me = 9.1093837015e-31; \t\t//electron mass kg\r\n\tstatic mp = 1.67262192369e-27; \t\t//proton mass kg\r\n\tstatic mn =\t1.67492749804e-27; \t\t//neutron mass kg\r\n\tstatic P0 = 1.01325e5; \t\t\t\t//Sea level pressure N/m^2\r\n\tstatic T0 = 288.15; \t\t\t\t//Sea level room temperature K\r\n\tstatic p0 = 1.225; \t\t\t\t\t//Sea level air density kg/m^3\r\n\tstatic Na = 6.0220978e23; \t\t\t//Avogadro's number 1 / kg*mol\r\n\tstatic y = 1.405; \t\t\t\t\t//Adiabatic constant\r\n\tstatic M0 = 28.96643; \t\t\t\t//Sea level molecular weight\r\n\tstatic g0 = 9.80665; \t\t\t\t//Sea level gravity m/s^2\r\n\tstatic Re = 6.3781e6; \t\t\t\t//Earth radius m\r\n\tstatic B = 1.458e-6; \t\t\t\t//Thermal constant Kg / m*s*sqrt(kg)\r\n\tstatic S = 110.4; \t\t\t\t\t//Sutherland's constant K\r\n\tstatic Sigma = 3.65e-10; \t\t\t//Collision diameter of air m\r\n\r\n\tstatic imgkernels = {\r\n\t\tedgeDetection: [\r\n\t\t  [-1, -1, -1],\r\n\t\t  [-1,  8, -1],\r\n\t\t  [-1, -1, -1]\r\n\t\t], boxBlur: [\r\n\t\t  [1/9, 1/9, 1/9],\r\n\t\t  [1/9, 1/9, 1/9],\r\n\t\t  [1/9, 1/9, 1/9]\r\n\t\t], sobelLeft: [\r\n\t\t  [1,  0, -1],\r\n\t\t  [2,  0, -2],\r\n\t\t  [1,  0, -1]\r\n\t\t], sobelRight: [\r\n\t\t  [-1, 0, 1],\r\n\t\t  [-2, 0, 2],\r\n\t\t  [-1, 0, 1]\r\n\t\t], sobelTop: [\r\n\t\t  [1,  2,   1],\r\n\t\t  [0,  0,   0],\r\n\t\t  [-1, -2, -1] \r\n\t\t], sobelBottom: [\r\n\t\t  [-1, 2, 1],\r\n\t\t  [0,  0, 0],\r\n\t\t  [1,  2, 1]\r\n\t\t], identity: [\r\n\t\t  [0, 0, 0],\r\n\t\t  [0, 1, 0], \r\n\t\t  [0, 0, 0]\r\n\t\t], gaussian3x3: [\r\n\t\t  [1,  2,  1],\r\n\t\t  [2,  4,  2], \r\n\t\t  [1,  2,  1]\r\n\t\t], guassian7x7: [\r\n\t\t  [0, 0,  0,   5,   0,   0,  0],\r\n\t\t  [0, 5,  18,  32,  18,  5,  0],\r\n\t\t  [0, 18, 64,  100, 64,  18, 0],\r\n\t\t  [5, 32, 100, 100, 100, 32, 5],\r\n\t\t  [0, 18, 64,  100, 64,  18, 0],\r\n\t\t  [0, 5,  18,  32,  18,  5,  0],\r\n\t\t  [0, 0,  0,   5,   0,   0,  0],\r\n\t\t], emboss: [\r\n\t\t  [-2, -1,  0],\r\n\t\t  [-1,  1,  1], \r\n\t\t  [ 0,  1,  2]\r\n\t\t], sharpen: [\r\n\t\t  [0, -1,   0],\r\n\t\t  [-1,  5, -1],\r\n\t\t  [0, -1,   0]\r\n\t\t]\r\n\t  };\r\n\r\n\t//----------------------------------------------------------------\r\n\t//-------------------- Static Functions --------------------------\r\n\t//----------------------------------------------------------------\r\n\r\n\t//Generate sinewave, you can add a noise frequency in too. Array length will be Math.ceil(fs*nSec)\r\n\tstatic genSineWave(freq=20,peakAmp=1,nSec=1,fs=512,freq2=0,peakAmp2=1){\r\n\t\tvar sineWave = [];\r\n\t\tvar t = [];\r\n\t\tvar increment = 1/fs; //x-axis time increment based on sample rate\r\n\t\tfor (var ti = 0; ti < nSec; ti+=increment){\r\n\t\t\tvar amplitude = Math.sin(2*Math.PI*freq*ti)*peakAmp;\r\n\t\t\tamplitude += Math.sin(2*Math.PI*freq2*ti)*peakAmp2; //Add interference\r\n\t\t\tsineWave.push(amplitude);\r\n\t\t\tt.push(ti);\r\n\t\t}\r\n\t\treturn [t,sineWave]; // [[times],[amplitudes]]\r\n\t}\r\n\r\n\t//get the sine amplitude at a particular time (seconds)\r\n\tstatic getSineAmplitude(frequency=20,peakAmplitude=1,ti=0, tOffset=0) {\r\n\t\treturn Math.sin(this.TWO_PI*frequency*ti+tOffset)*peakAmplitude;\r\n\t}\r\n\r\n\t//average value of array\r\n\tstatic mean(arr){\r\n\t\tvar sum = arr.reduce((prev,curr)=> curr += prev);\r\n\t\treturn sum / arr.length;\r\n\t}\r\n\r\n\t//array mode (most commonly occurring number)\r\n\tstatic mode(arr){\r\n\t\treturn arr.sort((a,b) =>\r\n\t\t\t  arr.filter(v => v===a).length\r\n\t\t\t- arr.filter(v => v===b).length\r\n\t\t).pop();\r\n\t}\r\n\r\n\t//standard deviation\r\n\tstatic std(arr,mean=undefined){\r\n\t\tlet avg = mean; \r\n\t\tif(!mean) avg = this.mean(arr);\r\n\t\tlet summed = 0;\r\n\t\tfor(let i = 0; i<arr.length; i++) {\r\n\t\t\tlet subbed = arr[i] - avg;\r\n\t\t\tsummed += subbed*subbed;\r\n\t\t}\r\n\t\t\r\n\t\treturn Math.sqrt(summed/arr.length);\r\n\t}\r\n\r\n\t//find the relative error of predicted results\r\n\tstatic relError(actual=[],forecast=[],abs=true) {\r\n\t\tif(actual.length !== forecast.length) throw new Error('Input arrays of same length!');\r\n\t\tlet i = actual.length;\r\n\t\tlet d = []; //relative errors\r\n\t\tfor(let j = 0; j<i; j++) {\r\n\t\t\tlet dd = (actual[j] - forecast[j])/actual[j];\r\n\t\t\tif(abs) dd = Math.abs(dd);\r\n\t\t\td.push(dd);\r\n\t\t}\r\n\t\treturn d;\r\n\t}\r\n\r\n\t//returns information entropy in natural units (base e)\r\n\tstatic informationEntropy(probabilities=[]) {\r\n\t\tlet entropy = [];\r\n\t\tlet len = probabilities.length;\r\n\t\tfor(let i = 0; i < len; i++) {\r\n\t\t\tlet ent = probabilities[i]*Math.log(probabilities[i]);\r\n\t\t\tif(isNaN(ent)) ent = 0;\r\n\t\t\tentropy.push(ent);\r\n\t\t}\r\n\r\n\t\treturn entropy;\r\n\t}\r\n\r\n\t//array zscore (probabilities)\r\n\tstatic zscore(arr){\r\n\t\tlet mean = this.mean(arr);\r\n\t\tlet std = this.std(arr,mean);\r\n\t\tlet z = [];\r\n\t\tfor (let i = 0; i<arr.length; i++) {\r\n\t\t\tz.push((arr[i]-mean) / std);\r\n\t\t}\r\n\r\n\t\treturn z;\r\n\t}\r\n\r\n\tstatic variance(arr) { //Variance of 1D input arrays of length n\r\n\t\tvar mean = this.mean(arr);\r\n\t\treturn arr.reduce((a,b) => a + ((b - mean)**2), 0)/arr.length;\r\n\t}\r\n\r\n\tstatic dot(vec1,vec2) { //nDimensional vector dot product\r\n        var dot=0;\r\n        for(var i=0; i<vec1.length; i++) {\r\n            dot += vec1[i]*vec2[i];\r\n        }\r\n\t\treturn dot;\r\n    }\r\n\r\n    static cross3D(vec1,vec2) { //3D vector cross product\r\n        return [\r\n            vec1[1]*vec2[2]-vec1[2]*vec2[1], //x\r\n            vec1[2]*vec2[0]-vec1[0]*vec2[2], //y\r\n            vec1[0]*vec2[1]-vec1[1]*vec2[0]  //z\r\n\t\t];\r\n    }\r\n\r\n    static magnitude(vec) { //nDimensional magnitude\r\n        var sqrd = 0;\r\n        vec.forEach((c) => {\r\n            sqrd+=c*c;\r\n        })\r\n        return Math.sqrt(sqrd)\r\n    }\r\n\r\n    static distance(point1, point2) { //nDimensional vector distance function\r\n        var dsqrd = 0;\r\n        point1.forEach((c,i) => {\r\n            dsqrd += (point2[i] - c)*(point2[i] - c);\r\n        })\r\n        return Math.sqrt(dsqrd);\r\n    }\r\n\tstatic normalize(vec) { //nDimensional vector normalization\r\n        var norm = 0;\r\n        norm = this.magnitude(vec);\r\n        var vecn = [];\r\n        vec.forEach((c,i) => {\r\n            vecn.push(c*norm);\r\n        })\r\n        return vecn;\r\n    }\r\n\r\n\t//return the quadratic roots based on your input ax^2 + bx + c = 0\r\n\tstatic quadraticFormula(a,b,c) {\r\n\t\tlet bbmac4 = Math.sqrt(b*b-4*a*c);\r\n\t\tif(!isNaN(bbmac4)) return ['complex','complex'];\r\n\t\tlet _a2 = 1/(2*a);\r\n\t\tif(bbmac4 === 0) return [b*_a2];\r\n\t\tlet nb = -b;\r\n\t\treturn [(nb + bbmac4)*_a2,((nb - bbmac4)*_a2)];\r\n\t}\r\n\r\n\t//approximation of function roots. Provide a function (1d), window, and precision and it will return approximate roots along that window\r\n\tstatic newtonsMethod(foo=(x)=>{return Math.pow(x,5) + x*x - x - 0.2}, start=0,end=1, precision=0.01, attempts=10) {\r\n\t\tlet roots = [];\r\n\r\n\t\tfor(let i = 0; i < attempts; i++) {\r\n\t\t\tlet seedx = Math.random()*(end-start);\t\r\n\t\t\tlet guess = foo(seedx);\r\n\t\t\tlet guess2 = foo(seedx + precision);\r\n\t\t\tlet slope = (guess2 - guess)/precision;\r\n\r\n\t\t\tlet xn = seedx+precision;\r\n\t\t\twhile((Math.abs(slope) > precision)) {\r\n\t\t\t\tlet step = -guess/slope;\r\n\t\t\t\tlet xn1 = xn+step;\r\n\t\t\t\tguess = guess2;\r\n\t\t\t\tguess2 = foo(xn1);\r\n\t\t\t\tlet slope = (guess2 - guess)/(xn1-xn);\r\n\t\t\t}\r\n\r\n\t\t\tlet idx;\r\n\t\t\tlet f = roots.find((root,i) => {\r\n\t\t\t\tif(Math.abs(xn1 - root) < precision) {\r\n\t\t\t\t\tidx = i;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tif(f) roots[idx] = (xn1 + f)*0.5;\r\n\t\t\telse roots.push(xn1);\r\n\t\t}\r\n\t\treturn roots;\r\n\t}\r\n\r\n\t//2D integral approximation using rectangular area under the curve. If you need absolute values be sure to return that.\r\n    static integral = (func=(x)=>{ let y=x; return y;}, range=[], stepx=0.01) => {\r\n        let area = 0;\r\n        for(let i = range[0]; i<range[1]; i+=stepx) {\r\n            let y=func(i);\r\n            area += y*stepx;\r\n        }\r\n        return area;\r\n    }\r\n\r\n    //3D double integral approximation\r\n    static dintegral = (func=(x,y)=>{ let z = x+y; return z;}, range=[[],[]], stepx=0.01,stepy=stepx) => {\r\n        let volume = 0;\r\n        for(let i = range[0][0]+stepx; i<range[0][1]; i+=stepx) {\r\n            for(let j = range[1][0]+stepy; j<range[1][1]; j+=stepy) {\r\n                let z=func(i,j);\r\n                volume += z*stepx*stepy;\r\n            }\r\n        }\r\n        return volume;\r\n    }\r\n\r\n    //4D triple integral approximation\r\n    static tintegral = (func=(x,y,z)=>{ let w=x+y+z; return w;}, range=[[],[],[]], stepx=0.01, stepy=stepx, stepz=stepx) => {\r\n        let volume = 0;\r\n        for(let i = range[0][0]+stepx; i<range[0][1]; i+=stepx) {\r\n            for(let j = range[1][0]+stepy; j<range[1][1]; j+=stepy) {\r\n                for(let k = range[2][0]+stepz; k<range[2][1]; k+=stepz) {\r\n                    let w=func(i,j,k);\r\n                    volume += w*stepx*stepy*stepz;\r\n                }\r\n            }\r\n        }\r\n        return volume;\r\n    }\r\n\r\n    //2D path integral approximation (the length of a curve)\r\n    static pintegral = (func=(x)=>{ let y=x; return y; }, range=[], stepx=0.01) => {\r\n        let length = 0;\r\n        let y0 = undefined;\r\n        let yi = undefined;\r\n        for(let i = range[0]; i<range[1]; i+=stepx) {\r\n            y0 = yi;\r\n            yi = func(i);\r\n            if(y0)\r\n                length += this.distance([0,y0],[stepx,yi]);\r\n        }\r\n        return length;\r\n    }\r\n\r\n    static makeVec(point1,point2) {  //Make vector from two nDimensional points (arrays)\r\n        var vec = [];\r\n        point1.forEach((c,i) => {\r\n            vec.push(point2[i]-c);\r\n        })\r\n        return vec;\r\n    }\r\n\r\n\tstatic transpose(mat){\r\n\t\treturn mat[0].map((_, colIndex) => mat.map(row => row[colIndex]));\r\n\t}\r\n\r\n\t//2D Matrix multiplication from: https://stackoverflow.com/questions/27205018/multiply-2-matrices-in-javascript\r\n\tstatic matmul(a, b) {\r\n\t\tvar aNumRows = a.length, aNumCols = a[0].length,\r\n\t\t\tbNumRows = b.length, bNumCols = b[0].length,\r\n\t\t\tm = new Array(aNumRows);  // initialize array of rows\r\n\t\tfor (var r = 0; r < aNumRows; ++r) {\r\n\t\t  m[r] = new Array(bNumCols); // initialize the current row\r\n\t\t  for (var c = 0; c < bNumCols; ++c) {\r\n\t\t\tm[r][c] = 0;             // initialize the current cell\r\n\t\t\tfor (var i = 0; i < aNumCols; ++i) {\r\n\t\t\t  m[r][c] += a[r][i] * b[i][c];\r\n\t\t\t}\r\n\t\t  }\r\n\t\t}\r\n\t\treturn m;\r\n\t}\r\n\r\n\t//Apply scalar to 2D matrix \r\n\tstatic matscale(mat,scalar) {\r\n\t\tlet m = [];\r\n\t\tfor (var i = 0; i < mat.length; i++) {\r\n\t\t\tm[i] = [];\r\n\t\t\tfor (let j = 0; j < mat[0].length; j++) {\r\n\t\t\t\tm[i][j] = mat[i][j] * scalar;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn m;\r\n\t}\r\n\r\n\t//2d matrix addition\r\n\tstatic matadd(a,b) {\r\n\t\tlet m = [];\r\n\t\tfor (let i = 0; i < a.length; i++) {\r\n\t\t\tm[i] = [];\r\n\t\t\tfor (var j = 0; j < a[0].length; j++) {\r\n\t\t\t\tm[i][j] = a[i][j] + b[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn m;\r\n\t}\r\n\r\n\t//2d matrix subtraction\r\n\tstatic matsub(a,b) {\r\n\t\tlet m = [];\r\n\t\tfor (let i = 0; i < a.length; i++) {\r\n\t\t\tm[i] = [];\r\n\t\t\tfor (var j = 0; j < a[0].length; j++) {\r\n\t\t\t\tm[i][j] = a[i][j] - b[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn m;\r\n\t}\r\n\r\n\t//return a histogram of the array, use nBins to override binSize\r\n\tstatic histogram(arr=[], binSize=1, nBins=undefined) {  \r\n\t\tlet copy = [...arr]; \r\n\t\tcopy.sort(function(a, b){return a - b}); //ascending sort\r\n\t\tlet binStart = Math.min(...copy);\r\n\t\tif(typeof nBins === 'number') {\r\n\t\t\tlet binEnd = Math.max(...copy);\r\n\t\t\tbinSize = Math.abs((binEnd - binStart) / (nBins-1));\r\n\t\t} \r\n\t\tlet j = binStart;\r\n\t\tlet binx = [];\r\n\t\tlet biny = [];\r\n\t\tfor(let i = 0; i < copy.length; i++) {\r\n\t\t\tlet binidx = binSize*j;\r\n\t\t\tif(copy[i] > binStart+binidx) { \r\n\t\t\t\tj++; \r\n\t\t\t\tbinidx+=binSize; \r\n\t\t\t\tlet binmin = binStart+binidx;\r\n\t\t\t\tlet binmid = binmin + binidx*0.5;\r\n\t\t\t\tbinx.push(binmid);\r\n\t\t\t\tbiny.push(0);\r\n\t\t\t}\r\n\t\t\tbiny[biny.length-1]++;\r\n\t\t}\r\n\r\n\t\treturn [binx,biny];\r\n\t}\r\n\r\n\r\n\t//Get probability densities for the samples, set a cutoff to avoid obscenely small numbers\r\n\tstatic normalDistribution(samples=[], normalize=true, cutoff = 0.0001) {\r\n\t\tlet m = this.mean(samples);\r\n\t\tlet vari = this.variance(samples);\r\n\t\tlet nSamples = samples.length;\r\n\r\n\t\tlet probabilities = [];\r\n\r\n\t\tlet denom = 1/(this.TWO_PI*vari);\r\n\t\tlet _variance = 1/vari;\r\n\t\tlet sum = 0; //for normalization\r\n\t\tfor (let i = 0; i < nSamples; i++) {\r\n\t\t\tlet px = Math.exp(-0.5*Math.pow((samples[i]-m)*_variance,2))*denom\r\n\t\t\tif(px < cutoff) px = 0;\r\n\t\t\tprobabilities.push(px);\r\n\t\t\tsum += px;\r\n\t\t}\r\n\t\tif(normalize) {\r\n\t\t\tlet _sum = 1/sum;\r\n\t\t\tprobabilities = probabilities.map(x => x*_sum);\r\n\t\t}\r\n\t\r\n\t\treturn probabilities;\r\n\t}\r\n\r\n\tstatic expectedValue(samples=[],probabilities=this.normalDistribution(samples)) {\r\n\t\treturn samples.reduce((sum,item,idx) => sum + item*probabilities[idx]);\r\n\t}\r\n\r\n\t//moment about the origin (statistics)\r\n\tstatic originMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) {\r\n\t\treturn samples.reduce((sum,item,idx) => sum + Math.pow(item,order)*probabilities[idx]);\r\n\t}\r\n\r\n\t//moment about the population mean (statistics)\r\n\tstatic centralMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) {\r\n\t\tlet m = this.mean(samples);\r\n\t\treturn samples.reduce((sum,item,idx) => sum + Math.pow((item-m),order)*probabilities[idx]/samples.length);\r\n\t}\r\n\r\n\tstatic linearDiscriminantAnalysis(samples=[], classifier=[]) {\r\n\t\tlet mean = this.mean(samples);\r\n\t\tlet meank = this.mean(classifier);\r\n\t\tlet covariance = this.cov1d(samples,classifier);\r\n\t\tlet probs = this.normalDistribution(samples);\r\n\r\n\t\tlet dk = [];\r\n\t\tfor(let i = 0; i < samples.length; i++){ \r\n\t\t\tdk.push(x[i]*covariance*meank - .5*mean*covariance*meank + Math.log10(probs[i]));\r\n\t\t}\r\n\r\n\t\treturn dk;\r\n\t}\r\n\r\n\t//1D convolution (filtering)\r\n\tstatic conv1D(arr=[],kern=[1/3,1/3,1/3],pad=Math.floor(kern.length*0.5)) {\r\n\t\tlet result = [];\r\n\t\tlet _n = 1/kern.length;\r\n\r\n\t\tif(pad > 0) {\r\n\t\t\tlet pads = new Array(pad).fill(0);\r\n\t\t\tarr = [...pads,...arr,...pads];\r\n\t\t}\r\n\r\n\t\tlet start = Math.floor(kern.length*0.5); //offset since kernel will reduce size of array\r\n\t\tlet end = arr.length - kern.length + start; //end index\r\n\r\n\t\tfor(let i = start; i < end; i++) {\r\n\t\t\tlet acc = 0;\r\n\t\t\tfor(let j = 0; j < kern.length; j++) {\r\n\t\t\t\tacc += arr[i-start] * kern[j];\r\n\t\t\t}\r\n\t\t\tresult.push(acc* _n);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\t\r\n\r\n\t//2D convolution (filtering), input 2d mat and 2d kernel \r\n\tstatic conv2D(mat=[[],[],[]],kern=[[],[],[]],pad=0) {\r\n\t\tlet result = new Array(mat.length - Math.ceil(kern.length*0.5)).fill([]);\r\n\t\t\r\n\t\tlet mat_t;\r\n\t\tlet kern_t = Math2.transpose(kern_t);\r\n\r\n\t\tif(pad > 0) {\r\n\t\t\tlet pads = new Array(pad).fill(0);\r\n\r\n\t\t\t//transpose to col/row\r\n\t\t\tmat_t = Math2.transpose(mat); //hard copy\r\n\t\t\tfor(let i = 0; i < mat_t.length; i++) {\r\n\t\t\t\tmat_t[i] = [...pads,...mat_t[i],...pads];\r\n\t\t\t}\r\n\r\n\t\t\t//transpose back\r\n\t\t\tmat = Math2.transpose(mat_t);\r\n\t\t\tfor(let j = 0; j < mat.length; j++) {\r\n\t\t\t\tmat[j] = [...pads,...mat[j],...pads];\r\n\t\t\t}\r\n \r\n\t\t}\r\n\r\n\t\t\r\n\t\tlet startr = Math.floor(kern[0].length*0.5); //offset since kernel will reduce size of array\r\n\t\tlet startl = Math.floor(kern_t[0].length*0.5); //offset since kernel will reduce size of array\r\n\r\n\t\tlet endr = mat[0].length - kern[0].length + startr; //row end\r\n\t\tlet endl = mat_t[0].length - kern_t[0].length + startl; //column end\r\n\r\n\t\tlet _n = 1/(kern[0].length*kern_t[0].length);\r\n\r\n\t\tlet iters = endr*endl; //number of convolutions to perform\r\n\r\n\t\tlet i = startr;\r\n\t\tlet x; let y=startl;\r\n\t\twhile(i < iters) {\r\n\t\t\tlet acc = 0;\r\n\t\t\tx = i % mat[0].length;\r\n\t\t\tif(x === 0) {\r\n\t\t\t\ty++;\r\n\t\t\t}\r\n\r\n\t\t\tfor(let j = 0; j < kern[0].length; j++) {\r\n\t\t\t\tfor(let k = 0; k < kern_t[0].length; j++) {\r\n\t\t\t\t\tacc += mat[y-startl+k][x-startr+j] * kern[k][j];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresult[y].push(acc*_n);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ti++;\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\r\n\t}\t\r\n\r\n\t//2D matrix covariance (e.g. for lists of signals). Pretty fast!!!\r\n\tstatic cov2d(mat) { //[[x,y,z,w],[x,y,z,w],...] input list of vectors of the same length\r\n\t\t//Get variance of rows and columns\r\n\t\t//console.time(\"cov2d\");\r\n\t\tvar mattransposed = this.transpose(mat);\r\n\t\t//console.log(mattransposed)\r\n\t\tvar matproducts = [];\r\n\r\n\t\tvar rowmeans = [];\r\n\t\tvar colmeans = [];\r\n\r\n\t\tmat.forEach((row, idx) => {\r\n\t\t\trowmeans.push(this.mean(row));\r\n\t\t});\r\n\r\n\t\tmattransposed.forEach((col,idx) => {\r\n\t\t\tcolmeans.push(this.mean(col));\r\n\t\t});\r\n\r\n\t\tmat.forEach((row,idx) => {\r\n\t\t\tmatproducts.push([]);\r\n\t\t\tfor(var col = 0; col < row.length; col++){\r\n\t\t\t\tmatproducts[idx].push((mat[idx][col]-rowmeans[idx])*(mat[idx][col]-colmeans[col])/(row.length - 1));\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t/*\r\n\t\t\tmat[y][x] = (x - rowAvg)*(x - colAvg) / (mat[y].length - 1);\r\n\t\t*/\r\n\r\n\t\t//console.log(matproducts);\r\n\t\t//Transpose matrix\r\n\t\tvar matproductstransposed = this.transpose(matproducts);\r\n\r\n\t\t//Matrix multiplication, stolen from: https://stackoverflow.com/questions/27205018/multiply-2-matrices-in-javascript\r\n\t\tvar aNumRows = matproducts.length, aNumCols = matproducts[0].length,\r\n\t\t\tbNumRows = matproductstransposed.length, bNumCols = matproductstransposed[0].length,\r\n\t\t\tm = new Array(aNumRows);  // initialize array of rows\r\n\t\tfor (var r = 0; r < aNumRows; ++r) {\r\n\t\t  m[r] = new Array(bNumCols); // initialize the current row\r\n\t\t  for (var c = 0; c < bNumCols; ++c) {\r\n\t\t\tm[r][c] = 0;             // initialize the current cell\r\n\t\t\tfor (var i = 0; i < aNumCols; ++i) {\r\n\t\t\t  m[r][c] += matproducts[r][i] * matproductstransposed[i][c] / (mat[0].length - 1); //divide by row length - 1\r\n\t\t\t}\r\n\t\t  }\r\n\t\t}\r\n\t\t//console.timeEnd(\"cov2d\");\r\n\t\treturn m; //Covariance matrix\r\n\t}\r\n\r\n\r\n\t//Covariance between two 1D arrays\r\n\tstatic cov1d(arr1=[],arr2=[]) {\r\n\t\treturn this.cov2d([arr1,arr2]);\r\n\t}\r\n\r\n\t//3d covariance\r\n\tstatic cov3d(x=[],y=[],z=[]) {\r\n\t\treturn [\r\n\t\t\t[this.cov1d(x,x),this.cov1d(x,y),this.cov1d(x,z)],\r\n\t\t\t[this.cov1d(y,x),this.cov1d(y,y),this.cov1d(y,z)],\r\n\t\t\t[this.cov1d(z,x),this.cov1d(z,y),this.cov1d(z,z)]\r\n\t\t];\r\n\t}\r\n\r\n\t//n-dimensional covariance matrix\r\n\tstatic covNd(dimensionalData=[]) {\r\n\t\tlet covariance = [];\r\n\t\tdimensionalData.forEach((arr,i)=>{\r\n\t\t\tcovariance.push([]);\r\n\t\t\tdimensionalData.forEach((arr2,j)=>{\r\n\t\t\t\tcovariance[i].push(this.cov1d(arr,arr2));\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\t//fast 2x2 eigenvalue calculator: https://www.youtube.com/watch?v=e50Bj7jn9IQ\r\n\tstatic eigens2x2(mat=[[1,2],[3,4]]) {\r\n\t\tlet det = mat[0][0]*mat[1][1] - mat[0][1]*mat[1][0];\r\n\t\tlet mean = (mat[0][0]+mat[1][1])*.5;\r\n\r\n\t\tlet sqrt = Math.sqrt(mean*mean - det);\r\n\t\tlet eig1 = mean + sqrt;\r\n\t\tlet eig2 = mean - sqrt;\r\n\r\n\t\treturn [eig1, eig2];\r\n\t}\r\n\r\n\t//http://math.colgate.edu/~wweckesser/math312Spring06/handouts/IMM_2x2linalg.pdf\r\n\tstatic eigenvectors2x2(mat=[[1,2],[3,4]], eigens=[1,2]) {\r\n\t\tlet v1 = [-mat[0][1], mat[0][0]-eigens[0]];\r\n\t\tif(v1[0] === 0 && v1[1] === 0) {\r\n\t\t\tv1[0] = mat[1][1]-eigens[0];\r\n\t\t\tv1[1] = -mat[1][0];\r\n\t\t}\r\n\t\tlet v2 = [-mat[0][1], mat[0][0]-eigens[1]];\r\n\t\tif(v2[0] === 0 && v2[1] === 0) {\r\n\t\t\tv2[0] = mat[1][1]-eigens[1];\r\n\t\t\tv2[1] = -mat[1][0];\r\n\t\t}\r\n\t\treturn [v1, v2];\r\n\t}\r\n\r\n\t//Fast PCA for 2D datasets https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c\r\n\tstatic fastpca2d(xarr,yarr){\r\n\t\tlet cov1d = this.cov1d(xarr,yarr); //yields a 2x2 matrix\r\n\t\tlet eigs = this.eigens2x2(cov1d);\r\n\t\tif(eigs[1] > eigs[0]) eigs.reverse();\r\n\t\tlet evs = this.eigenvectors2x2(cov1d,eigs);\r\n\r\n\t\tconsole.log(eigs,evs)\r\n\t\treturn [eigs,evs];\r\n\t}\r\n\r\n\t//Simple cross correlation.\r\n\tstatic crosscorrelation(arr1,arr2) {\r\n\r\n\t\t//console.time(\"crosscorrelation\");\r\n\t\tvar arr2buf = [...arr2,...Array(arr2.length).fill(0)];\r\n\t\tvar mean1 = this.mean(arr1);\r\n\t\tvar mean2 = this.mean(arr2);\r\n\r\n\t\t//Estimators\r\n\t\tvar arr1Est = arr1.reduce((sum,item) => sum += Math.pow(item-mean1,2));\r\n\t\tarr1Est = Math.sqrt(arr1Est);\r\n\t\tvar arr2Est = arr2.reduce((sum,item) => sum += Math.pow(item-mean1,2));\r\n\t\tarr2Est = Math.sqrt(arr2Est);\r\n\r\n\t\tvar _arrEstsMul = 1/(arr1Est * arr2Est);\r\n\t\tvar correlations = new Array(arr1.length).fill(0);\r\n\r\n\t\tfor(var delay = 0; delay < arr1.length; delay++) {\r\n\t\t\tvar r = arr1.reduce((sum,item,i) => sum += (item - mean1)*(arr2buf[delay+i]-mean2));\r\n\t\t\tcorrelations[delay] = r*_arrEstsMul;\r\n\t\t}\r\n\r\n\t\t//console.timeEnd(\"crosscorrelation\");\r\n\t\treturn correlations;\r\n\t}\r\n\r\n\t//Simple autocorrelation. Better method for long series: FFT[x1] .* FFT[x2]\r\n\tstatic autocorrelation(arr1) {\r\n\t\tvar delaybuf = [...arr1,...Array(arr1.length).fill(0)];\r\n\t\tvar mean1 = this.mean(arr1);\r\n\r\n\t\t//Estimators\r\n\t\tvar arr1Est = arr1.reduce((sum,item) => sum += Math.pow(item-mean1,2));\r\n\t\tarr1Est = Math.sqrt(arr1Est);\r\n\r\n\t\tvar _arr1estsqrd = 1/(arr1Est * arr1Est);\r\n\t\tvar correlations = new Array(arr1.length).fill(0);\r\n\r\n\t\tfor(var delay = 0; delay < arr1.length; delay++) {\r\n\t\t\tvar r = arr1.reduce((sum,item,i) => sum += (item - mean1)*(delaybuf[delay+i]-mean1));\r\n\t\t\tcorrelations[delay] = r*_arr1estsqrd;\r\n\t\t}\r\n\r\n\t\treturn correlations;\r\n\t}\r\n\r\n\t//Compute correlograms of the given array of arrays (of equal length). Input array of equal length arrays of latest raw data (use dat = eeg32instance.getTaggedRawData())\r\n\tstatic correlograms(dat=[[],[]]) {//Coherence network math for data pushed to the atlas\r\n\t\tvar correlograms = []; //auto and cross correlations for each channel\r\n\t\tdat.forEach((row1,i) => {\r\n\t\t\tdat.forEach((row2,j) => {\r\n\t\t\t\tif(j >= i) {\r\n\t\t\t\t\tcorrelograms.push(Math2.crosscorrelation(row1,row2));\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t});\r\n\t\treturn correlograms; //Output ordered like (tag1:tag1, tag1:tag2 ... tag2:tag2, tag2:tag3 ... tagn:tagn) where autocorrelograms are also included\r\n\t}\r\n\r\n\t//Input data and averaging window, output array of moving averages (should be same size as input array, initial values not fully averaged due to window)\r\n\tstatic sma(arr=[], window) {\r\n\t\tvar smaArr = []; //console.log(arr);\r\n\t\tfor(var i = 0; i < arr.length; i++) {\r\n\t\t\tif((i == 0)) {\r\n\t\t\t\tsmaArr.push(arr[0]);\r\n\t\t\t}\r\n\t\t\telse if(i < window) { //average partial window (prevents delays on screen)\r\n\t\t\t\tvar arrslice = arr.slice(0,i+1);\r\n\t\t\t\tsmaArr.push(arrslice.reduce((previous,current) => current += previous ) / (i+1));\r\n\t\t\t}\r\n\t\t\telse { //average windows\r\n\t\t\t\tvar arrslice = arr.slice(i-window,i);\r\n\t\t\t\tsmaArr.push(arrslice.reduce((previous,current) => current += previous) / window);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//console.log(temp);\r\n\t\treturn smaArr;\r\n\t}\r\n\r\n\tstatic sum(arr=[]){\r\n\t\tif (arr.length > 0){\r\n\t\t\tvar sum = arr.reduce((prev,curr)=> curr += prev);\r\n\t\treturn sum;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic reduceArrByFactor(arr,factor=2) { //faster than interpolating\r\n        let x = arr.filter((element, index) => {\r\n            return index % factor === 0;\r\n        });\r\n        return x;\r\n    }\r\n\r\n\t//Make an array of size n from a to b \r\n    static makeArr(startValue, stopValue, nSteps) {\r\n        var arr = [];\r\n        var step = (stopValue - startValue) / (nSteps - 1);\r\n        for (var i = 0; i < nSteps; i++) {\r\n          arr.push(startValue + (step * i));\r\n        }\r\n        return arr;\r\n    }\r\n\r\n\t//Linear interpolation from https://stackoverflow.com/questions/26941168/javascript-interpolate-an-array-of-numbers. Input array and number of samples to fit the data to\r\n\tstatic interpolateArray(data, fitCount, scalar=1) {\r\n\r\n\t\tvar linearInterpolate = function (before, after, atPoint) {\r\n\t\t\treturn (before + (after - before) * atPoint)*scalar;\r\n\t\t};\r\n\r\n\t\tvar newData = new Array();\r\n\t\tvar springFactor = new Number((data.length - 1) / (fitCount - 1));\r\n\t\tnewData[0] = data[0]; // for new allocation\r\n\t\tfor ( var i = 1; i < fitCount - 1; i++) {\r\n\t\t\tvar tmp = i * springFactor;\r\n\t\t\tvar before = new Number(Math.floor(tmp)).toFixed();\r\n\t\t\tvar after = new Number(Math.ceil(tmp)).toFixed();\r\n\t\t\tvar atPoint = tmp - before;\r\n\t\t\tnewData[i] = linearInterpolate(data[before], data[after], atPoint);\r\n\t\t}\r\n\t\tnewData[fitCount - 1] = data[data.length - 1]; // for new allocation\r\n\t\treturn newData;\r\n\t};\r\n\r\n\tstatic isExtrema(arr,critical='peak') { //Checks if the middle point of the (odd-numbered) array is a local extrema. options: 'peak','valley','tangent'. Even numbered arrays are popped\r\n        let ref = [...arr];\r\n\t\tif(ref.length%2 === 0) ref.pop();\r\n        if(arr.length > 1) { \r\n            let pass = true;\r\n            for(let i = 0; i < ref.length; i++) {\r\n                let val = ref[i];\r\n                if(critical === 'peak') { //search first derivative\r\n                    if(i < Math.floor(ref.length*.5) && val >= ref[Math.floor(ref.length*.5)] ) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if (i > Math.floor(ref.length*.5) && val >= ref[Math.floor(ref.length*.5)]) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                } else if (critical === 'valley') { //search first derivative\r\n                    if(i < Math.floor(ref.length*.5) && val <= ref[Math.floor(ref.length*.5)] ) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if (i > Math.floor(ref.length*.5) && val <= ref[Math.floor(ref.length*.5)]) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                } else { //look for tangents (best with 2nd derivative usually)\r\n                    if((i < Math.floor(ref.length*.5) && val <= ref[Math.floor(ref.length*.5)] )) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if ((i > Math.floor(ref.length*.5) && val <= ref[Math.floor(ref.length*.5)])) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                } //|| (i < ref.length*.5 && val <= 0 ) || (i > ref.length*.5 && val > 0)\r\n            }\r\n            if(critical !== 'peak' && critical !== 'valley' && pass === false) {\r\n                pass = true;\r\n                for(let i = 0; i < ref.length; i++) {\r\n                    let val = ref[i];\r\n                    if((i <  Math.floor(ref.length*.5) && val >= ref[Math.floor(ref.length*.5)] )) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if ((i >  Math.floor(ref.length*.5) && val >= ref[Math.floor(ref.length*.5)])) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return pass;\r\n        } else return undefined;\r\n    }\r\n\r\n    static isCriticalPoint(arr,critical='peak') { //Checks if the middle point of the (odd-numbered) array is a critical point. options: 'peak','valley','tangent'. Even numbered arrays are popped\r\n        let ref = [...arr];\r\n\t\tif(ref.length%2 === 0) ref.pop();\r\n        if(arr.length > 1) { \r\n            let pass = true;\r\n            for(let i = 0; i < ref.length; i++) {\r\n                let val = ref[i];\r\n                if(critical === 'peak') { //search first derivative\r\n                    if(i < ref.length*.5 && val <= 0 ) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if (i > ref.length*.5 && val > 0) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                } else if (critical === 'valley') { //search first derivative\r\n                    if(i < ref.length*.5 && val >= 0 ) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if (i > ref.length*.5 && val < 0) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                } else { //look for tangents (best with 2nd derivative usually)\r\n                    if((i < ref.length*.5 && val >= 0 )) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if ((i > ref.length*.5 && val < 0)) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if(critical !== 'peak' && critical !== 'valley' && pass === false) {\r\n                pass = true;\r\n                for(let i = 0; i < ref.length; i++) {\r\n                    let val = ref[i];\r\n                    if((i < ref.length*.5 && val <= 0 )) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if ((i > ref.length*.5 && val > 0)) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return pass;\r\n        } else return undefined;\r\n    }\r\n\r\n\t//returns array of indices of detected peaks/valleys\r\n    static peakDetect = (smoothedArray,type='peak',window=49) => {\r\n        let mid = Math.floor(window*.5);\r\n        let peaks = [];\r\n        //console.log(smoothedArray.length-window)\r\n        for(let i = 0; i<smoothedArray.length-window; i++) {\r\n            let isPeak = this.isExtrema(smoothedArray.slice(i,i+window),type);\r\n            if(isPeak) {\r\n                peaks.push(i+mid-1);\r\n            }\r\n        }\r\n        return peaks;\r\n    }\r\n\r\n\t//gets a mean threshold based on peaks in an array\r\n    static getPeakThreshold(arr,peakIndices, thresholdVar) {\r\n        let threshold;\r\n        let filtered = arr.filter((o,i)=>{if(peakIndices.indexOf(i)>-1) return true;});\r\n        if(thresholdVar === 0) {\r\n            threshold = this.mean(filtered); \r\n        } else threshold = (thresholdVar+this.mean(filtered))*0.5;  \r\n        \r\n        return threshold;\r\n    }\r\n\r\n\t//-------------------------------------------------------------\r\n\r\n\r\n\r\n\t//The following n-dimensional Eigenvalue/PCA Math was adapted from: https://github.com/johnmihalik/eigenvector/blob/master/pca.js\r\n\tstatic column(mat, x) {\r\n\t\tlet col = new Array(mat.length).fill(0).map(() => new Array(1).fill(0));\r\n\t\tfor (let i = 0; i < mat.length; i ++) {\r\n\t\t\tcol[i][0] = mat[i][x];\r\n\t\t}\r\n\t\treturn col;\r\n\t}\r\n\r\n\t//flatten a vector of 1-value vectors\r\n\tstatic flatten_vector(v) {\r\n\t\tlet v_new = [];\r\n\t\tfor (let i = 0; i < v.length; i++) {\r\n\t\t\tv_new[i] = v[i][0];\r\n\t\t}\r\n\t\treturn v_new;\r\n\t}\r\n\r\n\tstatic squared_difference(v1, v2) {\r\n\t\tlet sum = 0.0;\r\n\t\tfor (let i = 0; i < v1.length; i ++) {\r\n\t\t\tsum = sum + Math.pow( v1[i] - v2[i], 2 );\r\n\t\t}\r\n\t\treturn sum;\r\n\t}\r\n\r\n\t// See: https://math.stackexchange.com/questions/768882/power-method-for-finding-all-eigenvectors\r\n\tstatic shift_deflate(mat, eigenvalue, eigenvector)  {\r\n\t\tlet len = Math.sqrt( this.matmul(this.transpose(eigenvector), eigenvector)  );\r\n\t\tlet U = this.matscale(eigenvector, 1.0/len);\r\n\t\tlet delta = this.matscale( this.matmul(U, this.transpose(U)) , eigenvalue);\r\n\t\tlet M_new = this.matsub(mat, delta);\r\n\t\treturn M_new;\r\n\t}\r\n\r\n\tstatic eigenvalue_of_vector(mat, eigenvector) {\r\n\t\t// Xt * M * x\r\n\t\tev = this.matmul( this.matmul(this.transpose(eigenvector), mat ), eigenvector);\r\n\t\treturn ev;\r\n\t}\r\n\r\n\t//Input square 2D matrix\r\n\tstatic power_iteration(mat, tolerance=0.00001, max_iterations=1000) {\r\n\r\n\t\tlet rank = mat.length;\r\n\t\r\n\t\t// Initialize the first guess pf the eigenvector to a row vector of the sqrt of the rank\r\n\t\tlet eigenvector = new Array(rank).fill(0).map(() => new Array(1).fill(Math.sqrt(rank)));\r\n\t\r\n\t\t// Compute the corresponding eigenvalue\r\n\t\tlet eigenvalue = this.eigenvalue_of_vector(mat, eigenvector);\r\n\t\r\n\t\tlet epsilon = 1.0;\r\n\t\tlet iter = 0;\r\n\t\twhile (epsilon > tolerance && iter < max_iterations) {\r\n\t\r\n\t\t\tlet old_eigenvalue = JSON.parse(JSON.stringify(eigenvalue));\r\n\t\r\n\t\t\t// Multiply the Matrix M by the guessed eigenveector\r\n\t\t\tlet Mv = this.matmul(mat,eigenvector);\r\n\t\r\n\t\t\t// Normalize the eigenvector to unit length\r\n\t\t\teigenvector = this.normalize(Mv);\r\n\t\r\n\t\t\t// Calculate the associated eigenvalue with the eigenvector (transpose(v) * M * v)\r\n\t\t\teigenvalue = this.eigenvalue_of_vector(mat, eigenvector);\r\n\t\r\n\t\t\t// Calculate the epsilon of the differences\r\n\t\t\tepsilon = Math.abs( eigenvalue - old_eigenvalue);\r\n\t\t\titer++;\r\n\t\r\n\t\t};\r\n\t\r\n\t\treturn [eigenvalue, eigenvector];\r\n\t}\r\n\t\r\n\t//Input square 2D matrix\r\n\tstatic eigens(mat, tolerance=0.0001, max_iterations=1000) {\r\n\r\n\t\tlet eigenvalues = [];\r\n\t\tlet eigenvectors = [];\r\n\t\r\n\t\tfor (let i = 0; i < mat.length; i++ ) {\r\n\t\r\n\t\t\t// Compute the remaining most prominent eigenvector of the matrix M\r\n\t\t\tlet result = this.power_iteration(mat, tolerance, max_iterations);\r\n\t\r\n\t\t\t// Separate the eigenvalue and vector from the return array\r\n\t\t\tlet eigenvalue = result[0];\r\n\t\t\tlet eigenvector = result[1];\r\n\t\r\n\t\t\teigenvalues[i] = eigenvalue;\r\n\t\t\teigenvectors[i] = this.flatten_vector(eigenvector);\r\n\t\r\n\t\t\t// Now remove or peel off the last eigenvector\r\n\t\t\tmat = this.shift_deflate(mat, eigenvalue, eigenvector);\r\n\t\t}\r\n\t\r\n\t\treturn [eigenvalues, eigenvectors];\r\n\t}\r\n\r\n\t//Input square 2D matrix. For eeg data you input a square covariance matrix of the signal data (or the z-scores of the signal data)\r\n\tstatic pca(mat,tolerance = 0.00001) {\r\n\t\tlet dims = mat.length;\r\n\t\t\r\n\t\tlet t = new Array(dims);\r\n\t\tlet p = new Array(dims);\r\n\r\n\t\tlet mat_t = this.transpose(mat);\r\n\t\tt[0] = this.column(mat,0);\r\n\t\tlet epsilon = 1.0;\r\n\t\tlet iter = 0;\r\n\r\n\t\twhile(espilon > tolerance) {\r\n\t\t\titer++;\r\n\t\t\tp[0] = this.matmul(mat_t,t[0]);\r\n\t\t\tlet tp = this.matmul(this.transpose(t[0]),t[0]);\r\n\t\t\tp[0] = this.matscale(p[0], 1.0 / tp);\r\n\r\n\t\t\t// Normalize p\r\n\t\t\tlet p_length = Math.sqrt(this.matmul(this.transpose(p[0]), p[0]));\r\n\t\t\tp[0] = this.matscale(p[0], 1.0 / p_length);\r\n\t\r\n\t\t\tlet t_new = this.matmul(mat, p[0]);\r\n\t\t\tlet pp = this.matmul(this.transpose(p[0]), p[0]);\r\n\t\t\tt_new = this.matscale(t_new, 1.0 / pp);\r\n\t\r\n\t\t\tepsilon = this.squared_difference(t[0], t_new);\r\n\t\r\n\t\t\tt[0] = JSON.parse(JSON.stringify(t_new));\r\n\t\t}\r\n\r\n\t\tlet components = this.matmul(this.transpose(t[0]),t[0]);\r\n\r\n\t\treturn components;\r\n\t}\t\r\n\r\n\t//-------------------------------------------------------------\r\n\r\n\t//pass in 1 second of raw data ish recommended, desired event timestamps and signals are ordered from least current to most current \r\n\tstatic p300(event_timestamps=[],raw_signal=[],signal_timestamps=[], sps=256) {\r\n\t\tlet smoothingstep = Math.floor(sps/10); //300ms width peak, 1/10th sec smoothing for filtering\r\n\t\tlet smoothed = this.sma(raw_signal,smoothingstep);\r\n\t\tlet peaks = this.peakDetect(smoothed,'peak',smoothingstep); //returns indices of peaks\r\n\t\tlet mean = this.mean(smoothed);\r\n\t\tlet std = this.std(smoothed,mean);\r\n\r\n\t\tlet p_idx = 0;\r\n\t\tlet candidates = [];\r\n\t\tif(peaks.length > 0) {\r\n\t\t\tevent_timestamps.forEach((t,j) => {\r\n\t\t\t\twhile(signal_timestamps[peaks[p_idx]] < t + 200) { //roll over peaks that are behind of the latest event + 200ms\r\n\t\t\t\t\tp_idx++;\r\n\t\t\t\t\tif(!peaks[p_idx]) break;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tlet tempi = 0;\r\n\t\t\t\tlet tempcandidates = [];\r\n\t\t\t\twhile(signal_timestamps[peaks[p_idx+tempi]] < t + 600 ) { //get peaks that are behind the latest event + (200ms-600ms)\r\n\t\t\t\t\ttempcandidates.push(p_idx+tempi);\r\n\t\t\t\t\ttempi++;\r\n\t\t\t\t\tif(!peaks[p_idx+tempi]) break;\r\n\t\t\t\t}\r\n\t\t\t\tif(tempcandidates.length > 1) { //if multiple peaks found choose the biggest one for the main p300 peak (not worrying about p1,p2,n1,n2 yet)\r\n\t\t\t\t\tlet peakvals = [];\r\n\t\t\t\t\ttempcandidates.forEach((tc) => {\r\n\t\t\t\t\t\tpeakvals.push(smoothed[peaks[tc]]);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tlet max = Math.max(...peakvals);\r\n\t\t\t\t\tlet maxi = tempcandidates[peakvals.indexOf(max)];\r\n\r\n\t\t\t\t\tcandidates.push({\r\n\t\t\t\t\t\tevent_timestamp:t, \r\n\t\t\t\t\t\tevent_index:j, \r\n\t\t\t\t\t\tpeak_timestamp:signal_timestamps[[peaks[maxi]]],\r\n\t\t\t\t\t\tsignal_index:[peaks[maxi]], \r\n\t\t\t\t\t\tsignal_amplitude:raw_signal[[peaks[maxi]]], \r\n\t\t\t\t\t\tzscore:(smoothed[peaks[maxi]]-mean)/std //significance measure\r\n\t\t\t\t\t});\r\n\t\t\t\t} else if (tempcandidates.length === 1) candidates.push({\r\n\t\t\t\t\tevent_timestamp:t, \r\n\t\t\t\t\tevent_index:j, \r\n\t\t\t\t\tpeak_timestamp:signal_timestamps[peaks[tempcandidates[0]]],\r\n\t\t\t\t\tsignal_index:peaks[tempcandidates[0]],\r\n\t\t\t\t\tsignal_amplitude:raw_signal[[peaks[tempcandidates[0]]]],\r\n\t\t\t\t\tzscore:(smoothed[peaks[tempcandidates[0]]]-mean)/std //significance measure\r\n\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t} return candidates;\r\n\t}\r\n\r\n}\r\n","export * from './Math2'","/**\r\n * gpu.js\r\n * http://gpu.rocks/\r\n *\r\n * GPU Accelerated JavaScript\r\n *\r\n * @version 2.11.0\r\n * @date Tue Jan 05 2021 15:55:59 GMT-0500 (Eastern Standard Time)\r\n *\r\n * @license MIT\r\n * The MIT License\r\n *\r\n * Copyright (c) 2021 gpu.js Team\r\n */(function(f){\r\n     if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}\r\n     else if(typeof define===\"function\"&&define.amd){define([],f)}\r\n     else{var g;if(typeof window!==\"undefined\"){g=window}\r\n     else if(typeof global!==\"undefined\"){g=global}\r\n     else if(typeof self!==\"undefined\"){g=self}\r\n     else{g=this}\r\n         f()\r\n    }})\r\n     (function(){\r\n         var define,module,exports;\r\n         return (function(){\r\n             function r(e,n,t){\r\n                 function o(i,f){if(!n[i]){if(!e[i]){\r\n                     var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\r\n    (function (global, factory) {\r\n        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\r\n        typeof define === 'function' && define.amd ? define(['exports'], factory) :\r\n        (global = global || self, factory(global.acorn = {}));\r\n      }(this, function (exports) { 'use strict';\r\n      \r\n      \r\n        var reservedWords = {\r\n          3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\r\n          5: \"class enum extends super const export import\",\r\n          6: \"enum\",\r\n          strict: \"implements interface let package private protected public static yield\",\r\n          strictBind: \"eval arguments\"\r\n        };\r\n      \r\n      \r\n        var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\r\n      \r\n        var keywords = {\r\n          5: ecma5AndLessKeywords,\r\n          \"5module\": ecma5AndLessKeywords + \" export import\",\r\n          6: ecma5AndLessKeywords + \" const class extends export import super\"\r\n        };\r\n      \r\n        var keywordRelationalOperator = /^in(stanceof)?$/;\r\n      \r\n      \r\n        var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\r\n        var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\r\n      \r\n        var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\r\n        var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\r\n      \r\n        nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\r\n      \r\n      \r\n        var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\r\n      \r\n        var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];\r\n      \r\n        function isInAstralSet(code, set) {\r\n          var pos = 0x10000;\r\n          for (var i = 0; i < set.length; i += 2) {\r\n            pos += set[i];\r\n            if (pos > code) { return false }\r\n            pos += set[i + 1];\r\n            if (pos >= code) { return true }\r\n          }\r\n        }\r\n      \r\n      \r\n        function isIdentifierStart(code, astral) {\r\n          if (code < 65) { return code === 36 }\r\n          if (code < 91) { return true }\r\n          if (code < 97) { return code === 95 }\r\n          if (code < 123) { return true }\r\n          if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\r\n          if (astral === false) { return false }\r\n          return isInAstralSet(code, astralIdentifierStartCodes)\r\n        }\r\n      \r\n      \r\n        function isIdentifierChar(code, astral) {\r\n          if (code < 48) { return code === 36 }\r\n          if (code < 58) { return true }\r\n          if (code < 65) { return false }\r\n          if (code < 91) { return true }\r\n          if (code < 97) { return code === 95 }\r\n          if (code < 123) { return true }\r\n          if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\r\n          if (astral === false) { return false }\r\n          return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\r\n        }\r\n      \r\n      \r\n      \r\n      \r\n      \r\n        var TokenType = function TokenType(label, conf) {\r\n          if ( conf === void 0 ) conf = {};\r\n      \r\n          this.label = label;\r\n          this.keyword = conf.keyword;\r\n          this.beforeExpr = !!conf.beforeExpr;\r\n          this.startsExpr = !!conf.startsExpr;\r\n          this.isLoop = !!conf.isLoop;\r\n          this.isAssign = !!conf.isAssign;\r\n          this.prefix = !!conf.prefix;\r\n          this.postfix = !!conf.postfix;\r\n          this.binop = conf.binop || null;\r\n          this.updateContext = null;\r\n        };\r\n      \r\n        function binop(name, prec) {\r\n          return new TokenType(name, {beforeExpr: true, binop: prec})\r\n        }\r\n        var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\r\n      \r\n      \r\n        var keywords$1 = {};\r\n      \r\n        function kw(name, options) {\r\n          if ( options === void 0 ) options = {};\r\n      \r\n          options.keyword = name;\r\n          return keywords$1[name] = new TokenType(name, options)\r\n        }\r\n      \r\n        var types = {\r\n          num: new TokenType(\"num\", startsExpr),\r\n          regexp: new TokenType(\"regexp\", startsExpr),\r\n          string: new TokenType(\"string\", startsExpr),\r\n          name: new TokenType(\"name\", startsExpr),\r\n          eof: new TokenType(\"eof\"),\r\n      \r\n          bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\r\n          bracketR: new TokenType(\"]\"),\r\n          braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\r\n          braceR: new TokenType(\"}\"),\r\n          parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\r\n          parenR: new TokenType(\")\"),\r\n          comma: new TokenType(\",\", beforeExpr),\r\n          semi: new TokenType(\";\", beforeExpr),\r\n          colon: new TokenType(\":\", beforeExpr),\r\n          dot: new TokenType(\".\"),\r\n          question: new TokenType(\"?\", beforeExpr),\r\n          arrow: new TokenType(\"=>\", beforeExpr),\r\n          template: new TokenType(\"template\"),\r\n          invalidTemplate: new TokenType(\"invalidTemplate\"),\r\n          ellipsis: new TokenType(\"...\", beforeExpr),\r\n          backQuote: new TokenType(\"`\", startsExpr),\r\n          dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\r\n      \r\n      \r\n          eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\r\n          assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\r\n          incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\r\n          prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n          logicalOR: binop(\"||\", 1),\r\n          logicalAND: binop(\"&&\", 2),\r\n          bitwiseOR: binop(\"|\", 3),\r\n          bitwiseXOR: binop(\"^\", 4),\r\n          bitwiseAND: binop(\"&\", 5),\r\n          equality: binop(\"==/!=/===/!==\", 6),\r\n          relational: binop(\"</>/<=/>=\", 7),\r\n          bitShift: binop(\"<</>>/>>>\", 8),\r\n          plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\r\n          modulo: binop(\"%\", 10),\r\n          star: binop(\"*\", 10),\r\n          slash: binop(\"/\", 10),\r\n          starstar: new TokenType(\"**\", {beforeExpr: true}),\r\n      \r\n          _break: kw(\"break\"),\r\n          _case: kw(\"case\", beforeExpr),\r\n          _catch: kw(\"catch\"),\r\n          _continue: kw(\"continue\"),\r\n          _debugger: kw(\"debugger\"),\r\n          _default: kw(\"default\", beforeExpr),\r\n          _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\r\n          _else: kw(\"else\", beforeExpr),\r\n          _finally: kw(\"finally\"),\r\n          _for: kw(\"for\", {isLoop: true}),\r\n          _function: kw(\"function\", startsExpr),\r\n          _if: kw(\"if\"),\r\n          _return: kw(\"return\", beforeExpr),\r\n          _switch: kw(\"switch\"),\r\n          _throw: kw(\"throw\", beforeExpr),\r\n          _try: kw(\"try\"),\r\n          _var: kw(\"var\"),\r\n          _const: kw(\"const\"),\r\n          _while: kw(\"while\", {isLoop: true}),\r\n          _with: kw(\"with\"),\r\n          _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\r\n          _this: kw(\"this\", startsExpr),\r\n          _super: kw(\"super\", startsExpr),\r\n          _class: kw(\"class\", startsExpr),\r\n          _extends: kw(\"extends\", beforeExpr),\r\n          _export: kw(\"export\"),\r\n          _import: kw(\"import\", startsExpr),\r\n          _null: kw(\"null\", startsExpr),\r\n          _true: kw(\"true\", startsExpr),\r\n          _false: kw(\"false\", startsExpr),\r\n          _in: kw(\"in\", {beforeExpr: true, binop: 7}),\r\n          _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\r\n          _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n          _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n          _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\r\n        };\r\n      \r\n      \r\n        var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\r\n        var lineBreakG = new RegExp(lineBreak.source, \"g\");\r\n      \r\n        function isNewLine(code, ecma2019String) {\r\n          return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\r\n        }\r\n      \r\n        var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\r\n      \r\n        var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\r\n      \r\n        var ref = Object.prototype;\r\n        var hasOwnProperty = ref.hasOwnProperty;\r\n        var toString = ref.toString;\r\n      \r\n      \r\n        function has(obj, propName) {\r\n          return hasOwnProperty.call(obj, propName)\r\n        }\r\n      \r\n        var isArray = Array.isArray || (function (obj) { return (\r\n          toString.call(obj) === \"[object Array]\"\r\n        ); });\r\n      \r\n        function wordsRegexp(words) {\r\n          return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\r\n        }\r\n      \r\n      \r\n        var Position = function Position(line, col) {\r\n          this.line = line;\r\n          this.column = col;\r\n        };\r\n      \r\n        Position.prototype.offset = function offset (n) {\r\n          return new Position(this.line, this.column + n)\r\n        };\r\n      \r\n        var SourceLocation = function SourceLocation(p, start, end) {\r\n          this.start = start;\r\n          this.end = end;\r\n          if (p.sourceFile !== null) { this.source = p.sourceFile; }\r\n        };\r\n      \r\n      \r\n        function getLineInfo(input, offset) {\r\n          for (var line = 1, cur = 0;;) {\r\n            lineBreakG.lastIndex = cur;\r\n            var match = lineBreakG.exec(input);\r\n            if (match && match.index < offset) {\r\n              ++line;\r\n              cur = match.index + match[0].length;\r\n            } else {\r\n              return new Position(line, offset - cur)\r\n            }\r\n          }\r\n        }\r\n      \r\n      \r\n        var defaultOptions = {\r\n          ecmaVersion: 10,\r\n          sourceType: \"script\",\r\n          onInsertedSemicolon: null,\r\n          onTrailingComma: null,\r\n          allowReserved: null,\r\n          allowReturnOutsideFunction: false,\r\n          allowImportExportEverywhere: false,\r\n          allowAwaitOutsideFunction: false,\r\n          allowHashBang: false,\r\n          locations: false,\r\n          onToken: null,\r\n          onComment: null,\r\n          ranges: false,\r\n          program: null,\r\n          sourceFile: null,\r\n          directSourceFile: null,\r\n          preserveParens: false\r\n        };\r\n      \r\n      \r\n        function getOptions(opts) {\r\n          var options = {};\r\n      \r\n          for (var opt in defaultOptions)\r\n            { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\r\n      \r\n          if (options.ecmaVersion >= 2015)\r\n            { options.ecmaVersion -= 2009; }\r\n      \r\n          if (options.allowReserved == null)\r\n            { options.allowReserved = options.ecmaVersion < 5; }\r\n      \r\n          if (isArray(options.onToken)) {\r\n            var tokens = options.onToken;\r\n            options.onToken = function (token) { return tokens.push(token); };\r\n          }\r\n          if (isArray(options.onComment))\r\n            { options.onComment = pushComment(options, options.onComment); }\r\n      \r\n          return options\r\n        }\r\n      \r\n        function pushComment(options, array) {\r\n          return function(block, text, start, end, startLoc, endLoc) {\r\n            var comment = {\r\n              type: block ? \"Block\" : \"Line\",\r\n              value: text,\r\n              start: start,\r\n              end: end\r\n            };\r\n            if (options.locations)\r\n              { comment.loc = new SourceLocation(this, startLoc, endLoc); }\r\n            if (options.ranges)\r\n              { comment.range = [start, end]; }\r\n            array.push(comment);\r\n          }\r\n        }\r\n      \r\n        var\r\n            SCOPE_TOP = 1,\r\n            SCOPE_FUNCTION = 2,\r\n            SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\r\n            SCOPE_ASYNC = 4,\r\n            SCOPE_GENERATOR = 8,\r\n            SCOPE_ARROW = 16,\r\n            SCOPE_SIMPLE_CATCH = 32,\r\n            SCOPE_SUPER = 64,\r\n            SCOPE_DIRECT_SUPER = 128;\r\n      \r\n        function functionFlags(async, generator) {\r\n          return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\r\n        }\r\n      \r\n        var\r\n            BIND_NONE = 0, \r\n            BIND_VAR = 1, \r\n            BIND_LEXICAL = 2, \r\n            BIND_FUNCTION = 3, \r\n            BIND_SIMPLE_CATCH = 4, \r\n            BIND_OUTSIDE = 5; \r\n      \r\n        var Parser = function Parser(options, input, startPos) {\r\n          this.options = options = getOptions(options);\r\n          this.sourceFile = options.sourceFile;\r\n          this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\r\n          var reserved = \"\";\r\n          if (options.allowReserved !== true) {\r\n            for (var v = options.ecmaVersion;; v--)\r\n              { if (reserved = reservedWords[v]) { break } }\r\n            if (options.sourceType === \"module\") { reserved += \" await\"; }\r\n          }\r\n          this.reservedWords = wordsRegexp(reserved);\r\n          var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\r\n          this.reservedWordsStrict = wordsRegexp(reservedStrict);\r\n          this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\r\n          this.input = String(input);\r\n      \r\n          this.containsEsc = false;\r\n      \r\n      \r\n          if (startPos) {\r\n            this.pos = startPos;\r\n            this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\r\n            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\r\n          } else {\r\n            this.pos = this.lineStart = 0;\r\n            this.curLine = 1;\r\n          }\r\n      \r\n          this.type = types.eof;\r\n          this.value = null;\r\n          this.start = this.end = this.pos;\r\n          this.startLoc = this.endLoc = this.curPosition();\r\n      \r\n          this.lastTokEndLoc = this.lastTokStartLoc = null;\r\n          this.lastTokStart = this.lastTokEnd = this.pos;\r\n      \r\n          this.context = this.initialContext();\r\n          this.exprAllowed = true;\r\n      \r\n          this.inModule = options.sourceType === \"module\";\r\n          this.strict = this.inModule || this.strictDirective(this.pos);\r\n      \r\n          this.potentialArrowAt = -1;\r\n      \r\n          this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\r\n          this.labels = [];\r\n          this.undefinedExports = {};\r\n      \r\n          if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\r\n            { this.skipLineComment(2); }\r\n      \r\n          this.scopeStack = [];\r\n          this.enterScope(SCOPE_TOP);\r\n      \r\n          this.regexpState = null;\r\n        };\r\n      \r\n        var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\r\n      \r\n        Parser.prototype.parse = function parse () {\r\n          var node = this.options.program || this.startNode();\r\n          this.nextToken();\r\n          return this.parseTopLevel(node)\r\n        };\r\n      \r\n        prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\r\n        prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\r\n        prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\r\n        prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\r\n        prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\r\n        prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\r\n      \r\n        Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\r\n      \r\n        Parser.extend = function extend () {\r\n            var plugins = [], len = arguments.length;\r\n            while ( len-- ) plugins[ len ] = arguments[ len ];\r\n      \r\n          var cls = this;\r\n          for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\r\n          return cls\r\n        };\r\n      \r\n        Parser.parse = function parse (input, options) {\r\n          return new this(options, input).parse()\r\n        };\r\n      \r\n        Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\r\n          var parser = new this(options, input, pos);\r\n          parser.nextToken();\r\n          return parser.parseExpression()\r\n        };\r\n      \r\n        Parser.tokenizer = function tokenizer (input, options) {\r\n          return new this(options, input)\r\n        };\r\n      \r\n        Object.defineProperties( Parser.prototype, prototypeAccessors );\r\n      \r\n        var pp = Parser.prototype;\r\n      \r\n      \r\n        var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\r\n        pp.strictDirective = function(start) {\r\n          for (;;) {\r\n            skipWhiteSpace.lastIndex = start;\r\n            start += skipWhiteSpace.exec(this.input)[0].length;\r\n            var match = literal.exec(this.input.slice(start));\r\n            if (!match) { return false }\r\n            if ((match[1] || match[2]) === \"use strict\") { return true }\r\n            start += match[0].length;\r\n      \r\n            skipWhiteSpace.lastIndex = start;\r\n            start += skipWhiteSpace.exec(this.input)[0].length;\r\n            if (this.input[start] === \";\")\r\n              { start++; }\r\n          }\r\n        };\r\n      \r\n      \r\n        pp.eat = function(type) {\r\n          if (this.type === type) {\r\n            this.next();\r\n            return true\r\n          } else {\r\n            return false\r\n          }\r\n        };\r\n      \r\n      \r\n        pp.isContextual = function(name) {\r\n          return this.type === types.name && this.value === name && !this.containsEsc\r\n        };\r\n      \r\n      \r\n        pp.eatContextual = function(name) {\r\n          if (!this.isContextual(name)) { return false }\r\n          this.next();\r\n          return true\r\n        };\r\n      \r\n      \r\n        pp.expectContextual = function(name) {\r\n          if (!this.eatContextual(name)) { this.unexpected(); }\r\n        };\r\n      \r\n      \r\n        pp.canInsertSemicolon = function() {\r\n          return this.type === types.eof ||\r\n            this.type === types.braceR ||\r\n            lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\r\n        };\r\n      \r\n        pp.insertSemicolon = function() {\r\n          if (this.canInsertSemicolon()) {\r\n            if (this.options.onInsertedSemicolon)\r\n              { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\r\n            return true\r\n          }\r\n        };\r\n      \r\n      \r\n        pp.semicolon = function() {\r\n          if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\r\n        };\r\n      \r\n        pp.afterTrailingComma = function(tokType, notNext) {\r\n          if (this.type === tokType) {\r\n            if (this.options.onTrailingComma)\r\n              { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\r\n            if (!notNext)\r\n              { this.next(); }\r\n            return true\r\n          }\r\n        };\r\n      \r\n      \r\n        pp.expect = function(type) {\r\n          this.eat(type) || this.unexpected();\r\n        };\r\n      \r\n      \r\n        pp.unexpected = function(pos) {\r\n          this.raise(pos != null ? pos : this.start, \"Unexpected token\");\r\n        };\r\n      \r\n        function DestructuringErrors() {\r\n          this.shorthandAssign =\r\n          this.trailingComma =\r\n          this.parenthesizedAssign =\r\n          this.parenthesizedBind =\r\n          this.doubleProto =\r\n            -1;\r\n        }\r\n      \r\n        pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\r\n          if (!refDestructuringErrors) { return }\r\n          if (refDestructuringErrors.trailingComma > -1)\r\n            { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\r\n          var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\r\n          if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\r\n        };\r\n      \r\n        pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\r\n          if (!refDestructuringErrors) { return false }\r\n          var shorthandAssign = refDestructuringErrors.shorthandAssign;\r\n          var doubleProto = refDestructuringErrors.doubleProto;\r\n          if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\r\n          if (shorthandAssign >= 0)\r\n            { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\r\n          if (doubleProto >= 0)\r\n            { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\r\n        };\r\n      \r\n        pp.checkYieldAwaitInDefaultParams = function() {\r\n          if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\r\n            { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\r\n          if (this.awaitPos)\r\n            { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\r\n        };\r\n      \r\n        pp.isSimpleAssignTarget = function(expr) {\r\n          if (expr.type === \"ParenthesizedExpression\")\r\n            { return this.isSimpleAssignTarget(expr.expression) }\r\n          return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\r\n        };\r\n      \r\n        var pp$1 = Parser.prototype;\r\n      \r\n      \r\n      \r\n        pp$1.parseTopLevel = function(node) {\r\n          var exports = {};\r\n          if (!node.body) { node.body = []; }\r\n          while (this.type !== types.eof) {\r\n            var stmt = this.parseStatement(null, true, exports);\r\n            node.body.push(stmt);\r\n          }\r\n          if (this.inModule)\r\n            { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\r\n              {\r\n                var name = list[i];\r\n      \r\n                this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\r\n              } }\r\n          this.adaptDirectivePrologue(node.body);\r\n          this.next();\r\n          node.sourceType = this.options.sourceType;\r\n          return this.finishNode(node, \"Program\")\r\n        };\r\n      \r\n        var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\r\n      \r\n        pp$1.isLet = function(context) {\r\n          if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\r\n          skipWhiteSpace.lastIndex = this.pos;\r\n          var skip = skipWhiteSpace.exec(this.input);\r\n          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\r\n          if (nextCh === 91) { return true } \r\n          if (context) { return false }\r\n      \r\n          if (nextCh === 123) { return true } \r\n          if (isIdentifierStart(nextCh, true)) {\r\n            var pos = next + 1;\r\n            while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\r\n            var ident = this.input.slice(next, pos);\r\n            if (!keywordRelationalOperator.test(ident)) { return true }\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$1.isAsyncFunction = function() {\r\n          if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\r\n            { return false }\r\n      \r\n          skipWhiteSpace.lastIndex = this.pos;\r\n          var skip = skipWhiteSpace.exec(this.input);\r\n          var next = this.pos + skip[0].length;\r\n          return !lineBreak.test(this.input.slice(this.pos, next)) &&\r\n            this.input.slice(next, next + 8) === \"function\" &&\r\n            (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\r\n        };\r\n      \r\n      \r\n        pp$1.parseStatement = function(context, topLevel, exports) {\r\n          var starttype = this.type, node = this.startNode(), kind;\r\n      \r\n          if (this.isLet(context)) {\r\n            starttype = types._var;\r\n            kind = \"let\";\r\n          }\r\n      \r\n      \r\n          switch (starttype) {\r\n          case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\r\n          case types._debugger: return this.parseDebuggerStatement(node)\r\n          case types._do: return this.parseDoStatement(node)\r\n          case types._for: return this.parseForStatement(node)\r\n          case types._function:\r\n            if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\r\n            return this.parseFunctionStatement(node, false, !context)\r\n          case types._class:\r\n            if (context) { this.unexpected(); }\r\n            return this.parseClass(node, true)\r\n          case types._if: return this.parseIfStatement(node)\r\n          case types._return: return this.parseReturnStatement(node)\r\n          case types._switch: return this.parseSwitchStatement(node)\r\n          case types._throw: return this.parseThrowStatement(node)\r\n          case types._try: return this.parseTryStatement(node)\r\n          case types._const: case types._var:\r\n            kind = kind || this.value;\r\n            if (context && kind !== \"var\") { this.unexpected(); }\r\n            return this.parseVarStatement(node, kind)\r\n          case types._while: return this.parseWhileStatement(node)\r\n          case types._with: return this.parseWithStatement(node)\r\n          case types.braceL: return this.parseBlock(true, node)\r\n          case types.semi: return this.parseEmptyStatement(node)\r\n          case types._export:\r\n          case types._import:\r\n            if (this.options.ecmaVersion > 10 && starttype === types._import) {\r\n              skipWhiteSpace.lastIndex = this.pos;\r\n              var skip = skipWhiteSpace.exec(this.input);\r\n              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\r\n              if (nextCh === 40) \r\n                { return this.parseExpressionStatement(node, this.parseExpression()) }\r\n            }\r\n      \r\n            if (!this.options.allowImportExportEverywhere) {\r\n              if (!topLevel)\r\n                { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\r\n              if (!this.inModule)\r\n                { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\r\n            }\r\n            return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\r\n      \r\n          default:\r\n            if (this.isAsyncFunction()) {\r\n              if (context) { this.unexpected(); }\r\n              this.next();\r\n              return this.parseFunctionStatement(node, true, !context)\r\n            }\r\n      \r\n            var maybeName = this.value, expr = this.parseExpression();\r\n            if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\r\n              { return this.parseLabeledStatement(node, maybeName, expr, context) }\r\n            else { return this.parseExpressionStatement(node, expr) }\r\n          }\r\n        };\r\n      \r\n        pp$1.parseBreakContinueStatement = function(node, keyword) {\r\n          var isBreak = keyword === \"break\";\r\n          this.next();\r\n          if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\r\n          else if (this.type !== types.name) { this.unexpected(); }\r\n          else {\r\n            node.label = this.parseIdent();\r\n            this.semicolon();\r\n          }\r\n      \r\n          var i = 0;\r\n          for (; i < this.labels.length; ++i) {\r\n            var lab = this.labels[i];\r\n            if (node.label == null || lab.name === node.label.name) {\r\n              if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\r\n              if (node.label && isBreak) { break }\r\n            }\r\n          }\r\n          if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\r\n          return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\r\n        };\r\n      \r\n        pp$1.parseDebuggerStatement = function(node) {\r\n          this.next();\r\n          this.semicolon();\r\n          return this.finishNode(node, \"DebuggerStatement\")\r\n        };\r\n      \r\n        pp$1.parseDoStatement = function(node) {\r\n          this.next();\r\n          this.labels.push(loopLabel);\r\n          node.body = this.parseStatement(\"do\");\r\n          this.labels.pop();\r\n          this.expect(types._while);\r\n          node.test = this.parseParenExpression();\r\n          if (this.options.ecmaVersion >= 6)\r\n            { this.eat(types.semi); }\r\n          else\r\n            { this.semicolon(); }\r\n          return this.finishNode(node, \"DoWhileStatement\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseForStatement = function(node) {\r\n          this.next();\r\n          var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\r\n          this.labels.push(loopLabel);\r\n          this.enterScope(0);\r\n          this.expect(types.parenL);\r\n          if (this.type === types.semi) {\r\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n            return this.parseFor(node, null)\r\n          }\r\n          var isLet = this.isLet();\r\n          if (this.type === types._var || this.type === types._const || isLet) {\r\n            var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\r\n            this.next();\r\n            this.parseVar(init$1, true, kind);\r\n            this.finishNode(init$1, \"VariableDeclaration\");\r\n            if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\r\n              if (this.options.ecmaVersion >= 9) {\r\n                if (this.type === types._in) {\r\n                  if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n                } else { node.await = awaitAt > -1; }\r\n              }\r\n              return this.parseForIn(node, init$1)\r\n            }\r\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n            return this.parseFor(node, init$1)\r\n          }\r\n          var refDestructuringErrors = new DestructuringErrors;\r\n          var init = this.parseExpression(true, refDestructuringErrors);\r\n          if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\r\n            if (this.options.ecmaVersion >= 9) {\r\n              if (this.type === types._in) {\r\n                if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n              } else { node.await = awaitAt > -1; }\r\n            }\r\n            this.toAssignable(init, false, refDestructuringErrors);\r\n            this.checkLVal(init);\r\n            return this.parseForIn(node, init)\r\n          } else {\r\n            this.checkExpressionErrors(refDestructuringErrors, true);\r\n          }\r\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n          return this.parseFor(node, init)\r\n        };\r\n      \r\n        pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\r\n          this.next();\r\n          return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\r\n        };\r\n      \r\n        pp$1.parseIfStatement = function(node) {\r\n          this.next();\r\n          node.test = this.parseParenExpression();\r\n          node.consequent = this.parseStatement(\"if\");\r\n          node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\r\n          return this.finishNode(node, \"IfStatement\")\r\n        };\r\n      \r\n        pp$1.parseReturnStatement = function(node) {\r\n          if (!this.inFunction && !this.options.allowReturnOutsideFunction)\r\n            { this.raise(this.start, \"'return' outside of function\"); }\r\n          this.next();\r\n      \r\n      \r\n          if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\r\n          else { node.argument = this.parseExpression(); this.semicolon(); }\r\n          return this.finishNode(node, \"ReturnStatement\")\r\n        };\r\n      \r\n        pp$1.parseSwitchStatement = function(node) {\r\n          this.next();\r\n          node.discriminant = this.parseParenExpression();\r\n          node.cases = [];\r\n          this.expect(types.braceL);\r\n          this.labels.push(switchLabel);\r\n          this.enterScope(0);\r\n      \r\n      \r\n          var cur;\r\n          for (var sawDefault = false; this.type !== types.braceR;) {\r\n            if (this.type === types._case || this.type === types._default) {\r\n              var isCase = this.type === types._case;\r\n              if (cur) { this.finishNode(cur, \"SwitchCase\"); }\r\n              node.cases.push(cur = this.startNode());\r\n              cur.consequent = [];\r\n              this.next();\r\n              if (isCase) {\r\n                cur.test = this.parseExpression();\r\n              } else {\r\n                if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\r\n                sawDefault = true;\r\n                cur.test = null;\r\n              }\r\n              this.expect(types.colon);\r\n            } else {\r\n              if (!cur) { this.unexpected(); }\r\n              cur.consequent.push(this.parseStatement(null));\r\n            }\r\n          }\r\n          this.exitScope();\r\n          if (cur) { this.finishNode(cur, \"SwitchCase\"); }\r\n          this.next(); \r\n          this.labels.pop();\r\n          return this.finishNode(node, \"SwitchStatement\")\r\n        };\r\n      \r\n        pp$1.parseThrowStatement = function(node) {\r\n          this.next();\r\n          if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\r\n            { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\r\n          node.argument = this.parseExpression();\r\n          this.semicolon();\r\n          return this.finishNode(node, \"ThrowStatement\")\r\n        };\r\n      \r\n      \r\n        var empty = [];\r\n      \r\n        pp$1.parseTryStatement = function(node) {\r\n          this.next();\r\n          node.block = this.parseBlock();\r\n          node.handler = null;\r\n          if (this.type === types._catch) {\r\n            var clause = this.startNode();\r\n            this.next();\r\n            if (this.eat(types.parenL)) {\r\n              clause.param = this.parseBindingAtom();\r\n              var simple = clause.param.type === \"Identifier\";\r\n              this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\r\n              this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\r\n              this.expect(types.parenR);\r\n            } else {\r\n              if (this.options.ecmaVersion < 10) { this.unexpected(); }\r\n              clause.param = null;\r\n              this.enterScope(0);\r\n            }\r\n            clause.body = this.parseBlock(false);\r\n            this.exitScope();\r\n            node.handler = this.finishNode(clause, \"CatchClause\");\r\n          }\r\n          node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\r\n          if (!node.handler && !node.finalizer)\r\n            { this.raise(node.start, \"Missing catch or finally clause\"); }\r\n          return this.finishNode(node, \"TryStatement\")\r\n        };\r\n      \r\n        pp$1.parseVarStatement = function(node, kind) {\r\n          this.next();\r\n          this.parseVar(node, false, kind);\r\n          this.semicolon();\r\n          return this.finishNode(node, \"VariableDeclaration\")\r\n        };\r\n      \r\n        pp$1.parseWhileStatement = function(node) {\r\n          this.next();\r\n          node.test = this.parseParenExpression();\r\n          this.labels.push(loopLabel);\r\n          node.body = this.parseStatement(\"while\");\r\n          this.labels.pop();\r\n          return this.finishNode(node, \"WhileStatement\")\r\n        };\r\n      \r\n        pp$1.parseWithStatement = function(node) {\r\n          if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\r\n          this.next();\r\n          node.object = this.parseParenExpression();\r\n          node.body = this.parseStatement(\"with\");\r\n          return this.finishNode(node, \"WithStatement\")\r\n        };\r\n      \r\n        pp$1.parseEmptyStatement = function(node) {\r\n          this.next();\r\n          return this.finishNode(node, \"EmptyStatement\")\r\n        };\r\n      \r\n        pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\r\n          for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\r\n            {\r\n            var label = list[i$1];\r\n      \r\n            if (label.name === maybeName)\r\n              { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\r\n          } }\r\n          var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\r\n          for (var i = this.labels.length - 1; i >= 0; i--) {\r\n            var label$1 = this.labels[i];\r\n            if (label$1.statementStart === node.start) {\r\n              label$1.statementStart = this.start;\r\n              label$1.kind = kind;\r\n            } else { break }\r\n          }\r\n          this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\r\n          node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\r\n          this.labels.pop();\r\n          node.label = expr;\r\n          return this.finishNode(node, \"LabeledStatement\")\r\n        };\r\n      \r\n        pp$1.parseExpressionStatement = function(node, expr) {\r\n          node.expression = expr;\r\n          this.semicolon();\r\n          return this.finishNode(node, \"ExpressionStatement\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseBlock = function(createNewLexicalScope, node) {\r\n          if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\r\n          if ( node === void 0 ) node = this.startNode();\r\n      \r\n          node.body = [];\r\n          this.expect(types.braceL);\r\n          if (createNewLexicalScope) { this.enterScope(0); }\r\n          while (!this.eat(types.braceR)) {\r\n            var stmt = this.parseStatement(null);\r\n            node.body.push(stmt);\r\n          }\r\n          if (createNewLexicalScope) { this.exitScope(); }\r\n          return this.finishNode(node, \"BlockStatement\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseFor = function(node, init) {\r\n          node.init = init;\r\n          this.expect(types.semi);\r\n          node.test = this.type === types.semi ? null : this.parseExpression();\r\n          this.expect(types.semi);\r\n          node.update = this.type === types.parenR ? null : this.parseExpression();\r\n          this.expect(types.parenR);\r\n          node.body = this.parseStatement(\"for\");\r\n          this.exitScope();\r\n          this.labels.pop();\r\n          return this.finishNode(node, \"ForStatement\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseForIn = function(node, init) {\r\n          var isForIn = this.type === types._in;\r\n          this.next();\r\n      \r\n          if (\r\n            init.type === \"VariableDeclaration\" &&\r\n            init.declarations[0].init != null &&\r\n            (\r\n              !isForIn ||\r\n              this.options.ecmaVersion < 8 ||\r\n              this.strict ||\r\n              init.kind !== \"var\" ||\r\n              init.declarations[0].id.type !== \"Identifier\"\r\n            )\r\n          ) {\r\n            this.raise(\r\n              init.start,\r\n              ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\r\n            );\r\n          } else if (init.type === \"AssignmentPattern\") {\r\n            this.raise(init.start, \"Invalid left-hand side in for-loop\");\r\n          }\r\n          node.left = init;\r\n          node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\r\n          this.expect(types.parenR);\r\n          node.body = this.parseStatement(\"for\");\r\n          this.exitScope();\r\n          this.labels.pop();\r\n          return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseVar = function(node, isFor, kind) {\r\n          node.declarations = [];\r\n          node.kind = kind;\r\n          for (;;) {\r\n            var decl = this.startNode();\r\n            this.parseVarId(decl, kind);\r\n            if (this.eat(types.eq)) {\r\n              decl.init = this.parseMaybeAssign(isFor);\r\n            } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\r\n              this.unexpected();\r\n            } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\r\n              this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\r\n            } else {\r\n              decl.init = null;\r\n            }\r\n            node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\r\n            if (!this.eat(types.comma)) { break }\r\n          }\r\n          return node\r\n        };\r\n      \r\n        pp$1.parseVarId = function(decl, kind) {\r\n          decl.id = this.parseBindingAtom();\r\n          this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\r\n        };\r\n      \r\n        var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\r\n      \r\n      \r\n        pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\r\n          this.initFunction(node);\r\n          if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\r\n            if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\r\n              { this.unexpected(); }\r\n            node.generator = this.eat(types.star);\r\n          }\r\n          if (this.options.ecmaVersion >= 8)\r\n            { node.async = !!isAsync; }\r\n      \r\n          if (statement & FUNC_STATEMENT) {\r\n            node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\r\n            if (node.id && !(statement & FUNC_HANGING_STATEMENT))\r\n              { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\r\n          }\r\n      \r\n          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\r\n          this.yieldPos = 0;\r\n          this.awaitPos = 0;\r\n          this.awaitIdentPos = 0;\r\n          this.enterScope(functionFlags(node.async, node.generator));\r\n      \r\n          if (!(statement & FUNC_STATEMENT))\r\n            { node.id = this.type === types.name ? this.parseIdent() : null; }\r\n      \r\n          this.parseFunctionParams(node);\r\n          this.parseFunctionBody(node, allowExpressionBody, false);\r\n      \r\n          this.yieldPos = oldYieldPos;\r\n          this.awaitPos = oldAwaitPos;\r\n          this.awaitIdentPos = oldAwaitIdentPos;\r\n          return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\r\n        };\r\n      \r\n        pp$1.parseFunctionParams = function(node) {\r\n          this.expect(types.parenL);\r\n          node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\r\n          this.checkYieldAwaitInDefaultParams();\r\n        };\r\n      \r\n      \r\n        pp$1.parseClass = function(node, isStatement) {\r\n          this.next();\r\n      \r\n          var oldStrict = this.strict;\r\n          this.strict = true;\r\n      \r\n          this.parseClassId(node, isStatement);\r\n          this.parseClassSuper(node);\r\n          var classBody = this.startNode();\r\n          var hadConstructor = false;\r\n          classBody.body = [];\r\n          this.expect(types.braceL);\r\n          while (!this.eat(types.braceR)) {\r\n            var element = this.parseClassElement(node.superClass !== null);\r\n            if (element) {\r\n              classBody.body.push(element);\r\n              if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\r\n                if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\r\n                hadConstructor = true;\r\n              }\r\n            }\r\n          }\r\n          node.body = this.finishNode(classBody, \"ClassBody\");\r\n          this.strict = oldStrict;\r\n          return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\r\n        };\r\n      \r\n        pp$1.parseClassElement = function(constructorAllowsSuper) {\r\n          var this$1 = this;\r\n      \r\n          if (this.eat(types.semi)) { return null }\r\n      \r\n          var method = this.startNode();\r\n          var tryContextual = function (k, noLineBreak) {\r\n            if ( noLineBreak === void 0 ) noLineBreak = false;\r\n      \r\n            var start = this$1.start, startLoc = this$1.startLoc;\r\n            if (!this$1.eatContextual(k)) { return false }\r\n            if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\r\n            if (method.key) { this$1.unexpected(); }\r\n            method.computed = false;\r\n            method.key = this$1.startNodeAt(start, startLoc);\r\n            method.key.name = k;\r\n            this$1.finishNode(method.key, \"Identifier\");\r\n            return false\r\n          };\r\n      \r\n          method.kind = \"method\";\r\n          method.static = tryContextual(\"static\");\r\n          var isGenerator = this.eat(types.star);\r\n          var isAsync = false;\r\n          if (!isGenerator) {\r\n            if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\r\n              isAsync = true;\r\n              isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\r\n            } else if (tryContextual(\"get\")) {\r\n              method.kind = \"get\";\r\n            } else if (tryContextual(\"set\")) {\r\n              method.kind = \"set\";\r\n            }\r\n          }\r\n          if (!method.key) { this.parsePropertyName(method); }\r\n          var key = method.key;\r\n          var allowsDirectSuper = false;\r\n          if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\r\n              key.type === \"Literal\" && key.value === \"constructor\")) {\r\n            if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\r\n            if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\r\n            if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\r\n            method.kind = \"constructor\";\r\n            allowsDirectSuper = constructorAllowsSuper;\r\n          } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\r\n            this.raise(key.start, \"Classes may not have a static property named prototype\");\r\n          }\r\n          this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\r\n          if (method.kind === \"get\" && method.value.params.length !== 0)\r\n            { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\r\n          if (method.kind === \"set\" && method.value.params.length !== 1)\r\n            { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\r\n          if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\r\n            { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\r\n          return method\r\n        };\r\n      \r\n        pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\r\n          method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\r\n          return this.finishNode(method, \"MethodDefinition\")\r\n        };\r\n      \r\n        pp$1.parseClassId = function(node, isStatement) {\r\n          if (this.type === types.name) {\r\n            node.id = this.parseIdent();\r\n            if (isStatement)\r\n              { this.checkLVal(node.id, BIND_LEXICAL, false); }\r\n          } else {\r\n            if (isStatement === true)\r\n              { this.unexpected(); }\r\n            node.id = null;\r\n          }\r\n        };\r\n      \r\n        pp$1.parseClassSuper = function(node) {\r\n          node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\r\n        };\r\n      \r\n      \r\n        pp$1.parseExport = function(node, exports) {\r\n          this.next();\r\n          if (this.eat(types.star)) {\r\n            this.expectContextual(\"from\");\r\n            if (this.type !== types.string) { this.unexpected(); }\r\n            node.source = this.parseExprAtom();\r\n            this.semicolon();\r\n            return this.finishNode(node, \"ExportAllDeclaration\")\r\n          }\r\n          if (this.eat(types._default)) { \r\n            this.checkExport(exports, \"default\", this.lastTokStart);\r\n            var isAsync;\r\n            if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\r\n              var fNode = this.startNode();\r\n              this.next();\r\n              if (isAsync) { this.next(); }\r\n              node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\r\n            } else if (this.type === types._class) {\r\n              var cNode = this.startNode();\r\n              node.declaration = this.parseClass(cNode, \"nullableID\");\r\n            } else {\r\n              node.declaration = this.parseMaybeAssign();\r\n              this.semicolon();\r\n            }\r\n            return this.finishNode(node, \"ExportDefaultDeclaration\")\r\n          }\r\n          if (this.shouldParseExportStatement()) {\r\n            node.declaration = this.parseStatement(null);\r\n            if (node.declaration.type === \"VariableDeclaration\")\r\n              { this.checkVariableExport(exports, node.declaration.declarations); }\r\n            else\r\n              { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\r\n            node.specifiers = [];\r\n            node.source = null;\r\n          } else { \r\n            node.declaration = null;\r\n            node.specifiers = this.parseExportSpecifiers(exports);\r\n            if (this.eatContextual(\"from\")) {\r\n              if (this.type !== types.string) { this.unexpected(); }\r\n              node.source = this.parseExprAtom();\r\n            } else {\r\n              for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\r\n                var spec = list[i];\r\n      \r\n                this.checkUnreserved(spec.local);\r\n                this.checkLocalExport(spec.local);\r\n              }\r\n      \r\n              node.source = null;\r\n            }\r\n            this.semicolon();\r\n          }\r\n          return this.finishNode(node, \"ExportNamedDeclaration\")\r\n        };\r\n      \r\n        pp$1.checkExport = function(exports, name, pos) {\r\n          if (!exports) { return }\r\n          if (has(exports, name))\r\n            { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\r\n          exports[name] = true;\r\n        };\r\n      \r\n        pp$1.checkPatternExport = function(exports, pat) {\r\n          var type = pat.type;\r\n          if (type === \"Identifier\")\r\n            { this.checkExport(exports, pat.name, pat.start); }\r\n          else if (type === \"ObjectPattern\")\r\n            { for (var i = 0, list = pat.properties; i < list.length; i += 1)\r\n              {\r\n                var prop = list[i];\r\n      \r\n                this.checkPatternExport(exports, prop);\r\n              } }\r\n          else if (type === \"ArrayPattern\")\r\n            { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\r\n              var elt = list$1[i$1];\r\n      \r\n                if (elt) { this.checkPatternExport(exports, elt); }\r\n            } }\r\n          else if (type === \"Property\")\r\n            { this.checkPatternExport(exports, pat.value); }\r\n          else if (type === \"AssignmentPattern\")\r\n            { this.checkPatternExport(exports, pat.left); }\r\n          else if (type === \"RestElement\")\r\n            { this.checkPatternExport(exports, pat.argument); }\r\n          else if (type === \"ParenthesizedExpression\")\r\n            { this.checkPatternExport(exports, pat.expression); }\r\n        };\r\n      \r\n        pp$1.checkVariableExport = function(exports, decls) {\r\n          if (!exports) { return }\r\n          for (var i = 0, list = decls; i < list.length; i += 1)\r\n            {\r\n            var decl = list[i];\r\n      \r\n            this.checkPatternExport(exports, decl.id);\r\n          }\r\n        };\r\n      \r\n        pp$1.shouldParseExportStatement = function() {\r\n          return this.type.keyword === \"var\" ||\r\n            this.type.keyword === \"const\" ||\r\n            this.type.keyword === \"class\" ||\r\n            this.type.keyword === \"function\" ||\r\n            this.isLet() ||\r\n            this.isAsyncFunction()\r\n        };\r\n      \r\n      \r\n        pp$1.parseExportSpecifiers = function(exports) {\r\n          var nodes = [], first = true;\r\n          this.expect(types.braceL);\r\n          while (!this.eat(types.braceR)) {\r\n            if (!first) {\r\n              this.expect(types.comma);\r\n              if (this.afterTrailingComma(types.braceR)) { break }\r\n            } else { first = false; }\r\n      \r\n            var node = this.startNode();\r\n            node.local = this.parseIdent(true);\r\n            node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\r\n            this.checkExport(exports, node.exported.name, node.exported.start);\r\n            nodes.push(this.finishNode(node, \"ExportSpecifier\"));\r\n          }\r\n          return nodes\r\n        };\r\n      \r\n      \r\n        pp$1.parseImport = function(node) {\r\n          this.next();\r\n          if (this.type === types.string) {\r\n            node.specifiers = empty;\r\n            node.source = this.parseExprAtom();\r\n          } else {\r\n            node.specifiers = this.parseImportSpecifiers();\r\n            this.expectContextual(\"from\");\r\n            node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\r\n          }\r\n          this.semicolon();\r\n          return this.finishNode(node, \"ImportDeclaration\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseImportSpecifiers = function() {\r\n          var nodes = [], first = true;\r\n          if (this.type === types.name) {\r\n            var node = this.startNode();\r\n            node.local = this.parseIdent();\r\n            this.checkLVal(node.local, BIND_LEXICAL);\r\n            nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\r\n            if (!this.eat(types.comma)) { return nodes }\r\n          }\r\n          if (this.type === types.star) {\r\n            var node$1 = this.startNode();\r\n            this.next();\r\n            this.expectContextual(\"as\");\r\n            node$1.local = this.parseIdent();\r\n            this.checkLVal(node$1.local, BIND_LEXICAL);\r\n            nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\r\n            return nodes\r\n          }\r\n          this.expect(types.braceL);\r\n          while (!this.eat(types.braceR)) {\r\n            if (!first) {\r\n              this.expect(types.comma);\r\n              if (this.afterTrailingComma(types.braceR)) { break }\r\n            } else { first = false; }\r\n      \r\n            var node$2 = this.startNode();\r\n            node$2.imported = this.parseIdent(true);\r\n            if (this.eatContextual(\"as\")) {\r\n              node$2.local = this.parseIdent();\r\n            } else {\r\n              this.checkUnreserved(node$2.imported);\r\n              node$2.local = node$2.imported;\r\n            }\r\n            this.checkLVal(node$2.local, BIND_LEXICAL);\r\n            nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\r\n          }\r\n          return nodes\r\n        };\r\n      \r\n        pp$1.adaptDirectivePrologue = function(statements) {\r\n          for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\r\n            statements[i].directive = statements[i].expression.raw.slice(1, -1);\r\n          }\r\n        };\r\n        pp$1.isDirectiveCandidate = function(statement) {\r\n          return (\r\n            statement.type === \"ExpressionStatement\" &&\r\n            statement.expression.type === \"Literal\" &&\r\n            typeof statement.expression.value === \"string\" &&\r\n            (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\r\n          )\r\n        };\r\n      \r\n        var pp$2 = Parser.prototype;\r\n      \r\n      \r\n        pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\r\n          if (this.options.ecmaVersion >= 6 && node) {\r\n            switch (node.type) {\r\n            case \"Identifier\":\r\n              if (this.inAsync && node.name === \"await\")\r\n                { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\r\n              break\r\n      \r\n            case \"ObjectPattern\":\r\n            case \"ArrayPattern\":\r\n            case \"RestElement\":\r\n              break\r\n      \r\n            case \"ObjectExpression\":\r\n              node.type = \"ObjectPattern\";\r\n              if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n              for (var i = 0, list = node.properties; i < list.length; i += 1) {\r\n                var prop = list[i];\r\n      \r\n              this.toAssignable(prop, isBinding);\r\n                if (\r\n                  prop.type === \"RestElement\" &&\r\n                  (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\r\n                ) {\r\n                  this.raise(prop.argument.start, \"Unexpected token\");\r\n                }\r\n              }\r\n              break\r\n      \r\n            case \"Property\":\r\n              if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\r\n              this.toAssignable(node.value, isBinding);\r\n              break\r\n      \r\n            case \"ArrayExpression\":\r\n              node.type = \"ArrayPattern\";\r\n              if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n              this.toAssignableList(node.elements, isBinding);\r\n              break\r\n      \r\n            case \"SpreadElement\":\r\n              node.type = \"RestElement\";\r\n              this.toAssignable(node.argument, isBinding);\r\n              if (node.argument.type === \"AssignmentPattern\")\r\n                { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\r\n              break\r\n      \r\n            case \"AssignmentExpression\":\r\n              if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\r\n              node.type = \"AssignmentPattern\";\r\n              delete node.operator;\r\n              this.toAssignable(node.left, isBinding);\r\n      \r\n            case \"AssignmentPattern\":\r\n              break\r\n      \r\n            case \"ParenthesizedExpression\":\r\n              this.toAssignable(node.expression, isBinding, refDestructuringErrors);\r\n              break\r\n      \r\n            case \"MemberExpression\":\r\n              if (!isBinding) { break }\r\n      \r\n            default:\r\n              this.raise(node.start, \"Assigning to rvalue\");\r\n            }\r\n          } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n          return node\r\n        };\r\n      \r\n      \r\n        pp$2.toAssignableList = function(exprList, isBinding) {\r\n          var end = exprList.length;\r\n          for (var i = 0; i < end; i++) {\r\n            var elt = exprList[i];\r\n            if (elt) { this.toAssignable(elt, isBinding); }\r\n          }\r\n          if (end) {\r\n            var last = exprList[end - 1];\r\n            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\r\n              { this.unexpected(last.argument.start); }\r\n          }\r\n          return exprList\r\n        };\r\n      \r\n      \r\n        pp$2.parseSpread = function(refDestructuringErrors) {\r\n          var node = this.startNode();\r\n          this.next();\r\n          node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\r\n          return this.finishNode(node, \"SpreadElement\")\r\n        };\r\n      \r\n        pp$2.parseRestBinding = function() {\r\n          var node = this.startNode();\r\n          this.next();\r\n      \r\n          if (this.options.ecmaVersion === 6 && this.type !== types.name)\r\n            { this.unexpected(); }\r\n      \r\n          node.argument = this.parseBindingAtom();\r\n      \r\n          return this.finishNode(node, \"RestElement\")\r\n        };\r\n      \r\n      \r\n        pp$2.parseBindingAtom = function() {\r\n          if (this.options.ecmaVersion >= 6) {\r\n            switch (this.type) {\r\n            case types.bracketL:\r\n              var node = this.startNode();\r\n              this.next();\r\n              node.elements = this.parseBindingList(types.bracketR, true, true);\r\n              return this.finishNode(node, \"ArrayPattern\")\r\n      \r\n            case types.braceL:\r\n              return this.parseObj(true)\r\n            }\r\n          }\r\n          return this.parseIdent()\r\n        };\r\n      \r\n        pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\r\n          var elts = [], first = true;\r\n          while (!this.eat(close)) {\r\n            if (first) { first = false; }\r\n            else { this.expect(types.comma); }\r\n            if (allowEmpty && this.type === types.comma) {\r\n              elts.push(null);\r\n            } else if (allowTrailingComma && this.afterTrailingComma(close)) {\r\n              break\r\n            } else if (this.type === types.ellipsis) {\r\n              var rest = this.parseRestBinding();\r\n              this.parseBindingListItem(rest);\r\n              elts.push(rest);\r\n              if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\r\n              this.expect(close);\r\n              break\r\n            } else {\r\n              var elem = this.parseMaybeDefault(this.start, this.startLoc);\r\n              this.parseBindingListItem(elem);\r\n              elts.push(elem);\r\n            }\r\n          }\r\n          return elts\r\n        };\r\n      \r\n        pp$2.parseBindingListItem = function(param) {\r\n          return param\r\n        };\r\n      \r\n      \r\n        pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\r\n          left = left || this.parseBindingAtom();\r\n          if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\r\n          var node = this.startNodeAt(startPos, startLoc);\r\n          node.left = left;\r\n          node.right = this.parseMaybeAssign();\r\n          return this.finishNode(node, \"AssignmentPattern\")\r\n        };\r\n      \r\n      \r\n        pp$2.checkLVal = function(expr, bindingType, checkClashes) {\r\n          if ( bindingType === void 0 ) bindingType = BIND_NONE;\r\n      \r\n          switch (expr.type) {\r\n          case \"Identifier\":\r\n            if (bindingType === BIND_LEXICAL && expr.name === \"let\")\r\n              { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\r\n            if (this.strict && this.reservedWordsStrictBind.test(expr.name))\r\n              { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\r\n            if (checkClashes) {\r\n              if (has(checkClashes, expr.name))\r\n                { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\r\n              checkClashes[expr.name] = true;\r\n            }\r\n            if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\r\n            break\r\n      \r\n          case \"MemberExpression\":\r\n            if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\r\n            break\r\n      \r\n          case \"ObjectPattern\":\r\n            for (var i = 0, list = expr.properties; i < list.length; i += 1)\r\n              {\r\n            var prop = list[i];\r\n      \r\n            this.checkLVal(prop, bindingType, checkClashes);\r\n          }\r\n            break\r\n      \r\n          case \"Property\":\r\n            this.checkLVal(expr.value, bindingType, checkClashes);\r\n            break\r\n      \r\n          case \"ArrayPattern\":\r\n            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\r\n              var elem = list$1[i$1];\r\n      \r\n            if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\r\n            }\r\n            break\r\n      \r\n          case \"AssignmentPattern\":\r\n            this.checkLVal(expr.left, bindingType, checkClashes);\r\n            break\r\n      \r\n          case \"RestElement\":\r\n            this.checkLVal(expr.argument, bindingType, checkClashes);\r\n            break\r\n      \r\n          case \"ParenthesizedExpression\":\r\n            this.checkLVal(expr.expression, bindingType, checkClashes);\r\n            break\r\n      \r\n          default:\r\n            this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\r\n          }\r\n        };\r\n      \r\n      \r\n        var pp$3 = Parser.prototype;\r\n      \r\n      \r\n        pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\r\n          if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\r\n            { return }\r\n          if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\r\n            { return }\r\n          var key = prop.key;\r\n          var name;\r\n          switch (key.type) {\r\n          case \"Identifier\": name = key.name; break\r\n          case \"Literal\": name = String(key.value); break\r\n          default: return\r\n          }\r\n          var kind = prop.kind;\r\n          if (this.options.ecmaVersion >= 6) {\r\n            if (name === \"__proto__\" && kind === \"init\") {\r\n              if (propHash.proto) {\r\n                if (refDestructuringErrors) {\r\n                  if (refDestructuringErrors.doubleProto < 0)\r\n                    { refDestructuringErrors.doubleProto = key.start; }\r\n                } else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\r\n              }\r\n              propHash.proto = true;\r\n            }\r\n            return\r\n          }\r\n          name = \"$\" + name;\r\n          var other = propHash[name];\r\n          if (other) {\r\n            var redefinition;\r\n            if (kind === \"init\") {\r\n              redefinition = this.strict && other.init || other.get || other.set;\r\n            } else {\r\n              redefinition = other.init || other[kind];\r\n            }\r\n            if (redefinition)\r\n              { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\r\n          } else {\r\n            other = propHash[name] = {\r\n              init: false,\r\n              get: false,\r\n              set: false\r\n            };\r\n          }\r\n          other[kind] = true;\r\n        };\r\n      \r\n      \r\n      \r\n      \r\n        pp$3.parseExpression = function(noIn, refDestructuringErrors) {\r\n          var startPos = this.start, startLoc = this.startLoc;\r\n          var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\r\n          if (this.type === types.comma) {\r\n            var node = this.startNodeAt(startPos, startLoc);\r\n            node.expressions = [expr];\r\n            while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\r\n            return this.finishNode(node, \"SequenceExpression\")\r\n          }\r\n          return expr\r\n        };\r\n      \r\n      \r\n        pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\r\n          if (this.isContextual(\"yield\")) {\r\n            if (this.inGenerator) { return this.parseYield(noIn) }\r\n            else { this.exprAllowed = false; }\r\n          }\r\n      \r\n          var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\r\n          if (refDestructuringErrors) {\r\n            oldParenAssign = refDestructuringErrors.parenthesizedAssign;\r\n            oldTrailingComma = refDestructuringErrors.trailingComma;\r\n            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\r\n          } else {\r\n            refDestructuringErrors = new DestructuringErrors;\r\n            ownDestructuringErrors = true;\r\n          }\r\n      \r\n          var startPos = this.start, startLoc = this.startLoc;\r\n          if (this.type === types.parenL || this.type === types.name)\r\n            { this.potentialArrowAt = this.start; }\r\n          var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\r\n          if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\r\n          if (this.type.isAssign) {\r\n            var node = this.startNodeAt(startPos, startLoc);\r\n            node.operator = this.value;\r\n            node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\r\n            if (!ownDestructuringErrors) {\r\n              refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\r\n            }\r\n            if (refDestructuringErrors.shorthandAssign >= node.left.start)\r\n              { refDestructuringErrors.shorthandAssign = -1; } \r\n            this.checkLVal(left);\r\n            this.next();\r\n            node.right = this.parseMaybeAssign(noIn);\r\n            return this.finishNode(node, \"AssignmentExpression\")\r\n          } else {\r\n            if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\r\n          }\r\n          if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\r\n          if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\r\n          return left\r\n        };\r\n      \r\n      \r\n        pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\r\n          var startPos = this.start, startLoc = this.startLoc;\r\n          var expr = this.parseExprOps(noIn, refDestructuringErrors);\r\n          if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n          if (this.eat(types.question)) {\r\n            var node = this.startNodeAt(startPos, startLoc);\r\n            node.test = expr;\r\n            node.consequent = this.parseMaybeAssign();\r\n            this.expect(types.colon);\r\n            node.alternate = this.parseMaybeAssign(noIn);\r\n            return this.finishNode(node, \"ConditionalExpression\")\r\n          }\r\n          return expr\r\n        };\r\n      \r\n      \r\n        pp$3.parseExprOps = function(noIn, refDestructuringErrors) {\r\n          var startPos = this.start, startLoc = this.startLoc;\r\n          var expr = this.parseMaybeUnary(refDestructuringErrors, false);\r\n          if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n          return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\r\n        };\r\n      \r\n      \r\n        pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\r\n          var prec = this.type.binop;\r\n          if (prec != null && (!noIn || this.type !== types._in)) {\r\n            if (prec > minPrec) {\r\n              var logical = this.type === types.logicalOR || this.type === types.logicalAND;\r\n              var op = this.value;\r\n              this.next();\r\n              var startPos = this.start, startLoc = this.startLoc;\r\n              var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\r\n              var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\r\n              return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\r\n            }\r\n          }\r\n          return left\r\n        };\r\n      \r\n        pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\r\n          var node = this.startNodeAt(startPos, startLoc);\r\n          node.left = left;\r\n          node.operator = op;\r\n          node.right = right;\r\n          return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\r\n        };\r\n      \r\n      \r\n        pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\r\n          var startPos = this.start, startLoc = this.startLoc, expr;\r\n          if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\r\n            expr = this.parseAwait();\r\n            sawUnary = true;\r\n          } else if (this.type.prefix) {\r\n            var node = this.startNode(), update = this.type === types.incDec;\r\n            node.operator = this.value;\r\n            node.prefix = true;\r\n            this.next();\r\n            node.argument = this.parseMaybeUnary(null, true);\r\n            this.checkExpressionErrors(refDestructuringErrors, true);\r\n            if (update) { this.checkLVal(node.argument); }\r\n            else if (this.strict && node.operator === \"delete\" &&\r\n                     node.argument.type === \"Identifier\")\r\n              { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\r\n            else { sawUnary = true; }\r\n            expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\r\n          } else {\r\n            expr = this.parseExprSubscripts(refDestructuringErrors);\r\n            if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n            while (this.type.postfix && !this.canInsertSemicolon()) {\r\n              var node$1 = this.startNodeAt(startPos, startLoc);\r\n              node$1.operator = this.value;\r\n              node$1.prefix = false;\r\n              node$1.argument = expr;\r\n              this.checkLVal(expr);\r\n              this.next();\r\n              expr = this.finishNode(node$1, \"UpdateExpression\");\r\n            }\r\n          }\r\n      \r\n          if (!sawUnary && this.eat(types.starstar))\r\n            { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\r\n          else\r\n            { return expr }\r\n        };\r\n      \r\n      \r\n        pp$3.parseExprSubscripts = function(refDestructuringErrors) {\r\n          var startPos = this.start, startLoc = this.startLoc;\r\n          var expr = this.parseExprAtom(refDestructuringErrors);\r\n          if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\r\n            { return expr }\r\n          var result = this.parseSubscripts(expr, startPos, startLoc);\r\n          if (refDestructuringErrors && result.type === \"MemberExpression\") {\r\n            if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\r\n            if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\r\n          }\r\n          return result\r\n        };\r\n      \r\n        pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\r\n          var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\r\n              this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\r\n          while (true) {\r\n            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\r\n            if (element === base || element.type === \"ArrowFunctionExpression\") { return element }\r\n            base = element;\r\n          }\r\n        };\r\n      \r\n        pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\r\n          var computed = this.eat(types.bracketL);\r\n          if (computed || this.eat(types.dot)) {\r\n            var node = this.startNodeAt(startPos, startLoc);\r\n            node.object = base;\r\n            node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\r\n            node.computed = !!computed;\r\n            if (computed) { this.expect(types.bracketR); }\r\n            base = this.finishNode(node, \"MemberExpression\");\r\n          } else if (!noCalls && this.eat(types.parenL)) {\r\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\r\n            this.yieldPos = 0;\r\n            this.awaitPos = 0;\r\n            this.awaitIdentPos = 0;\r\n            var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\r\n            if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\r\n              this.checkPatternErrors(refDestructuringErrors, false);\r\n              this.checkYieldAwaitInDefaultParams();\r\n              if (this.awaitIdentPos > 0)\r\n                { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\r\n              this.yieldPos = oldYieldPos;\r\n              this.awaitPos = oldAwaitPos;\r\n              this.awaitIdentPos = oldAwaitIdentPos;\r\n              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\r\n            }\r\n            this.checkExpressionErrors(refDestructuringErrors, true);\r\n            this.yieldPos = oldYieldPos || this.yieldPos;\r\n            this.awaitPos = oldAwaitPos || this.awaitPos;\r\n            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\r\n            var node$1 = this.startNodeAt(startPos, startLoc);\r\n            node$1.callee = base;\r\n            node$1.arguments = exprList;\r\n            base = this.finishNode(node$1, \"CallExpression\");\r\n          } else if (this.type === types.backQuote) {\r\n            var node$2 = this.startNodeAt(startPos, startLoc);\r\n            node$2.tag = base;\r\n            node$2.quasi = this.parseTemplate({isTagged: true});\r\n            base = this.finishNode(node$2, \"TaggedTemplateExpression\");\r\n          }\r\n          return base\r\n        };\r\n      \r\n      \r\n        pp$3.parseExprAtom = function(refDestructuringErrors) {\r\n          if (this.type === types.slash) { this.readRegexp(); }\r\n      \r\n          var node, canBeArrow = this.potentialArrowAt === this.start;\r\n          switch (this.type) {\r\n          case types._super:\r\n            if (!this.allowSuper)\r\n              { this.raise(this.start, \"'super' keyword outside a method\"); }\r\n            node = this.startNode();\r\n            this.next();\r\n            if (this.type === types.parenL && !this.allowDirectSuper)\r\n              { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\r\n            if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\r\n              { this.unexpected(); }\r\n            return this.finishNode(node, \"Super\")\r\n      \r\n          case types._this:\r\n            node = this.startNode();\r\n            this.next();\r\n            return this.finishNode(node, \"ThisExpression\")\r\n      \r\n          case types.name:\r\n            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\r\n            var id = this.parseIdent(false);\r\n            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\r\n              { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\r\n            if (canBeArrow && !this.canInsertSemicolon()) {\r\n              if (this.eat(types.arrow))\r\n                { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\r\n              if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\r\n                id = this.parseIdent(false);\r\n                if (this.canInsertSemicolon() || !this.eat(types.arrow))\r\n                  { this.unexpected(); }\r\n                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\r\n              }\r\n            }\r\n            return id\r\n      \r\n          case types.regexp:\r\n            var value = this.value;\r\n            node = this.parseLiteral(value.value);\r\n            node.regex = {pattern: value.pattern, flags: value.flags};\r\n            return node\r\n      \r\n          case types.num: case types.string:\r\n            return this.parseLiteral(this.value)\r\n      \r\n          case types._null: case types._true: case types._false:\r\n            node = this.startNode();\r\n            node.value = this.type === types._null ? null : this.type === types._true;\r\n            node.raw = this.type.keyword;\r\n            this.next();\r\n            return this.finishNode(node, \"Literal\")\r\n      \r\n          case types.parenL:\r\n            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\r\n            if (refDestructuringErrors) {\r\n              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\r\n                { refDestructuringErrors.parenthesizedAssign = start; }\r\n              if (refDestructuringErrors.parenthesizedBind < 0)\r\n                { refDestructuringErrors.parenthesizedBind = start; }\r\n            }\r\n            return expr\r\n      \r\n          case types.bracketL:\r\n            node = this.startNode();\r\n            this.next();\r\n            node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\r\n            return this.finishNode(node, \"ArrayExpression\")\r\n      \r\n          case types.braceL:\r\n            return this.parseObj(false, refDestructuringErrors)\r\n      \r\n          case types._function:\r\n            node = this.startNode();\r\n            this.next();\r\n            return this.parseFunction(node, 0)\r\n      \r\n          case types._class:\r\n            return this.parseClass(this.startNode(), false)\r\n      \r\n          case types._new:\r\n            return this.parseNew()\r\n      \r\n          case types.backQuote:\r\n            return this.parseTemplate()\r\n      \r\n          case types._import:\r\n            if (this.options.ecmaVersion >= 11) {\r\n              return this.parseExprImport()\r\n            } else {\r\n              return this.unexpected()\r\n            }\r\n      \r\n          default:\r\n            this.unexpected();\r\n          }\r\n        };\r\n      \r\n        pp$3.parseExprImport = function() {\r\n          var node = this.startNode();\r\n          this.next(); \r\n          switch (this.type) {\r\n          case types.parenL:\r\n            return this.parseDynamicImport(node)\r\n          default:\r\n            this.unexpected();\r\n          }\r\n        };\r\n      \r\n        pp$3.parseDynamicImport = function(node) {\r\n          this.next(); \r\n      \r\n          node.source = this.parseMaybeAssign();\r\n      \r\n          if (!this.eat(types.parenR)) {\r\n            var errorPos = this.start;\r\n            if (this.eat(types.comma) && this.eat(types.parenR)) {\r\n              this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\r\n            } else {\r\n              this.unexpected(errorPos);\r\n            }\r\n          }\r\n      \r\n          return this.finishNode(node, \"ImportExpression\")\r\n        };\r\n      \r\n        pp$3.parseLiteral = function(value) {\r\n          var node = this.startNode();\r\n          node.value = value;\r\n          node.raw = this.input.slice(this.start, this.end);\r\n          if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\r\n          this.next();\r\n          return this.finishNode(node, \"Literal\")\r\n        };\r\n      \r\n        pp$3.parseParenExpression = function() {\r\n          this.expect(types.parenL);\r\n          var val = this.parseExpression();\r\n          this.expect(types.parenR);\r\n          return val\r\n        };\r\n      \r\n        pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\r\n          var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\r\n          if (this.options.ecmaVersion >= 6) {\r\n            this.next();\r\n      \r\n            var innerStartPos = this.start, innerStartLoc = this.startLoc;\r\n            var exprList = [], first = true, lastIsComma = false;\r\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\r\n            this.yieldPos = 0;\r\n            this.awaitPos = 0;\r\n            while (this.type !== types.parenR) {\r\n              first ? first = false : this.expect(types.comma);\r\n              if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\r\n                lastIsComma = true;\r\n                break\r\n              } else if (this.type === types.ellipsis) {\r\n                spreadStart = this.start;\r\n                exprList.push(this.parseParenItem(this.parseRestBinding()));\r\n                if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\r\n                break\r\n              } else {\r\n                exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\r\n              }\r\n            }\r\n            var innerEndPos = this.start, innerEndLoc = this.startLoc;\r\n            this.expect(types.parenR);\r\n      \r\n            if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\r\n              this.checkPatternErrors(refDestructuringErrors, false);\r\n              this.checkYieldAwaitInDefaultParams();\r\n              this.yieldPos = oldYieldPos;\r\n              this.awaitPos = oldAwaitPos;\r\n              return this.parseParenArrowList(startPos, startLoc, exprList)\r\n            }\r\n      \r\n            if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\r\n            if (spreadStart) { this.unexpected(spreadStart); }\r\n            this.checkExpressionErrors(refDestructuringErrors, true);\r\n            this.yieldPos = oldYieldPos || this.yieldPos;\r\n            this.awaitPos = oldAwaitPos || this.awaitPos;\r\n      \r\n            if (exprList.length > 1) {\r\n              val = this.startNodeAt(innerStartPos, innerStartLoc);\r\n              val.expressions = exprList;\r\n              this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\r\n            } else {\r\n              val = exprList[0];\r\n            }\r\n          } else {\r\n            val = this.parseParenExpression();\r\n          }\r\n      \r\n          if (this.options.preserveParens) {\r\n            var par = this.startNodeAt(startPos, startLoc);\r\n            par.expression = val;\r\n            return this.finishNode(par, \"ParenthesizedExpression\")\r\n          } else {\r\n            return val\r\n          }\r\n        };\r\n      \r\n        pp$3.parseParenItem = function(item) {\r\n          return item\r\n        };\r\n      \r\n        pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\r\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\r\n        };\r\n      \r\n      \r\n        var empty$1 = [];\r\n      \r\n        pp$3.parseNew = function() {\r\n          if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\r\n          var node = this.startNode();\r\n          var meta = this.parseIdent(true);\r\n          if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\r\n            node.meta = meta;\r\n            var containsEsc = this.containsEsc;\r\n            node.property = this.parseIdent(true);\r\n            if (node.property.name !== \"target\" || containsEsc)\r\n              { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\r\n            if (!this.inNonArrowFunction())\r\n              { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\r\n            return this.finishNode(node, \"MetaProperty\")\r\n          }\r\n          var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;\r\n          node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\r\n          if (isImport && node.callee.type === \"ImportExpression\") {\r\n            this.raise(startPos, \"Cannot use new with import()\");\r\n          }\r\n          if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\r\n          else { node.arguments = empty$1; }\r\n          return this.finishNode(node, \"NewExpression\")\r\n        };\r\n      \r\n      \r\n        pp$3.parseTemplateElement = function(ref) {\r\n          var isTagged = ref.isTagged;\r\n      \r\n          var elem = this.startNode();\r\n          if (this.type === types.invalidTemplate) {\r\n            if (!isTagged) {\r\n              this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\r\n            }\r\n            elem.value = {\r\n              raw: this.value,\r\n              cooked: null\r\n            };\r\n          } else {\r\n            elem.value = {\r\n              raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\r\n              cooked: this.value\r\n            };\r\n          }\r\n          this.next();\r\n          elem.tail = this.type === types.backQuote;\r\n          return this.finishNode(elem, \"TemplateElement\")\r\n        };\r\n      \r\n        pp$3.parseTemplate = function(ref) {\r\n          if ( ref === void 0 ) ref = {};\r\n          var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\r\n      \r\n          var node = this.startNode();\r\n          this.next();\r\n          node.expressions = [];\r\n          var curElt = this.parseTemplateElement({isTagged: isTagged});\r\n          node.quasis = [curElt];\r\n          while (!curElt.tail) {\r\n            if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\r\n            this.expect(types.dollarBraceL);\r\n            node.expressions.push(this.parseExpression());\r\n            this.expect(types.braceR);\r\n            node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\r\n          }\r\n          this.next();\r\n          return this.finishNode(node, \"TemplateLiteral\")\r\n        };\r\n      \r\n        pp$3.isAsyncProp = function(prop) {\r\n          return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\r\n            (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\r\n            !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\r\n        };\r\n      \r\n      \r\n        pp$3.parseObj = function(isPattern, refDestructuringErrors) {\r\n          var node = this.startNode(), first = true, propHash = {};\r\n          node.properties = [];\r\n          this.next();\r\n          while (!this.eat(types.braceR)) {\r\n            if (!first) {\r\n              this.expect(types.comma);\r\n              if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }\r\n            } else { first = false; }\r\n      \r\n            var prop = this.parseProperty(isPattern, refDestructuringErrors);\r\n            if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\r\n            node.properties.push(prop);\r\n          }\r\n          return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\r\n        };\r\n      \r\n        pp$3.parseProperty = function(isPattern, refDestructuringErrors) {\r\n          var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\r\n          if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\r\n            if (isPattern) {\r\n              prop.argument = this.parseIdent(false);\r\n              if (this.type === types.comma) {\r\n                this.raise(this.start, \"Comma is not permitted after the rest element\");\r\n              }\r\n              return this.finishNode(prop, \"RestElement\")\r\n            }\r\n            if (this.type === types.parenL && refDestructuringErrors) {\r\n              if (refDestructuringErrors.parenthesizedAssign < 0) {\r\n                refDestructuringErrors.parenthesizedAssign = this.start;\r\n              }\r\n              if (refDestructuringErrors.parenthesizedBind < 0) {\r\n                refDestructuringErrors.parenthesizedBind = this.start;\r\n              }\r\n            }\r\n            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\r\n            if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\r\n              refDestructuringErrors.trailingComma = this.start;\r\n            }\r\n            return this.finishNode(prop, \"SpreadElement\")\r\n          }\r\n          if (this.options.ecmaVersion >= 6) {\r\n            prop.method = false;\r\n            prop.shorthand = false;\r\n            if (isPattern || refDestructuringErrors) {\r\n              startPos = this.start;\r\n              startLoc = this.startLoc;\r\n            }\r\n            if (!isPattern)\r\n              { isGenerator = this.eat(types.star); }\r\n          }\r\n          var containsEsc = this.containsEsc;\r\n          this.parsePropertyName(prop);\r\n          if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\r\n            isAsync = true;\r\n            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\r\n            this.parsePropertyName(prop, refDestructuringErrors);\r\n          } else {\r\n            isAsync = false;\r\n          }\r\n          this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\r\n          return this.finishNode(prop, \"Property\")\r\n        };\r\n      \r\n        pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\r\n          if ((isGenerator || isAsync) && this.type === types.colon)\r\n            { this.unexpected(); }\r\n      \r\n          if (this.eat(types.colon)) {\r\n            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\r\n            prop.kind = \"init\";\r\n          } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\r\n            if (isPattern) { this.unexpected(); }\r\n            prop.kind = \"init\";\r\n            prop.method = true;\r\n            prop.value = this.parseMethod(isGenerator, isAsync);\r\n          } else if (!isPattern && !containsEsc &&\r\n                     this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\r\n                     (prop.key.name === \"get\" || prop.key.name === \"set\") &&\r\n                     (this.type !== types.comma && this.type !== types.braceR)) {\r\n            if (isGenerator || isAsync) { this.unexpected(); }\r\n            prop.kind = prop.key.name;\r\n            this.parsePropertyName(prop);\r\n            prop.value = this.parseMethod(false);\r\n            var paramCount = prop.kind === \"get\" ? 0 : 1;\r\n            if (prop.value.params.length !== paramCount) {\r\n              var start = prop.value.start;\r\n              if (prop.kind === \"get\")\r\n                { this.raiseRecoverable(start, \"getter should have no params\"); }\r\n              else\r\n                { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\r\n            } else {\r\n              if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\r\n                { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\r\n            }\r\n          } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\r\n            if (isGenerator || isAsync) { this.unexpected(); }\r\n            this.checkUnreserved(prop.key);\r\n            if (prop.key.name === \"await\" && !this.awaitIdentPos)\r\n              { this.awaitIdentPos = startPos; }\r\n            prop.kind = \"init\";\r\n            if (isPattern) {\r\n              prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\r\n            } else if (this.type === types.eq && refDestructuringErrors) {\r\n              if (refDestructuringErrors.shorthandAssign < 0)\r\n                { refDestructuringErrors.shorthandAssign = this.start; }\r\n              prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\r\n            } else {\r\n              prop.value = prop.key;\r\n            }\r\n            prop.shorthand = true;\r\n          } else { this.unexpected(); }\r\n        };\r\n      \r\n        pp$3.parsePropertyName = function(prop) {\r\n          if (this.options.ecmaVersion >= 6) {\r\n            if (this.eat(types.bracketL)) {\r\n              prop.computed = true;\r\n              prop.key = this.parseMaybeAssign();\r\n              this.expect(types.bracketR);\r\n              return prop.key\r\n            } else {\r\n              prop.computed = false;\r\n            }\r\n          }\r\n          return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\r\n        };\r\n      \r\n      \r\n        pp$3.initFunction = function(node) {\r\n          node.id = null;\r\n          if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\r\n          if (this.options.ecmaVersion >= 8) { node.async = false; }\r\n        };\r\n      \r\n      \r\n        pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\r\n          var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\r\n      \r\n          this.initFunction(node);\r\n          if (this.options.ecmaVersion >= 6)\r\n            { node.generator = isGenerator; }\r\n          if (this.options.ecmaVersion >= 8)\r\n            { node.async = !!isAsync; }\r\n      \r\n          this.yieldPos = 0;\r\n          this.awaitPos = 0;\r\n          this.awaitIdentPos = 0;\r\n          this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\r\n      \r\n          this.expect(types.parenL);\r\n          node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\r\n          this.checkYieldAwaitInDefaultParams();\r\n          this.parseFunctionBody(node, false, true);\r\n      \r\n          this.yieldPos = oldYieldPos;\r\n          this.awaitPos = oldAwaitPos;\r\n          this.awaitIdentPos = oldAwaitIdentPos;\r\n          return this.finishNode(node, \"FunctionExpression\")\r\n        };\r\n      \r\n      \r\n        pp$3.parseArrowExpression = function(node, params, isAsync) {\r\n          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\r\n      \r\n          this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\r\n          this.initFunction(node);\r\n          if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\r\n      \r\n          this.yieldPos = 0;\r\n          this.awaitPos = 0;\r\n          this.awaitIdentPos = 0;\r\n      \r\n          node.params = this.toAssignableList(params, true);\r\n          this.parseFunctionBody(node, true, false);\r\n      \r\n          this.yieldPos = oldYieldPos;\r\n          this.awaitPos = oldAwaitPos;\r\n          this.awaitIdentPos = oldAwaitIdentPos;\r\n          return this.finishNode(node, \"ArrowFunctionExpression\")\r\n        };\r\n      \r\n      \r\n        pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\r\n          var isExpression = isArrowFunction && this.type !== types.braceL;\r\n          var oldStrict = this.strict, useStrict = false;\r\n      \r\n          if (isExpression) {\r\n            node.body = this.parseMaybeAssign();\r\n            node.expression = true;\r\n            this.checkParams(node, false);\r\n          } else {\r\n            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\r\n            if (!oldStrict || nonSimple) {\r\n              useStrict = this.strictDirective(this.end);\r\n              if (useStrict && nonSimple)\r\n                { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\r\n            }\r\n            var oldLabels = this.labels;\r\n            this.labels = [];\r\n            if (useStrict) { this.strict = true; }\r\n      \r\n            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\r\n            node.body = this.parseBlock(false);\r\n            node.expression = false;\r\n            this.adaptDirectivePrologue(node.body.body);\r\n            this.labels = oldLabels;\r\n          }\r\n          this.exitScope();\r\n      \r\n          if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\r\n          this.strict = oldStrict;\r\n        };\r\n      \r\n        pp$3.isSimpleParamList = function(params) {\r\n          for (var i = 0, list = params; i < list.length; i += 1)\r\n            {\r\n            var param = list[i];\r\n      \r\n            if (param.type !== \"Identifier\") { return false\r\n          } }\r\n          return true\r\n        };\r\n      \r\n      \r\n        pp$3.checkParams = function(node, allowDuplicates) {\r\n          var nameHash = {};\r\n          for (var i = 0, list = node.params; i < list.length; i += 1)\r\n            {\r\n            var param = list[i];\r\n      \r\n            this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\r\n          }\r\n        };\r\n      \r\n      \r\n        pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\r\n          var elts = [], first = true;\r\n          while (!this.eat(close)) {\r\n            if (!first) {\r\n              this.expect(types.comma);\r\n              if (allowTrailingComma && this.afterTrailingComma(close)) { break }\r\n            } else { first = false; }\r\n      \r\n            var elt = (void 0);\r\n            if (allowEmpty && this.type === types.comma)\r\n              { elt = null; }\r\n            else if (this.type === types.ellipsis) {\r\n              elt = this.parseSpread(refDestructuringErrors);\r\n              if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\r\n                { refDestructuringErrors.trailingComma = this.start; }\r\n            } else {\r\n              elt = this.parseMaybeAssign(false, refDestructuringErrors);\r\n            }\r\n            elts.push(elt);\r\n          }\r\n          return elts\r\n        };\r\n      \r\n        pp$3.checkUnreserved = function(ref) {\r\n          var start = ref.start;\r\n          var end = ref.end;\r\n          var name = ref.name;\r\n      \r\n          if (this.inGenerator && name === \"yield\")\r\n            { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\r\n          if (this.inAsync && name === \"await\")\r\n            { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\r\n          if (this.keywords.test(name))\r\n            { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\r\n          if (this.options.ecmaVersion < 6 &&\r\n            this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\r\n          var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\r\n          if (re.test(name)) {\r\n            if (!this.inAsync && name === \"await\")\r\n              { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\r\n            this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\r\n          }\r\n        };\r\n      \r\n      \r\n        pp$3.parseIdent = function(liberal, isBinding) {\r\n          var node = this.startNode();\r\n          if (this.type === types.name) {\r\n            node.name = this.value;\r\n          } else if (this.type.keyword) {\r\n            node.name = this.type.keyword;\r\n      \r\n            if ((node.name === \"class\" || node.name === \"function\") &&\r\n                (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\r\n              this.context.pop();\r\n            }\r\n          } else {\r\n            this.unexpected();\r\n          }\r\n          this.next(!!liberal);\r\n          this.finishNode(node, \"Identifier\");\r\n          if (!liberal) {\r\n            this.checkUnreserved(node);\r\n            if (node.name === \"await\" && !this.awaitIdentPos)\r\n              { this.awaitIdentPos = node.start; }\r\n          }\r\n          return node\r\n        };\r\n      \r\n      \r\n        pp$3.parseYield = function(noIn) {\r\n          if (!this.yieldPos) { this.yieldPos = this.start; }\r\n      \r\n          var node = this.startNode();\r\n          this.next();\r\n          if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\r\n            node.delegate = false;\r\n            node.argument = null;\r\n          } else {\r\n            node.delegate = this.eat(types.star);\r\n            node.argument = this.parseMaybeAssign(noIn);\r\n          }\r\n          return this.finishNode(node, \"YieldExpression\")\r\n        };\r\n      \r\n        pp$3.parseAwait = function() {\r\n          if (!this.awaitPos) { this.awaitPos = this.start; }\r\n      \r\n          var node = this.startNode();\r\n          this.next();\r\n          node.argument = this.parseMaybeUnary(null, false);\r\n          return this.finishNode(node, \"AwaitExpression\")\r\n        };\r\n      \r\n        var pp$4 = Parser.prototype;\r\n      \r\n      \r\n        pp$4.raise = function(pos, message) {\r\n          var loc = getLineInfo(this.input, pos);\r\n          message += \" (\" + loc.line + \":\" + loc.column + \")\";\r\n          var err = new SyntaxError(message);\r\n          err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\r\n          throw err\r\n        };\r\n      \r\n        pp$4.raiseRecoverable = pp$4.raise;\r\n      \r\n        pp$4.curPosition = function() {\r\n          if (this.options.locations) {\r\n            return new Position(this.curLine, this.pos - this.lineStart)\r\n          }\r\n        };\r\n      \r\n        var pp$5 = Parser.prototype;\r\n      \r\n        var Scope = function Scope(flags) {\r\n          this.flags = flags;\r\n          this.var = [];\r\n          this.lexical = [];\r\n          this.functions = [];\r\n        };\r\n      \r\n      \r\n        pp$5.enterScope = function(flags) {\r\n          this.scopeStack.push(new Scope(flags));\r\n        };\r\n      \r\n        pp$5.exitScope = function() {\r\n          this.scopeStack.pop();\r\n        };\r\n      \r\n        pp$5.treatFunctionsAsVarInScope = function(scope) {\r\n          return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\r\n        };\r\n      \r\n        pp$5.declareName = function(name, bindingType, pos) {\r\n          var redeclared = false;\r\n          if (bindingType === BIND_LEXICAL) {\r\n            var scope = this.currentScope();\r\n            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\r\n            scope.lexical.push(name);\r\n            if (this.inModule && (scope.flags & SCOPE_TOP))\r\n              { delete this.undefinedExports[name]; }\r\n          } else if (bindingType === BIND_SIMPLE_CATCH) {\r\n            var scope$1 = this.currentScope();\r\n            scope$1.lexical.push(name);\r\n          } else if (bindingType === BIND_FUNCTION) {\r\n            var scope$2 = this.currentScope();\r\n            if (this.treatFunctionsAsVar)\r\n              { redeclared = scope$2.lexical.indexOf(name) > -1; }\r\n            else\r\n              { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\r\n            scope$2.functions.push(name);\r\n          } else {\r\n            for (var i = this.scopeStack.length - 1; i >= 0; --i) {\r\n              var scope$3 = this.scopeStack[i];\r\n              if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\r\n                  !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\r\n                redeclared = true;\r\n                break\r\n              }\r\n              scope$3.var.push(name);\r\n              if (this.inModule && (scope$3.flags & SCOPE_TOP))\r\n                { delete this.undefinedExports[name]; }\r\n              if (scope$3.flags & SCOPE_VAR) { break }\r\n            }\r\n          }\r\n          if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\r\n        };\r\n      \r\n        pp$5.checkLocalExport = function(id) {\r\n          if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\r\n              this.scopeStack[0].var.indexOf(id.name) === -1) {\r\n            this.undefinedExports[id.name] = id;\r\n          }\r\n        };\r\n      \r\n        pp$5.currentScope = function() {\r\n          return this.scopeStack[this.scopeStack.length - 1]\r\n        };\r\n      \r\n        pp$5.currentVarScope = function() {\r\n          for (var i = this.scopeStack.length - 1;; i--) {\r\n            var scope = this.scopeStack[i];\r\n            if (scope.flags & SCOPE_VAR) { return scope }\r\n          }\r\n        };\r\n      \r\n        pp$5.currentThisScope = function() {\r\n          for (var i = this.scopeStack.length - 1;; i--) {\r\n            var scope = this.scopeStack[i];\r\n            if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\r\n          }\r\n        };\r\n      \r\n        var Node = function Node(parser, pos, loc) {\r\n          this.type = \"\";\r\n          this.start = pos;\r\n          this.end = 0;\r\n          if (parser.options.locations)\r\n            { this.loc = new SourceLocation(parser, loc); }\r\n          if (parser.options.directSourceFile)\r\n            { this.sourceFile = parser.options.directSourceFile; }\r\n          if (parser.options.ranges)\r\n            { this.range = [pos, 0]; }\r\n        };\r\n      \r\n      \r\n        var pp$6 = Parser.prototype;\r\n      \r\n        pp$6.startNode = function() {\r\n          return new Node(this, this.start, this.startLoc)\r\n        };\r\n      \r\n        pp$6.startNodeAt = function(pos, loc) {\r\n          return new Node(this, pos, loc)\r\n        };\r\n      \r\n      \r\n        function finishNodeAt(node, type, pos, loc) {\r\n          node.type = type;\r\n          node.end = pos;\r\n          if (this.options.locations)\r\n            { node.loc.end = loc; }\r\n          if (this.options.ranges)\r\n            { node.range[1] = pos; }\r\n          return node\r\n        }\r\n      \r\n        pp$6.finishNode = function(node, type) {\r\n          return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\r\n        };\r\n      \r\n      \r\n        pp$6.finishNodeAt = function(node, type, pos, loc) {\r\n          return finishNodeAt.call(this, node, type, pos, loc)\r\n        };\r\n      \r\n      \r\n        var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\r\n          this.token = token;\r\n          this.isExpr = !!isExpr;\r\n          this.preserveSpace = !!preserveSpace;\r\n          this.override = override;\r\n          this.generator = !!generator;\r\n        };\r\n      \r\n        var types$1 = {\r\n          b_stat: new TokContext(\"{\", false),\r\n          b_expr: new TokContext(\"{\", true),\r\n          b_tmpl: new TokContext(\"${\", false),\r\n          p_stat: new TokContext(\"(\", false),\r\n          p_expr: new TokContext(\"(\", true),\r\n          q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\r\n          f_stat: new TokContext(\"function\", false),\r\n          f_expr: new TokContext(\"function\", true),\r\n          f_expr_gen: new TokContext(\"function\", true, false, null, true),\r\n          f_gen: new TokContext(\"function\", false, false, null, true)\r\n        };\r\n      \r\n        var pp$7 = Parser.prototype;\r\n      \r\n        pp$7.initialContext = function() {\r\n          return [types$1.b_stat]\r\n        };\r\n      \r\n        pp$7.braceIsBlock = function(prevType) {\r\n          var parent = this.curContext();\r\n          if (parent === types$1.f_expr || parent === types$1.f_stat)\r\n            { return true }\r\n          if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\r\n            { return !parent.isExpr }\r\n      \r\n          if (prevType === types._return || prevType === types.name && this.exprAllowed)\r\n            { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\r\n          if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\r\n            { return true }\r\n          if (prevType === types.braceL)\r\n            { return parent === types$1.b_stat }\r\n          if (prevType === types._var || prevType === types._const || prevType === types.name)\r\n            { return false }\r\n          return !this.exprAllowed\r\n        };\r\n      \r\n        pp$7.inGeneratorContext = function() {\r\n          for (var i = this.context.length - 1; i >= 1; i--) {\r\n            var context = this.context[i];\r\n            if (context.token === \"function\")\r\n              { return context.generator }\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$7.updateContext = function(prevType) {\r\n          var update, type = this.type;\r\n          if (type.keyword && prevType === types.dot)\r\n            { this.exprAllowed = false; }\r\n          else if (update = type.updateContext)\r\n            { update.call(this, prevType); }\r\n          else\r\n            { this.exprAllowed = type.beforeExpr; }\r\n        };\r\n      \r\n      \r\n        types.parenR.updateContext = types.braceR.updateContext = function() {\r\n          if (this.context.length === 1) {\r\n            this.exprAllowed = true;\r\n            return\r\n          }\r\n          var out = this.context.pop();\r\n          if (out === types$1.b_stat && this.curContext().token === \"function\") {\r\n            out = this.context.pop();\r\n          }\r\n          this.exprAllowed = !out.isExpr;\r\n        };\r\n      \r\n        types.braceL.updateContext = function(prevType) {\r\n          this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\r\n          this.exprAllowed = true;\r\n        };\r\n      \r\n        types.dollarBraceL.updateContext = function() {\r\n          this.context.push(types$1.b_tmpl);\r\n          this.exprAllowed = true;\r\n        };\r\n      \r\n        types.parenL.updateContext = function(prevType) {\r\n          var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\r\n          this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\r\n          this.exprAllowed = true;\r\n        };\r\n      \r\n        types.incDec.updateContext = function() {\r\n        };\r\n      \r\n        types._function.updateContext = types._class.updateContext = function(prevType) {\r\n          if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\r\n              !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\r\n              !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\r\n            { this.context.push(types$1.f_expr); }\r\n          else\r\n            { this.context.push(types$1.f_stat); }\r\n          this.exprAllowed = false;\r\n        };\r\n      \r\n        types.backQuote.updateContext = function() {\r\n          if (this.curContext() === types$1.q_tmpl)\r\n            { this.context.pop(); }\r\n          else\r\n            { this.context.push(types$1.q_tmpl); }\r\n          this.exprAllowed = false;\r\n        };\r\n      \r\n        types.star.updateContext = function(prevType) {\r\n          if (prevType === types._function) {\r\n            var index = this.context.length - 1;\r\n            if (this.context[index] === types$1.f_expr)\r\n              { this.context[index] = types$1.f_expr_gen; }\r\n            else\r\n              { this.context[index] = types$1.f_gen; }\r\n          }\r\n          this.exprAllowed = true;\r\n        };\r\n      \r\n        types.name.updateContext = function(prevType) {\r\n          var allowed = false;\r\n          if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\r\n            if (this.value === \"of\" && !this.exprAllowed ||\r\n                this.value === \"yield\" && this.inGeneratorContext())\r\n              { allowed = true; }\r\n          }\r\n          this.exprAllowed = allowed;\r\n        };\r\n      \r\n      \r\n        var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\r\n        var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\r\n        var ecma11BinaryProperties = ecma10BinaryProperties;\r\n        var unicodeBinaryProperties = {\r\n          9: ecma9BinaryProperties,\r\n          10: ecma10BinaryProperties,\r\n          11: ecma11BinaryProperties\r\n        };\r\n      \r\n        var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\r\n      \r\n        var ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\r\n        var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\r\n        var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\r\n        var unicodeScriptValues = {\r\n          9: ecma9ScriptValues,\r\n          10: ecma10ScriptValues,\r\n          11: ecma11ScriptValues\r\n        };\r\n      \r\n        var data = {};\r\n        function buildUnicodeData(ecmaVersion) {\r\n          var d = data[ecmaVersion] = {\r\n            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\r\n            nonBinary: {\r\n              General_Category: wordsRegexp(unicodeGeneralCategoryValues),\r\n              Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\r\n            }\r\n          };\r\n          d.nonBinary.Script_Extensions = d.nonBinary.Script;\r\n      \r\n          d.nonBinary.gc = d.nonBinary.General_Category;\r\n          d.nonBinary.sc = d.nonBinary.Script;\r\n          d.nonBinary.scx = d.nonBinary.Script_Extensions;\r\n        }\r\n        buildUnicodeData(9);\r\n        buildUnicodeData(10);\r\n        buildUnicodeData(11);\r\n      \r\n        var pp$8 = Parser.prototype;\r\n      \r\n        var RegExpValidationState = function RegExpValidationState(parser) {\r\n          this.parser = parser;\r\n          this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\r\n          this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\r\n          this.source = \"\";\r\n          this.flags = \"\";\r\n          this.start = 0;\r\n          this.switchU = false;\r\n          this.switchN = false;\r\n          this.pos = 0;\r\n          this.lastIntValue = 0;\r\n          this.lastStringValue = \"\";\r\n          this.lastAssertionIsQuantifiable = false;\r\n          this.numCapturingParens = 0;\r\n          this.maxBackReference = 0;\r\n          this.groupNames = [];\r\n          this.backReferenceNames = [];\r\n        };\r\n      \r\n        RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\r\n          var unicode = flags.indexOf(\"u\") !== -1;\r\n          this.start = start | 0;\r\n          this.source = pattern + \"\";\r\n          this.flags = flags;\r\n          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\r\n          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\r\n        };\r\n      \r\n        RegExpValidationState.prototype.raise = function raise (message) {\r\n          this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\r\n        };\r\n      \r\n        RegExpValidationState.prototype.at = function at (i) {\r\n          var s = this.source;\r\n          var l = s.length;\r\n          if (i >= l) {\r\n            return -1\r\n          }\r\n          var c = s.charCodeAt(i);\r\n          if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\r\n            return c\r\n          }\r\n          var next = s.charCodeAt(i + 1);\r\n          return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\r\n        };\r\n      \r\n        RegExpValidationState.prototype.nextIndex = function nextIndex (i) {\r\n          var s = this.source;\r\n          var l = s.length;\r\n          if (i >= l) {\r\n            return l\r\n          }\r\n          var c = s.charCodeAt(i), next;\r\n          if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\r\n              (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\r\n            return i + 1\r\n          }\r\n          return i + 2\r\n        };\r\n      \r\n        RegExpValidationState.prototype.current = function current () {\r\n          return this.at(this.pos)\r\n        };\r\n      \r\n        RegExpValidationState.prototype.lookahead = function lookahead () {\r\n          return this.at(this.nextIndex(this.pos))\r\n        };\r\n      \r\n        RegExpValidationState.prototype.advance = function advance () {\r\n          this.pos = this.nextIndex(this.pos);\r\n        };\r\n      \r\n        RegExpValidationState.prototype.eat = function eat (ch) {\r\n          if (this.current() === ch) {\r\n            this.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        function codePointToString(ch) {\r\n          if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\r\n          ch -= 0x10000;\r\n          return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\r\n        }\r\n      \r\n        pp$8.validateRegExpFlags = function(state) {\r\n          var validFlags = state.validFlags;\r\n          var flags = state.flags;\r\n      \r\n          for (var i = 0; i < flags.length; i++) {\r\n            var flag = flags.charAt(i);\r\n            if (validFlags.indexOf(flag) === -1) {\r\n              this.raise(state.start, \"Invalid regular expression flag\");\r\n            }\r\n            if (flags.indexOf(flag, i + 1) > -1) {\r\n              this.raise(state.start, \"Duplicate regular expression flag\");\r\n            }\r\n          }\r\n        };\r\n      \r\n        pp$8.validateRegExpPattern = function(state) {\r\n          this.regexp_pattern(state);\r\n      \r\n          if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\r\n            state.switchN = true;\r\n            this.regexp_pattern(state);\r\n          }\r\n        };\r\n      \r\n        pp$8.regexp_pattern = function(state) {\r\n          state.pos = 0;\r\n          state.lastIntValue = 0;\r\n          state.lastStringValue = \"\";\r\n          state.lastAssertionIsQuantifiable = false;\r\n          state.numCapturingParens = 0;\r\n          state.maxBackReference = 0;\r\n          state.groupNames.length = 0;\r\n          state.backReferenceNames.length = 0;\r\n      \r\n          this.regexp_disjunction(state);\r\n      \r\n          if (state.pos !== state.source.length) {\r\n            if (state.eat(0x29 )) {\r\n              state.raise(\"Unmatched ')'\");\r\n            }\r\n            if (state.eat(0x5D ) || state.eat(0x7D )) {\r\n              state.raise(\"Lone quantifier brackets\");\r\n            }\r\n          }\r\n          if (state.maxBackReference > state.numCapturingParens) {\r\n            state.raise(\"Invalid escape\");\r\n          }\r\n          for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\r\n            var name = list[i];\r\n      \r\n            if (state.groupNames.indexOf(name) === -1) {\r\n              state.raise(\"Invalid named capture referenced\");\r\n            }\r\n          }\r\n        };\r\n      \r\n        pp$8.regexp_disjunction = function(state) {\r\n          this.regexp_alternative(state);\r\n          while (state.eat(0x7C )) {\r\n            this.regexp_alternative(state);\r\n          }\r\n      \r\n          if (this.regexp_eatQuantifier(state, true)) {\r\n            state.raise(\"Nothing to repeat\");\r\n          }\r\n          if (state.eat(0x7B )) {\r\n            state.raise(\"Lone quantifier brackets\");\r\n          }\r\n        };\r\n      \r\n        pp$8.regexp_alternative = function(state) {\r\n          while (state.pos < state.source.length && this.regexp_eatTerm(state))\r\n            { }\r\n        };\r\n      \r\n        pp$8.regexp_eatTerm = function(state) {\r\n          if (this.regexp_eatAssertion(state)) {\r\n            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\r\n              if (state.switchU) {\r\n                state.raise(\"Invalid quantifier\");\r\n              }\r\n            }\r\n            return true\r\n          }\r\n      \r\n          if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\r\n            this.regexp_eatQuantifier(state);\r\n            return true\r\n          }\r\n      \r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatAssertion = function(state) {\r\n          var start = state.pos;\r\n          state.lastAssertionIsQuantifiable = false;\r\n      \r\n          if (state.eat(0x5E ) || state.eat(0x24 )) {\r\n            return true\r\n          }\r\n      \r\n          if (state.eat(0x5C )) {\r\n            if (state.eat(0x42 ) || state.eat(0x62 )) {\r\n              return true\r\n            }\r\n            state.pos = start;\r\n          }\r\n      \r\n          if (state.eat(0x28 ) && state.eat(0x3F )) {\r\n            var lookbehind = false;\r\n            if (this.options.ecmaVersion >= 9) {\r\n              lookbehind = state.eat(0x3C );\r\n            }\r\n            if (state.eat(0x3D ) || state.eat(0x21 )) {\r\n              this.regexp_disjunction(state);\r\n              if (!state.eat(0x29 )) {\r\n                state.raise(\"Unterminated group\");\r\n              }\r\n              state.lastAssertionIsQuantifiable = !lookbehind;\r\n              return true\r\n            }\r\n          }\r\n      \r\n          state.pos = start;\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatQuantifier = function(state, noError) {\r\n          if ( noError === void 0 ) noError = false;\r\n      \r\n          if (this.regexp_eatQuantifierPrefix(state, noError)) {\r\n            state.eat(0x3F );\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatQuantifierPrefix = function(state, noError) {\r\n          return (\r\n            state.eat(0x2A ) ||\r\n            state.eat(0x2B ) ||\r\n            state.eat(0x3F ) ||\r\n            this.regexp_eatBracedQuantifier(state, noError)\r\n          )\r\n        };\r\n        pp$8.regexp_eatBracedQuantifier = function(state, noError) {\r\n          var start = state.pos;\r\n          if (state.eat(0x7B )) {\r\n            var min = 0, max = -1;\r\n            if (this.regexp_eatDecimalDigits(state)) {\r\n              min = state.lastIntValue;\r\n              if (state.eat(0x2C ) && this.regexp_eatDecimalDigits(state)) {\r\n                max = state.lastIntValue;\r\n              }\r\n              if (state.eat(0x7D )) {\r\n                if (max !== -1 && max < min && !noError) {\r\n                  state.raise(\"numbers out of order in {} quantifier\");\r\n                }\r\n                return true\r\n              }\r\n            }\r\n            if (state.switchU && !noError) {\r\n              state.raise(\"Incomplete quantifier\");\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatAtom = function(state) {\r\n          return (\r\n            this.regexp_eatPatternCharacters(state) ||\r\n            state.eat(0x2E ) ||\r\n            this.regexp_eatReverseSolidusAtomEscape(state) ||\r\n            this.regexp_eatCharacterClass(state) ||\r\n            this.regexp_eatUncapturingGroup(state) ||\r\n            this.regexp_eatCapturingGroup(state)\r\n          )\r\n        };\r\n        pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\r\n          var start = state.pos;\r\n          if (state.eat(0x5C )) {\r\n            if (this.regexp_eatAtomEscape(state)) {\r\n              return true\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_eatUncapturingGroup = function(state) {\r\n          var start = state.pos;\r\n          if (state.eat(0x28 )) {\r\n            if (state.eat(0x3F ) && state.eat(0x3A )) {\r\n              this.regexp_disjunction(state);\r\n              if (state.eat(0x29 )) {\r\n                return true\r\n              }\r\n              state.raise(\"Unterminated group\");\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_eatCapturingGroup = function(state) {\r\n          if (state.eat(0x28 )) {\r\n            if (this.options.ecmaVersion >= 9) {\r\n              this.regexp_groupSpecifier(state);\r\n            } else if (state.current() === 0x3F ) {\r\n              state.raise(\"Invalid group\");\r\n            }\r\n            this.regexp_disjunction(state);\r\n            if (state.eat(0x29 )) {\r\n              state.numCapturingParens += 1;\r\n              return true\r\n            }\r\n            state.raise(\"Unterminated group\");\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatExtendedAtom = function(state) {\r\n          return (\r\n            state.eat(0x2E ) ||\r\n            this.regexp_eatReverseSolidusAtomEscape(state) ||\r\n            this.regexp_eatCharacterClass(state) ||\r\n            this.regexp_eatUncapturingGroup(state) ||\r\n            this.regexp_eatCapturingGroup(state) ||\r\n            this.regexp_eatInvalidBracedQuantifier(state) ||\r\n            this.regexp_eatExtendedPatternCharacter(state)\r\n          )\r\n        };\r\n      \r\n        pp$8.regexp_eatInvalidBracedQuantifier = function(state) {\r\n          if (this.regexp_eatBracedQuantifier(state, true)) {\r\n            state.raise(\"Nothing to repeat\");\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatSyntaxCharacter = function(state) {\r\n          var ch = state.current();\r\n          if (isSyntaxCharacter(ch)) {\r\n            state.lastIntValue = ch;\r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n        function isSyntaxCharacter(ch) {\r\n          return (\r\n            ch === 0x24  ||\r\n            ch >= 0x28  && ch <= 0x2B  ||\r\n            ch === 0x2E  ||\r\n            ch === 0x3F  ||\r\n            ch >= 0x5B  && ch <= 0x5E  ||\r\n            ch >= 0x7B  && ch <= 0x7D \r\n          )\r\n        }\r\n      \r\n        pp$8.regexp_eatPatternCharacters = function(state) {\r\n          var start = state.pos;\r\n          var ch = 0;\r\n          while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\r\n            state.advance();\r\n          }\r\n          return state.pos !== start\r\n        };\r\n      \r\n        pp$8.regexp_eatExtendedPatternCharacter = function(state) {\r\n          var ch = state.current();\r\n          if (\r\n            ch !== -1 &&\r\n            ch !== 0x24  &&\r\n            !(ch >= 0x28  && ch <= 0x2B ) &&\r\n            ch !== 0x2E  &&\r\n            ch !== 0x3F  &&\r\n            ch !== 0x5B  &&\r\n            ch !== 0x5E  &&\r\n            ch !== 0x7C \r\n          ) {\r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_groupSpecifier = function(state) {\r\n          if (state.eat(0x3F )) {\r\n            if (this.regexp_eatGroupName(state)) {\r\n              if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\r\n                state.raise(\"Duplicate capture group name\");\r\n              }\r\n              state.groupNames.push(state.lastStringValue);\r\n              return\r\n            }\r\n            state.raise(\"Invalid group\");\r\n          }\r\n        };\r\n      \r\n        pp$8.regexp_eatGroupName = function(state) {\r\n          state.lastStringValue = \"\";\r\n          if (state.eat(0x3C )) {\r\n            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E )) {\r\n              return true\r\n            }\r\n            state.raise(\"Invalid capture group name\");\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatRegExpIdentifierName = function(state) {\r\n          state.lastStringValue = \"\";\r\n          if (this.regexp_eatRegExpIdentifierStart(state)) {\r\n            state.lastStringValue += codePointToString(state.lastIntValue);\r\n            while (this.regexp_eatRegExpIdentifierPart(state)) {\r\n              state.lastStringValue += codePointToString(state.lastIntValue);\r\n            }\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatRegExpIdentifierStart = function(state) {\r\n          var start = state.pos;\r\n          var ch = state.current();\r\n          state.advance();\r\n      \r\n          if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\r\n            ch = state.lastIntValue;\r\n          }\r\n          if (isRegExpIdentifierStart(ch)) {\r\n            state.lastIntValue = ch;\r\n            return true\r\n          }\r\n      \r\n          state.pos = start;\r\n          return false\r\n        };\r\n        function isRegExpIdentifierStart(ch) {\r\n          return isIdentifierStart(ch, true) || ch === 0x24  || ch === 0x5F \r\n        }\r\n      \r\n        pp$8.regexp_eatRegExpIdentifierPart = function(state) {\r\n          var start = state.pos;\r\n          var ch = state.current();\r\n          state.advance();\r\n      \r\n          if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\r\n            ch = state.lastIntValue;\r\n          }\r\n          if (isRegExpIdentifierPart(ch)) {\r\n            state.lastIntValue = ch;\r\n            return true\r\n          }\r\n      \r\n          state.pos = start;\r\n          return false\r\n        };\r\n        function isRegExpIdentifierPart(ch) {\r\n          return isIdentifierChar(ch, true) || ch === 0x24  || ch === 0x5F  || ch === 0x200C  || ch === 0x200D \r\n        }\r\n      \r\n        pp$8.regexp_eatAtomEscape = function(state) {\r\n          if (\r\n            this.regexp_eatBackReference(state) ||\r\n            this.regexp_eatCharacterClassEscape(state) ||\r\n            this.regexp_eatCharacterEscape(state) ||\r\n            (state.switchN && this.regexp_eatKGroupName(state))\r\n          ) {\r\n            return true\r\n          }\r\n          if (state.switchU) {\r\n            if (state.current() === 0x63 ) {\r\n              state.raise(\"Invalid unicode escape\");\r\n            }\r\n            state.raise(\"Invalid escape\");\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_eatBackReference = function(state) {\r\n          var start = state.pos;\r\n          if (this.regexp_eatDecimalEscape(state)) {\r\n            var n = state.lastIntValue;\r\n            if (state.switchU) {\r\n              if (n > state.maxBackReference) {\r\n                state.maxBackReference = n;\r\n              }\r\n              return true\r\n            }\r\n            if (n <= state.numCapturingParens) {\r\n              return true\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_eatKGroupName = function(state) {\r\n          if (state.eat(0x6B )) {\r\n            if (this.regexp_eatGroupName(state)) {\r\n              state.backReferenceNames.push(state.lastStringValue);\r\n              return true\r\n            }\r\n            state.raise(\"Invalid named reference\");\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatCharacterEscape = function(state) {\r\n          return (\r\n            this.regexp_eatControlEscape(state) ||\r\n            this.regexp_eatCControlLetter(state) ||\r\n            this.regexp_eatZero(state) ||\r\n            this.regexp_eatHexEscapeSequence(state) ||\r\n            this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\r\n            (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\r\n            this.regexp_eatIdentityEscape(state)\r\n          )\r\n        };\r\n        pp$8.regexp_eatCControlLetter = function(state) {\r\n          var start = state.pos;\r\n          if (state.eat(0x63 )) {\r\n            if (this.regexp_eatControlLetter(state)) {\r\n              return true\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_eatZero = function(state) {\r\n          if (state.current() === 0x30  && !isDecimalDigit(state.lookahead())) {\r\n            state.lastIntValue = 0;\r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatControlEscape = function(state) {\r\n          var ch = state.current();\r\n          if (ch === 0x74 ) {\r\n            state.lastIntValue = 0x09; \r\n            state.advance();\r\n            return true\r\n          }\r\n          if (ch === 0x6E ) {\r\n            state.lastIntValue = 0x0A; \r\n            state.advance();\r\n            return true\r\n          }\r\n          if (ch === 0x76 ) {\r\n            state.lastIntValue = 0x0B; \r\n            state.advance();\r\n            return true\r\n          }\r\n          if (ch === 0x66 ) {\r\n            state.lastIntValue = 0x0C; \r\n            state.advance();\r\n            return true\r\n          }\r\n          if (ch === 0x72 ) {\r\n            state.lastIntValue = 0x0D; \r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatControlLetter = function(state) {\r\n          var ch = state.current();\r\n          if (isControlLetter(ch)) {\r\n            state.lastIntValue = ch % 0x20;\r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n        function isControlLetter(ch) {\r\n          return (\r\n            (ch >= 0x41  && ch <= 0x5A ) ||\r\n            (ch >= 0x61  && ch <= 0x7A )\r\n          )\r\n        }\r\n      \r\n        pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\r\n          var start = state.pos;\r\n      \r\n          if (state.eat(0x75 )) {\r\n            if (this.regexp_eatFixedHexDigits(state, 4)) {\r\n              var lead = state.lastIntValue;\r\n              if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\r\n                var leadSurrogateEnd = state.pos;\r\n                if (state.eat(0x5C ) && state.eat(0x75 ) && this.regexp_eatFixedHexDigits(state, 4)) {\r\n                  var trail = state.lastIntValue;\r\n                  if (trail >= 0xDC00 && trail <= 0xDFFF) {\r\n                    state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\r\n                    return true\r\n                  }\r\n                }\r\n                state.pos = leadSurrogateEnd;\r\n                state.lastIntValue = lead;\r\n              }\r\n              return true\r\n            }\r\n            if (\r\n              state.switchU &&\r\n              state.eat(0x7B ) &&\r\n              this.regexp_eatHexDigits(state) &&\r\n              state.eat(0x7D ) &&\r\n              isValidUnicode(state.lastIntValue)\r\n            ) {\r\n              return true\r\n            }\r\n            if (state.switchU) {\r\n              state.raise(\"Invalid unicode escape\");\r\n            }\r\n            state.pos = start;\r\n          }\r\n      \r\n          return false\r\n        };\r\n        function isValidUnicode(ch) {\r\n          return ch >= 0 && ch <= 0x10FFFF\r\n        }\r\n      \r\n        pp$8.regexp_eatIdentityEscape = function(state) {\r\n          if (state.switchU) {\r\n            if (this.regexp_eatSyntaxCharacter(state)) {\r\n              return true\r\n            }\r\n            if (state.eat(0x2F )) {\r\n              state.lastIntValue = 0x2F; \r\n              return true\r\n            }\r\n            return false\r\n          }\r\n      \r\n          var ch = state.current();\r\n          if (ch !== 0x63  && (!state.switchN || ch !== 0x6B )) {\r\n            state.lastIntValue = ch;\r\n            state.advance();\r\n            return true\r\n          }\r\n      \r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatDecimalEscape = function(state) {\r\n          state.lastIntValue = 0;\r\n          var ch = state.current();\r\n          if (ch >= 0x31  && ch <= 0x39 ) {\r\n            do {\r\n              state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );\r\n              state.advance();\r\n            } while ((ch = state.current()) >= 0x30  && ch <= 0x39 )\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatCharacterClassEscape = function(state) {\r\n          var ch = state.current();\r\n      \r\n          if (isCharacterClassEscape(ch)) {\r\n            state.lastIntValue = -1;\r\n            state.advance();\r\n            return true\r\n          }\r\n      \r\n          if (\r\n            state.switchU &&\r\n            this.options.ecmaVersion >= 9 &&\r\n            (ch === 0x50  || ch === 0x70 )\r\n          ) {\r\n            state.lastIntValue = -1;\r\n            state.advance();\r\n            if (\r\n              state.eat(0x7B ) &&\r\n              this.regexp_eatUnicodePropertyValueExpression(state) &&\r\n              state.eat(0x7D )\r\n            ) {\r\n              return true\r\n            }\r\n            state.raise(\"Invalid property name\");\r\n          }\r\n      \r\n          return false\r\n        };\r\n        function isCharacterClassEscape(ch) {\r\n          return (\r\n            ch === 0x64  ||\r\n            ch === 0x44  ||\r\n            ch === 0x73  ||\r\n            ch === 0x53  ||\r\n            ch === 0x77  ||\r\n            ch === 0x57 \r\n          )\r\n        }\r\n      \r\n        pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\r\n          var start = state.pos;\r\n      \r\n          if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D )) {\r\n            var name = state.lastStringValue;\r\n            if (this.regexp_eatUnicodePropertyValue(state)) {\r\n              var value = state.lastStringValue;\r\n              this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\r\n              return true\r\n            }\r\n          }\r\n          state.pos = start;\r\n      \r\n          if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\r\n            var nameOrValue = state.lastStringValue;\r\n            this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\r\n          if (!has(state.unicodeProperties.nonBinary, name))\r\n            { state.raise(\"Invalid property name\"); }\r\n          if (!state.unicodeProperties.nonBinary[name].test(value))\r\n            { state.raise(\"Invalid property value\"); }\r\n        };\r\n        pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\r\n          if (!state.unicodeProperties.binary.test(nameOrValue))\r\n            { state.raise(\"Invalid property name\"); }\r\n        };\r\n      \r\n        pp$8.regexp_eatUnicodePropertyName = function(state) {\r\n          var ch = 0;\r\n          state.lastStringValue = \"\";\r\n          while (isUnicodePropertyNameCharacter(ch = state.current())) {\r\n            state.lastStringValue += codePointToString(ch);\r\n            state.advance();\r\n          }\r\n          return state.lastStringValue !== \"\"\r\n        };\r\n        function isUnicodePropertyNameCharacter(ch) {\r\n          return isControlLetter(ch) || ch === 0x5F \r\n        }\r\n      \r\n        pp$8.regexp_eatUnicodePropertyValue = function(state) {\r\n          var ch = 0;\r\n          state.lastStringValue = \"\";\r\n          while (isUnicodePropertyValueCharacter(ch = state.current())) {\r\n            state.lastStringValue += codePointToString(ch);\r\n            state.advance();\r\n          }\r\n          return state.lastStringValue !== \"\"\r\n        };\r\n        function isUnicodePropertyValueCharacter(ch) {\r\n          return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\r\n        }\r\n      \r\n        pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\r\n          return this.regexp_eatUnicodePropertyValue(state)\r\n        };\r\n      \r\n        pp$8.regexp_eatCharacterClass = function(state) {\r\n          if (state.eat(0x5B )) {\r\n            state.eat(0x5E );\r\n            this.regexp_classRanges(state);\r\n            if (state.eat(0x5D )) {\r\n              return true\r\n            }\r\n            state.raise(\"Unterminated character class\");\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_classRanges = function(state) {\r\n          while (this.regexp_eatClassAtom(state)) {\r\n            var left = state.lastIntValue;\r\n            if (state.eat(0x2D ) && this.regexp_eatClassAtom(state)) {\r\n              var right = state.lastIntValue;\r\n              if (state.switchU && (left === -1 || right === -1)) {\r\n                state.raise(\"Invalid character class\");\r\n              }\r\n              if (left !== -1 && right !== -1 && left > right) {\r\n                state.raise(\"Range out of order in character class\");\r\n              }\r\n            }\r\n          }\r\n        };\r\n      \r\n        pp$8.regexp_eatClassAtom = function(state) {\r\n          var start = state.pos;\r\n      \r\n          if (state.eat(0x5C )) {\r\n            if (this.regexp_eatClassEscape(state)) {\r\n              return true\r\n            }\r\n            if (state.switchU) {\r\n              var ch$1 = state.current();\r\n              if (ch$1 === 0x63  || isOctalDigit(ch$1)) {\r\n                state.raise(\"Invalid class escape\");\r\n              }\r\n              state.raise(\"Invalid escape\");\r\n            }\r\n            state.pos = start;\r\n          }\r\n      \r\n          var ch = state.current();\r\n          if (ch !== 0x5D ) {\r\n            state.lastIntValue = ch;\r\n            state.advance();\r\n            return true\r\n          }\r\n      \r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatClassEscape = function(state) {\r\n          var start = state.pos;\r\n      \r\n          if (state.eat(0x62 )) {\r\n            state.lastIntValue = 0x08; \r\n            return true\r\n          }\r\n      \r\n          if (state.switchU && state.eat(0x2D )) {\r\n            state.lastIntValue = 0x2D; \r\n            return true\r\n          }\r\n      \r\n          if (!state.switchU && state.eat(0x63 )) {\r\n            if (this.regexp_eatClassControlLetter(state)) {\r\n              return true\r\n            }\r\n            state.pos = start;\r\n          }\r\n      \r\n          return (\r\n            this.regexp_eatCharacterClassEscape(state) ||\r\n            this.regexp_eatCharacterEscape(state)\r\n          )\r\n        };\r\n      \r\n        pp$8.regexp_eatClassControlLetter = function(state) {\r\n          var ch = state.current();\r\n          if (isDecimalDigit(ch) || ch === 0x5F ) {\r\n            state.lastIntValue = ch % 0x20;\r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatHexEscapeSequence = function(state) {\r\n          var start = state.pos;\r\n          if (state.eat(0x78 )) {\r\n            if (this.regexp_eatFixedHexDigits(state, 2)) {\r\n              return true\r\n            }\r\n            if (state.switchU) {\r\n              state.raise(\"Invalid escape\");\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatDecimalDigits = function(state) {\r\n          var start = state.pos;\r\n          var ch = 0;\r\n          state.lastIntValue = 0;\r\n          while (isDecimalDigit(ch = state.current())) {\r\n            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );\r\n            state.advance();\r\n          }\r\n          return state.pos !== start\r\n        };\r\n        function isDecimalDigit(ch) {\r\n          return ch >= 0x30  && ch <= 0x39 \r\n        }\r\n      \r\n        pp$8.regexp_eatHexDigits = function(state) {\r\n          var start = state.pos;\r\n          var ch = 0;\r\n          state.lastIntValue = 0;\r\n          while (isHexDigit(ch = state.current())) {\r\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\r\n            state.advance();\r\n          }\r\n          return state.pos !== start\r\n        };\r\n        function isHexDigit(ch) {\r\n          return (\r\n            (ch >= 0x30  && ch <= 0x39 ) ||\r\n            (ch >= 0x41  && ch <= 0x46 ) ||\r\n            (ch >= 0x61  && ch <= 0x66 )\r\n          )\r\n        }\r\n        function hexToInt(ch) {\r\n          if (ch >= 0x41  && ch <= 0x46 ) {\r\n            return 10 + (ch - 0x41 )\r\n          }\r\n          if (ch >= 0x61  && ch <= 0x66 ) {\r\n            return 10 + (ch - 0x61 )\r\n          }\r\n          return ch - 0x30 \r\n        }\r\n      \r\n        pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\r\n          if (this.regexp_eatOctalDigit(state)) {\r\n            var n1 = state.lastIntValue;\r\n            if (this.regexp_eatOctalDigit(state)) {\r\n              var n2 = state.lastIntValue;\r\n              if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\r\n                state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\r\n              } else {\r\n                state.lastIntValue = n1 * 8 + n2;\r\n              }\r\n            } else {\r\n              state.lastIntValue = n1;\r\n            }\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatOctalDigit = function(state) {\r\n          var ch = state.current();\r\n          if (isOctalDigit(ch)) {\r\n            state.lastIntValue = ch - 0x30; \r\n            state.advance();\r\n            return true\r\n          }\r\n          state.lastIntValue = 0;\r\n          return false\r\n        };\r\n        function isOctalDigit(ch) {\r\n          return ch >= 0x30  && ch <= 0x37 \r\n        }\r\n      \r\n        pp$8.regexp_eatFixedHexDigits = function(state, length) {\r\n          var start = state.pos;\r\n          state.lastIntValue = 0;\r\n          for (var i = 0; i < length; ++i) {\r\n            var ch = state.current();\r\n            if (!isHexDigit(ch)) {\r\n              state.pos = start;\r\n              return false\r\n            }\r\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\r\n            state.advance();\r\n          }\r\n          return true\r\n        };\r\n      \r\n      \r\n        var Token = function Token(p) {\r\n          this.type = p.type;\r\n          this.value = p.value;\r\n          this.start = p.start;\r\n          this.end = p.end;\r\n          if (p.options.locations)\r\n            { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\r\n          if (p.options.ranges)\r\n            { this.range = [p.start, p.end]; }\r\n        };\r\n      \r\n      \r\n        var pp$9 = Parser.prototype;\r\n      \r\n      \r\n        pp$9.next = function(ignoreEscapeSequenceInKeyword) {\r\n          if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\r\n            { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\r\n          if (this.options.onToken)\r\n            { this.options.onToken(new Token(this)); }\r\n      \r\n          this.lastTokEnd = this.end;\r\n          this.lastTokStart = this.start;\r\n          this.lastTokEndLoc = this.endLoc;\r\n          this.lastTokStartLoc = this.startLoc;\r\n          this.nextToken();\r\n        };\r\n      \r\n        pp$9.getToken = function() {\r\n          this.next();\r\n          return new Token(this)\r\n        };\r\n      \r\n        if (typeof Symbol !== \"undefined\")\r\n          { pp$9[Symbol.iterator] = function() {\r\n            var this$1 = this;\r\n      \r\n            return {\r\n              next: function () {\r\n                var token = this$1.getToken();\r\n                return {\r\n                  done: token.type === types.eof,\r\n                  value: token\r\n                }\r\n              }\r\n            }\r\n          }; }\r\n      \r\n      \r\n        pp$9.curContext = function() {\r\n          return this.context[this.context.length - 1]\r\n        };\r\n      \r\n      \r\n        pp$9.nextToken = function() {\r\n          var curContext = this.curContext();\r\n          if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\r\n      \r\n          this.start = this.pos;\r\n          if (this.options.locations) { this.startLoc = this.curPosition(); }\r\n          if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\r\n      \r\n          if (curContext.override) { return curContext.override(this) }\r\n          else { this.readToken(this.fullCharCodeAtPos()); }\r\n        };\r\n      \r\n        pp$9.readToken = function(code) {\r\n          if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 )\r\n            { return this.readWord() }\r\n      \r\n          return this.getTokenFromCode(code)\r\n        };\r\n      \r\n        pp$9.fullCharCodeAtPos = function() {\r\n          var code = this.input.charCodeAt(this.pos);\r\n          if (code <= 0xd7ff || code >= 0xe000) { return code }\r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          return (code << 10) + next - 0x35fdc00\r\n        };\r\n      \r\n        pp$9.skipBlockComment = function() {\r\n          var startLoc = this.options.onComment && this.curPosition();\r\n          var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\r\n          if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\r\n          this.pos = end + 2;\r\n          if (this.options.locations) {\r\n            lineBreakG.lastIndex = start;\r\n            var match;\r\n            while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\r\n              ++this.curLine;\r\n              this.lineStart = match.index + match[0].length;\r\n            }\r\n          }\r\n          if (this.options.onComment)\r\n            { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\r\n                                   startLoc, this.curPosition()); }\r\n        };\r\n      \r\n        pp$9.skipLineComment = function(startSkip) {\r\n          var start = this.pos;\r\n          var startLoc = this.options.onComment && this.curPosition();\r\n          var ch = this.input.charCodeAt(this.pos += startSkip);\r\n          while (this.pos < this.input.length && !isNewLine(ch)) {\r\n            ch = this.input.charCodeAt(++this.pos);\r\n          }\r\n          if (this.options.onComment)\r\n            { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\r\n                                   startLoc, this.curPosition()); }\r\n        };\r\n      \r\n      \r\n        pp$9.skipSpace = function() {\r\n          loop: while (this.pos < this.input.length) {\r\n            var ch = this.input.charCodeAt(this.pos);\r\n            switch (ch) {\r\n            case 32: case 160: \r\n              ++this.pos;\r\n              break\r\n            case 13:\r\n              if (this.input.charCodeAt(this.pos + 1) === 10) {\r\n                ++this.pos;\r\n              }\r\n            case 10: case 8232: case 8233:\r\n              ++this.pos;\r\n              if (this.options.locations) {\r\n                ++this.curLine;\r\n                this.lineStart = this.pos;\r\n              }\r\n              break\r\n            case 47: \r\n              switch (this.input.charCodeAt(this.pos + 1)) {\r\n              case 42: \r\n                this.skipBlockComment();\r\n                break\r\n              case 47:\r\n                this.skipLineComment(2);\r\n                break\r\n              default:\r\n                break loop\r\n              }\r\n              break\r\n            default:\r\n              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\r\n                ++this.pos;\r\n              } else {\r\n                break loop\r\n              }\r\n            }\r\n          }\r\n        };\r\n      \r\n      \r\n        pp$9.finishToken = function(type, val) {\r\n          this.end = this.pos;\r\n          if (this.options.locations) { this.endLoc = this.curPosition(); }\r\n          var prevType = this.type;\r\n          this.type = type;\r\n          this.value = val;\r\n      \r\n          this.updateContext(prevType);\r\n        };\r\n      \r\n      \r\n        pp$9.readToken_dot = function() {\r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (next >= 48 && next <= 57) { return this.readNumber(true) }\r\n          var next2 = this.input.charCodeAt(this.pos + 2);\r\n          if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { \r\n            this.pos += 3;\r\n            return this.finishToken(types.ellipsis)\r\n          } else {\r\n            ++this.pos;\r\n            return this.finishToken(types.dot)\r\n          }\r\n        };\r\n      \r\n        pp$9.readToken_slash = function() { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\r\n          if (next === 61) { return this.finishOp(types.assign, 2) }\r\n          return this.finishOp(types.slash, 1)\r\n        };\r\n      \r\n        pp$9.readToken_mult_modulo_exp = function(code) { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          var size = 1;\r\n          var tokentype = code === 42 ? types.star : types.modulo;\r\n      \r\n          if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\r\n            ++size;\r\n            tokentype = types.starstar;\r\n            next = this.input.charCodeAt(this.pos + 2);\r\n          }\r\n      \r\n          if (next === 61) { return this.finishOp(types.assign, size + 1) }\r\n          return this.finishOp(tokentype, size)\r\n        };\r\n      \r\n        pp$9.readToken_pipe_amp = function(code) { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\r\n          if (next === 61) { return this.finishOp(types.assign, 2) }\r\n          return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\r\n        };\r\n      \r\n        pp$9.readToken_caret = function() { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (next === 61) { return this.finishOp(types.assign, 2) }\r\n          return this.finishOp(types.bitwiseXOR, 1)\r\n        };\r\n      \r\n        pp$9.readToken_plus_min = function(code) { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (next === code) {\r\n            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\r\n                (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\r\n              this.skipLineComment(3);\r\n              this.skipSpace();\r\n              return this.nextToken()\r\n            }\r\n            return this.finishOp(types.incDec, 2)\r\n          }\r\n          if (next === 61) { return this.finishOp(types.assign, 2) }\r\n          return this.finishOp(types.plusMin, 1)\r\n        };\r\n      \r\n        pp$9.readToken_lt_gt = function(code) { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          var size = 1;\r\n          if (next === code) {\r\n            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\r\n            if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\r\n            return this.finishOp(types.bitShift, size)\r\n          }\r\n          if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\r\n              this.input.charCodeAt(this.pos + 3) === 45) {\r\n            this.skipLineComment(4);\r\n            this.skipSpace();\r\n            return this.nextToken()\r\n          }\r\n          if (next === 61) { size = 2; }\r\n          return this.finishOp(types.relational, size)\r\n        };\r\n      \r\n        pp$9.readToken_eq_excl = function(code) { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\r\n          if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { \r\n            this.pos += 2;\r\n            return this.finishToken(types.arrow)\r\n          }\r\n          return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\r\n        };\r\n      \r\n        pp$9.getTokenFromCode = function(code) {\r\n          switch (code) {\r\n          case 46: \r\n            return this.readToken_dot()\r\n      \r\n          case 40: ++this.pos; return this.finishToken(types.parenL)\r\n          case 41: ++this.pos; return this.finishToken(types.parenR)\r\n          case 59: ++this.pos; return this.finishToken(types.semi)\r\n          case 44: ++this.pos; return this.finishToken(types.comma)\r\n          case 91: ++this.pos; return this.finishToken(types.bracketL)\r\n          case 93: ++this.pos; return this.finishToken(types.bracketR)\r\n          case 123: ++this.pos; return this.finishToken(types.braceL)\r\n          case 125: ++this.pos; return this.finishToken(types.braceR)\r\n          case 58: ++this.pos; return this.finishToken(types.colon)\r\n          case 63: ++this.pos; return this.finishToken(types.question)\r\n      \r\n          case 96: \r\n            if (this.options.ecmaVersion < 6) { break }\r\n            ++this.pos;\r\n            return this.finishToken(types.backQuote)\r\n      \r\n          case 48: \r\n            var next = this.input.charCodeAt(this.pos + 1);\r\n            if (next === 120 || next === 88) { return this.readRadixNumber(16) } \r\n            if (this.options.ecmaVersion >= 6) {\r\n              if (next === 111 || next === 79) { return this.readRadixNumber(8) } \r\n              if (next === 98 || next === 66) { return this.readRadixNumber(2) } \r\n            }\r\n      \r\n          case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: \r\n            return this.readNumber(false)\r\n      \r\n          case 34: case 39: \r\n            return this.readString(code)\r\n      \r\n      \r\n          case 47: \r\n            return this.readToken_slash()\r\n      \r\n          case 37: case 42: \r\n            return this.readToken_mult_modulo_exp(code)\r\n      \r\n          case 124: case 38: \r\n            return this.readToken_pipe_amp(code)\r\n      \r\n          case 94: \r\n            return this.readToken_caret()\r\n      \r\n          case 43: case 45: \r\n            return this.readToken_plus_min(code)\r\n      \r\n          case 60: case 62: \r\n            return this.readToken_lt_gt(code)\r\n      \r\n          case 61: case 33: \r\n            return this.readToken_eq_excl(code)\r\n      \r\n          case 126: \r\n            return this.finishOp(types.prefix, 1)\r\n          }\r\n      \r\n          this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\r\n        };\r\n      \r\n        pp$9.finishOp = function(type, size) {\r\n          var str = this.input.slice(this.pos, this.pos + size);\r\n          this.pos += size;\r\n          return this.finishToken(type, str)\r\n        };\r\n      \r\n        pp$9.readRegexp = function() {\r\n          var escaped, inClass, start = this.pos;\r\n          for (;;) {\r\n            if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\r\n            var ch = this.input.charAt(this.pos);\r\n            if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\r\n            if (!escaped) {\r\n              if (ch === \"[\") { inClass = true; }\r\n              else if (ch === \"]\" && inClass) { inClass = false; }\r\n              else if (ch === \"/\" && !inClass) { break }\r\n              escaped = ch === \"\\\\\";\r\n            } else { escaped = false; }\r\n            ++this.pos;\r\n          }\r\n          var pattern = this.input.slice(start, this.pos);\r\n          ++this.pos;\r\n          var flagsStart = this.pos;\r\n          var flags = this.readWord1();\r\n          if (this.containsEsc) { this.unexpected(flagsStart); }\r\n      \r\n          var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\r\n          state.reset(start, pattern, flags);\r\n          this.validateRegExpFlags(state);\r\n          this.validateRegExpPattern(state);\r\n      \r\n          var value = null;\r\n          try {\r\n            value = new RegExp(pattern, flags);\r\n          } catch (e) {\r\n          }\r\n      \r\n          return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\r\n        };\r\n      \r\n      \r\n        pp$9.readInt = function(radix, len) {\r\n          var start = this.pos, total = 0;\r\n          for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\r\n            var code = this.input.charCodeAt(this.pos), val = (void 0);\r\n            if (code >= 97) { val = code - 97 + 10; } \r\n            else if (code >= 65) { val = code - 65 + 10; } \r\n            else if (code >= 48 && code <= 57) { val = code - 48; } \r\n            else { val = Infinity; }\r\n            if (val >= radix) { break }\r\n            ++this.pos;\r\n            total = total * radix + val;\r\n          }\r\n          if (this.pos === start || len != null && this.pos - start !== len) { return null }\r\n      \r\n          return total\r\n        };\r\n      \r\n        pp$9.readRadixNumber = function(radix) {\r\n          var start = this.pos;\r\n          this.pos += 2; \r\n          var val = this.readInt(radix);\r\n          if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\r\n          if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\r\n            val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\r\n            ++this.pos;\r\n          } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\r\n          return this.finishToken(types.num, val)\r\n        };\r\n      \r\n      \r\n        pp$9.readNumber = function(startsWithDot) {\r\n          var start = this.pos;\r\n          if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\r\n          var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\r\n          if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\r\n          var next = this.input.charCodeAt(this.pos);\r\n          if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\r\n            var str$1 = this.input.slice(start, this.pos);\r\n            var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\r\n            ++this.pos;\r\n            if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\r\n            return this.finishToken(types.num, val$1)\r\n          }\r\n          if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\r\n          if (next === 46 && !octal) { \r\n            ++this.pos;\r\n            this.readInt(10);\r\n            next = this.input.charCodeAt(this.pos);\r\n          }\r\n          if ((next === 69 || next === 101) && !octal) { \r\n            next = this.input.charCodeAt(++this.pos);\r\n            if (next === 43 || next === 45) { ++this.pos; } \r\n            if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\r\n          }\r\n          if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\r\n      \r\n          var str = this.input.slice(start, this.pos);\r\n          var val = octal ? parseInt(str, 8) : parseFloat(str);\r\n          return this.finishToken(types.num, val)\r\n        };\r\n      \r\n      \r\n        pp$9.readCodePoint = function() {\r\n          var ch = this.input.charCodeAt(this.pos), code;\r\n      \r\n          if (ch === 123) { \r\n            if (this.options.ecmaVersion < 6) { this.unexpected(); }\r\n            var codePos = ++this.pos;\r\n            code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\r\n            ++this.pos;\r\n            if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\r\n          } else {\r\n            code = this.readHexChar(4);\r\n          }\r\n          return code\r\n        };\r\n      \r\n        function codePointToString$1(code) {\r\n          if (code <= 0xFFFF) { return String.fromCharCode(code) }\r\n          code -= 0x10000;\r\n          return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\r\n        }\r\n      \r\n        pp$9.readString = function(quote) {\r\n          var out = \"\", chunkStart = ++this.pos;\r\n          for (;;) {\r\n            if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\r\n            var ch = this.input.charCodeAt(this.pos);\r\n            if (ch === quote) { break }\r\n            if (ch === 92) { \r\n              out += this.input.slice(chunkStart, this.pos);\r\n              out += this.readEscapedChar(false);\r\n              chunkStart = this.pos;\r\n            } else {\r\n              if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\r\n              ++this.pos;\r\n            }\r\n          }\r\n          out += this.input.slice(chunkStart, this.pos++);\r\n          return this.finishToken(types.string, out)\r\n        };\r\n      \r\n      \r\n        var INVALID_TEMPLATE_ESCAPE_ERROR = {};\r\n      \r\n        pp$9.tryReadTemplateToken = function() {\r\n          this.inTemplateElement = true;\r\n          try {\r\n            this.readTmplToken();\r\n          } catch (err) {\r\n            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\r\n              this.readInvalidTemplateToken();\r\n            } else {\r\n              throw err\r\n            }\r\n          }\r\n      \r\n          this.inTemplateElement = false;\r\n        };\r\n      \r\n        pp$9.invalidStringToken = function(position, message) {\r\n          if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\r\n            throw INVALID_TEMPLATE_ESCAPE_ERROR\r\n          } else {\r\n            this.raise(position, message);\r\n          }\r\n        };\r\n      \r\n        pp$9.readTmplToken = function() {\r\n          var out = \"\", chunkStart = this.pos;\r\n          for (;;) {\r\n            if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\r\n            var ch = this.input.charCodeAt(this.pos);\r\n            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { \r\n              if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\r\n                if (ch === 36) {\r\n                  this.pos += 2;\r\n                  return this.finishToken(types.dollarBraceL)\r\n                } else {\r\n                  ++this.pos;\r\n                  return this.finishToken(types.backQuote)\r\n                }\r\n              }\r\n              out += this.input.slice(chunkStart, this.pos);\r\n              return this.finishToken(types.template, out)\r\n            }\r\n            if (ch === 92) { \r\n              out += this.input.slice(chunkStart, this.pos);\r\n              out += this.readEscapedChar(true);\r\n              chunkStart = this.pos;\r\n            } else if (isNewLine(ch)) {\r\n              out += this.input.slice(chunkStart, this.pos);\r\n              ++this.pos;\r\n              switch (ch) {\r\n              case 13:\r\n                if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\r\n              case 10:\r\n                out += \"\\n\";\r\n                break\r\n              default:\r\n                out += String.fromCharCode(ch);\r\n                break\r\n              }\r\n              if (this.options.locations) {\r\n                ++this.curLine;\r\n                this.lineStart = this.pos;\r\n              }\r\n              chunkStart = this.pos;\r\n            } else {\r\n              ++this.pos;\r\n            }\r\n          }\r\n        };\r\n      \r\n        pp$9.readInvalidTemplateToken = function() {\r\n          for (; this.pos < this.input.length; this.pos++) {\r\n            switch (this.input[this.pos]) {\r\n            case \"\\\\\":\r\n              ++this.pos;\r\n              break\r\n      \r\n            case \"$\":\r\n              if (this.input[this.pos + 1] !== \"{\") {\r\n                break\r\n              }\r\n      \r\n            case \"`\":\r\n              return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\r\n      \r\n            }\r\n          }\r\n          this.raise(this.start, \"Unterminated template\");\r\n        };\r\n      \r\n      \r\n        pp$9.readEscapedChar = function(inTemplate) {\r\n          var ch = this.input.charCodeAt(++this.pos);\r\n          ++this.pos;\r\n          switch (ch) {\r\n          case 110: return \"\\n\" \r\n          case 114: return \"\\r\" \r\n          case 120: return String.fromCharCode(this.readHexChar(2)) \r\n          case 117: return codePointToString$1(this.readCodePoint()) \r\n          case 116: return \"\\t\" \r\n          case 98: return \"\\b\" \r\n          case 118: return \"\\u000b\" \r\n          case 102: return \"\\f\" \r\n          case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } \r\n          case 10: \r\n            if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\r\n            return \"\"\r\n          case 56:\r\n          case 57:\r\n            if (inTemplate) {\r\n              var codePos = this.pos - 1;\r\n      \r\n              this.invalidStringToken(\r\n                codePos,\r\n                \"Invalid escape sequence in template string\"\r\n              );\r\n      \r\n              return null\r\n            }\r\n          default:\r\n            if (ch >= 48 && ch <= 55) {\r\n              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\r\n              var octal = parseInt(octalStr, 8);\r\n              if (octal > 255) {\r\n                octalStr = octalStr.slice(0, -1);\r\n                octal = parseInt(octalStr, 8);\r\n              }\r\n              this.pos += octalStr.length - 1;\r\n              ch = this.input.charCodeAt(this.pos);\r\n              if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\r\n                this.invalidStringToken(\r\n                  this.pos - 1 - octalStr.length,\r\n                  inTemplate\r\n                    ? \"Octal literal in template string\"\r\n                    : \"Octal literal in strict mode\"\r\n                );\r\n              }\r\n              return String.fromCharCode(octal)\r\n            }\r\n            if (isNewLine(ch)) {\r\n              return \"\"\r\n            }\r\n            return String.fromCharCode(ch)\r\n          }\r\n        };\r\n      \r\n      \r\n        pp$9.readHexChar = function(len) {\r\n          var codePos = this.pos;\r\n          var n = this.readInt(16, len);\r\n          if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\r\n          return n\r\n        };\r\n      \r\n      \r\n        pp$9.readWord1 = function() {\r\n          this.containsEsc = false;\r\n          var word = \"\", first = true, chunkStart = this.pos;\r\n          var astral = this.options.ecmaVersion >= 6;\r\n          while (this.pos < this.input.length) {\r\n            var ch = this.fullCharCodeAtPos();\r\n            if (isIdentifierChar(ch, astral)) {\r\n              this.pos += ch <= 0xffff ? 1 : 2;\r\n            } else if (ch === 92) { \r\n              this.containsEsc = true;\r\n              word += this.input.slice(chunkStart, this.pos);\r\n              var escStart = this.pos;\r\n              if (this.input.charCodeAt(++this.pos) !== 117) \r\n                { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\r\n              ++this.pos;\r\n              var esc = this.readCodePoint();\r\n              if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\r\n                { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\r\n              word += codePointToString$1(esc);\r\n              chunkStart = this.pos;\r\n            } else {\r\n              break\r\n            }\r\n            first = false;\r\n          }\r\n          return word + this.input.slice(chunkStart, this.pos)\r\n        };\r\n      \r\n      \r\n        pp$9.readWord = function() {\r\n          var word = this.readWord1();\r\n          var type = types.name;\r\n          if (this.keywords.test(word)) {\r\n            type = keywords$1[word];\r\n          }\r\n          return this.finishToken(type, word)\r\n        };\r\n      \r\n      \r\n        var version = \"7.1.0\";\r\n      \r\n        Parser.acorn = {\r\n          Parser: Parser,\r\n          version: version,\r\n          defaultOptions: defaultOptions,\r\n          Position: Position,\r\n          SourceLocation: SourceLocation,\r\n          getLineInfo: getLineInfo,\r\n          Node: Node,\r\n          TokenType: TokenType,\r\n          tokTypes: types,\r\n          keywordTypes: keywords$1,\r\n          TokContext: TokContext,\r\n          tokContexts: types$1,\r\n          isIdentifierChar: isIdentifierChar,\r\n          isIdentifierStart: isIdentifierStart,\r\n          Token: Token,\r\n          isNewLine: isNewLine,\r\n          lineBreak: lineBreak,\r\n          lineBreakG: lineBreakG,\r\n          nonASCIIwhitespace: nonASCIIwhitespace\r\n        };\r\n      \r\n      \r\n        function parse(input, options) {\r\n          return Parser.parse(input, options)\r\n        }\r\n      \r\n      \r\n        function parseExpressionAt(input, pos, options) {\r\n          return Parser.parseExpressionAt(input, pos, options)\r\n        }\r\n      \r\n      \r\n        function tokenizer(input, options) {\r\n          return Parser.tokenizer(input, options)\r\n        }\r\n      \r\n        exports.Node = Node;\r\n        exports.Parser = Parser;\r\n        exports.Position = Position;\r\n        exports.SourceLocation = SourceLocation;\r\n        exports.TokContext = TokContext;\r\n        exports.Token = Token;\r\n        exports.TokenType = TokenType;\r\n        exports.defaultOptions = defaultOptions;\r\n        exports.getLineInfo = getLineInfo;\r\n        exports.isIdentifierChar = isIdentifierChar;\r\n        exports.isIdentifierStart = isIdentifierStart;\r\n        exports.isNewLine = isNewLine;\r\n        exports.keywordTypes = keywords$1;\r\n        exports.lineBreak = lineBreak;\r\n        exports.lineBreakG = lineBreakG;\r\n        exports.nonASCIIwhitespace = nonASCIIwhitespace;\r\n        exports.parse = parse;\r\n        exports.parseExpressionAt = parseExpressionAt;\r\n        exports.tokContexts = types$1;\r\n        exports.tokTypes = types;\r\n        exports.tokenizer = tokenizer;\r\n        exports.version = version;\r\n      \r\n        Object.defineProperty(exports, '__esModule', { value: true });\r\n      \r\n      }));\r\n      \r\n      },{}],2:[function(require,module,exports){\r\n      \r\n      },{}],3:[function(require,module,exports){\r\n      function glWiretap(gl, options = {}) {\r\n        const {\r\n          contextName = 'gl',\r\n          throwGetError,\r\n          useTrackablePrimitives,\r\n          readPixelsFile,\r\n          recording = [],\r\n          variables = {},\r\n          onReadPixels,\r\n          onUnrecognizedArgumentLookup,\r\n        } = options;\r\n        const proxy = new Proxy(gl, { get: listen });\r\n        const contextVariables = [];\r\n        const entityNames = {};\r\n        let imageCount = 0;\r\n        let indent = '';\r\n        let readPixelsVariableName;\r\n        return proxy;\r\n        function listen(obj, property) {\r\n          switch (property) {\r\n            case 'addComment': return addComment;\r\n            case 'checkThrowError': return checkThrowError;\r\n            case 'getReadPixelsVariableName': return readPixelsVariableName;\r\n            case 'insertVariable': return insertVariable;\r\n            case 'reset': return reset;\r\n            case 'setIndent': return setIndent;\r\n            case 'toString': return toString;\r\n            case 'getContextVariableName': return getContextVariableName;\r\n          }\r\n          if (typeof gl[property] === 'function') {\r\n            return function() { \r\n              switch (property) {\r\n                case 'getError':\r\n                  if (throwGetError) {\r\n                    recording.push(`${indent}if (${contextName}.getError() !== ${contextName}.NONE) throw new Error('error');`);\r\n                  } else {\r\n                    recording.push(`${indent}${contextName}.getError();`); \r\n                  }\r\n                  return gl.getError();\r\n                case 'getExtension': {\r\n                  const variableName = `${contextName}Variables${contextVariables.length}`;\r\n                  recording.push(`${indent}const ${variableName} = ${contextName}.getExtension('${arguments[0]}');`);\r\n                  const extension = gl.getExtension(arguments[0]);\r\n                  if (extension && typeof extension === 'object') {\r\n                    const tappedExtension = glExtensionWiretap(extension, {\r\n                      getEntity,\r\n                      useTrackablePrimitives,\r\n                      recording,\r\n                      contextName: variableName,\r\n                      contextVariables,\r\n                      variables,\r\n                      indent,\r\n                      onUnrecognizedArgumentLookup,\r\n                    });\r\n                    contextVariables.push(tappedExtension);\r\n                    return tappedExtension;\r\n                  } else {\r\n                    contextVariables.push(null);\r\n                  }\r\n                  return extension;\r\n                }\r\n                case 'readPixels':\r\n                  const i = contextVariables.indexOf(arguments[6]);\r\n                  let targetVariableName;\r\n                  if (i === -1) {\r\n                    const variableName = getVariableName(arguments[6]);\r\n                    if (variableName) {\r\n                      targetVariableName = variableName;\r\n                      recording.push(`${indent}${variableName}`);\r\n                    } else {\r\n                      targetVariableName = `${contextName}Variable${contextVariables.length}`;\r\n                      contextVariables.push(arguments[6]);\r\n                      recording.push(`${indent}const ${targetVariableName} = new ${arguments[6].constructor.name}(${arguments[6].length});`);\r\n                    }\r\n                  } else {\r\n                    targetVariableName = `${contextName}Variable${i}`;\r\n                  }\r\n                  readPixelsVariableName = targetVariableName;\r\n                  const argumentAsStrings = [\r\n                    arguments[0],\r\n                    arguments[1],\r\n                    arguments[2],\r\n                    arguments[3],\r\n                    getEntity(arguments[4]),\r\n                    getEntity(arguments[5]),\r\n                    targetVariableName\r\n                  ];\r\n                  recording.push(`${indent}${contextName}.readPixels(${argumentAsStrings.join(', ')});`);\r\n                  if (readPixelsFile) {\r\n                    writePPM(arguments[2], arguments[3]);\r\n                  }\r\n                  if (onReadPixels) {\r\n                    onReadPixels(targetVariableName, argumentAsStrings);\r\n                  }\r\n                  return gl.readPixels.apply(gl, arguments);\r\n                case 'drawBuffers':\r\n                  recording.push(`${indent}${contextName}.drawBuffers([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup } )}]);`);\r\n                  return gl.drawBuffers(arguments[0]);\r\n              }\r\n              let result = gl[property].apply(gl, arguments);\r\n              switch (typeof result) {\r\n                case 'undefined':\r\n                  recording.push(`${indent}${methodCallToString(property, arguments)};`);\r\n                  return;\r\n                case 'number':\r\n                case 'boolean':\r\n                  if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {\r\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\r\n                    contextVariables.push(result = trackablePrimitive(result));\r\n                    break;\r\n                  }\r\n                default:\r\n                  if (result === null) {\r\n                    recording.push(`${methodCallToString(property, arguments)};`);\r\n                  } else {\r\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\r\n                  }\r\n      \r\n                  contextVariables.push(result);\r\n              }\r\n              return result;\r\n            }\r\n          }\r\n          entityNames[gl[property]] = property;\r\n          return gl[property];\r\n        }\r\n        function toString() {\r\n          return recording.join('\\n');\r\n        }\r\n        function reset() {\r\n          while (recording.length > 0) {\r\n            recording.pop();\r\n          }\r\n        }\r\n        function insertVariable(name, value) {\r\n          variables[name] = value;\r\n        }\r\n        function getEntity(value) {\r\n          const name = entityNames[value];\r\n          if (name) {\r\n            return contextName + '.' + name;\r\n          }\r\n          return value;\r\n        }\r\n        function setIndent(spaces) {\r\n          indent = ' '.repeat(spaces);\r\n        }\r\n        function addVariable(value, source) {\r\n          const variableName = `${contextName}Variable${contextVariables.length}`;\r\n          recording.push(`${indent}const ${variableName} = ${source};`);\r\n          contextVariables.push(value);\r\n          return variableName;\r\n        }\r\n        function writePPM(width, height) {\r\n          const sourceVariable = `${contextName}Variable${contextVariables.length}`;\r\n          const imageVariable = `imageDatum${imageCount}`;\r\n          recording.push(`${indent}let ${imageVariable} = [\"P3\\\\n# ${readPixelsFile}.ppm\\\\n\", ${width}, ' ', ${height}, \"\\\\n255\\\\n\"].join(\"\");`);\r\n          recording.push(`${indent}for (let i = 0; i < ${imageVariable}.length; i += 4) {`);\r\n          recording.push(`${indent}  ${imageVariable} += ${sourceVariable}[i] + ' ' + ${sourceVariable}[i + 1] + ' ' + ${sourceVariable}[i + 2] + ' ';`);\r\n          recording.push(`${indent}}`);\r\n          recording.push(`${indent}if (typeof require !== \"undefined\") {`);\r\n          recording.push(`${indent}  require('fs').writeFileSync('./${readPixelsFile}.ppm', ${imageVariable});`);\r\n          recording.push(`${indent}}`);\r\n          imageCount++;\r\n        }\r\n        function addComment(value) {\r\n          recording.push(`${indent}// ${value}`);\r\n        }\r\n        function checkThrowError() {\r\n          recording.push(`${indent}(() => {\r\n      ${indent}const error = ${contextName}.getError();\r\n      ${indent}if (error !== ${contextName}.NONE) {\r\n      ${indent}  const names = Object.getOwnPropertyNames(gl);\r\n      ${indent}  for (let i = 0; i < names.length; i++) {\r\n      ${indent}    const name = names[i];\r\n      ${indent}    if (${contextName}[name] === error) {\r\n      ${indent}      throw new Error('${contextName} threw ' + name);\r\n      ${indent}    }\r\n      ${indent}  }\r\n      ${indent}}\r\n      ${indent}})();`);\r\n        }\r\n        function methodCallToString(method, args) {\r\n          return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;\r\n        }\r\n      \r\n        function getVariableName(value) {\r\n          if (variables) {\r\n            for (const name in variables) {\r\n              if (variables[name] === value) {\r\n                return name;\r\n              }\r\n            }\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        function getContextVariableName(value) {\r\n          const i = contextVariables.indexOf(value);\r\n          if (i !== -1) {\r\n            return `${contextName}Variable${i}`;\r\n          }\r\n          return null;\r\n        }\r\n      }\r\n      \r\n      function glExtensionWiretap(extension, options) {\r\n        const proxy = new Proxy(extension, { get: listen });\r\n        const extensionEntityNames = {};\r\n        const {\r\n          contextName,\r\n          contextVariables,\r\n          getEntity,\r\n          useTrackablePrimitives,\r\n          recording,\r\n          variables,\r\n          indent,\r\n          onUnrecognizedArgumentLookup,\r\n        } = options;\r\n        return proxy;\r\n        function listen(obj, property) {\r\n          if (typeof obj[property] === 'function') {\r\n            return function() {\r\n              switch (property) {\r\n                case 'drawBuffersWEBGL':\r\n                  recording.push(`${indent}${contextName}.drawBuffersWEBGL([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })}]);`);\r\n                  return extension.drawBuffersWEBGL(arguments[0]);\r\n              }\r\n              let result = extension[property].apply(extension, arguments);\r\n              switch (typeof result) {\r\n                case 'undefined':\r\n                  recording.push(`${indent}${methodCallToString(property, arguments)};`);\r\n                  return;\r\n                case 'number':\r\n                case 'boolean':\r\n                  if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {\r\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\r\n                    contextVariables.push(result = trackablePrimitive(result));\r\n                  } else {\r\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\r\n                    contextVariables.push(result);\r\n                  }\r\n                  break;\r\n                default:\r\n                  if (result === null) {\r\n                    recording.push(`${methodCallToString(property, arguments)};`);\r\n                  } else {\r\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\r\n                  }\r\n                  contextVariables.push(result);\r\n              }\r\n              return result;\r\n            };\r\n          }\r\n          extensionEntityNames[extension[property]] = property;\r\n          return extension[property];\r\n        }\r\n      \r\n        function getExtensionEntity(value) {\r\n          if (extensionEntityNames.hasOwnProperty(value)) {\r\n            return `${contextName}.${extensionEntityNames[value]}`;\r\n          }\r\n          return getEntity(value);\r\n        }\r\n      \r\n        function methodCallToString(method, args) {\r\n          return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;\r\n        }\r\n      \r\n        function addVariable(value, source) {\r\n          const variableName = `${contextName}Variable${contextVariables.length}`;\r\n          contextVariables.push(value);\r\n          recording.push(`${indent}const ${variableName} = ${source};`);\r\n          return variableName;\r\n        }\r\n      }\r\n      \r\n      function argumentsToString(args, options) {\r\n        const { variables, onUnrecognizedArgumentLookup } = options;\r\n        return (Array.from(args).map((arg) => {\r\n          const variableName = getVariableName(arg);\r\n          if (variableName) {\r\n            return variableName;\r\n          }\r\n          return argumentToString(arg, options);\r\n        }).join(', '));\r\n      \r\n        function getVariableName(value) {\r\n          if (variables) {\r\n            for (const name in variables) {\r\n              if (!variables.hasOwnProperty(name)) continue;\r\n              if (variables[name] === value) {\r\n                return name;\r\n              }\r\n            }\r\n          }\r\n          if (onUnrecognizedArgumentLookup) {\r\n            return onUnrecognizedArgumentLookup(value);\r\n          }\r\n          return null;\r\n        }\r\n      }\r\n      \r\n      function argumentToString(arg, options) {\r\n        const { contextName, contextVariables, getEntity, addVariable, onUnrecognizedArgumentLookup } = options;\r\n        if (typeof arg === 'undefined') {\r\n          return 'undefined';\r\n        }\r\n        if (arg === null) {\r\n          return 'null';\r\n        }\r\n        const i = contextVariables.indexOf(arg);\r\n        if (i > -1) {\r\n          return `${contextName}Variable${i}`;\r\n        }\r\n        switch (arg.constructor.name) {\r\n          case 'String':\r\n            const hasLines = /\\n/.test(arg);\r\n            const hasSingleQuotes = /'/.test(arg);\r\n            const hasDoubleQuotes = /\"/.test(arg);\r\n            if (hasLines) {\r\n              return '`' + arg + '`';\r\n            } else if (hasSingleQuotes && !hasDoubleQuotes) {\r\n              return '\"' + arg + '\"';\r\n            } else if (!hasSingleQuotes && hasDoubleQuotes) {\r\n              return \"'\" + arg + \"'\";\r\n            } else {\r\n              return '\\'' + arg + '\\'';\r\n            }\r\n          case 'Number': return getEntity(arg);\r\n          case 'Boolean': return getEntity(arg);\r\n          case 'Array':\r\n            return addVariable(arg, `new ${arg.constructor.name}([${Array.from(arg).join(',')}])`);\r\n          case 'Float32Array':\r\n          case 'Uint8Array':\r\n          case 'Uint16Array':\r\n          case 'Int32Array':\r\n            return addVariable(arg, `new ${arg.constructor.name}(${JSON.stringify(Array.from(arg))})`);\r\n          default:\r\n            if (onUnrecognizedArgumentLookup) {\r\n              const instantiationString = onUnrecognizedArgumentLookup(arg);\r\n              if (instantiationString) {\r\n                return instantiationString;\r\n              }\r\n            }\r\n            throw new Error(`unrecognized argument type ${arg.constructor.name}`);\r\n        }\r\n      }\r\n      \r\n      function trackablePrimitive(value) {\r\n        return new value.constructor(value);\r\n      }\r\n      \r\n      if (typeof module !== 'undefined') {\r\n        module.exports = { glWiretap, glExtensionWiretap };\r\n      }\r\n      \r\n      if (typeof window !== 'undefined') {\r\n        glWiretap.glExtensionWiretap = glExtensionWiretap;\r\n        window.glWiretap = glWiretap;\r\n      }\r\n      \r\n      },{}],4:[function(require,module,exports){\r\n      function setupArguments(args) {\r\n        const newArguments = new Array(args.length);\r\n        for (let i = 0; i < args.length; i++) {\r\n          const arg = args[i];\r\n          if (arg.toArray) {\r\n            newArguments[i] = arg.toArray();\r\n          } else {\r\n            newArguments[i] = arg;\r\n          }\r\n        }\r\n        return newArguments;\r\n      }\r\n      \r\n      function mock1D() {\r\n        const args = setupArguments(arguments);\r\n        const row = new Float32Array(this.output.x);\r\n        for (let x = 0; x < this.output.x; x++) {\r\n          this.thread.x = x;\r\n          this.thread.y = 0;\r\n          this.thread.z = 0;\r\n          row[x] = this._fn.apply(this, args);\r\n        }\r\n        return row;\r\n      }\r\n      \r\n      function mock2D() {\r\n        const args = setupArguments(arguments);\r\n        const matrix = new Array(this.output.y);\r\n        for (let y = 0; y < this.output.y; y++) {\r\n          const row = new Float32Array(this.output.x);\r\n          for (let x = 0; x < this.output.x; x++) {\r\n            this.thread.x = x;\r\n            this.thread.y = y;\r\n            this.thread.z = 0;\r\n            row[x] = this._fn.apply(this, args);\r\n          }\r\n          matrix[y] = row;\r\n        }\r\n        return matrix;\r\n      }\r\n      \r\n      function mock2DGraphical() {\r\n        const args = setupArguments(arguments);\r\n        for (let y = 0; y < this.output.y; y++) {\r\n          for (let x = 0; x < this.output.x; x++) {\r\n            this.thread.x = x;\r\n            this.thread.y = y;\r\n            this.thread.z = 0;\r\n            this._fn.apply(this, args);\r\n          }\r\n        }\r\n      }\r\n      \r\n      function mock3D() {\r\n        const args = setupArguments(arguments);\r\n        const cube = new Array(this.output.z);\r\n        for (let z = 0; z < this.output.z; z++) {\r\n          const matrix = new Array(this.output.y);\r\n          for (let y = 0; y < this.output.y; y++) {\r\n            const row = new Float32Array(this.output.x);\r\n            for (let x = 0; x < this.output.x; x++) {\r\n              this.thread.x = x;\r\n              this.thread.y = y;\r\n              this.thread.z = z;\r\n              row[x] = this._fn.apply(this, args);\r\n            }\r\n            matrix[y] = row;\r\n          }\r\n          cube[z] = matrix;\r\n        }\r\n        return cube;\r\n      }\r\n      \r\n      function apiDecorate(kernel) {\r\n        kernel.setOutput = (output) => {\r\n          kernel.output = setupOutput(output);\r\n          if (kernel.graphical) {\r\n            setupGraphical(kernel);\r\n          }\r\n        };\r\n        kernel.toJSON = () => {\r\n          throw new Error('Not usable with gpuMock');\r\n        };\r\n        kernel.setConstants = (flag) => {\r\n          kernel.constants = flag;\r\n          return kernel;\r\n        };\r\n        kernel.setGraphical = (flag) => {\r\n          kernel.graphical = flag;\r\n          return kernel;\r\n        };\r\n        kernel.setCanvas = (flag) => {\r\n          kernel.canvas = flag;\r\n          return kernel;\r\n        };\r\n        kernel.setContext = (flag) => {\r\n          kernel.context = flag;\r\n          return kernel;\r\n        };\r\n        kernel.destroy = () => {};\r\n        kernel.validateSettings = () => {};\r\n        if (kernel.graphical && kernel.output) {\r\n          setupGraphical(kernel);\r\n        }\r\n        kernel.exec = function() {\r\n          return new Promise((resolve, reject) => {\r\n            try {\r\n              resolve(kernel.apply(kernel, arguments));\r\n            } catch(e) {\r\n              reject(e);\r\n            }\r\n          });\r\n        };\r\n        kernel.getPixels = (flip) => {\r\n          const {x, y} = kernel.output;\r\n          return flip ? flipPixels(kernel._imageData.data, x, y) : kernel._imageData.data.slice(0);\r\n        };\r\n        kernel.color = function(r, g, b, a) {\r\n          if (typeof a === 'undefined') {\r\n            a = 1;\r\n          }\r\n      \r\n          r = Math.floor(r * 255);\r\n          g = Math.floor(g * 255);\r\n          b = Math.floor(b * 255);\r\n          a = Math.floor(a * 255);\r\n      \r\n          const width = kernel.output.x;\r\n          const height = kernel.output.y;\r\n      \r\n          const x = kernel.thread.x;\r\n          const y = height - kernel.thread.y - 1;\r\n      \r\n          const index = x + y * width;\r\n      \r\n          kernel._colorData[index * 4 + 0] = r;\r\n          kernel._colorData[index * 4 + 1] = g;\r\n          kernel._colorData[index * 4 + 2] = b;\r\n          kernel._colorData[index * 4 + 3] = a;\r\n        };\r\n      \r\n        const mockMethod = () => kernel;\r\n        const methods = [\r\n          'setWarnVarUsage',\r\n          'setArgumentTypes',\r\n          'setTactic',\r\n          'setOptimizeFloatMemory',\r\n          'setDebug',\r\n          'setLoopMaxIterations',\r\n          'setConstantTypes',\r\n          'setFunctions',\r\n          'setNativeFunctions',\r\n          'setInjectedNative',\r\n          'setPipeline',\r\n          'setPrecision',\r\n          'setOutputToTexture',\r\n          'setImmutable',\r\n          'setStrictIntegers',\r\n          'setDynamicOutput',\r\n          'setHardcodeConstants',\r\n          'setDynamicArguments',\r\n          'setUseLegacyEncoder',\r\n          'setWarnVarUsage',\r\n          'addSubKernel',\r\n        ];\r\n        for (let i = 0; i < methods.length; i++) {\r\n          kernel[methods[i]] = mockMethod;\r\n        }\r\n        return kernel;\r\n      }\r\n      \r\n      function setupGraphical(kernel) {\r\n        const {x, y} = kernel.output;\r\n        if (kernel.context && kernel.context.createImageData) {\r\n          const data = new Uint8ClampedArray(x * y * 4);\r\n          kernel._imageData = kernel.context.createImageData(x, y);\r\n          kernel._colorData = data;\r\n        } else {\r\n          const data = new Uint8ClampedArray(x * y * 4);\r\n          kernel._imageData = { data };\r\n          kernel._colorData = data;\r\n        }\r\n      }\r\n      \r\n      function setupOutput(output) {\r\n        let result = null;\r\n        if (output.length) {\r\n          if (output.length === 3) {\r\n            const [x,y,z] = output;\r\n            result = { x, y, z };\r\n          } else if (output.length === 2) {\r\n            const [x,y] = output;\r\n            result = { x, y };\r\n          } else {\r\n            const [x] = output;\r\n            result = { x };\r\n          }\r\n        } else {\r\n          result = output;\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      function gpuMock(fn, settings = {}) {\r\n        const output = settings.output ? setupOutput(settings.output) : null;\r\n        function kernel() {\r\n          if (kernel.output.z) {\r\n            return mock3D.apply(kernel, arguments);\r\n          } else if (kernel.output.y) {\r\n            if (kernel.graphical) {\r\n              return mock2DGraphical.apply(kernel, arguments);\r\n            }\r\n            return mock2D.apply(kernel, arguments);\r\n          } else {\r\n            return mock1D.apply(kernel, arguments);\r\n          }\r\n        }\r\n        kernel._fn = fn;\r\n        kernel.constants = settings.constants || null;\r\n        kernel.context = settings.context || null;\r\n        kernel.canvas = settings.canvas || null;\r\n        kernel.graphical = settings.graphical || false;\r\n        kernel._imageData = null;\r\n        kernel._colorData = null;\r\n        kernel.output = output;\r\n        kernel.thread = {\r\n          x: 0,\r\n          y: 0,\r\n          z: 0\r\n        };\r\n        return apiDecorate(kernel);\r\n      }\r\n      \r\n      function flipPixels(pixels, width, height) {\r\n        const halfHeight = height / 2 | 0; \r\n        const bytesPerRow = width * 4;\r\n        const temp = new Uint8ClampedArray(width * 4);\r\n        const result = pixels.slice(0);\r\n        for (let y = 0; y < halfHeight; ++y) {\r\n          const topOffset = y * bytesPerRow;\r\n          const bottomOffset = (height - y - 1) * bytesPerRow;\r\n      \r\n          temp.set(result.subarray(topOffset, topOffset + bytesPerRow));\r\n      \r\n          result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);\r\n      \r\n          result.set(temp, bottomOffset);\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      module.exports = {\r\n        gpuMock\r\n      };\r\n      \r\n      },{}],5:[function(require,module,exports){\r\n      const { utils } = require('./utils');\r\n      \r\n      function alias(name, source) {\r\n        const fnString = source.toString();\r\n        return new Function(`return function ${ name } (${ utils.getArgumentNamesFromString(fnString).join(', ') }) {\r\n        ${ utils.getFunctionBodyFromString(fnString) }\r\n      }`)();\r\n      }\r\n      \r\n      module.exports = {\r\n        alias\r\n      };\r\n      },{\"./utils\":114}],6:[function(require,module,exports){\r\n      const { FunctionNode } = require('../function-node');\r\n      \r\n      class CPUFunctionNode extends FunctionNode {\r\n        astFunction(ast, retArr) {\r\n      \r\n          if (!this.isRootKernel) {\r\n            retArr.push('function');\r\n            retArr.push(' ');\r\n            retArr.push(this.name);\r\n            retArr.push('(');\r\n      \r\n            for (let i = 0; i < this.argumentNames.length; ++i) {\r\n              const argumentName = this.argumentNames[i];\r\n      \r\n              if (i > 0) {\r\n                retArr.push(', ');\r\n              }\r\n              retArr.push('user_');\r\n              retArr.push(argumentName);\r\n            }\r\n      \r\n            retArr.push(') {\\n');\r\n          }\r\n      \r\n          for (let i = 0; i < ast.body.body.length; ++i) {\r\n            this.astGeneric(ast.body.body[i], retArr);\r\n            retArr.push('\\n');\r\n          }\r\n      \r\n          if (!this.isRootKernel) {\r\n            retArr.push('}\\n');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astReturnStatement(ast, retArr) {\r\n          const type = this.returnType || this.getType(ast.argument);\r\n      \r\n          if (!this.returnType) {\r\n            this.returnType = type;\r\n          }\r\n      \r\n          if (this.isRootKernel) {\r\n            retArr.push(this.leadingReturnStatement);\r\n            this.astGeneric(ast.argument, retArr);\r\n            retArr.push(';\\n');\r\n            retArr.push(this.followingReturnStatement);\r\n            retArr.push('continue;\\n');\r\n          } else if (this.isSubKernel) {\r\n            retArr.push(`subKernelResult_${ this.name } = `);\r\n            this.astGeneric(ast.argument, retArr);\r\n            retArr.push(';');\r\n            retArr.push(`return subKernelResult_${ this.name };`);\r\n          } else {\r\n            retArr.push('return ');\r\n            this.astGeneric(ast.argument, retArr);\r\n            retArr.push(';');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astLiteral(ast, retArr) {\r\n      \r\n          if (isNaN(ast.value)) {\r\n            throw this.astErrorOutput(\r\n              'Non-numeric literal not supported : ' + ast.value,\r\n              ast\r\n            );\r\n          }\r\n      \r\n          retArr.push(ast.value);\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astBinaryExpression(ast, retArr) {\r\n          retArr.push('(');\r\n          this.astGeneric(ast.left, retArr);\r\n          retArr.push(ast.operator);\r\n          this.astGeneric(ast.right, retArr);\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        astIdentifierExpression(idtNode, retArr) {\r\n          if (idtNode.type !== 'Identifier') {\r\n            throw this.astErrorOutput(\r\n              'IdentifierExpression - not an Identifier',\r\n              idtNode\r\n            );\r\n          }\r\n      \r\n          switch (idtNode.name) {\r\n            case 'Infinity':\r\n              retArr.push('Infinity');\r\n              break;\r\n            default:\r\n              if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {\r\n                retArr.push('constants_' + idtNode.name);\r\n              } else {\r\n                retArr.push('user_' + idtNode.name);\r\n              }\r\n          }\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astForStatement(forNode, retArr) {\r\n          if (forNode.type !== 'ForStatement') {\r\n            throw this.astErrorOutput('Invalid for statement', forNode);\r\n          }\r\n      \r\n          const initArr = [];\r\n          const testArr = [];\r\n          const updateArr = [];\r\n          const bodyArr = [];\r\n          let isSafe = null;\r\n      \r\n          if (forNode.init) {\r\n            this.pushState('in-for-loop-init');\r\n            this.astGeneric(forNode.init, initArr);\r\n            for (let i = 0; i < initArr.length; i++) {\r\n              if (initArr[i].includes && initArr[i].includes(',')) {\r\n                isSafe = false;\r\n              }\r\n            }\r\n            this.popState('in-for-loop-init');\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.test) {\r\n            this.astGeneric(forNode.test, testArr);\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.update) {\r\n            this.astGeneric(forNode.update, updateArr);\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.body) {\r\n            this.pushState('loop-body');\r\n            this.astGeneric(forNode.body, bodyArr);\r\n            this.popState('loop-body');\r\n          }\r\n      \r\n          if (isSafe === null) {\r\n            isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);\r\n          }\r\n      \r\n          if (isSafe) {\r\n            retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\\n`);\r\n            retArr.push(bodyArr.join(''));\r\n            retArr.push('}\\n');\r\n          } else {\r\n            const iVariableName = this.getInternalVariableName('safeI');\r\n            if (initArr.length > 0) {\r\n              retArr.push(initArr.join(''), ';\\n');\r\n            }\r\n            retArr.push(`for (let ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\n`);\r\n            if (testArr.length > 0) {\r\n              retArr.push(`if (!${testArr.join('')}) break;\\n`);\r\n            }\r\n            retArr.push(bodyArr.join(''));\r\n            retArr.push(`\\n${updateArr.join('')};`);\r\n            retArr.push('}\\n');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astWhileStatement(whileNode, retArr) {\r\n          if (whileNode.type !== 'WhileStatement') {\r\n            throw this.astErrorOutput(\r\n              'Invalid while statement',\r\n              whileNode\r\n            );\r\n          }\r\n      \r\n          retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');\r\n          retArr.push('if (');\r\n          this.astGeneric(whileNode.test, retArr);\r\n          retArr.push(') {\\n');\r\n          this.astGeneric(whileNode.body, retArr);\r\n          retArr.push('} else {\\n');\r\n          retArr.push('break;\\n');\r\n          retArr.push('}\\n');\r\n          retArr.push('}\\n');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astDoWhileStatement(doWhileNode, retArr) {\r\n          if (doWhileNode.type !== 'DoWhileStatement') {\r\n            throw this.astErrorOutput(\r\n              'Invalid while statement',\r\n              doWhileNode\r\n            );\r\n          }\r\n      \r\n          retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');\r\n          this.astGeneric(doWhileNode.body, retArr);\r\n          retArr.push('if (!');\r\n          this.astGeneric(doWhileNode.test, retArr);\r\n          retArr.push(') {\\n');\r\n          retArr.push('break;\\n');\r\n          retArr.push('}\\n');\r\n          retArr.push('}\\n');\r\n      \r\n          return retArr;\r\n      \r\n        }\r\n      \r\n        astAssignmentExpression(assNode, retArr) {\r\n          const declaration = this.getDeclaration(assNode.left);\r\n          if (declaration && !declaration.assignable) {\r\n            throw this.astErrorOutput(`Variable ${assNode.left.name} is not assignable here`, assNode);\r\n          }\r\n          this.astGeneric(assNode.left, retArr);\r\n          retArr.push(assNode.operator);\r\n          this.astGeneric(assNode.right, retArr);\r\n          return retArr;\r\n        }\r\n      \r\n        astBlockStatement(bNode, retArr) {\r\n          if (this.isState('loop-body')) {\r\n            this.pushState('block-body'); \r\n            for (let i = 0; i < bNode.body.length; i++) {\r\n              this.astGeneric(bNode.body[i], retArr);\r\n            }\r\n            this.popState('block-body');\r\n          } else {\r\n            retArr.push('{\\n');\r\n            for (let i = 0; i < bNode.body.length; i++) {\r\n              this.astGeneric(bNode.body[i], retArr);\r\n            }\r\n            retArr.push('}\\n');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astVariableDeclaration(varDecNode, retArr) {\r\n          retArr.push(`${varDecNode.kind} `);\r\n          const { declarations } = varDecNode;\r\n          for (let i = 0; i < declarations.length; i++) {\r\n            if (i > 0) {\r\n              retArr.push(',');\r\n            }\r\n            const declaration = declarations[i];\r\n            const info = this.getDeclaration(declaration.id);\r\n            if (!info.valueType) {\r\n              info.valueType = this.getType(declaration.init);\r\n            }\r\n            this.astGeneric(declaration, retArr);\r\n          }\r\n          if (!this.isState('in-for-loop-init')) {\r\n            retArr.push(';');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astIfStatement(ifNode, retArr) {\r\n          retArr.push('if (');\r\n          this.astGeneric(ifNode.test, retArr);\r\n          retArr.push(')');\r\n          if (ifNode.consequent.type === 'BlockStatement') {\r\n            this.astGeneric(ifNode.consequent, retArr);\r\n          } else {\r\n            retArr.push(' {\\n');\r\n            this.astGeneric(ifNode.consequent, retArr);\r\n            retArr.push('\\n}\\n');\r\n          }\r\n      \r\n          if (ifNode.alternate) {\r\n            retArr.push('else ');\r\n            if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {\r\n              this.astGeneric(ifNode.alternate, retArr);\r\n            } else {\r\n              retArr.push(' {\\n');\r\n              this.astGeneric(ifNode.alternate, retArr);\r\n              retArr.push('\\n}\\n');\r\n            }\r\n          }\r\n          return retArr;\r\n      \r\n        }\r\n      \r\n        astSwitchStatement(ast, retArr) {\r\n          const { discriminant, cases } = ast;\r\n          retArr.push('switch (');\r\n          this.astGeneric(discriminant, retArr);\r\n          retArr.push(') {\\n');\r\n          for (let i = 0; i < cases.length; i++) {\r\n            if (cases[i].test === null) {\r\n              retArr.push('default:\\n');\r\n              this.astGeneric(cases[i].consequent, retArr);\r\n              if (cases[i].consequent && cases[i].consequent.length > 0) {\r\n                retArr.push('break;\\n');\r\n              }\r\n              continue;\r\n            }\r\n            retArr.push('case ');\r\n            this.astGeneric(cases[i].test, retArr);\r\n            retArr.push(':\\n');\r\n            if (cases[i].consequent && cases[i].consequent.length > 0) {\r\n              this.astGeneric(cases[i].consequent, retArr);\r\n              retArr.push('break;\\n');\r\n            }\r\n          }\r\n          retArr.push('\\n}');\r\n        }\r\n      \r\n        astThisExpression(tNode, retArr) {\r\n          retArr.push('_this');\r\n          return retArr;\r\n        }\r\n      \r\n        astMemberExpression(mNode, retArr) {\r\n          const {\r\n            signature,\r\n            type,\r\n            property,\r\n            xProperty,\r\n            yProperty,\r\n            zProperty,\r\n            name,\r\n            origin\r\n          } = this.getMemberExpressionDetails(mNode);\r\n          switch (signature) {\r\n            case 'this.thread.value':\r\n              retArr.push(`_this.thread.${ name }`);\r\n              return retArr;\r\n            case 'this.output.value':\r\n              switch (name) {\r\n                case 'x':\r\n                  retArr.push('outputX');\r\n                  break;\r\n                case 'y':\r\n                  retArr.push('outputY');\r\n                  break;\r\n                case 'z':\r\n                  retArr.push('outputZ');\r\n                  break;\r\n                default:\r\n                  throw this.astErrorOutput('Unexpected expression', mNode);\r\n              }\r\n              return retArr;\r\n            case 'value':\r\n              throw this.astErrorOutput('Unexpected expression', mNode);\r\n            case 'value[]':\r\n            case 'value[][]':\r\n            case 'value[][][]':\r\n            case 'value.value':\r\n              if (origin === 'Math') {\r\n                retArr.push(Math[name]);\r\n                return retArr;\r\n              }\r\n              switch (property) {\r\n                case 'r':\r\n                  retArr.push(`user_${ name }[0]`);\r\n                  return retArr;\r\n                case 'g':\r\n                  retArr.push(`user_${ name }[1]`);\r\n                  return retArr;\r\n                case 'b':\r\n                  retArr.push(`user_${ name }[2]`);\r\n                  return retArr;\r\n                case 'a':\r\n                  retArr.push(`user_${ name }[3]`);\r\n                  return retArr;\r\n              }\r\n              break;\r\n            case 'this.constants.value':\r\n            case 'this.constants.value[]':\r\n            case 'this.constants.value[][]':\r\n            case 'this.constants.value[][][]':\r\n              break;\r\n            case 'fn()[]':\r\n              this.astGeneric(mNode.object, retArr);\r\n              retArr.push('[');\r\n              this.astGeneric(mNode.property, retArr);\r\n              retArr.push(']');\r\n              return retArr;\r\n            case 'fn()[][]':\r\n              this.astGeneric(mNode.object.object, retArr);\r\n              retArr.push('[');\r\n              this.astGeneric(mNode.object.property, retArr);\r\n              retArr.push(']');\r\n              retArr.push('[');\r\n              this.astGeneric(mNode.property, retArr);\r\n              retArr.push(']');\r\n              return retArr;\r\n            default:\r\n              throw this.astErrorOutput('Unexpected expression', mNode);\r\n          }\r\n      \r\n          if (!mNode.computed) {\r\n            switch (type) {\r\n              case 'Number':\r\n              case 'Integer':\r\n              case 'Float':\r\n              case 'Boolean':\r\n                retArr.push(`${origin}_${name}`);\r\n                return retArr;\r\n            }\r\n          }\r\n      \r\n          const markupName = `${origin}_${name}`;\r\n      \r\n          switch (type) {\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n            case 'HTMLImageArray':\r\n            case 'ArrayTexture(1)':\r\n            case 'ArrayTexture(2)':\r\n            case 'ArrayTexture(3)':\r\n            case 'ArrayTexture(4)':\r\n            case 'HTMLImage':\r\n            default:\r\n              let size;\r\n              let isInput;\r\n              if (origin === 'constants') {\r\n                const constant = this.constants[name];\r\n                isInput = this.constantTypes[name] === 'Input';\r\n                size = isInput ? constant.size : null;\r\n              } else {\r\n                isInput = this.isInput(name);\r\n                size = isInput ? this.argumentSizes[this.argumentNames.indexOf(name)] : null;\r\n              }\r\n              retArr.push(`${ markupName }`);\r\n              if (zProperty && yProperty) {\r\n                if (isInput) {\r\n                  retArr.push('[(');\r\n                  this.astGeneric(zProperty, retArr);\r\n                  retArr.push(`*${ this.dynamicArguments ? '(outputY * outputX)' : size[1] * size[0] })+(`);\r\n                  this.astGeneric(yProperty, retArr);\r\n                  retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);\r\n                  this.astGeneric(xProperty, retArr);\r\n                  retArr.push(']');\r\n                } else {\r\n                  retArr.push('[');\r\n                  this.astGeneric(zProperty, retArr);\r\n                  retArr.push(']');\r\n                  retArr.push('[');\r\n                  this.astGeneric(yProperty, retArr);\r\n                  retArr.push(']');\r\n                  retArr.push('[');\r\n                  this.astGeneric(xProperty, retArr);\r\n                  retArr.push(']');\r\n                }\r\n              } else if (yProperty) {\r\n                if (isInput) {\r\n                  retArr.push('[(');\r\n                  this.astGeneric(yProperty, retArr);\r\n                  retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);\r\n                  this.astGeneric(xProperty, retArr);\r\n                  retArr.push(']');\r\n                } else {\r\n                  retArr.push('[');\r\n                  this.astGeneric(yProperty, retArr);\r\n                  retArr.push(']');\r\n                  retArr.push('[');\r\n                  this.astGeneric(xProperty, retArr);\r\n                  retArr.push(']');\r\n                }\r\n              } else if (typeof xProperty !== 'undefined') {\r\n                retArr.push('[');\r\n                this.astGeneric(xProperty, retArr);\r\n                retArr.push(']');\r\n              }\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astCallExpression(ast, retArr) {\r\n          if (ast.type !== 'CallExpression') {\r\n            throw this.astErrorOutput('Unknown CallExpression', ast);\r\n          }\r\n          let functionName = this.astMemberExpressionUnroll(ast.callee);\r\n      \r\n          if (this.calledFunctions.indexOf(functionName) < 0) {\r\n            this.calledFunctions.push(functionName);\r\n          }\r\n      \r\n          const isMathFunction = this.isAstMathFunction(ast);\r\n      \r\n          if (this.onFunctionCall) {\r\n            this.onFunctionCall(this.name, functionName, ast.arguments);\r\n          }\r\n      \r\n          retArr.push(functionName);\r\n      \r\n          retArr.push('(');\r\n          const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];\r\n          for (let i = 0; i < ast.arguments.length; ++i) {\r\n            const argument = ast.arguments[i];\r\n      \r\n            let argumentType = this.getType(argument);\r\n            if (!targetTypes[i]) {\r\n              this.triggerImplyArgumentType(functionName, i, argumentType, this);\r\n            }\r\n      \r\n            if (i > 0) {\r\n              retArr.push(', ');\r\n            }\r\n            this.astGeneric(argument, retArr);\r\n          }\r\n          retArr.push(')');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astArrayExpression(arrNode, retArr) {\r\n          const returnType = this.getType(arrNode);\r\n          const arrLen = arrNode.elements.length;\r\n          const elements = [];\r\n          for (let i = 0; i < arrLen; ++i) {\r\n            const element = [];\r\n            this.astGeneric(arrNode.elements[i], element);\r\n            elements.push(element.join(''));\r\n          }\r\n          switch (returnType) {\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n              retArr.push(`[${elements.join(', ')}]`);\r\n              break;\r\n            default:\r\n              retArr.push(`new Float32Array([${elements.join(', ')}])`);\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astDebuggerStatement(arrNode, retArr) {\r\n          retArr.push('debugger;');\r\n          return retArr;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        CPUFunctionNode\r\n      };\r\n      },{\"../function-node\":10}],7:[function(require,module,exports){\r\n      const { utils } = require('../../utils');\r\n      \r\n      function constantsToString(constants, types) {\r\n        const results = [];\r\n        for (const name in types) {\r\n          if (!types.hasOwnProperty(name)) continue;\r\n          const type = types[name];\r\n          const constant = constants[name];\r\n          switch (type) {\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n            case 'Boolean':\r\n              results.push(`${name}:${constant}`);\r\n              break;\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n              results.push(`${name}:new ${constant.constructor.name}(${JSON.stringify(Array.from(constant))})`);\r\n              break;\r\n          }\r\n        }\r\n        return `{ ${ results.join() } }`;\r\n      }\r\n      \r\n      function cpuKernelString(cpuKernel, name) {\r\n        const header = [];\r\n        const thisProperties = [];\r\n        const beforeReturn = [];\r\n      \r\n        const useFunctionKeyword = !/^function/.test(cpuKernel.color.toString());\r\n      \r\n        header.push(\r\n          '  const { context, canvas, constants: incomingConstants } = settings;',\r\n          `  const output = new Int32Array(${JSON.stringify(Array.from(cpuKernel.output))});`,\r\n          `  const _constantTypes = ${JSON.stringify(cpuKernel.constantTypes)};`,\r\n          `  const _constants = ${constantsToString(cpuKernel.constants, cpuKernel.constantTypes)};`,\r\n        );\r\n      \r\n        thisProperties.push(\r\n          '    constants: _constants,',\r\n          '    context,',\r\n          '    output,',\r\n          '    thread: {x: 0, y: 0, z: 0},',\r\n        );\r\n      \r\n        if (cpuKernel.graphical) {\r\n          header.push(`  const _imageData = context.createImageData(${cpuKernel.output[0]}, ${cpuKernel.output[1]});`);\r\n          header.push(`  const _colorData = new Uint8ClampedArray(${cpuKernel.output[0]} * ${cpuKernel.output[1]} * 4);`);\r\n      \r\n          const colorFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.color.toString(), {\r\n            thisLookup: (propertyName) => {\r\n              switch (propertyName) {\r\n                case '_colorData':\r\n                  return '_colorData';\r\n                case '_imageData':\r\n                  return '_imageData';\r\n                case 'output':\r\n                  return 'output';\r\n                case 'thread':\r\n                  return 'this.thread';\r\n              }\r\n              return JSON.stringify(cpuKernel[propertyName]);\r\n            },\r\n            findDependency: (object, name) => {\r\n              return null;\r\n            }\r\n          });\r\n      \r\n          const getPixelsFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.getPixels.toString(), {\r\n            thisLookup: (propertyName) => {\r\n              switch (propertyName) {\r\n                case '_colorData':\r\n                  return '_colorData';\r\n                case '_imageData':\r\n                  return '_imageData';\r\n                case 'output':\r\n                  return 'output';\r\n                case 'thread':\r\n                  return 'this.thread';\r\n              }\r\n              return JSON.stringify(cpuKernel[propertyName]);\r\n            },\r\n            findDependency: () => {\r\n              return null;\r\n            }\r\n          });\r\n      \r\n          thisProperties.push(\r\n            '    _imageData,',\r\n            '    _colorData,',\r\n            `    color: ${colorFn},`,\r\n          );\r\n      \r\n          beforeReturn.push(\r\n            `  kernel.getPixels = ${getPixelsFn};`\r\n          );\r\n        }\r\n      \r\n        const constantTypes = [];\r\n        const constantKeys = Object.keys(cpuKernel.constantTypes);\r\n        for (let i = 0; i < constantKeys.length; i++) {\r\n          constantTypes.push(cpuKernel.constantTypes[constantKeys]);\r\n        }\r\n        if (cpuKernel.argumentTypes.indexOf('HTMLImageArray') !== -1 || constantTypes.indexOf('HTMLImageArray') !== -1) {\r\n          const flattenedImageTo3DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo3DArray.toString(), {\r\n            doNotDefine: ['canvas'],\r\n            findDependency: (object, name) => {\r\n              if (object === 'this') {\r\n                return (useFunctionKeyword ? 'function ' : '') + cpuKernel[name].toString();\r\n              }\r\n              return null;\r\n            },\r\n            thisLookup: (propertyName) => {\r\n              switch (propertyName) {\r\n                case 'canvas':\r\n                  return;\r\n                case 'context':\r\n                  return 'context';\r\n              }\r\n            }\r\n          });\r\n          beforeReturn.push(flattenedImageTo3DArray);\r\n          thisProperties.push(`    _mediaTo2DArray,`);\r\n          thisProperties.push(`    _imageTo3DArray,`);\r\n        } else if (cpuKernel.argumentTypes.indexOf('HTMLImage') !== -1 || constantTypes.indexOf('HTMLImage') !== -1) {\r\n          const flattenedImageTo2DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._mediaTo2DArray.toString(), {\r\n            findDependency: (object, name) => {\r\n              return null;\r\n            },\r\n            thisLookup: (propertyName) => {\r\n              switch (propertyName) {\r\n                case 'canvas':\r\n                  return 'settings.canvas';\r\n                case 'context':\r\n                  return 'settings.context';\r\n              }\r\n              throw new Error('unhandled thisLookup');\r\n            }\r\n          });\r\n          beforeReturn.push(flattenedImageTo2DArray);\r\n          thisProperties.push(`    _mediaTo2DArray,`);\r\n        }\r\n      \r\n        return `function(settings) {\r\n      ${ header.join('\\n') }\r\n        for (const p in _constantTypes) {\r\n          if (!_constantTypes.hasOwnProperty(p)) continue;\r\n          const type = _constantTypes[p];\r\n          switch (type) {\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n            case 'Boolean':\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n              if (incomingConstants.hasOwnProperty(p)) {\r\n                console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');\r\n              }\r\n              continue;\r\n          }\r\n          if (!incomingConstants.hasOwnProperty(p)) {\r\n            throw new Error('constant ' + p + ' not found');\r\n          }\r\n          _constants[p] = incomingConstants[p];\r\n        }\r\n        const kernel = (function() {\r\n      ${cpuKernel._kernelString}\r\n        })\r\n          .apply({ ${thisProperties.join('\\n')} });\r\n        ${ beforeReturn.join('\\n') }\r\n        return kernel;\r\n      }`;\r\n      }\r\n      \r\n      module.exports = {\r\n        cpuKernelString\r\n      };\r\n      },{\"../../utils\":114}],8:[function(require,module,exports){\r\n      const { Kernel } = require('../kernel');\r\n      const { FunctionBuilder } = require('../function-builder');\r\n      const { CPUFunctionNode } = require('./function-node');\r\n      const { utils } = require('../../utils');\r\n      const { cpuKernelString } = require('./kernel-string');\r\n      \r\n      class CPUKernel extends Kernel {\r\n        static getFeatures() {\r\n          return this.features;\r\n        }\r\n        static get features() {\r\n          return Object.freeze({\r\n            kernelMap: true,\r\n            isIntegerDivisionAccurate: true\r\n          });\r\n        }\r\n        static get isSupported() {\r\n          return true;\r\n        }\r\n        static isContextMatch(context) {\r\n          return false;\r\n        }\r\n        static get mode() {\r\n          return 'cpu';\r\n        }\r\n      \r\n        static nativeFunctionArguments() {\r\n          return null;\r\n        }\r\n      \r\n        static nativeFunctionReturnType() {\r\n          throw new Error(`Looking up native function return type not supported on ${this.name}`);\r\n        }\r\n      \r\n        static combineKernels(combinedKernel) {\r\n          return combinedKernel;\r\n        }\r\n      \r\n        static getSignature(kernel, argumentTypes) {\r\n          return 'cpu' + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');\r\n        }\r\n      \r\n        constructor(source, settings) {\r\n          super(source, settings);\r\n          this.mergeSettings(source.settings || settings);\r\n      \r\n          this._imageData = null;\r\n          this._colorData = null;\r\n          this._kernelString = null;\r\n          this._prependedString = [];\r\n          this.thread = {\r\n            x: 0,\r\n            y: 0,\r\n            z: 0\r\n          };\r\n          this.translatedSources = null;\r\n        }\r\n      \r\n        initCanvas() {\r\n          if (typeof document !== 'undefined') {\r\n            return document.createElement('canvas');\r\n          } else if (typeof OffscreenCanvas !== 'undefined') {\r\n            return new OffscreenCanvas(0, 0);\r\n          }\r\n        }\r\n      \r\n        initContext() {\r\n          if (!this.canvas) return null;\r\n          return this.canvas.getContext('2d');\r\n        }\r\n      \r\n        initPlugins(settings) {\r\n          return [];\r\n        }\r\n      \r\n        validateSettings(args) {\r\n          if (!this.output || this.output.length === 0) {\r\n            if (args.length !== 1) {\r\n              throw new Error('Auto output only supported for kernels with only one input');\r\n            }\r\n      \r\n            const argType = utils.getVariableType(args[0], this.strictIntegers);\r\n            if (argType === 'Array') {\r\n              this.output = utils.getDimensions(argType);\r\n            } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {\r\n              this.output = args[0].output;\r\n            } else {\r\n              throw new Error('Auto output not supported for input type: ' + argType);\r\n            }\r\n          }\r\n      \r\n          if (this.graphical) {\r\n            if (this.output.length !== 2) {\r\n              throw new Error('Output must have 2 dimensions on graphical mode');\r\n            }\r\n          }\r\n      \r\n          this.checkOutput();\r\n        }\r\n      \r\n        translateSource() {\r\n          this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';\r\n          if (this.subKernels) {\r\n            const followingReturnStatement = [];\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              const {\r\n                name\r\n              } = this.subKernels[i];\r\n              followingReturnStatement.push(this.output.length > 1 ? `resultX_${ name }[x] = subKernelResult_${ name };\\n` : `result_${ name }[x] = subKernelResult_${ name };\\n`);\r\n            }\r\n            this.followingReturnStatement = followingReturnStatement.join('');\r\n          }\r\n          const functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);\r\n          this.translatedSources = functionBuilder.getPrototypes('kernel');\r\n          if (!this.graphical && !this.returnType) {\r\n            this.returnType = functionBuilder.getKernelResultType();\r\n          }\r\n        }\r\n      \r\n        build() {\r\n          if (this.built) return;\r\n          this.setupConstants();\r\n          this.setupArguments(arguments);\r\n          this.validateSettings(arguments);\r\n          this.translateSource();\r\n      \r\n          if (this.graphical) {\r\n            const {\r\n              canvas,\r\n              output\r\n            } = this;\r\n            if (!canvas) {\r\n              throw new Error('no canvas available for using graphical output');\r\n            }\r\n            const width = output[0];\r\n            const height = output[1] || 1;\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            this._imageData = this.context.createImageData(width, height);\r\n            this._colorData = new Uint8ClampedArray(width * height * 4);\r\n          }\r\n      \r\n          const kernelString = this.getKernelString();\r\n          this.kernelString = kernelString;\r\n      \r\n          if (this.debug) {\r\n            console.log('Function output:');\r\n            console.log(kernelString);\r\n          }\r\n      \r\n          try {\r\n            this.run = new Function([], kernelString).bind(this)();\r\n          } catch (e) {\r\n            console.error('An error occurred compiling the javascript: ', e);\r\n          }\r\n          this.buildSignature(arguments);\r\n          this.built = true;\r\n        }\r\n      \r\n        color(r, g, b, a) {\r\n          if (typeof a === 'undefined') {\r\n            a = 1;\r\n          }\r\n      \r\n          r = Math.floor(r * 255);\r\n          g = Math.floor(g * 255);\r\n          b = Math.floor(b * 255);\r\n          a = Math.floor(a * 255);\r\n      \r\n          const width = this.output[0];\r\n          const height = this.output[1];\r\n      \r\n          const x = this.thread.x;\r\n          const y = height - this.thread.y - 1;\r\n      \r\n          const index = x + y * width;\r\n      \r\n          this._colorData[index * 4 + 0] = r;\r\n          this._colorData[index * 4 + 1] = g;\r\n          this._colorData[index * 4 + 2] = b;\r\n          this._colorData[index * 4 + 3] = a;\r\n        }\r\n      \r\n        getKernelString() {\r\n          if (this._kernelString !== null) return this._kernelString;\r\n      \r\n          let kernelThreadString = null;\r\n          let {\r\n            translatedSources\r\n          } = this;\r\n          if (translatedSources.length > 1) {\r\n            translatedSources = translatedSources.filter(fn => {\r\n              if (/^function/.test(fn)) return fn;\r\n              kernelThreadString = fn;\r\n              return false;\r\n            });\r\n          } else {\r\n            kernelThreadString = translatedSources.shift();\r\n          }\r\n          return this._kernelString = `  const LOOP_MAX = ${ this._getLoopMaxString() };\r\n        ${ this.injectedNative || '' }\r\n        const _this = this;\r\n        ${ this._resultKernelHeader() }\r\n        ${ this._processConstants() }\r\n        return (${ this.argumentNames.map(argumentName => 'user_' + argumentName).join(', ') }) => {\r\n          ${ this._prependedString.join('') }\r\n          ${ this._earlyThrows() }\r\n          ${ this._processArguments() }\r\n          ${ this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString) }\r\n          ${ translatedSources.length > 0 ? translatedSources.join('\\n') : '' }\r\n        };`;\r\n        }\r\n      \r\n        toString() {\r\n          return cpuKernelString(this);\r\n        }\r\n      \r\n        _getLoopMaxString() {\r\n          return (\r\n            this.loopMaxIterations ?\r\n            ` ${ parseInt(this.loopMaxIterations) };` :\r\n            ' 1000;'\r\n          );\r\n        }\r\n      \r\n        _processConstants() {\r\n          if (!this.constants) return '';\r\n      \r\n          const result = [];\r\n          for (let p in this.constants) {\r\n            const type = this.constantTypes[p];\r\n            switch (type) {\r\n              case 'HTMLCanvas':\r\n              case 'HTMLImage':\r\n              case 'HTMLVideo':\r\n                result.push(`    const constants_${p} = this._mediaTo2DArray(this.constants.${p});\\n`);\r\n                break;\r\n              case 'HTMLImageArray':\r\n                result.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});\\n`);\r\n                break;\r\n              case 'Input':\r\n                result.push(`    const constants_${p} = this.constants.${p}.value;\\n`);\r\n                break;\r\n              default:\r\n                result.push(`    const constants_${p} = this.constants.${p};\\n`);\r\n            }\r\n          }\r\n          return result.join('');\r\n        }\r\n      \r\n        _earlyThrows() {\r\n          if (this.graphical) return '';\r\n          if (this.immutable) return '';\r\n          if (!this.pipeline) return '';\r\n          const arrayArguments = [];\r\n          for (let i = 0; i < this.argumentTypes.length; i++) {\r\n            if (this.argumentTypes[i] === 'Array') {\r\n              arrayArguments.push(this.argumentNames[i]);\r\n            }\r\n          }\r\n          if (arrayArguments.length === 0) return '';\r\n          const checks = [];\r\n          for (let i = 0; i < arrayArguments.length; i++) {\r\n            const argumentName = arrayArguments[i];\r\n            const checkSubKernels = this._mapSubKernels(subKernel => `user_${argumentName} === result_${subKernel.name}`).join(' || ');\r\n            checks.push(`user_${argumentName} === result${checkSubKernels ? ` || ${checkSubKernels}` : ''}`);\r\n          }\r\n          return `if (${checks.join(' || ')}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`;\r\n        }\r\n      \r\n        _processArguments() {\r\n          const result = [];\r\n          for (let i = 0; i < this.argumentTypes.length; i++) {\r\n            const variableName = `user_${this.argumentNames[i]}`;\r\n            switch (this.argumentTypes[i]) {\r\n              case 'HTMLCanvas':\r\n              case 'HTMLImage':\r\n              case 'HTMLVideo':\r\n                result.push(`    ${variableName} = this._mediaTo2DArray(${variableName});\\n`);\r\n                break;\r\n              case 'HTMLImageArray':\r\n                result.push(`    ${variableName} = this._imageTo3DArray(${variableName});\\n`);\r\n                break;\r\n              case 'Input':\r\n                result.push(`    ${variableName} = ${variableName}.value;\\n`);\r\n                break;\r\n              case 'ArrayTexture(1)':\r\n              case 'ArrayTexture(2)':\r\n              case 'ArrayTexture(3)':\r\n              case 'ArrayTexture(4)':\r\n              case 'NumberTexture':\r\n              case 'MemoryOptimizedNumberTexture':\r\n                result.push(`\r\n          if (${variableName}.toArray) {\r\n            if (!_this.textureCache) {\r\n              _this.textureCache = [];\r\n              _this.arrayCache = [];\r\n            }\r\n            const textureIndex = _this.textureCache.indexOf(${variableName});\r\n            if (textureIndex !== -1) {\r\n              ${variableName} = _this.arrayCache[textureIndex];\r\n            } else {\r\n              _this.textureCache.push(${variableName});\r\n              ${variableName} = ${variableName}.toArray();\r\n              _this.arrayCache.push(${variableName});\r\n            }\r\n          }`);\r\n                break;\r\n            }\r\n          }\r\n          return result.join('');\r\n        }\r\n      \r\n        _mediaTo2DArray(media) {\r\n          const canvas = this.canvas;\r\n          const width = media.width > 0 ? media.width : media.videoWidth;\r\n          const height = media.height > 0 ? media.height : media.videoHeight;\r\n          if (canvas.width < width) {\r\n            canvas.width = width;\r\n          }\r\n          if (canvas.height < height) {\r\n            canvas.height = height;\r\n          }\r\n          const ctx = this.context;\r\n          ctx.drawImage(media, 0, 0, width, height);\r\n          const pixelsData = ctx.getImageData(0, 0, width, height).data;\r\n          const imageArray = new Array(height);\r\n          let index = 0;\r\n          for (let y = height - 1; y >= 0; y--) {\r\n            const row = imageArray[y] = new Array(width);\r\n            for (let x = 0; x < width; x++) {\r\n              const pixel = new Float32Array(4);\r\n              pixel[0] = pixelsData[index++] / 255; \r\n              pixel[1] = pixelsData[index++] / 255; \r\n              pixel[2] = pixelsData[index++] / 255; \r\n              pixel[3] = pixelsData[index++] / 255; \r\n              row[x] = pixel;\r\n            }\r\n          }\r\n          return imageArray;\r\n        }\r\n      \r\n        getPixels(flip) {\r\n          const [width, height] = this.output;\r\n          return flip ? utils.flipPixels(this._imageData.data, width, height) : this._imageData.data.slice(0);\r\n        }\r\n      \r\n        _imageTo3DArray(images) {\r\n          const imagesArray = new Array(images.length);\r\n          for (let i = 0; i < images.length; i++) {\r\n            imagesArray[i] = this._mediaTo2DArray(images[i]);\r\n          }\r\n          return imagesArray;\r\n        }\r\n      \r\n        _resultKernelHeader() {\r\n          if (this.graphical) return '';\r\n          if (this.immutable) return '';\r\n          if (!this.pipeline) return '';\r\n          switch (this.output.length) {\r\n            case 1:\r\n              return this._mutableKernel1DResults();\r\n            case 2:\r\n              return this._mutableKernel2DResults();\r\n            case 3:\r\n              return this._mutableKernel3DResults();\r\n          }\r\n        }\r\n      \r\n        _resultKernelBody(kernelString) {\r\n          switch (this.output.length) {\r\n            case 1:\r\n              return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(kernelString) : this._resultImmutableKernel1DLoop(kernelString)) + this._kernelOutput();\r\n            case 2:\r\n              return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(kernelString) : this._resultImmutableKernel2DLoop(kernelString)) + this._kernelOutput();\r\n            case 3:\r\n              return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(kernelString) : this._resultImmutableKernel3DLoop(kernelString)) + this._kernelOutput();\r\n            default:\r\n              throw new Error('unsupported size kernel');\r\n          }\r\n        }\r\n      \r\n        _graphicalKernelBody(kernelThreadString) {\r\n          switch (this.output.length) {\r\n            case 2:\r\n              return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();\r\n            default:\r\n              throw new Error('unsupported size kernel');\r\n          }\r\n        }\r\n      \r\n        _graphicalOutput() {\r\n          return `\r\n          this._imageData.data.set(this._colorData);\r\n          this.context.putImageData(this._imageData, 0, 0);\r\n          return;`\r\n        }\r\n      \r\n        _getKernelResultTypeConstructorString() {\r\n          switch (this.returnType) {\r\n            case 'LiteralInteger':\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n              return 'Float32Array';\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n              return 'Array';\r\n            default:\r\n              if (this.graphical) {\r\n                return 'Float32Array';\r\n              }\r\n              throw new Error(`unhandled returnType ${ this.returnType }`);\r\n          }\r\n        }\r\n      \r\n        _resultImmutableKernel1DLoop(kernelString) {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const result = new ${constructorString}(outputX);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }\r\n          for (let x = 0; x < outputX; x++) {\r\n            this.thread.x = x;\r\n            this.thread.y = 0;\r\n            this.thread.z = 0;\r\n            ${ kernelString }\r\n          }`;\r\n        }\r\n      \r\n        _mutableKernel1DResults() {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const result = new ${constructorString}(outputX);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }`;\r\n        }\r\n      \r\n        _resultMutableKernel1DLoop(kernelString) {\r\n          return `  const outputX = _this.output[0];\r\n          for (let x = 0; x < outputX; x++) {\r\n            this.thread.x = x;\r\n            this.thread.y = 0;\r\n            this.thread.z = 0;\r\n            ${ kernelString }\r\n          }`;\r\n        }\r\n      \r\n        _resultImmutableKernel2DLoop(kernelString) {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          const result = new Array(outputY);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }\r\n          for (let y = 0; y < outputY; y++) {\r\n            this.thread.z = 0;\r\n            this.thread.y = y;\r\n            const resultX = result[y] = new ${constructorString}(outputX);\r\n            ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\\n`).join('') }\r\n            for (let x = 0; x < outputX; x++) {\r\n              this.thread.x = x;\r\n              ${ kernelString }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _mutableKernel2DResults() {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          const result = new Array(outputY);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }\r\n          for (let y = 0; y < outputY; y++) {\r\n            const resultX = result[y] = new ${constructorString}(outputX);\r\n            ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\\n`).join('') }\r\n          }`;\r\n        }\r\n      \r\n        _resultMutableKernel2DLoop(kernelString) {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          for (let y = 0; y < outputY; y++) {\r\n            this.thread.z = 0;\r\n            this.thread.y = y;\r\n            const resultX = result[y];\r\n            ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\\n`).join('') }\r\n            for (let x = 0; x < outputX; x++) {\r\n              this.thread.x = x;\r\n              ${ kernelString }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _graphicalKernel2DLoop(kernelString) {\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          for (let y = 0; y < outputY; y++) {\r\n            this.thread.z = 0;\r\n            this.thread.y = y;\r\n            for (let x = 0; x < outputX; x++) {\r\n              this.thread.x = x;\r\n              ${ kernelString }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _resultImmutableKernel3DLoop(kernelString) {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          const outputZ = _this.output[2];\r\n          const result = new Array(outputZ);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }\r\n          for (let z = 0; z < outputZ; z++) {\r\n            this.thread.z = z;\r\n            const resultY = result[z] = new Array(outputY);\r\n            ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\\n`).join('      ') }\r\n            for (let y = 0; y < outputY; y++) {\r\n              this.thread.y = y;\r\n              const resultX = resultY[y] = new ${constructorString}(outputX);\r\n              ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\\n`).join('        ') }\r\n              for (let x = 0; x < outputX; x++) {\r\n                this.thread.x = x;\r\n                ${ kernelString }\r\n              }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _mutableKernel3DResults() {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          const outputZ = _this.output[2];\r\n          const result = new Array(outputZ);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }\r\n          for (let z = 0; z < outputZ; z++) {\r\n            const resultY = result[z] = new Array(outputY);\r\n            ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\\n`).join('      ') }\r\n            for (let y = 0; y < outputY; y++) {\r\n              const resultX = resultY[y] = new ${constructorString}(outputX);\r\n              ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\\n`).join('        ') }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _resultMutableKernel3DLoop(kernelString) {\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          const outputZ = _this.output[2];\r\n          for (let z = 0; z < outputZ; z++) {\r\n            this.thread.z = z;\r\n            const resultY = result[z];\r\n            for (let y = 0; y < outputY; y++) {\r\n              this.thread.y = y;\r\n              const resultX = resultY[y];\r\n              for (let x = 0; x < outputX; x++) {\r\n                this.thread.x = x;\r\n                ${ kernelString }\r\n              }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _kernelOutput() {\r\n          if (!this.subKernels) {\r\n            return '\\n    return result;';\r\n          }\r\n          return `\\n    return {\r\n            result: result,\r\n            ${ this.subKernels.map(subKernel => `${ subKernel.property }: result_${ subKernel.name }`).join(',\\n      ') }\r\n          };`;\r\n        }\r\n      \r\n        _mapSubKernels(fn) {\r\n          return this.subKernels === null ? [''] :\r\n            this.subKernels.map(fn);\r\n        }\r\n      \r\n        destroy(removeCanvasReference) {\r\n          if (removeCanvasReference) {\r\n            delete this.canvas;\r\n          }\r\n        }\r\n      \r\n        static destroyContext(context) {}\r\n      \r\n        toJSON() {\r\n          const json = super.toJSON();\r\n          json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();\r\n          return json;\r\n        }\r\n      \r\n        setOutput(output) {\r\n          super.setOutput(output);\r\n          const [width, height] = this.output;\r\n          if (this.graphical) {\r\n            this._imageData = this.context.createImageData(width, height);\r\n            this._colorData = new Uint8ClampedArray(width * height * 4);\r\n          }\r\n        }\r\n      \r\n        prependString(value) {\r\n          if (this._kernelString) throw new Error('Kernel already built');\r\n          this._prependedString.push(value);\r\n        }\r\n      \r\n        hasPrependString(value) {\r\n          return this._prependedString.indexOf(value) > -1;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        CPUKernel\r\n      };\r\n      },{\"../../utils\":114,\"../function-builder\":9,\"../kernel\":36,\"./function-node\":6,\"./kernel-string\":7}],9:[function(require,module,exports){\r\n      class FunctionBuilder {\r\n        static fromKernel(kernel, FunctionNode, extraNodeOptions) {\r\n          const {\r\n            kernelArguments,\r\n            kernelConstants,\r\n            argumentNames,\r\n            argumentSizes,\r\n            argumentBitRatios,\r\n            constants,\r\n            constantBitRatios,\r\n            debug,\r\n            loopMaxIterations,\r\n            nativeFunctions,\r\n            output,\r\n            optimizeFloatMemory,\r\n            precision,\r\n            plugins,\r\n            source,\r\n            subKernels,\r\n            functions,\r\n            leadingReturnStatement,\r\n            followingReturnStatement,\r\n            dynamicArguments,\r\n            dynamicOutput,\r\n          } = kernel;\r\n      \r\n          const argumentTypes = new Array(kernelArguments.length);\r\n          const constantTypes = {};\r\n      \r\n          for (let i = 0; i < kernelArguments.length; i++) {\r\n            argumentTypes[i] = kernelArguments[i].type;\r\n          }\r\n      \r\n          for (let i = 0; i < kernelConstants.length; i++) {\r\n            const kernelConstant = kernelConstants[i];\r\n            constantTypes[kernelConstant.name] = kernelConstant.type;\r\n          }\r\n      \r\n          const needsArgumentType = (functionName, index) => {\r\n            return functionBuilder.needsArgumentType(functionName, index);\r\n          };\r\n      \r\n          const assignArgumentType = (functionName, index, type) => {\r\n            functionBuilder.assignArgumentType(functionName, index, type);\r\n          };\r\n      \r\n          const lookupReturnType = (functionName, ast, requestingNode) => {\r\n            return functionBuilder.lookupReturnType(functionName, ast, requestingNode);\r\n          };\r\n      \r\n          const lookupFunctionArgumentTypes = (functionName) => {\r\n            return functionBuilder.lookupFunctionArgumentTypes(functionName);\r\n          };\r\n      \r\n          const lookupFunctionArgumentName = (functionName, argumentIndex) => {\r\n            return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);\r\n          };\r\n      \r\n          const lookupFunctionArgumentBitRatio = (functionName, argumentName) => {\r\n            return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);\r\n          };\r\n      \r\n          const triggerImplyArgumentType = (functionName, i, argumentType, requestingNode) => {\r\n            functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);\r\n          };\r\n      \r\n          const triggerImplyArgumentBitRatio = (functionName, argumentName, calleeFunctionName, argumentIndex) => {\r\n            functionBuilder.assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex);\r\n          };\r\n      \r\n          const onFunctionCall = (functionName, calleeFunctionName, args) => {\r\n            functionBuilder.trackFunctionCall(functionName, calleeFunctionName, args);\r\n          };\r\n      \r\n          const onNestedFunction = (ast, source) => {\r\n            const argumentNames = [];\r\n            for (let i = 0; i < ast.params.length; i++) {\r\n              argumentNames.push(ast.params[i].name);\r\n            }\r\n            const nestedFunction = new FunctionNode(source, Object.assign({}, nodeOptions, {\r\n              returnType: null,\r\n              ast,\r\n              name: ast.id.name,\r\n              argumentNames,\r\n              lookupReturnType,\r\n              lookupFunctionArgumentTypes,\r\n              lookupFunctionArgumentName,\r\n              lookupFunctionArgumentBitRatio,\r\n              needsArgumentType,\r\n              assignArgumentType,\r\n              triggerImplyArgumentType,\r\n              triggerImplyArgumentBitRatio,\r\n              onFunctionCall,\r\n            }));\r\n            nestedFunction.traceFunctionAST(ast);\r\n            functionBuilder.addFunctionNode(nestedFunction);\r\n          };\r\n      \r\n          const nodeOptions = Object.assign({\r\n            isRootKernel: false,\r\n            onNestedFunction,\r\n            lookupReturnType,\r\n            lookupFunctionArgumentTypes,\r\n            lookupFunctionArgumentName,\r\n            lookupFunctionArgumentBitRatio,\r\n            needsArgumentType,\r\n            assignArgumentType,\r\n            triggerImplyArgumentType,\r\n            triggerImplyArgumentBitRatio,\r\n            onFunctionCall,\r\n            optimizeFloatMemory,\r\n            precision,\r\n            constants,\r\n            constantTypes,\r\n            constantBitRatios,\r\n            debug,\r\n            loopMaxIterations,\r\n            output,\r\n            plugins,\r\n            dynamicArguments,\r\n            dynamicOutput,\r\n          }, extraNodeOptions || {});\r\n      \r\n          const rootNodeOptions = Object.assign({}, nodeOptions, {\r\n            isRootKernel: true,\r\n            name: 'kernel',\r\n            argumentNames,\r\n            argumentTypes,\r\n            argumentSizes,\r\n            argumentBitRatios,\r\n            leadingReturnStatement,\r\n            followingReturnStatement,\r\n          });\r\n      \r\n          if (typeof source === 'object' && source.functionNodes) {\r\n            return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);\r\n          }\r\n      \r\n          const rootNode = new FunctionNode(source, rootNodeOptions);\r\n      \r\n          let functionNodes = null;\r\n          if (functions) {\r\n            functionNodes = functions.map((fn) => new FunctionNode(fn.source, {\r\n              returnType: fn.returnType,\r\n              argumentTypes: fn.argumentTypes,\r\n              output,\r\n              plugins,\r\n              constants,\r\n              constantTypes,\r\n              constantBitRatios,\r\n              optimizeFloatMemory,\r\n              precision,\r\n              lookupReturnType,\r\n              lookupFunctionArgumentTypes,\r\n              lookupFunctionArgumentName,\r\n              lookupFunctionArgumentBitRatio,\r\n              needsArgumentType,\r\n              assignArgumentType,\r\n              triggerImplyArgumentType,\r\n              triggerImplyArgumentBitRatio,\r\n              onFunctionCall,\r\n              onNestedFunction,\r\n            }));\r\n          }\r\n      \r\n          let subKernelNodes = null;\r\n          if (subKernels) {\r\n            subKernelNodes = subKernels.map((subKernel) => {\r\n              const { name, source } = subKernel;\r\n              return new FunctionNode(source, Object.assign({}, nodeOptions, {\r\n                name,\r\n                isSubKernel: true,\r\n                isRootKernel: false,\r\n              }));\r\n            });\r\n          }\r\n      \r\n          const functionBuilder = new FunctionBuilder({\r\n            kernel,\r\n            rootNode,\r\n            functionNodes,\r\n            nativeFunctions,\r\n            subKernelNodes\r\n          });\r\n      \r\n          return functionBuilder;\r\n        }\r\n      \r\n        constructor(settings) {\r\n          settings = settings || {};\r\n          this.kernel = settings.kernel;\r\n          this.rootNode = settings.rootNode;\r\n          this.functionNodes = settings.functionNodes || [];\r\n          this.subKernelNodes = settings.subKernelNodes || [];\r\n          this.nativeFunctions = settings.nativeFunctions || [];\r\n          this.functionMap = {};\r\n          this.nativeFunctionNames = [];\r\n          this.lookupChain = [];\r\n          this.functionNodeDependencies = {};\r\n          this.functionCalls = {};\r\n      \r\n          if (this.rootNode) {\r\n            this.functionMap['kernel'] = this.rootNode;\r\n          }\r\n      \r\n          if (this.functionNodes) {\r\n            for (let i = 0; i < this.functionNodes.length; i++) {\r\n              this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];\r\n            }\r\n          }\r\n      \r\n          if (this.subKernelNodes) {\r\n            for (let i = 0; i < this.subKernelNodes.length; i++) {\r\n              this.functionMap[this.subKernelNodes[i].name] = this.subKernelNodes[i];\r\n            }\r\n          }\r\n      \r\n          if (this.nativeFunctions) {\r\n            for (let i = 0; i < this.nativeFunctions.length; i++) {\r\n              const nativeFunction = this.nativeFunctions[i];\r\n              this.nativeFunctionNames.push(nativeFunction.name);\r\n            }\r\n          }\r\n        }\r\n      \r\n        addFunctionNode(functionNode) {\r\n          if (!functionNode.name) throw new Error('functionNode.name needs set');\r\n          this.functionMap[functionNode.name] = functionNode;\r\n          if (functionNode.isRootKernel) {\r\n            this.rootNode = functionNode;\r\n          }\r\n        }\r\n      \r\n        traceFunctionCalls(functionName, retList) {\r\n          functionName = functionName || 'kernel';\r\n          retList = retList || [];\r\n      \r\n          if (this.nativeFunctionNames.indexOf(functionName) > -1) {\r\n            const nativeFunctionIndex = retList.indexOf(functionName);\r\n            if (nativeFunctionIndex === -1) {\r\n              retList.push(functionName);\r\n            } else {\r\n              const dependantNativeFunctionName = retList.splice(nativeFunctionIndex, 1)[0];\r\n              retList.push(dependantNativeFunctionName);\r\n            }\r\n            return retList;\r\n          }\r\n      \r\n          const functionNode = this.functionMap[functionName];\r\n          if (functionNode) {\r\n            const functionIndex = retList.indexOf(functionName);\r\n            if (functionIndex === -1) {\r\n              retList.push(functionName);\r\n              functionNode.toString(); \r\n              for (let i = 0; i < functionNode.calledFunctions.length; ++i) {\r\n                this.traceFunctionCalls(functionNode.calledFunctions[i], retList);\r\n              }\r\n            } else {\r\n              const dependantFunctionName = retList.splice(functionIndex, 1)[0];\r\n              retList.push(dependantFunctionName);\r\n            }\r\n          }\r\n      \r\n          return retList;\r\n        }\r\n      \r\n        getPrototypeString(functionName) {\r\n          return this.getPrototypes(functionName).join('\\n');\r\n        }\r\n      \r\n        getPrototypes(functionName) {\r\n          if (this.rootNode) {\r\n            this.rootNode.toString();\r\n          }\r\n          if (functionName) {\r\n            return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());\r\n          }\r\n          return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));\r\n        }\r\n      \r\n        getStringFromFunctionNames(functionList) {\r\n          const ret = [];\r\n          for (let i = 0; i < functionList.length; ++i) {\r\n            const node = this.functionMap[functionList[i]];\r\n            if (node) {\r\n              ret.push(this.functionMap[functionList[i]].toString());\r\n            }\r\n          }\r\n          return ret.join('\\n');\r\n        }\r\n      \r\n        getPrototypesFromFunctionNames(functionList) {\r\n          const ret = [];\r\n          for (let i = 0; i < functionList.length; ++i) {\r\n            const functionName = functionList[i];\r\n            const functionIndex = this.nativeFunctionNames.indexOf(functionName);\r\n            if (functionIndex > -1) {\r\n              ret.push(this.nativeFunctions[functionIndex].source);\r\n              continue;\r\n            }\r\n            const node = this.functionMap[functionName];\r\n            if (node) {\r\n              ret.push(node.toString());\r\n            }\r\n          }\r\n          return ret;\r\n        }\r\n      \r\n        toJSON() {\r\n          return this.traceFunctionCalls(this.rootNode.name).reverse().map(name => {\r\n            const nativeIndex = this.nativeFunctions.indexOf(name);\r\n            if (nativeIndex > -1) {\r\n              return {\r\n                name,\r\n                source: this.nativeFunctions[nativeIndex].source\r\n              };\r\n            } else if (this.functionMap[name]) {\r\n              return this.functionMap[name].toJSON();\r\n            } else {\r\n              throw new Error(`function ${ name } not found`);\r\n            }\r\n          });\r\n        }\r\n      \r\n        fromJSON(jsonFunctionNodes, FunctionNode) {\r\n          this.functionMap = {};\r\n          for (let i = 0; i < jsonFunctionNodes.length; i++) {\r\n            const jsonFunctionNode = jsonFunctionNodes[i];\r\n            this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);\r\n          }\r\n          return this;\r\n        }\r\n      \r\n        getString(functionName) {\r\n          if (functionName) {\r\n            return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());\r\n          }\r\n          return this.getStringFromFunctionNames(Object.keys(this.functionMap));\r\n        }\r\n      \r\n        lookupReturnType(functionName, ast, requestingNode) {\r\n          if (ast.type !== 'CallExpression') {\r\n            throw new Error(`expected ast type of \"CallExpression\", but is ${ ast.type }`);\r\n          }\r\n          if (this._isNativeFunction(functionName)) {\r\n            return this._lookupNativeFunctionReturnType(functionName);\r\n          } else if (this._isFunction(functionName)) {\r\n            const node = this._getFunction(functionName);\r\n            if (node.returnType) {\r\n              return node.returnType;\r\n            } else {\r\n              for (let i = 0; i < this.lookupChain.length; i++) {\r\n                if (this.lookupChain[i].ast === ast) {\r\n                  if (node.argumentTypes.length === 0 && ast.arguments.length > 0) {\r\n                    const args = ast.arguments;\r\n                    for (let j = 0; j < args.length; j++) {\r\n                      this.lookupChain.push({\r\n                        name: requestingNode.name,\r\n                        ast: args[i],\r\n                        requestingNode\r\n                      });\r\n                      node.argumentTypes[j] = requestingNode.getType(args[j]);\r\n                      this.lookupChain.pop();\r\n                    }\r\n                    return node.returnType = node.getType(node.getJsAST());\r\n                  }\r\n      \r\n                  throw new Error('circlical logic detected!');\r\n                }\r\n              }\r\n              this.lookupChain.push({\r\n                name: requestingNode.name,\r\n                ast,\r\n                requestingNode\r\n              });\r\n              const type = node.getType(node.getJsAST());\r\n              this.lookupChain.pop();\r\n              return node.returnType = type;\r\n            }\r\n          }\r\n      \r\n          return null;\r\n        }\r\n      \r\n        _getFunction(functionName) {\r\n          if (!this._isFunction(functionName)) {\r\n            new Error(`Function ${functionName} not found`);\r\n          }\r\n          return this.functionMap[functionName];\r\n        }\r\n      \r\n        _isFunction(functionName) {\r\n          return Boolean(this.functionMap[functionName]);\r\n        }\r\n      \r\n        _getNativeFunction(functionName) {\r\n          for (let i = 0; i < this.nativeFunctions.length; i++) {\r\n            if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        _isNativeFunction(functionName) {\r\n          return Boolean(this._getNativeFunction(functionName));\r\n        }\r\n      \r\n        _lookupNativeFunctionReturnType(functionName) {\r\n          let nativeFunction = this._getNativeFunction(functionName);\r\n          if (nativeFunction) {\r\n            return nativeFunction.returnType;\r\n          }\r\n          throw new Error(`Native function ${ functionName } not found`);\r\n        }\r\n      \r\n        lookupFunctionArgumentTypes(functionName) {\r\n          if (this._isNativeFunction(functionName)) {\r\n            return this._getNativeFunction(functionName).argumentTypes;\r\n          } else if (this._isFunction(functionName)) {\r\n            return this._getFunction(functionName).argumentTypes;\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        lookupFunctionArgumentName(functionName, argumentIndex) {\r\n          return this._getFunction(functionName).argumentNames[argumentIndex];\r\n        }\r\n      \r\n        lookupFunctionArgumentBitRatio(functionName, argumentName) {\r\n          if (!this._isFunction(functionName)) {\r\n            throw new Error('function not found');\r\n          }\r\n          if (this.rootNode.name === functionName) {\r\n            const i = this.rootNode.argumentNames.indexOf(argumentName);\r\n            if (i !== -1) {\r\n              return this.rootNode.argumentBitRatios[i];\r\n            }\r\n          }\r\n          const node = this._getFunction(functionName);\r\n          const i = node.argumentNames.indexOf(argumentName);\r\n          if (i === -1) {\r\n            throw new Error('argument not found');\r\n          }\r\n          const bitRatio = node.argumentBitRatios[i];\r\n          if (typeof bitRatio !== 'number') {\r\n            throw new Error('argument bit ratio not found');\r\n          }\r\n          return bitRatio;\r\n        }\r\n      \r\n        needsArgumentType(functionName, i) {\r\n          if (!this._isFunction(functionName)) return false;\r\n          const fnNode = this._getFunction(functionName);\r\n          return !fnNode.argumentTypes[i];\r\n        }\r\n      \r\n        assignArgumentType(functionName, i, argumentType, requestingNode) {\r\n          if (!this._isFunction(functionName)) return;\r\n          const fnNode = this._getFunction(functionName);\r\n          if (!fnNode.argumentTypes[i]) {\r\n            fnNode.argumentTypes[i] = argumentType;\r\n          }\r\n        }\r\n      \r\n        assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex) {\r\n          const node = this._getFunction(functionName);\r\n          if (this._isNativeFunction(calleeFunctionName)) return null;\r\n          const calleeNode = this._getFunction(calleeFunctionName);\r\n          const i = node.argumentNames.indexOf(argumentName);\r\n          if (i === -1) {\r\n            throw new Error(`Argument ${argumentName} not found in arguments from function ${functionName}`);\r\n          }\r\n          const bitRatio = node.argumentBitRatios[i];\r\n          if (typeof bitRatio !== 'number') {\r\n            throw new Error(`Bit ratio for argument ${argumentName} not found in function ${functionName}`);\r\n          }\r\n          if (!calleeNode.argumentBitRatios) {\r\n            calleeNode.argumentBitRatios = new Array(calleeNode.argumentNames.length);\r\n          }\r\n          const calleeBitRatio = calleeNode.argumentBitRatios[i];\r\n          if (typeof calleeBitRatio === 'number') {\r\n            if (calleeBitRatio !== bitRatio) {\r\n              throw new Error(`Incompatible bit ratio found at function ${functionName} at argument ${argumentName}`);\r\n            }\r\n            return calleeBitRatio;\r\n          }\r\n          calleeNode.argumentBitRatios[i] = bitRatio;\r\n          return bitRatio;\r\n        }\r\n      \r\n        trackFunctionCall(functionName, calleeFunctionName, args) {\r\n          if (!this.functionNodeDependencies[functionName]) {\r\n            this.functionNodeDependencies[functionName] = new Set();\r\n            this.functionCalls[functionName] = [];\r\n          }\r\n          this.functionNodeDependencies[functionName].add(calleeFunctionName);\r\n          this.functionCalls[functionName].push(args);\r\n        }\r\n      \r\n        getKernelResultType() {\r\n          return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);\r\n        }\r\n      \r\n        getSubKernelResultType(index) {\r\n          const subKernelNode = this.subKernelNodes[index];\r\n          let called = false;\r\n          for (let functionCallIndex = 0; functionCallIndex < this.rootNode.functionCalls.length; functionCallIndex++) {\r\n            const functionCall = this.rootNode.functionCalls[functionCallIndex];\r\n            if (functionCall.ast.callee.name === subKernelNode.name) {\r\n              called = true;\r\n            }\r\n          }\r\n          if (!called) {\r\n            throw new Error(`SubKernel ${ subKernelNode.name } never called by kernel`);\r\n          }\r\n          return subKernelNode.returnType || subKernelNode.getType(subKernelNode.getJsAST());\r\n        }\r\n      \r\n        getReturnTypes() {\r\n          const result = {\r\n            [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast),\r\n          };\r\n          const list = this.traceFunctionCalls(this.rootNode.name);\r\n          for (let i = 0; i < list.length; i++) {\r\n            const functionName = list[i];\r\n            const functionNode = this.functionMap[functionName];\r\n            result[functionName] = functionNode.getType(functionNode.ast);\r\n          }\r\n          return result;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        FunctionBuilder\r\n      };\r\n      },{}],10:[function(require,module,exports){\r\n      const acorn = require('acorn');\r\n      const { utils } = require('../utils');\r\n      const { FunctionTracer } = require('./function-tracer');\r\n      \r\n      class FunctionNode {\r\n        constructor(source, settings) {\r\n          if (!source && !settings.ast) {\r\n            throw new Error('source parameter is missing');\r\n          }\r\n          settings = settings || {};\r\n          this.source = source;\r\n          this.ast = null;\r\n          this.name = typeof source === 'string' ? settings.isRootKernel ?\r\n            'kernel' :\r\n            (settings.name || utils.getFunctionNameFromString(source)) : null;\r\n          this.calledFunctions = [];\r\n          this.constants = {};\r\n          this.constantTypes = {};\r\n          this.constantBitRatios = {};\r\n          this.isRootKernel = false;\r\n          this.isSubKernel = false;\r\n          this.debug = null;\r\n          this.functions = null;\r\n          this.identifiers = null;\r\n          this.contexts = null;\r\n          this.functionCalls = null;\r\n          this.states = [];\r\n          this.needsArgumentType = null;\r\n          this.assignArgumentType = null;\r\n          this.lookupReturnType = null;\r\n          this.lookupFunctionArgumentTypes = null;\r\n          this.lookupFunctionArgumentBitRatio = null;\r\n          this.triggerImplyArgumentType = null;\r\n          this.triggerImplyArgumentBitRatio = null;\r\n          this.onNestedFunction = null;\r\n          this.onFunctionCall = null;\r\n          this.optimizeFloatMemory = null;\r\n          this.precision = null;\r\n          this.loopMaxIterations = null;\r\n          this.argumentNames = (typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null);\r\n          this.argumentTypes = [];\r\n          this.argumentSizes = [];\r\n          this.argumentBitRatios = null;\r\n          this.returnType = null;\r\n          this.output = [];\r\n          this.plugins = null;\r\n          this.leadingReturnStatement = null;\r\n          this.followingReturnStatement = null;\r\n          this.dynamicOutput = null;\r\n          this.dynamicArguments = null;\r\n          this.strictTypingChecking = false;\r\n          this.fixIntegerDivisionAccuracy = null;\r\n      \r\n          if (settings) {\r\n            for (const p in settings) {\r\n              if (!settings.hasOwnProperty(p)) continue;\r\n              if (!this.hasOwnProperty(p)) continue;\r\n              this[p] = settings[p];\r\n            }\r\n          }\r\n      \r\n          this.literalTypes = {};\r\n      \r\n          this.validate();\r\n          this._string = null;\r\n          this._internalVariableNames = {};\r\n        }\r\n      \r\n        validate() {\r\n          if (typeof this.source !== 'string' && !this.ast) {\r\n            throw new Error('this.source not a string');\r\n          }\r\n      \r\n          if (!this.ast && !utils.isFunctionString(this.source)) {\r\n            throw new Error('this.source not a function string');\r\n          }\r\n      \r\n          if (!this.name) {\r\n            throw new Error('this.name could not be set');\r\n          }\r\n      \r\n          if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {\r\n            throw new Error(`argumentTypes count of ${ this.argumentTypes.length } exceeds ${ this.argumentNames.length }`);\r\n          }\r\n      \r\n          if (this.output.length < 1) {\r\n            throw new Error('this.output is not big enough');\r\n          }\r\n        }\r\n      \r\n        isIdentifierConstant(name) {\r\n          if (!this.constants) return false;\r\n          return this.constants.hasOwnProperty(name);\r\n        }\r\n      \r\n        isInput(argumentName) {\r\n          return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';\r\n        }\r\n      \r\n        pushState(state) {\r\n          this.states.push(state);\r\n        }\r\n      \r\n        popState(state) {\r\n          if (this.state !== state) {\r\n            throw new Error(`Cannot popState ${ state } when in ${ this.state }`);\r\n          }\r\n          this.states.pop();\r\n        }\r\n      \r\n        isState(state) {\r\n          return this.state === state;\r\n        }\r\n      \r\n        get state() {\r\n          return this.states[this.states.length - 1];\r\n        }\r\n      \r\n        astMemberExpressionUnroll(ast) {\r\n          if (ast.type === 'Identifier') {\r\n            return ast.name;\r\n          } else if (ast.type === 'ThisExpression') {\r\n            return 'this';\r\n          }\r\n      \r\n          if (ast.type === 'MemberExpression') {\r\n            if (ast.object && ast.property) {\r\n              if (ast.object.hasOwnProperty('name') && ast.object.name !== 'Math') {\r\n                return this.astMemberExpressionUnroll(ast.property);\r\n              }\r\n      \r\n              return (\r\n                this.astMemberExpressionUnroll(ast.object) +\r\n                '.' +\r\n                this.astMemberExpressionUnroll(ast.property)\r\n              );\r\n            }\r\n          }\r\n      \r\n          if (ast.hasOwnProperty('expressions')) {\r\n            const firstExpression = ast.expressions[0];\r\n            if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {\r\n              return this.astMemberExpressionUnroll(ast.expressions[1]);\r\n            }\r\n          }\r\n      \r\n          throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);\r\n        }\r\n      \r\n        getJsAST(inParser) {\r\n          if (this.ast) {\r\n            return this.ast;\r\n          }\r\n          if (typeof this.source === 'object') {\r\n            this.traceFunctionAST(this.source);\r\n            return this.ast = this.source;\r\n          }\r\n      \r\n          inParser = inParser || acorn;\r\n          if (inParser === null) {\r\n            throw new Error('Missing JS to AST parser');\r\n          }\r\n      \r\n          const ast = Object.freeze(inParser.parse(`const parser_${ this.name } = ${ this.source };`, {\r\n            locations: true\r\n          }));\r\n          const functionAST = ast.body[0].declarations[0].init;\r\n          this.traceFunctionAST(functionAST);\r\n      \r\n          if (!ast) {\r\n            throw new Error('Failed to parse JS code');\r\n          }\r\n      \r\n          return this.ast = functionAST;\r\n        }\r\n      \r\n        traceFunctionAST(ast) {\r\n          const { contexts, declarations, functions, identifiers, functionCalls } = new FunctionTracer(ast);\r\n          this.contexts = contexts;\r\n          this.identifiers = identifiers;\r\n          this.functionCalls = functionCalls;\r\n          this.functions = functions;\r\n          for (let i = 0; i < declarations.length; i++) {\r\n            const declaration = declarations[i];\r\n            const { ast, inForLoopInit, inForLoopTest } = declaration;\r\n            const { init } = ast;\r\n            const dependencies = this.getDependencies(init);\r\n            let valueType = null;\r\n      \r\n            if (inForLoopInit && inForLoopTest) {\r\n              valueType = 'Integer';\r\n            } else {\r\n              if (init) {\r\n                const realType = this.getType(init);\r\n                switch (realType) {\r\n                  case 'Integer':\r\n                  case 'Float':\r\n                  case 'Number':\r\n                    if (init.type === 'MemberExpression') {\r\n                      valueType = realType;\r\n                    } else {\r\n                      valueType = 'Number';\r\n                    }\r\n                    break;\r\n                  case 'LiteralInteger':\r\n                    valueType = 'Number';\r\n                    break;\r\n                  default:\r\n                    valueType = realType;\r\n                }\r\n              }\r\n            }\r\n            declaration.valueType = valueType;\r\n            declaration.dependencies = dependencies;\r\n            declaration.isSafe = this.isSafeDependencies(dependencies);\r\n          }\r\n      \r\n          for (let i = 0; i < functions.length; i++) {\r\n            this.onNestedFunction(functions[i], this.source);\r\n          }\r\n        }\r\n      \r\n        getDeclaration(ast) {\r\n          for (let i = 0; i < this.identifiers.length; i++) {\r\n            const identifier = this.identifiers[i];\r\n            if (ast === identifier.ast) {\r\n              return identifier.declaration;\r\n            }\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        getVariableType(ast) {\r\n          if (ast.type !== 'Identifier') {\r\n            throw new Error(`ast of ${ast.type} not \"Identifier\"`);\r\n          }\r\n          let type = null;\r\n          const argumentIndex = this.argumentNames.indexOf(ast.name);\r\n          if (argumentIndex === -1) {\r\n            const declaration = this.getDeclaration(ast);\r\n            if (declaration) {\r\n              return declaration.valueType;\r\n            }\r\n          } else {\r\n            const argumentType = this.argumentTypes[argumentIndex];\r\n            if (argumentType) {\r\n              type = argumentType;\r\n            }\r\n          }\r\n          if (!type && this.strictTypingChecking) {\r\n            throw new Error(`Declaration of ${name} not found`);\r\n          }\r\n          return type;\r\n        }\r\n      \r\n        getLookupType(type) {\r\n          if (!typeLookupMap.hasOwnProperty(type)) {\r\n            throw new Error(`unknown typeLookupMap ${ type }`);\r\n          }\r\n          return typeLookupMap[type];\r\n        }\r\n      \r\n        getConstantType(constantName) {\r\n          if (this.constantTypes[constantName]) {\r\n            const type = this.constantTypes[constantName];\r\n            if (type === 'Float') {\r\n              return 'Number';\r\n            } else {\r\n              return type;\r\n            }\r\n          }\r\n          throw new Error(`Type for constant \"${ constantName }\" not declared`);\r\n        }\r\n      \r\n        toString() {\r\n          if (this._string) return this._string;\r\n          return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();\r\n        }\r\n      \r\n        toJSON() {\r\n          const settings = {\r\n            source: this.source,\r\n            name: this.name,\r\n            constants: this.constants,\r\n            constantTypes: this.constantTypes,\r\n            isRootKernel: this.isRootKernel,\r\n            isSubKernel: this.isSubKernel,\r\n            debug: this.debug,\r\n            output: this.output,\r\n            loopMaxIterations: this.loopMaxIterations,\r\n            argumentNames: this.argumentNames,\r\n            argumentTypes: this.argumentTypes,\r\n            argumentSizes: this.argumentSizes,\r\n            returnType: this.returnType,\r\n            leadingReturnStatement: this.leadingReturnStatement,\r\n            followingReturnStatement: this.followingReturnStatement,\r\n          };\r\n      \r\n          return {\r\n            ast: this.ast,\r\n            settings\r\n          };\r\n        }\r\n      \r\n        getType(ast) {\r\n          if (Array.isArray(ast)) {\r\n            return this.getType(ast[ast.length - 1]);\r\n          }\r\n          switch (ast.type) {\r\n            case 'BlockStatement':\r\n              return this.getType(ast.body);\r\n            case 'ArrayExpression':\r\n              const childType = this.getType(ast.elements[0]);\r\n              switch (childType) {\r\n                case 'Array(2)':\r\n                case 'Array(3)':\r\n                case 'Array(4)':\r\n                  return `Matrix(${ast.elements.length})`;\r\n              }\r\n              return `Array(${ ast.elements.length })`;\r\n            case 'Literal':\r\n              const literalKey = this.astKey(ast);\r\n              if (this.literalTypes[literalKey]) {\r\n                return this.literalTypes[literalKey];\r\n              }\r\n              if (Number.isInteger(ast.value)) {\r\n                return 'LiteralInteger';\r\n              } else if (ast.value === true || ast.value === false) {\r\n                return 'Boolean';\r\n              } else {\r\n                return 'Number';\r\n              }\r\n              case 'AssignmentExpression':\r\n                return this.getType(ast.left);\r\n              case 'CallExpression':\r\n                if (this.isAstMathFunction(ast)) {\r\n                  return 'Number';\r\n                }\r\n                if (!ast.callee || !ast.callee.name) {\r\n                  if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {\r\n                    const functionName = ast.callee.expressions[ast.callee.expressions.length - 1].property.name;\r\n                    this.inferArgumentTypesIfNeeded(functionName, ast.arguments);\r\n                    return this.lookupReturnType(functionName, ast, this);\r\n                  }\r\n                  if (this.getVariableSignature(ast.callee, true) === 'this.color') {\r\n                    return null;\r\n                  }\r\n                  if (ast.callee.type === 'MemberExpression' && ast.callee.object && ast.callee.property && ast.callee.property.name && ast.arguments) {\r\n                    const functionName = ast.callee.property.name;\r\n                    this.inferArgumentTypesIfNeeded(functionName, ast.arguments);\r\n                    return this.lookupReturnType(functionName, ast, this);\r\n                  }\r\n                  throw this.astErrorOutput('Unknown call expression', ast);\r\n                }\r\n                if (ast.callee && ast.callee.name) {\r\n                  const functionName = ast.callee.name;\r\n                  this.inferArgumentTypesIfNeeded(functionName, ast.arguments);\r\n                  return this.lookupReturnType(functionName, ast, this);\r\n                }\r\n                throw this.astErrorOutput(`Unhandled getType Type \"${ ast.type }\"`, ast);\r\n              case 'LogicalExpression':\r\n                return 'Boolean';\r\n              case 'BinaryExpression':\r\n                switch (ast.operator) {\r\n                  case '%':\r\n                  case '/':\r\n                    if (this.fixIntegerDivisionAccuracy) {\r\n                      return 'Number';\r\n                    } else {\r\n                      break;\r\n                    }\r\n                    case '>':\r\n                    case '<':\r\n                      return 'Boolean';\r\n                    case '&':\r\n                    case '|':\r\n                    case '^':\r\n                    case '<<':\r\n                    case '>>':\r\n                    case '>>>':\r\n                      return 'Integer';\r\n                }\r\n                const type = this.getType(ast.left);\r\n                if (this.isState('skip-literal-correction')) return type;\r\n                if (type === 'LiteralInteger') {\r\n                  const rightType = this.getType(ast.right);\r\n                  if (rightType === 'LiteralInteger') {\r\n                    if (ast.left.value % 1 === 0) {\r\n                      return 'Integer';\r\n                    } else {\r\n                      return 'Float';\r\n                    }\r\n                  }\r\n                  return rightType;\r\n                }\r\n                return typeLookupMap[type] || type;\r\n              case 'UpdateExpression':\r\n                return this.getType(ast.argument);\r\n              case 'UnaryExpression':\r\n                if (ast.operator === '~') {\r\n                  return 'Integer';\r\n                }\r\n                return this.getType(ast.argument);\r\n              case 'VariableDeclaration': {\r\n                const declarations = ast.declarations;\r\n                let lastType;\r\n                for (let i = 0; i < declarations.length; i++) {\r\n                  const declaration = declarations[i];\r\n                  lastType = this.getType(declaration);\r\n                }\r\n                if (!lastType) {\r\n                  throw this.astErrorOutput(`Unable to find type for declaration`, ast);\r\n                }\r\n                return lastType;\r\n              }\r\n              case 'VariableDeclarator':\r\n                const declaration = this.getDeclaration(ast.id);\r\n                if (!declaration) {\r\n                  throw this.astErrorOutput(`Unable to find declarator`, ast);\r\n                }\r\n      \r\n                if (!declaration.valueType) {\r\n                  throw this.astErrorOutput(`Unable to find declarator valueType`, ast);\r\n                }\r\n      \r\n                return declaration.valueType;\r\n              case 'Identifier':\r\n                if (ast.name === 'Infinity') {\r\n                  return 'Number';\r\n                }\r\n                if (this.isAstVariable(ast)) {\r\n                  const signature = this.getVariableSignature(ast);\r\n                  if (signature === 'value') {\r\n                    return this.getCheckVariableType(ast);\r\n                  }\r\n                }\r\n                const origin = this.findIdentifierOrigin(ast);\r\n                if (origin && origin.init) {\r\n                  return this.getType(origin.init);\r\n                }\r\n                return null;\r\n              case 'ReturnStatement':\r\n                return this.getType(ast.argument);\r\n              case 'MemberExpression':\r\n                if (this.isAstMathFunction(ast)) {\r\n                  switch (ast.property.name) {\r\n                    case 'ceil':\r\n                      return 'Integer';\r\n                    case 'floor':\r\n                      return 'Integer';\r\n                    case 'round':\r\n                      return 'Integer';\r\n                  }\r\n                  return 'Number';\r\n                }\r\n                if (this.isAstVariable(ast)) {\r\n                  const variableSignature = this.getVariableSignature(ast);\r\n                  switch (variableSignature) {\r\n                    case 'value[]':\r\n                      return this.getLookupType(this.getCheckVariableType(ast.object));\r\n                    case 'value[][]':\r\n                      return this.getLookupType(this.getCheckVariableType(ast.object.object));\r\n                    case 'value[][][]':\r\n                      return this.getLookupType(this.getCheckVariableType(ast.object.object.object));\r\n                    case 'value[][][][]':\r\n                      return this.getLookupType(this.getCheckVariableType(ast.object.object.object.object));\r\n                    case 'value.thread.value':\r\n                    case 'this.thread.value':\r\n                      return 'Integer';\r\n                    case 'this.output.value':\r\n                      return this.dynamicOutput ? 'Integer' : 'LiteralInteger';\r\n                    case 'this.constants.value':\r\n                      return this.getConstantType(ast.property.name);\r\n                    case 'this.constants.value[]':\r\n                      return this.getLookupType(this.getConstantType(ast.object.property.name));\r\n                    case 'this.constants.value[][]':\r\n                      return this.getLookupType(this.getConstantType(ast.object.object.property.name));\r\n                    case 'this.constants.value[][][]':\r\n                      return this.getLookupType(this.getConstantType(ast.object.object.object.property.name));\r\n                    case 'this.constants.value[][][][]':\r\n                      return this.getLookupType(this.getConstantType(ast.object.object.object.object.property.name));\r\n                    case 'fn()[]':\r\n                    case 'fn()[][]':\r\n                    case 'fn()[][][]':\r\n                      return this.getLookupType(this.getType(ast.object));\r\n                    case 'value.value':\r\n                      if (this.isAstMathVariable(ast)) {\r\n                        return 'Number';\r\n                      }\r\n                      switch (ast.property.name) {\r\n                        case 'r':\r\n                        case 'g':\r\n                        case 'b':\r\n                        case 'a':\r\n                          return this.getLookupType(this.getCheckVariableType(ast.object));\r\n                      }\r\n                      case '[][]':\r\n                        return 'Number';\r\n                  }\r\n                  throw this.astErrorOutput('Unhandled getType MemberExpression', ast);\r\n                }\r\n                throw this.astErrorOutput('Unhandled getType MemberExpression', ast);\r\n              case 'ConditionalExpression':\r\n                return this.getType(ast.consequent);\r\n              case 'FunctionDeclaration':\r\n              case 'FunctionExpression':\r\n                const lastReturn = this.findLastReturn(ast.body);\r\n                if (lastReturn) {\r\n                  return this.getType(lastReturn);\r\n                }\r\n                return null;\r\n              case 'IfStatement':\r\n                return this.getType(ast.consequent);\r\n              case 'SequenceExpression':\r\n                return this.getType(ast.expressions[ast.expressions.length - 1]);\r\n              default:\r\n                throw this.astErrorOutput(`Unhandled getType Type \"${ ast.type }\"`, ast);\r\n          }\r\n        }\r\n      \r\n        getCheckVariableType(ast) {\r\n          const type = this.getVariableType(ast);\r\n          if (!type) {\r\n            throw this.astErrorOutput(`${ast.type} is not defined`, ast);\r\n          }\r\n          return type;\r\n        }\r\n      \r\n        inferArgumentTypesIfNeeded(functionName, args) {\r\n          for (let i = 0; i < args.length; i++) {\r\n            if (!this.needsArgumentType(functionName, i)) continue;\r\n            const type = this.getType(args[i]);\r\n            if (!type) {\r\n              throw this.astErrorOutput(`Unable to infer argument ${i}`, args[i]);\r\n            }\r\n            this.assignArgumentType(functionName, i, type);\r\n          }\r\n        }\r\n      \r\n        isAstMathVariable(ast) {\r\n          const mathProperties = [\r\n            'E',\r\n            'PI',\r\n            'SQRT2',\r\n            'SQRT1_2',\r\n            'LN2',\r\n            'LN10',\r\n            'LOG2E',\r\n            'LOG10E',\r\n          ];\r\n          return ast.type === 'MemberExpression' &&\r\n            ast.object && ast.object.type === 'Identifier' &&\r\n            ast.object.name === 'Math' &&\r\n            ast.property &&\r\n            ast.property.type === 'Identifier' &&\r\n            mathProperties.indexOf(ast.property.name) > -1;\r\n        }\r\n      \r\n        isAstMathFunction(ast) {\r\n          const mathFunctions = [\r\n            'abs',\r\n            'acos',\r\n            'acosh',\r\n            'asin',\r\n            'asinh',\r\n            'atan',\r\n            'atan2',\r\n            'atanh',\r\n            'cbrt',\r\n            'ceil',\r\n            'clz32',\r\n            'cos',\r\n            'cosh',\r\n            'expm1',\r\n            'exp',\r\n            'floor',\r\n            'fround',\r\n            'imul',\r\n            'log',\r\n            'log2',\r\n            'log10',\r\n            'log1p',\r\n            'max',\r\n            'min',\r\n            'pow',\r\n            'random',\r\n            'round',\r\n            'sign',\r\n            'sin',\r\n            'sinh',\r\n            'sqrt',\r\n            'tan',\r\n            'tanh',\r\n            'trunc',\r\n          ];\r\n          return ast.type === 'CallExpression' &&\r\n            ast.callee &&\r\n            ast.callee.type === 'MemberExpression' &&\r\n            ast.callee.object &&\r\n            ast.callee.object.type === 'Identifier' &&\r\n            ast.callee.object.name === 'Math' &&\r\n            ast.callee.property &&\r\n            ast.callee.property.type === 'Identifier' &&\r\n            mathFunctions.indexOf(ast.callee.property.name) > -1;\r\n        }\r\n      \r\n        isAstVariable(ast) {\r\n          return ast.type === 'Identifier' || ast.type === 'MemberExpression';\r\n        }\r\n      \r\n        isSafe(ast) {\r\n          return this.isSafeDependencies(this.getDependencies(ast));\r\n        }\r\n      \r\n        isSafeDependencies(dependencies) {\r\n          return dependencies && dependencies.every ? dependencies.every(dependency => dependency.isSafe) : true;\r\n        }\r\n      \r\n        getDependencies(ast, dependencies, isNotSafe) {\r\n          if (!dependencies) {\r\n            dependencies = [];\r\n          }\r\n          if (!ast) return null;\r\n          if (Array.isArray(ast)) {\r\n            for (let i = 0; i < ast.length; i++) {\r\n              this.getDependencies(ast[i], dependencies, isNotSafe);\r\n            }\r\n            return dependencies;\r\n          }\r\n          switch (ast.type) {\r\n            case 'AssignmentExpression':\r\n              this.getDependencies(ast.left, dependencies, isNotSafe);\r\n              this.getDependencies(ast.right, dependencies, isNotSafe);\r\n              return dependencies;\r\n            case 'ConditionalExpression':\r\n              this.getDependencies(ast.test, dependencies, isNotSafe);\r\n              this.getDependencies(ast.alternate, dependencies, isNotSafe);\r\n              this.getDependencies(ast.consequent, dependencies, isNotSafe);\r\n              return dependencies;\r\n            case 'Literal':\r\n              dependencies.push({\r\n                origin: 'literal',\r\n                value: ast.value,\r\n                isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)\r\n              });\r\n              break;\r\n            case 'VariableDeclarator':\r\n              return this.getDependencies(ast.init, dependencies, isNotSafe);\r\n            case 'Identifier':\r\n              const declaration = this.getDeclaration(ast);\r\n              if (declaration) {\r\n                dependencies.push({\r\n                  name: ast.name,\r\n                  origin: 'declaration',\r\n                  isSafe: isNotSafe ? false : this.isSafeDependencies(declaration.dependencies),\r\n                });\r\n              } else if (this.argumentNames.indexOf(ast.name) > -1) {\r\n                dependencies.push({\r\n                  name: ast.name,\r\n                  origin: 'argument',\r\n                  isSafe: false,\r\n                });\r\n              } else if (this.strictTypingChecking) {\r\n                throw new Error(`Cannot find identifier origin \"${ast.name}\"`);\r\n              }\r\n              break;\r\n            case 'FunctionDeclaration':\r\n              return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);\r\n            case 'ReturnStatement':\r\n              return this.getDependencies(ast.argument, dependencies);\r\n            case 'BinaryExpression':\r\n            case 'LogicalExpression':\r\n              isNotSafe = (ast.operator === '/' || ast.operator === '*');\r\n              this.getDependencies(ast.left, dependencies, isNotSafe);\r\n              this.getDependencies(ast.right, dependencies, isNotSafe);\r\n              return dependencies;\r\n            case 'UnaryExpression':\r\n            case 'UpdateExpression':\r\n              return this.getDependencies(ast.argument, dependencies, isNotSafe);\r\n            case 'VariableDeclaration':\r\n              return this.getDependencies(ast.declarations, dependencies, isNotSafe);\r\n            case 'ArrayExpression':\r\n              dependencies.push({\r\n                origin: 'declaration',\r\n                isSafe: true,\r\n              });\r\n              return dependencies;\r\n            case 'CallExpression':\r\n              dependencies.push({\r\n                origin: 'function',\r\n                isSafe: true,\r\n              });\r\n              return dependencies;\r\n            case 'MemberExpression':\r\n              const details = this.getMemberExpressionDetails(ast);\r\n              switch (details.signature) {\r\n                case 'value[]':\r\n                  this.getDependencies(ast.object, dependencies, isNotSafe);\r\n                  break;\r\n                case 'value[][]':\r\n                  this.getDependencies(ast.object.object, dependencies, isNotSafe);\r\n                  break;\r\n                case 'value[][][]':\r\n                  this.getDependencies(ast.object.object.object, dependencies, isNotSafe);\r\n                  break;\r\n                case 'this.output.value':\r\n                  if (this.dynamicOutput) {\r\n                    dependencies.push({\r\n                      name: details.name,\r\n                      origin: 'output',\r\n                      isSafe: false,\r\n                    });\r\n                  }\r\n                  break;\r\n              }\r\n              if (details) {\r\n                if (details.property) {\r\n                  this.getDependencies(details.property, dependencies, isNotSafe);\r\n                }\r\n                if (details.xProperty) {\r\n                  this.getDependencies(details.xProperty, dependencies, isNotSafe);\r\n                }\r\n                if (details.yProperty) {\r\n                  this.getDependencies(details.yProperty, dependencies, isNotSafe);\r\n                }\r\n                if (details.zProperty) {\r\n                  this.getDependencies(details.zProperty, dependencies, isNotSafe);\r\n                }\r\n                return dependencies;\r\n              }\r\n              case 'SequenceExpression':\r\n                return this.getDependencies(ast.expressions, dependencies, isNotSafe);\r\n              default:\r\n                throw this.astErrorOutput(`Unhandled type ${ ast.type } in getDependencies`, ast);\r\n          }\r\n          return dependencies;\r\n        }\r\n      \r\n        getVariableSignature(ast, returnRawValue) {\r\n          if (!this.isAstVariable(ast)) {\r\n            throw new Error(`ast of type \"${ ast.type }\" is not a variable signature`);\r\n          }\r\n          if (ast.type === 'Identifier') {\r\n            return 'value';\r\n          }\r\n          const signature = [];\r\n          while (true) {\r\n            if (!ast) break;\r\n            if (ast.computed) {\r\n              signature.push('[]');\r\n            } else if (ast.type === 'ThisExpression') {\r\n              signature.unshift('this');\r\n            } else if (ast.property && ast.property.name) {\r\n              if (\r\n                ast.property.name === 'x' ||\r\n                ast.property.name === 'y' ||\r\n                ast.property.name === 'z'\r\n              ) {\r\n                signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');\r\n              } else if (\r\n                ast.property.name === 'constants' ||\r\n                ast.property.name === 'thread' ||\r\n                ast.property.name === 'output'\r\n              ) {\r\n                signature.unshift('.' + ast.property.name);\r\n              } else {\r\n                signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');\r\n              }\r\n            } else if (ast.name) {\r\n              signature.unshift(returnRawValue ? ast.name : 'value');\r\n            } else if (ast.callee && ast.callee.name) {\r\n              signature.unshift(returnRawValue ? ast.callee.name + '()' : 'fn()');\r\n            } else if (ast.elements) {\r\n              signature.unshift('[]');\r\n            } else {\r\n              signature.unshift('unknown');\r\n            }\r\n            ast = ast.object;\r\n          }\r\n      \r\n          const signatureString = signature.join('');\r\n          if (returnRawValue) {\r\n            return signatureString;\r\n          }\r\n      \r\n          const allowedExpressions = [\r\n            'value',\r\n            'value[]',\r\n            'value[][]',\r\n            'value[][][]',\r\n            'value[][][][]',\r\n            'value.value',\r\n            'value.thread.value',\r\n            'this.thread.value',\r\n            'this.output.value',\r\n            'this.constants.value',\r\n            'this.constants.value[]',\r\n            'this.constants.value[][]',\r\n            'this.constants.value[][][]',\r\n            'this.constants.value[][][][]',\r\n            'fn()[]',\r\n            'fn()[][]',\r\n            'fn()[][][]',\r\n            '[][]',\r\n          ];\r\n          if (allowedExpressions.indexOf(signatureString) > -1) {\r\n            return signatureString;\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        build() {\r\n          return this.toString().length > 0;\r\n        }\r\n      \r\n        astGeneric(ast, retArr) {\r\n          if (ast === null) {\r\n            throw this.astErrorOutput('NULL ast', ast);\r\n          } else {\r\n            if (Array.isArray(ast)) {\r\n              for (let i = 0; i < ast.length; i++) {\r\n                this.astGeneric(ast[i], retArr);\r\n              }\r\n              return retArr;\r\n            }\r\n      \r\n            switch (ast.type) {\r\n              case 'FunctionDeclaration':\r\n                return this.astFunctionDeclaration(ast, retArr);\r\n              case 'FunctionExpression':\r\n                return this.astFunctionExpression(ast, retArr);\r\n              case 'ReturnStatement':\r\n                return this.astReturnStatement(ast, retArr);\r\n              case 'Literal':\r\n                return this.astLiteral(ast, retArr);\r\n              case 'BinaryExpression':\r\n                return this.astBinaryExpression(ast, retArr);\r\n              case 'Identifier':\r\n                return this.astIdentifierExpression(ast, retArr);\r\n              case 'AssignmentExpression':\r\n                return this.astAssignmentExpression(ast, retArr);\r\n              case 'ExpressionStatement':\r\n                return this.astExpressionStatement(ast, retArr);\r\n              case 'EmptyStatement':\r\n                return this.astEmptyStatement(ast, retArr);\r\n              case 'BlockStatement':\r\n                return this.astBlockStatement(ast, retArr);\r\n              case 'IfStatement':\r\n                return this.astIfStatement(ast, retArr);\r\n              case 'SwitchStatement':\r\n                return this.astSwitchStatement(ast, retArr);\r\n              case 'BreakStatement':\r\n                return this.astBreakStatement(ast, retArr);\r\n              case 'ContinueStatement':\r\n                return this.astContinueStatement(ast, retArr);\r\n              case 'ForStatement':\r\n                return this.astForStatement(ast, retArr);\r\n              case 'WhileStatement':\r\n                return this.astWhileStatement(ast, retArr);\r\n              case 'DoWhileStatement':\r\n                return this.astDoWhileStatement(ast, retArr);\r\n              case 'VariableDeclaration':\r\n                return this.astVariableDeclaration(ast, retArr);\r\n              case 'VariableDeclarator':\r\n                return this.astVariableDeclarator(ast, retArr);\r\n              case 'ThisExpression':\r\n                return this.astThisExpression(ast, retArr);\r\n              case 'SequenceExpression':\r\n                return this.astSequenceExpression(ast, retArr);\r\n              case 'UnaryExpression':\r\n                return this.astUnaryExpression(ast, retArr);\r\n              case 'UpdateExpression':\r\n                return this.astUpdateExpression(ast, retArr);\r\n              case 'LogicalExpression':\r\n                return this.astLogicalExpression(ast, retArr);\r\n              case 'MemberExpression':\r\n                return this.astMemberExpression(ast, retArr);\r\n              case 'CallExpression':\r\n                return this.astCallExpression(ast, retArr);\r\n              case 'ArrayExpression':\r\n                return this.astArrayExpression(ast, retArr);\r\n              case 'DebuggerStatement':\r\n                return this.astDebuggerStatement(ast, retArr);\r\n              case 'ConditionalExpression':\r\n                return this.astConditionalExpression(ast, retArr);\r\n            }\r\n      \r\n            throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);\r\n          }\r\n        }\r\n        astErrorOutput(error, ast) {\r\n          if (typeof this.source !== 'string') {\r\n            return new Error(error);\r\n          }\r\n      \r\n          const debugString = utils.getAstString(this.source, ast);\r\n          const leadingSource = this.source.substr(ast.start);\r\n          const splitLines = leadingSource.split(/\\n/);\r\n          const lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;\r\n          return new Error(`${error} on line ${ splitLines.length }, position ${ lineBefore.length }:\\n ${ debugString }`);\r\n        }\r\n      \r\n        astDebuggerStatement(arrNode, retArr) {\r\n          return retArr;\r\n        }\r\n      \r\n        astConditionalExpression(ast, retArr) {\r\n          if (ast.type !== 'ConditionalExpression') {\r\n            throw this.astErrorOutput('Not a conditional expression', ast);\r\n          }\r\n          retArr.push('(');\r\n          this.astGeneric(ast.test, retArr);\r\n          retArr.push('?');\r\n          this.astGeneric(ast.consequent, retArr);\r\n          retArr.push(':');\r\n          this.astGeneric(ast.alternate, retArr);\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        astFunction(ast, retArr) {\r\n          throw new Error(`\"astFunction\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        astFunctionDeclaration(ast, retArr) {\r\n          if (this.isChildFunction(ast)) {\r\n            return retArr;\r\n          }\r\n          return this.astFunction(ast, retArr);\r\n        }\r\n        astFunctionExpression(ast, retArr) {\r\n          if (this.isChildFunction(ast)) {\r\n            return retArr;\r\n          }\r\n          return this.astFunction(ast, retArr);\r\n        }\r\n        isChildFunction(ast) {\r\n          for (let i = 0; i < this.functions.length; i++) {\r\n            if (this.functions[i] === ast) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        }\r\n        astReturnStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astLiteral(ast, retArr) {\r\n          this.literalTypes[this.astKey(ast)] = 'Number';\r\n          return retArr;\r\n        }\r\n        astBinaryExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astIdentifierExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astAssignmentExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astExpressionStatement(esNode, retArr) {\r\n          this.astGeneric(esNode.expression, retArr);\r\n          retArr.push(';');\r\n          return retArr;\r\n        }\r\n        astEmptyStatement(eNode, retArr) {\r\n          return retArr;\r\n        }\r\n        astBlockStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astIfStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astSwitchStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astBreakStatement(brNode, retArr) {\r\n          retArr.push('break;');\r\n          return retArr;\r\n        }\r\n        astContinueStatement(crNode, retArr) {\r\n          retArr.push('continue;\\n');\r\n          return retArr;\r\n        }\r\n        astForStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astWhileStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astDoWhileStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astVariableDeclarator(iVarDecNode, retArr) {\r\n          this.astGeneric(iVarDecNode.id, retArr);\r\n          if (iVarDecNode.init !== null) {\r\n            retArr.push('=');\r\n            this.astGeneric(iVarDecNode.init, retArr);\r\n          }\r\n          return retArr;\r\n        }\r\n        astThisExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astSequenceExpression(sNode, retArr) {\r\n          const { expressions } = sNode;\r\n          const sequenceResult = [];\r\n          for (let i = 0; i < expressions.length; i++) {\r\n            const expression = expressions[i];\r\n            const expressionResult = [];\r\n            this.astGeneric(expression, expressionResult);\r\n            sequenceResult.push(expressionResult.join(''));\r\n          }\r\n          if (sequenceResult.length > 1) {\r\n            retArr.push('(', sequenceResult.join(','), ')');\r\n          } else {\r\n            retArr.push(sequenceResult[0]);\r\n          }\r\n          return retArr;\r\n        }\r\n        astUnaryExpression(uNode, retArr) {\r\n          const unaryResult = this.checkAndUpconvertBitwiseUnary(uNode, retArr);\r\n          if (unaryResult) {\r\n            return retArr;\r\n          }\r\n      \r\n          if (uNode.prefix) {\r\n            retArr.push(uNode.operator);\r\n            this.astGeneric(uNode.argument, retArr);\r\n          } else {\r\n            this.astGeneric(uNode.argument, retArr);\r\n            retArr.push(uNode.operator);\r\n          }\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        checkAndUpconvertBitwiseUnary(uNode, retArr) {}\r\n      \r\n        astUpdateExpression(uNode, retArr) {\r\n          if (uNode.prefix) {\r\n            retArr.push(uNode.operator);\r\n            this.astGeneric(uNode.argument, retArr);\r\n          } else {\r\n            this.astGeneric(uNode.argument, retArr);\r\n            retArr.push(uNode.operator);\r\n          }\r\n      \r\n          return retArr;\r\n        }\r\n        astLogicalExpression(logNode, retArr) {\r\n          retArr.push('(');\r\n          this.astGeneric(logNode.left, retArr);\r\n          retArr.push(logNode.operator);\r\n          this.astGeneric(logNode.right, retArr);\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n        astMemberExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astCallExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astArrayExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n      \r\n        getMemberExpressionDetails(ast) {\r\n          if (ast.type !== 'MemberExpression') {\r\n            throw this.astErrorOutput(`Expression ${ ast.type } not a MemberExpression`, ast);\r\n          }\r\n          let name = null;\r\n          let type = null;\r\n          const variableSignature = this.getVariableSignature(ast);\r\n          switch (variableSignature) {\r\n            case 'value':\r\n              return null;\r\n            case 'value.thread.value':\r\n            case 'this.thread.value':\r\n            case 'this.output.value':\r\n              return {\r\n                signature: variableSignature,\r\n                  type: 'Integer',\r\n                  name: ast.property.name\r\n              };\r\n            case 'value[]':\r\n              if (typeof ast.object.name !== 'string') {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              name = ast.object.name;\r\n              return {\r\n                name,\r\n                origin: 'user',\r\n                  signature: variableSignature,\r\n                  type: this.getVariableType(ast.object),\r\n                  xProperty: ast.property\r\n              };\r\n            case 'value[][]':\r\n              if (typeof ast.object.object.name !== 'string') {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              name = ast.object.object.name;\r\n              return {\r\n                name,\r\n                origin: 'user',\r\n                  signature: variableSignature,\r\n                  type: this.getVariableType(ast.object.object),\r\n                  yProperty: ast.object.property,\r\n                  xProperty: ast.property,\r\n              };\r\n            case 'value[][][]':\r\n              if (typeof ast.object.object.object.name !== 'string') {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              name = ast.object.object.object.name;\r\n              return {\r\n                name,\r\n                origin: 'user',\r\n                  signature: variableSignature,\r\n                  type: this.getVariableType(ast.object.object.object),\r\n                  zProperty: ast.object.object.property,\r\n                  yProperty: ast.object.property,\r\n                  xProperty: ast.property,\r\n              };\r\n            case 'value[][][][]':\r\n              if (typeof ast.object.object.object.object.name !== 'string') {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              name = ast.object.object.object.object.name;\r\n              return {\r\n                name,\r\n                origin: 'user',\r\n                  signature: variableSignature,\r\n                  type: this.getVariableType(ast.object.object.object.object),\r\n                  zProperty: ast.object.object.property,\r\n                  yProperty: ast.object.property,\r\n                  xProperty: ast.property,\r\n              };\r\n            case 'value.value':\r\n              if (typeof ast.property.name !== 'string') {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              if (this.isAstMathVariable(ast)) {\r\n                name = ast.property.name;\r\n                return {\r\n                  name,\r\n                  origin: 'Math',\r\n                  type: 'Number',\r\n                  signature: variableSignature,\r\n                };\r\n              }\r\n              switch (ast.property.name) {\r\n                case 'r':\r\n                case 'g':\r\n                case 'b':\r\n                case 'a':\r\n                  name = ast.object.name;\r\n                  return {\r\n                    name,\r\n                    property: ast.property.name,\r\n                      origin: 'user',\r\n                      signature: variableSignature,\r\n                      type: 'Number'\r\n                  };\r\n                default:\r\n                  throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              case 'this.constants.value':\r\n                if (typeof ast.property.name !== 'string') {\r\n                  throw this.astErrorOutput('Unexpected expression', ast);\r\n                }\r\n                name = ast.property.name;\r\n                type = this.getConstantType(name);\r\n                if (!type) {\r\n                  throw this.astErrorOutput('Constant has no type', ast);\r\n                }\r\n                return {\r\n                  name,\r\n                  type,\r\n                  origin: 'constants',\r\n                    signature: variableSignature,\r\n                };\r\n              case 'this.constants.value[]':\r\n                if (typeof ast.object.property.name !== 'string') {\r\n                  throw this.astErrorOutput('Unexpected expression', ast);\r\n                }\r\n                name = ast.object.property.name;\r\n                type = this.getConstantType(name);\r\n                if (!type) {\r\n                  throw this.astErrorOutput('Constant has no type', ast);\r\n                }\r\n                return {\r\n                  name,\r\n                  type,\r\n                  origin: 'constants',\r\n                    signature: variableSignature,\r\n                    xProperty: ast.property,\r\n                };\r\n              case 'this.constants.value[][]': {\r\n                if (typeof ast.object.object.property.name !== 'string') {\r\n                  throw this.astErrorOutput('Unexpected expression', ast);\r\n                }\r\n                name = ast.object.object.property.name;\r\n                type = this.getConstantType(name);\r\n                if (!type) {\r\n                  throw this.astErrorOutput('Constant has no type', ast);\r\n                }\r\n                return {\r\n                  name,\r\n                  type,\r\n                  origin: 'constants',\r\n                  signature: variableSignature,\r\n                  yProperty: ast.object.property,\r\n                  xProperty: ast.property,\r\n                };\r\n              }\r\n              case 'this.constants.value[][][]': {\r\n                if (typeof ast.object.object.object.property.name !== 'string') {\r\n                  throw this.astErrorOutput('Unexpected expression', ast);\r\n                }\r\n                name = ast.object.object.object.property.name;\r\n                type = this.getConstantType(name);\r\n                if (!type) {\r\n                  throw this.astErrorOutput('Constant has no type', ast);\r\n                }\r\n                return {\r\n                  name,\r\n                  type,\r\n                  origin: 'constants',\r\n                  signature: variableSignature,\r\n                  zProperty: ast.object.object.property,\r\n                  yProperty: ast.object.property,\r\n                  xProperty: ast.property,\r\n                };\r\n              }\r\n              case 'fn()[]':\r\n              case 'fn()[][]':\r\n              case '[][]':\r\n                return {\r\n                  signature: variableSignature,\r\n                    property: ast.property,\r\n                };\r\n              default:\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n          }\r\n        }\r\n      \r\n        findIdentifierOrigin(astToFind) {\r\n          const stack = [this.ast];\r\n      \r\n          while (stack.length > 0) {\r\n            const atNode = stack[0];\r\n            if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {\r\n              return atNode;\r\n            }\r\n            stack.shift();\r\n            if (atNode.argument) {\r\n              stack.push(atNode.argument);\r\n            } else if (atNode.body) {\r\n              stack.push(atNode.body);\r\n            } else if (atNode.declarations) {\r\n              stack.push(atNode.declarations);\r\n            } else if (Array.isArray(atNode)) {\r\n              for (let i = 0; i < atNode.length; i++) {\r\n                stack.push(atNode[i]);\r\n              }\r\n            }\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        findLastReturn(ast) {\r\n          const stack = [ast || this.ast];\r\n      \r\n          while (stack.length > 0) {\r\n            const atNode = stack.pop();\r\n            if (atNode.type === 'ReturnStatement') {\r\n              return atNode;\r\n            }\r\n            if (atNode.type === 'FunctionDeclaration') {\r\n              continue;\r\n            }\r\n            if (atNode.argument) {\r\n              stack.push(atNode.argument);\r\n            } else if (atNode.body) {\r\n              stack.push(atNode.body);\r\n            } else if (atNode.declarations) {\r\n              stack.push(atNode.declarations);\r\n            } else if (Array.isArray(atNode)) {\r\n              for (let i = 0; i < atNode.length; i++) {\r\n                stack.push(atNode[i]);\r\n              }\r\n            } else if (atNode.consequent) {\r\n              stack.push(atNode.consequent);\r\n            } else if (atNode.cases) {\r\n              stack.push(atNode.cases);\r\n            }\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        getInternalVariableName(name) {\r\n          if (!this._internalVariableNames.hasOwnProperty(name)) {\r\n            this._internalVariableNames[name] = 0;\r\n          }\r\n          this._internalVariableNames[name]++;\r\n          if (this._internalVariableNames[name] === 1) {\r\n            return name;\r\n          }\r\n          return name + this._internalVariableNames[name];\r\n        }\r\n      \r\n        astKey(ast, separator = ',') {\r\n          if (!ast.start || !ast.end) throw new Error('AST start and end needed');\r\n          return `${ast.start}${separator}${ast.end}`;\r\n        }\r\n      }\r\n      \r\n      const typeLookupMap = {\r\n        'Number': 'Number',\r\n        'Float': 'Float',\r\n        'Integer': 'Integer',\r\n        'Array': 'Number',\r\n        'Array(2)': 'Number',\r\n        'Array(3)': 'Number',\r\n        'Array(4)': 'Number',\r\n        'Matrix(2)': 'Number',\r\n        'Matrix(3)': 'Number',\r\n        'Matrix(4)': 'Number',\r\n        'Array2D': 'Number',\r\n        'Array3D': 'Number',\r\n        'Input': 'Number',\r\n        'HTMLCanvas': 'Array(4)',\r\n        'HTMLImage': 'Array(4)',\r\n        'HTMLVideo': 'Array(4)',\r\n        'HTMLImageArray': 'Array(4)',\r\n        'NumberTexture': 'Number',\r\n        'MemoryOptimizedNumberTexture': 'Number',\r\n        'Array1D(2)': 'Array(2)',\r\n        'Array1D(3)': 'Array(3)',\r\n        'Array1D(4)': 'Array(4)',\r\n        'Array2D(2)': 'Array(2)',\r\n        'Array2D(3)': 'Array(3)',\r\n        'Array2D(4)': 'Array(4)',\r\n        'Array3D(2)': 'Array(2)',\r\n        'Array3D(3)': 'Array(3)',\r\n        'Array3D(4)': 'Array(4)',\r\n        'ArrayTexture(1)': 'Number',\r\n        'ArrayTexture(2)': 'Array(2)',\r\n        'ArrayTexture(3)': 'Array(3)',\r\n        'ArrayTexture(4)': 'Array(4)',\r\n      };\r\n      \r\n      module.exports = {\r\n        FunctionNode\r\n      };\r\n      },{\"../utils\":114,\"./function-tracer\":11,\"acorn\":1}],11:[function(require,module,exports){\r\n      const { utils } = require('../utils');\r\n      \r\n      function last(array) {\r\n        return array.length > 0 ? array[array.length - 1] : null;\r\n      }\r\n      \r\n      const states = {\r\n        trackIdentifiers: 'trackIdentifiers',\r\n        memberExpression: 'memberExpression',\r\n        inForLoopInit: 'inForLoopInit'\r\n      };\r\n      \r\n      class FunctionTracer {\r\n        constructor(ast) {\r\n          this.runningContexts = [];\r\n          this.functionContexts = [];\r\n          this.contexts = [];\r\n          this.functionCalls = [];\r\n          this.declarations = [];\r\n          this.identifiers = [];\r\n          this.functions = [];\r\n          this.returnStatements = [];\r\n          this.trackedIdentifiers = null;\r\n          this.states = [];\r\n          this.newFunctionContext();\r\n          this.scan(ast);\r\n        }\r\n      \r\n        isState(state) {\r\n          return this.states[this.states.length - 1] === state;\r\n        }\r\n      \r\n        hasState(state) {\r\n          return this.states.indexOf(state) > -1;\r\n        }\r\n      \r\n        pushState(state) {\r\n          this.states.push(state);\r\n        }\r\n      \r\n        popState(state) {\r\n          if (this.isState(state)) {\r\n            this.states.pop();\r\n          } else {\r\n            throw new Error(`Cannot pop the non-active state \"${state}\"`);\r\n          }\r\n        }\r\n      \r\n        get currentFunctionContext() {\r\n          return last(this.functionContexts);\r\n        }\r\n      \r\n        get currentContext() {\r\n          return last(this.runningContexts);\r\n        }\r\n      \r\n        newFunctionContext() {\r\n          const newContext = { '@contextType': 'function' };\r\n          this.contexts.push(newContext);\r\n          this.functionContexts.push(newContext);\r\n        }\r\n      \r\n        newContext(run) {\r\n          const newContext = Object.assign({ '@contextType': 'const/let' }, this.currentContext);\r\n          this.contexts.push(newContext);\r\n          this.runningContexts.push(newContext);\r\n          run();\r\n          const { currentFunctionContext } = this;\r\n          for (const p in currentFunctionContext) {\r\n            if (!currentFunctionContext.hasOwnProperty(p) || newContext.hasOwnProperty(p)) continue;\r\n            newContext[p] = currentFunctionContext[p];\r\n          }\r\n          this.runningContexts.pop();\r\n          return newContext;\r\n        }\r\n      \r\n        useFunctionContext(run) {\r\n          const functionContext = last(this.functionContexts);\r\n          this.runningContexts.push(functionContext);\r\n          run();\r\n          this.runningContexts.pop();\r\n        }\r\n      \r\n        getIdentifiers(run) {\r\n          const trackedIdentifiers = this.trackedIdentifiers = [];\r\n          this.pushState(states.trackIdentifiers);\r\n          run();\r\n          this.trackedIdentifiers = null;\r\n          this.popState(states.trackIdentifiers);\r\n          return trackedIdentifiers;\r\n        }\r\n      \r\n        getDeclaration(name) {\r\n          const { currentContext, currentFunctionContext, runningContexts } = this;\r\n          const declaration = currentContext[name] || currentFunctionContext[name] || null;\r\n      \r\n          if (\r\n            !declaration &&\r\n            currentContext === currentFunctionContext &&\r\n            runningContexts.length > 0\r\n          ) {\r\n            const previousRunningContext = runningContexts[runningContexts.length - 2];\r\n            if (previousRunningContext[name]) {\r\n              return previousRunningContext[name];\r\n            }\r\n          }\r\n      \r\n          return declaration;\r\n        }\r\n      \r\n        scan(ast) {\r\n          if (!ast) return;\r\n          if (Array.isArray(ast)) {\r\n            for (let i = 0; i < ast.length; i++) {\r\n              this.scan(ast[i]);\r\n            }\r\n            return;\r\n          }\r\n          switch (ast.type) {\r\n            case 'Program':\r\n              this.useFunctionContext(() => {\r\n                this.scan(ast.body);\r\n              });\r\n              break;\r\n            case 'BlockStatement':\r\n              this.newContext(() => {\r\n                this.scan(ast.body);\r\n              });\r\n              break;\r\n            case 'AssignmentExpression':\r\n            case 'LogicalExpression':\r\n              this.scan(ast.left);\r\n              this.scan(ast.right);\r\n              break;\r\n            case 'BinaryExpression':\r\n              this.scan(ast.left);\r\n              this.scan(ast.right);\r\n              break;\r\n            case 'UpdateExpression':\r\n              if (ast.operator === '++') {\r\n                const declaration = this.getDeclaration(ast.argument.name);\r\n                if (declaration) {\r\n                  declaration.suggestedType = 'Integer';\r\n                }\r\n              }\r\n              this.scan(ast.argument);\r\n              break;\r\n            case 'UnaryExpression':\r\n              this.scan(ast.argument);\r\n              break;\r\n            case 'VariableDeclaration':\r\n              if (ast.kind === 'var') {\r\n                this.useFunctionContext(() => {\r\n                  ast.declarations = utils.normalizeDeclarations(ast);\r\n                  this.scan(ast.declarations);\r\n                });\r\n              } else {\r\n                ast.declarations = utils.normalizeDeclarations(ast);\r\n                this.scan(ast.declarations);\r\n              }\r\n              break;\r\n            case 'VariableDeclarator': {\r\n              const { currentContext } = this;\r\n              const inForLoopInit = this.hasState(states.inForLoopInit);\r\n              const declaration = {\r\n                ast: ast,\r\n                context: currentContext,\r\n                name: ast.id.name,\r\n                origin: 'declaration',\r\n                inForLoopInit,\r\n                inForLoopTest: null,\r\n                assignable: currentContext === this.currentFunctionContext || (!inForLoopInit && !currentContext.hasOwnProperty(ast.id.name)),\r\n                suggestedType: null,\r\n                valueType: null,\r\n                dependencies: null,\r\n                isSafe: null,\r\n              };\r\n              if (!currentContext[ast.id.name]) {\r\n                currentContext[ast.id.name] = declaration;\r\n              }\r\n              this.declarations.push(declaration);\r\n              this.scan(ast.id);\r\n              this.scan(ast.init);\r\n              break;\r\n            }\r\n            case 'FunctionExpression':\r\n            case 'FunctionDeclaration':\r\n              if (this.runningContexts.length === 0) {\r\n                this.scan(ast.body);\r\n              } else {\r\n                this.functions.push(ast);\r\n              }\r\n              break;\r\n            case 'IfStatement':\r\n              this.scan(ast.test);\r\n              this.scan(ast.consequent);\r\n              if (ast.alternate) this.scan(ast.alternate);\r\n              break;\r\n            case 'ForStatement': {\r\n              let testIdentifiers;\r\n              const context = this.newContext(() => {\r\n                this.pushState(states.inForLoopInit);\r\n                this.scan(ast.init);\r\n                this.popState(states.inForLoopInit);\r\n      \r\n                testIdentifiers = this.getIdentifiers(() => {\r\n                  this.scan(ast.test);\r\n                });\r\n      \r\n                this.scan(ast.update);\r\n                this.newContext(() => {\r\n                  this.scan(ast.body);\r\n                });\r\n              });\r\n      \r\n              if (testIdentifiers) {\r\n                for (const p in context) {\r\n                  if (p === '@contextType') continue;\r\n                  if (testIdentifiers.indexOf(p) > -1) {\r\n                    context[p].inForLoopTest = true;\r\n                  }\r\n                }\r\n              }\r\n              break;\r\n            }\r\n            case 'DoWhileStatement':\r\n            case 'WhileStatement':\r\n              this.newContext(() => {\r\n                this.scan(ast.body);\r\n                this.scan(ast.test);\r\n              });\r\n              break;\r\n            case 'Identifier': {\r\n              if (this.isState(states.trackIdentifiers)) {\r\n                this.trackedIdentifiers.push(ast.name);\r\n              }\r\n              this.identifiers.push({\r\n                context: this.currentContext,\r\n                declaration: this.getDeclaration(ast.name),\r\n                ast,\r\n              });\r\n              break;\r\n            }\r\n            case 'ReturnStatement':\r\n              this.returnStatements.push(ast);\r\n              this.scan(ast.argument);\r\n              break;\r\n            case 'MemberExpression':\r\n              this.pushState(states.memberExpression);\r\n              this.scan(ast.object);\r\n              this.scan(ast.property);\r\n              this.popState(states.memberExpression);\r\n              break;\r\n            case 'ExpressionStatement':\r\n              this.scan(ast.expression);\r\n              break;\r\n            case 'SequenceExpression':\r\n              this.scan(ast.expressions);\r\n              break;\r\n            case 'CallExpression':\r\n              this.functionCalls.push({\r\n                context: this.currentContext,\r\n                ast,\r\n              });\r\n              this.scan(ast.arguments);\r\n              break;\r\n            case 'ArrayExpression':\r\n              this.scan(ast.elements);\r\n              break;\r\n            case 'ConditionalExpression':\r\n              this.scan(ast.test);\r\n              this.scan(ast.alternate);\r\n              this.scan(ast.consequent);\r\n              break;\r\n            case 'SwitchStatement':\r\n              this.scan(ast.discriminant);\r\n              this.scan(ast.cases);\r\n              break;\r\n            case 'SwitchCase':\r\n              this.scan(ast.test);\r\n              this.scan(ast.consequent);\r\n              break;\r\n      \r\n            case 'ThisExpression':\r\n            case 'Literal':\r\n            case 'DebuggerStatement':\r\n            case 'EmptyStatement':\r\n            case 'BreakStatement':\r\n            case 'ContinueStatement':\r\n              break;\r\n            default:\r\n              throw new Error(`unhandled type \"${ast.type}\"`);\r\n          }\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        FunctionTracer,\r\n      };\r\n      },{\"../utils\":114}],12:[function(require,module,exports){\r\n      const { glWiretap } = require('gl-wiretap');\r\n      const { utils } = require('../../utils');\r\n      \r\n      function toStringWithoutUtils(fn) {\r\n        return fn.toString()\r\n          .replace('=>', '')\r\n          .replace(/^function /, '')\r\n          .replace(/utils[.]/g, '/*utils.*/');\r\n      }\r\n      \r\n      function glKernelString(Kernel, args, originKernel, setupContextString, destroyContextString) {\r\n        if (!originKernel.built) {\r\n          originKernel.build.apply(originKernel, args);\r\n        }\r\n        args = args ? Array.from(args).map(arg => {\r\n          switch (typeof arg) {\r\n            case 'boolean':\r\n              return new Boolean(arg);\r\n            case 'number':\r\n              return new Number(arg);\r\n            default:\r\n              return arg;\r\n          }\r\n        }) : null;\r\n        const uploadedValues = [];\r\n        const postResult = [];\r\n        const context = glWiretap(originKernel.context, {\r\n          useTrackablePrimitives: true,\r\n          onReadPixels: (targetName) => {\r\n            if (kernel.subKernels) {\r\n              if (!subKernelsResultVariableSetup) {\r\n                postResult.push(`    const result = { result: ${getRenderString(targetName, kernel)} };`);\r\n                subKernelsResultVariableSetup = true;\r\n              } else {\r\n                const property = kernel.subKernels[subKernelsResultIndex++].property;\r\n                postResult.push(`    result${isNaN(property) ? '.' + property : `[${property}]`} = ${getRenderString(targetName, kernel)};`);\r\n              }\r\n              if (subKernelsResultIndex === kernel.subKernels.length) {\r\n                postResult.push('    return result;');\r\n              }\r\n              return;\r\n            }\r\n            if (targetName) {\r\n              postResult.push(`    return ${getRenderString(targetName, kernel)};`);\r\n            } else {\r\n              postResult.push(`    return null;`);\r\n            }\r\n          },\r\n          onUnrecognizedArgumentLookup: (argument) => {\r\n            const argumentName = findKernelValue(argument, kernel.kernelArguments, [], context, uploadedValues);\r\n            if (argumentName) {\r\n              return argumentName;\r\n            }\r\n            const constantName = findKernelValue(argument, kernel.kernelConstants, constants ? Object.keys(constants).map(key => constants[key]) : [], context, uploadedValues);\r\n            if (constantName) {\r\n              return constantName;\r\n            }\r\n            return null;\r\n          }\r\n        });\r\n        let subKernelsResultVariableSetup = false;\r\n        let subKernelsResultIndex = 0;\r\n        const {\r\n          source,\r\n          canvas,\r\n          output,\r\n          pipeline,\r\n          graphical,\r\n          loopMaxIterations,\r\n          constants,\r\n          optimizeFloatMemory,\r\n          precision,\r\n          fixIntegerDivisionAccuracy,\r\n          functions,\r\n          nativeFunctions,\r\n          subKernels,\r\n          immutable,\r\n          argumentTypes,\r\n          constantTypes,\r\n          kernelArguments,\r\n          kernelConstants,\r\n          tactic,\r\n        } = originKernel;\r\n        const kernel = new Kernel(source, {\r\n          canvas,\r\n          context,\r\n          checkContext: false,\r\n          output,\r\n          pipeline,\r\n          graphical,\r\n          loopMaxIterations,\r\n          constants,\r\n          optimizeFloatMemory,\r\n          precision,\r\n          fixIntegerDivisionAccuracy,\r\n          functions,\r\n          nativeFunctions,\r\n          subKernels,\r\n          immutable,\r\n          argumentTypes,\r\n          constantTypes,\r\n          tactic,\r\n        });\r\n        let result = [];\r\n        context.setIndent(2);\r\n        kernel.build.apply(kernel, args);\r\n        result.push(context.toString());\r\n        context.reset();\r\n      \r\n        kernel.kernelArguments.forEach((kernelArgument, i) => {\r\n          switch (kernelArgument.type) {\r\n            case 'Integer':\r\n            case 'Boolean':\r\n            case 'Number':\r\n            case 'Float':\r\n            case 'Array':\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n            case 'HTMLCanvas':\r\n            case 'HTMLImage':\r\n            case 'HTMLVideo':\r\n              context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);\r\n              break;\r\n            case 'HTMLImageArray':\r\n              for (let imageIndex = 0; imageIndex < args[i].length; imageIndex++) {\r\n                const arg = args[i];\r\n                context.insertVariable(`uploadValue_${kernelArgument.name}[${imageIndex}]`, arg[imageIndex]);\r\n              }\r\n              break;\r\n            case 'Input':\r\n              context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);\r\n              break;\r\n            case 'MemoryOptimizedNumberTexture':\r\n            case 'NumberTexture':\r\n            case 'Array1D(2)':\r\n            case 'Array1D(3)':\r\n            case 'Array1D(4)':\r\n            case 'Array2D(2)':\r\n            case 'Array2D(3)':\r\n            case 'Array2D(4)':\r\n            case 'Array3D(2)':\r\n            case 'Array3D(3)':\r\n            case 'Array3D(4)':\r\n            case 'ArrayTexture(1)':\r\n            case 'ArrayTexture(2)':\r\n            case 'ArrayTexture(3)':\r\n            case 'ArrayTexture(4)':\r\n              context.insertVariable(`uploadValue_${kernelArgument.name}`, args[i].texture);\r\n              break;\r\n            default:\r\n              throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${kernelArgument.type}`);\r\n          }\r\n        });\r\n        result.push('/** start of injected functions **/');\r\n        result.push(`function ${toStringWithoutUtils(utils.flattenTo)}`);\r\n        result.push(`function ${toStringWithoutUtils(utils.flatten2dArrayTo)}`);\r\n        result.push(`function ${toStringWithoutUtils(utils.flatten3dArrayTo)}`);\r\n        result.push(`function ${toStringWithoutUtils(utils.flatten4dArrayTo)}`);\r\n        result.push(`function ${toStringWithoutUtils(utils.isArray)}`);\r\n        if (kernel.renderOutput !== kernel.renderTexture && kernel.formatValues) {\r\n          result.push(\r\n            `  const renderOutput = function ${toStringWithoutUtils(kernel.formatValues)};`\r\n          );\r\n        }\r\n        result.push('/** end of injected functions **/');\r\n        result.push(`  const innerKernel = function (${kernel.kernelArguments.map(kernelArgument => kernelArgument.varName).join(', ')}) {`);\r\n        context.setIndent(4);\r\n        kernel.run.apply(kernel, args);\r\n        if (kernel.renderKernels) {\r\n          kernel.renderKernels();\r\n        } else if (kernel.renderOutput) {\r\n          kernel.renderOutput();\r\n        }\r\n        result.push('    /** start setup uploads for kernel values **/');\r\n        kernel.kernelArguments.forEach(kernelArgument => {\r\n          result.push('    ' + kernelArgument.getStringValueHandler().split('\\n').join('\\n    '));\r\n        });\r\n        result.push('    /** end setup uploads for kernel values **/');\r\n        result.push(context.toString());\r\n        if (kernel.renderOutput === kernel.renderTexture) {\r\n          context.reset();\r\n          const framebufferName = context.getContextVariableName(kernel.framebuffer);\r\n          if (kernel.renderKernels) {\r\n            const results = kernel.renderKernels();\r\n            const textureName = context.getContextVariableName(kernel.texture.texture);\r\n            result.push(`    return {\r\n            result: {\r\n              texture: ${ textureName },\r\n              type: '${ results.result.type }',\r\n              toArray: ${ getToArrayString(results.result, textureName, framebufferName) }\r\n            },`);\r\n            const { subKernels, mappedTextures } = kernel;\r\n            for (let i = 0; i < subKernels.length; i++) {\r\n              const texture = mappedTextures[i];\r\n              const subKernel = subKernels[i];\r\n              const subKernelResult = results[subKernel.property];\r\n              const subKernelTextureName = context.getContextVariableName(texture.texture);\r\n              result.push(`\r\n            ${subKernel.property}: {\r\n              texture: ${ subKernelTextureName },\r\n              type: '${ subKernelResult.type }',\r\n              toArray: ${ getToArrayString(subKernelResult, subKernelTextureName, framebufferName) }\r\n            },`);\r\n            }\r\n            result.push(`    };`);\r\n          } else {\r\n            const rendered = kernel.renderOutput();\r\n            const textureName = context.getContextVariableName(kernel.texture.texture);\r\n            result.push(`    return {\r\n              texture: ${ textureName },\r\n              type: '${ rendered.type }',\r\n              toArray: ${ getToArrayString(rendered, textureName, framebufferName) }\r\n            };`);\r\n          }\r\n        }\r\n        result.push(`    ${destroyContextString ? '\\n' + destroyContextString + '    ': ''}`);\r\n        result.push(postResult.join('\\n'));\r\n        result.push('  };');\r\n        if (kernel.graphical) {\r\n          result.push(getGetPixelsString(kernel));\r\n          result.push(`  innerKernel.getPixels = getPixels;`);\r\n        }\r\n        result.push('  return innerKernel;');\r\n      \r\n        let constantsUpload = [];\r\n        kernelConstants.forEach((kernelConstant) => {\r\n          constantsUpload.push(`${kernelConstant.getStringValueHandler()}`);\r\n        });\r\n        return `function kernel(settings) {\r\n        const { context, constants } = settings;\r\n        ${constantsUpload.join('')}\r\n        ${setupContextString ? setupContextString : ''}\r\n      ${result.join('\\n')}\r\n      }`;\r\n      }\r\n      \r\n      function getRenderString(targetName, kernel) {\r\n        const readBackValue = kernel.precision === 'single' ? targetName : `new Float32Array(${targetName}.buffer)`;\r\n        if (kernel.output[2]) {\r\n          return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]}, ${kernel.output[2]})`;\r\n        }\r\n        if (kernel.output[1]) {\r\n          return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]})`;\r\n        }\r\n      \r\n        return `renderOutput(${readBackValue}, ${kernel.output[0]})`;\r\n      }\r\n      \r\n      function getGetPixelsString(kernel) {\r\n        const getPixels = kernel.getPixels.toString();\r\n        const useFunctionKeyword = !/^function/.test(getPixels);\r\n        return utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ getPixels }`, {\r\n          findDependency: (object, name) => {\r\n            if (object === 'utils') {\r\n              return `const ${name} = ${utils[name].toString()};`;\r\n            }\r\n            return null;\r\n          },\r\n          thisLookup: (property) => {\r\n            if (property === 'context') {\r\n              return null;\r\n            }\r\n            if (kernel.hasOwnProperty(property)) {\r\n              return JSON.stringify(kernel[property]);\r\n            }\r\n            throw new Error(`unhandled thisLookup ${ property }`);\r\n          }\r\n        });\r\n      }\r\n      \r\n      function getToArrayString(kernelResult, textureName, framebufferName) {\r\n        const toArray = kernelResult.toArray.toString();\r\n        const useFunctionKeyword = !/^function/.test(toArray);\r\n        const flattenedFunctions = utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ toArray }`, {\r\n          findDependency: (object, name) => {\r\n            if (object === 'utils') {\r\n              return `const ${name} = ${utils[name].toString()};`;\r\n            } else if (object === 'this') {\r\n              if (name === 'framebuffer') {\r\n                return '';\r\n              }\r\n              return `${useFunctionKeyword ? 'function ' : ''}${kernelResult[name].toString()}`;\r\n            } else {\r\n              throw new Error('unhandled fromObject');\r\n            }\r\n          },\r\n          thisLookup: (property, isDeclaration) => {\r\n            if (property === 'texture') {\r\n              return textureName;\r\n            }\r\n            if (property === 'context') {\r\n              if (isDeclaration) return null;\r\n              return 'gl';\r\n            }\r\n            if (kernelResult.hasOwnProperty(property)) {\r\n              return JSON.stringify(kernelResult[property]);\r\n            }\r\n            throw new Error(`unhandled thisLookup ${ property }`);\r\n          }\r\n        });\r\n        return `() => {\r\n        function framebuffer() { return ${framebufferName}; };\r\n        ${flattenedFunctions}\r\n        return toArray();\r\n        }`;\r\n      }\r\n      \r\n      function findKernelValue(argument, kernelValues, values, context, uploadedValues) {\r\n        if (argument === null) return null;\r\n        if (kernelValues === null) return null;\r\n        switch (typeof argument) {\r\n          case 'boolean':\r\n          case 'number':\r\n            return null;\r\n        }\r\n        if (\r\n          typeof HTMLImageElement !== 'undefined' &&\r\n          argument instanceof HTMLImageElement\r\n        ) {\r\n          for (let i = 0; i < kernelValues.length; i++) {\r\n            const kernelValue = kernelValues[i];\r\n            if (kernelValue.type !== 'HTMLImageArray' && kernelValue) continue;\r\n            if (kernelValue.uploadValue !== argument) continue;\r\n            const variableIndex = values[i].indexOf(argument);\r\n            if (variableIndex === -1) continue;\r\n            const variableName = `uploadValue_${kernelValue.name}[${variableIndex}]`;\r\n            context.insertVariable(variableName, argument);\r\n            return variableName;\r\n          }\r\n        }\r\n      \r\n        for (let i = 0; i < kernelValues.length; i++) {\r\n          const kernelValue = kernelValues[i];\r\n          if (argument !== kernelValue.uploadValue) continue;\r\n          const variable = `uploadValue_${kernelValue.name}`;\r\n          context.insertVariable(variable, kernelValue);\r\n          return variable;\r\n        }\r\n        return null;\r\n      }\r\n      \r\n      module.exports = {\r\n        glKernelString\r\n      };\r\n      },{\"../../utils\":114,\"gl-wiretap\":3}],13:[function(require,module,exports){\r\n      const { Kernel } = require('../kernel');\r\n      const { utils } = require('../../utils');\r\n      const { GLTextureArray2Float } = require('./texture/array-2-float');\r\n      const { GLTextureArray2Float2D } = require('./texture/array-2-float-2d');\r\n      const { GLTextureArray2Float3D } = require('./texture/array-2-float-3d');\r\n      const { GLTextureArray3Float } = require('./texture/array-3-float');\r\n      const { GLTextureArray3Float2D } = require('./texture/array-3-float-2d');\r\n      const { GLTextureArray3Float3D } = require('./texture/array-3-float-3d');\r\n      const { GLTextureArray4Float } = require('./texture/array-4-float');\r\n      const { GLTextureArray4Float2D } = require('./texture/array-4-float-2d');\r\n      const { GLTextureArray4Float3D } = require('./texture/array-4-float-3d');\r\n      const { GLTextureFloat } = require('./texture/float');\r\n      const { GLTextureFloat2D } = require('./texture/float-2d');\r\n      const { GLTextureFloat3D } = require('./texture/float-3d');\r\n      const { GLTextureMemoryOptimized } = require('./texture/memory-optimized');\r\n      const { GLTextureMemoryOptimized2D } = require('./texture/memory-optimized-2d');\r\n      const { GLTextureMemoryOptimized3D } = require('./texture/memory-optimized-3d');\r\n      const { GLTextureUnsigned } = require('./texture/unsigned');\r\n      const { GLTextureUnsigned2D } = require('./texture/unsigned-2d');\r\n      const { GLTextureUnsigned3D } = require('./texture/unsigned-3d');\r\n      const { GLTextureGraphical } = require('./texture/graphical');\r\n      \r\n      class GLKernel extends Kernel {\r\n        static get mode() {\r\n          return 'gpu';\r\n        }\r\n      \r\n        static getIsFloatRead() {\r\n          const kernelString = `function kernelFunction() {\r\n            return 1;\r\n          }`;\r\n          const kernel = new this(kernelString, {\r\n            context: this.testContext,\r\n            canvas: this.testCanvas,\r\n            validate: false,\r\n            output: [1],\r\n            precision: 'single',\r\n            returnType: 'Number',\r\n            tactic: 'speed',\r\n          });\r\n          kernel.build();\r\n          kernel.run();\r\n          const result = kernel.renderOutput();\r\n          kernel.destroy(true);\r\n          return result[0] === 1;\r\n        }\r\n      \r\n        static getIsIntegerDivisionAccurate() {\r\n          function kernelFunction(v1, v2) {\r\n            return v1[this.thread.x] / v2[this.thread.x];\r\n          }\r\n          const kernel = new this(kernelFunction.toString(), {\r\n            context: this.testContext,\r\n            canvas: this.testCanvas,\r\n            validate: false,\r\n            output: [2],\r\n            returnType: 'Number',\r\n            precision: 'unsigned',\r\n            tactic: 'speed',\r\n          });\r\n          const args = [\r\n            [6, 6030401],\r\n            [3, 3991]\r\n          ];\r\n          kernel.build.apply(kernel, args);\r\n          kernel.run.apply(kernel, args);\r\n          const result = kernel.renderOutput();\r\n          kernel.destroy(true);\r\n          return result[0] === 2 && result[1] === 1511;\r\n        }\r\n      \r\n        static getIsSpeedTacticSupported() {\r\n          function kernelFunction(value) {\r\n            return value[this.thread.x];\r\n          }\r\n          const kernel = new this(kernelFunction.toString(), {\r\n            context: this.testContext,\r\n            canvas: this.testCanvas,\r\n            validate: false,\r\n            output: [4],\r\n            returnType: 'Number',\r\n            precision: 'unsigned',\r\n            tactic: 'speed',\r\n          });\r\n          const args = [\r\n            [0, 1, 2, 3]\r\n          ];\r\n          kernel.build.apply(kernel, args);\r\n          kernel.run.apply(kernel, args);\r\n          const result = kernel.renderOutput();\r\n          kernel.destroy(true);\r\n          return Math.round(result[0]) === 0 && Math.round(result[1]) === 1 && Math.round(result[2]) === 2 && Math.round(result[3]) === 3;\r\n        }\r\n      \r\n        static get testCanvas() {\r\n          throw new Error(`\"testCanvas\" not defined on ${ this.name }`);\r\n        }\r\n      \r\n        static get testContext() {\r\n          throw new Error(`\"testContext\" not defined on ${ this.name }`);\r\n        }\r\n      \r\n        static getFeatures() {\r\n          const gl = this.testContext;\r\n          const isDrawBuffers = this.getIsDrawBuffers();\r\n          return Object.freeze({\r\n            isFloatRead: this.getIsFloatRead(),\r\n            isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),\r\n            isSpeedTacticSupported: this.getIsSpeedTacticSupported(),\r\n            isTextureFloat: this.getIsTextureFloat(),\r\n            isDrawBuffers,\r\n            kernelMap: isDrawBuffers,\r\n            channelCount: this.getChannelCount(),\r\n            maxTextureSize: this.getMaxTextureSize(),\r\n            lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),\r\n            lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),\r\n            mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),\r\n            mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),\r\n            highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),\r\n            highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),\r\n          });\r\n        }\r\n      \r\n        static setupFeatureChecks() {\r\n          throw new Error(`\"setupFeatureChecks\" not defined on ${ this.name }`);\r\n        }\r\n      \r\n        static getSignature(kernel, argumentTypes) {\r\n          return kernel.getVariablePrecisionString() + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');\r\n        }\r\n      \r\n        setFixIntegerDivisionAccuracy(fix) {\r\n          this.fixIntegerDivisionAccuracy = fix;\r\n          return this;\r\n        }\r\n      \r\n        setPrecision(flag) {\r\n          this.precision = flag;\r\n          return this;\r\n        }\r\n      \r\n        setFloatTextures(flag) {\r\n          utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');\r\n          this.floatTextures = flag;\r\n          return this;\r\n        }\r\n      \r\n        static nativeFunctionArguments(source) {\r\n          const argumentTypes = [];\r\n          const argumentNames = [];\r\n          const states = [];\r\n          const isStartingVariableName = /^[a-zA-Z_]/;\r\n          const isVariableChar = /[a-zA-Z_0-9]/;\r\n          let i = 0;\r\n          let argumentName = null;\r\n          let argumentType = null;\r\n          while (i < source.length) {\r\n            const char = source[i];\r\n            const nextChar = source[i + 1];\r\n            const state = states.length > 0 ? states[states.length - 1] : null;\r\n      \r\n            if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {\r\n              states.push('MULTI_LINE_COMMENT');\r\n              i += 2;\r\n              continue;\r\n            } else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {\r\n              states.pop();\r\n              i += 2;\r\n              continue;\r\n            }\r\n      \r\n            else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {\r\n              states.push('COMMENT');\r\n              i += 2;\r\n              continue;\r\n            } else if (state === 'COMMENT' && char === '\\n') {\r\n              states.pop();\r\n              i++;\r\n              continue;\r\n            }\r\n      \r\n            else if (state === null && char === '(') {\r\n              states.push('FUNCTION_ARGUMENTS');\r\n              i++;\r\n              continue;\r\n            } else if (state === 'FUNCTION_ARGUMENTS') {\r\n              if (char === ')') {\r\n                states.pop();\r\n                break;\r\n              }\r\n              if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {\r\n                states.push('DECLARE_VARIABLE');\r\n                argumentType = 'float';\r\n                argumentName = '';\r\n                i += 6;\r\n                continue;\r\n              } else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {\r\n                states.push('DECLARE_VARIABLE');\r\n                argumentType = 'int';\r\n                argumentName = '';\r\n                i += 4;\r\n                continue;\r\n              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {\r\n                states.push('DECLARE_VARIABLE');\r\n                argumentType = 'vec2';\r\n                argumentName = '';\r\n                i += 5;\r\n                continue;\r\n              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {\r\n                states.push('DECLARE_VARIABLE');\r\n                argumentType = 'vec3';\r\n                argumentName = '';\r\n                i += 5;\r\n                continue;\r\n              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {\r\n                states.push('DECLARE_VARIABLE');\r\n                argumentType = 'vec4';\r\n                argumentName = '';\r\n                i += 5;\r\n                continue;\r\n              }\r\n            }\r\n      \r\n            else if (state === 'DECLARE_VARIABLE') {\r\n              if (argumentName === '') {\r\n                if (char === ' ') {\r\n                  i++;\r\n                  continue;\r\n                }\r\n                if (!isStartingVariableName.test(char)) {\r\n                  throw new Error('variable name is not expected string');\r\n                }\r\n              }\r\n              argumentName += char;\r\n              if (!isVariableChar.test(nextChar)) {\r\n                states.pop();\r\n                argumentNames.push(argumentName);\r\n                argumentTypes.push(typeMap[argumentType]);\r\n              }\r\n            }\r\n      \r\n            i++;\r\n          }\r\n          if (states.length > 0) {\r\n            throw new Error('GLSL function was not parsable');\r\n          }\r\n          return {\r\n            argumentNames,\r\n            argumentTypes,\r\n          };\r\n        }\r\n      \r\n        static nativeFunctionReturnType(source) {\r\n          return typeMap[source.match(/int|float|vec[2-4]/)[0]];\r\n        }\r\n      \r\n        static combineKernels(combinedKernel, lastKernel) {\r\n          combinedKernel.apply(null, arguments);\r\n          const {\r\n            texSize,\r\n            context,\r\n            threadDim\r\n          } = lastKernel.texSize;\r\n          let result;\r\n          if (lastKernel.precision === 'single') {\r\n            const w = texSize[0];\r\n            const h = Math.ceil(texSize[1] / 4);\r\n            result = new Float32Array(w * h * 4 * 4);\r\n            context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);\r\n          } else {\r\n            const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);\r\n            context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);\r\n            result = new Float32Array(bytes.buffer);\r\n          }\r\n      \r\n          result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);\r\n      \r\n          if (lastKernel.output.length === 1) {\r\n            return result;\r\n          } else if (lastKernel.output.length === 2) {\r\n            return utils.splitArray(result, lastKernel.output[0]);\r\n          } else if (lastKernel.output.length === 3) {\r\n            const cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);\r\n            return cube.map(function(x) {\r\n              return utils.splitArray(x, lastKernel.output[0]);\r\n            });\r\n          }\r\n        }\r\n      \r\n        constructor(source, settings) {\r\n          super(source, settings);\r\n          this.transferValues = null;\r\n          this.formatValues = null;\r\n          this.TextureConstructor = null;\r\n          this.renderOutput = null;\r\n          this.renderRawOutput = null;\r\n          this.texSize = null;\r\n          this.translatedSource = null;\r\n          this.compiledFragmentShader = null;\r\n          this.compiledVertexShader = null;\r\n          this.switchingKernels = null;\r\n          this._textureSwitched = null;\r\n          this._mappedTextureSwitched = null;\r\n        }\r\n      \r\n        checkTextureSize() {\r\n          const { features } = this.constructor;\r\n          if (this.texSize[0] > features.maxTextureSize || this.texSize[1] > features.maxTextureSize) {\r\n            throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${features.maxTextureSize},${features.maxTextureSize}]`);\r\n          }\r\n        }\r\n      \r\n        translateSource() {\r\n          throw new Error(`\"translateSource\" not defined on ${this.constructor.name}`);\r\n        }\r\n      \r\n        pickRenderStrategy(args) {\r\n          if (this.graphical) {\r\n            this.renderRawOutput = this.readPackedPixelsToUint8Array;\r\n            this.transferValues = (pixels) => pixels;\r\n            this.TextureConstructor = GLTextureGraphical;\r\n            return null;\r\n          }\r\n          if (this.precision === 'unsigned') {\r\n            this.renderRawOutput = this.readPackedPixelsToUint8Array;\r\n            this.transferValues = this.readPackedPixelsToFloat32Array;\r\n            if (this.pipeline) {\r\n              this.renderOutput = this.renderTexture;\r\n              if (this.subKernels !== null) {\r\n                this.renderKernels = this.renderKernelsToTextures;\r\n              }\r\n              switch (this.returnType) {\r\n                case 'LiteralInteger':\r\n                case 'Float':\r\n                case 'Number':\r\n                case 'Integer':\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureUnsigned3D;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureUnsigned2D;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureUnsigned;\r\n                    return null;\r\n                  }\r\n                  case 'Array(2)':\r\n                  case 'Array(3)':\r\n                  case 'Array(4)':\r\n                    return this.requestFallback(args);\r\n              }\r\n            } else {\r\n              if (this.subKernels !== null) {\r\n                this.renderKernels = this.renderKernelsToArrays;\r\n              }\r\n              switch (this.returnType) {\r\n                case 'LiteralInteger':\r\n                case 'Float':\r\n                case 'Number':\r\n                case 'Integer':\r\n                  this.renderOutput = this.renderValues;\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureUnsigned3D;\r\n                    this.formatValues = utils.erect3DPackedFloat;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureUnsigned2D;\r\n                    this.formatValues = utils.erect2DPackedFloat;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureUnsigned;\r\n                    this.formatValues = utils.erectPackedFloat;\r\n                    return null;\r\n                  }\r\n                  case 'Array(2)':\r\n                  case 'Array(3)':\r\n                  case 'Array(4)':\r\n                    return this.requestFallback(args);\r\n              }\r\n            }\r\n          } else if (this.precision === 'single') {\r\n            this.renderRawOutput = this.readFloatPixelsToFloat32Array;\r\n            this.transferValues = this.readFloatPixelsToFloat32Array;\r\n            if (this.pipeline) {\r\n              this.renderOutput = this.renderTexture;\r\n              if (this.subKernels !== null) {\r\n                this.renderKernels = this.renderKernelsToTextures;\r\n              }\r\n              switch (this.returnType) {\r\n                case 'LiteralInteger':\r\n                case 'Float':\r\n                case 'Number':\r\n                case 'Integer': {\r\n                  if (this.optimizeFloatMemory) {\r\n                    if (this.output[2] > 0) {\r\n                      this.TextureConstructor = GLTextureMemoryOptimized3D;\r\n                      return null;\r\n                    } else if (this.output[1] > 0) {\r\n                      this.TextureConstructor = GLTextureMemoryOptimized2D;\r\n                      return null;\r\n                    } else {\r\n                      this.TextureConstructor = GLTextureMemoryOptimized;\r\n                      return null;\r\n                    }\r\n                  } else {\r\n                    if (this.output[2] > 0) {\r\n                      this.TextureConstructor = GLTextureFloat3D;\r\n                      return null;\r\n                    } else if (this.output[1] > 0) {\r\n                      this.TextureConstructor = GLTextureFloat2D;\r\n                      return null;\r\n                    } else {\r\n                      this.TextureConstructor = GLTextureFloat;\r\n                      return null;\r\n                    }\r\n                  }\r\n                }\r\n                case 'Array(2)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float3D;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float2D;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray2Float;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(3)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float3D;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float2D;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray3Float;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(4)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float3D;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float2D;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray4Float;\r\n                    return null;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            this.renderOutput = this.renderValues;\r\n            if (this.subKernels !== null) {\r\n              this.renderKernels = this.renderKernelsToArrays;\r\n            }\r\n            if (this.optimizeFloatMemory) {\r\n              switch (this.returnType) {\r\n                case 'LiteralInteger':\r\n                case 'Float':\r\n                case 'Number':\r\n                case 'Integer': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureMemoryOptimized3D;\r\n                    this.formatValues = utils.erectMemoryOptimized3DFloat;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureMemoryOptimized2D;\r\n                    this.formatValues = utils.erectMemoryOptimized2DFloat;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureMemoryOptimized;\r\n                    this.formatValues = utils.erectMemoryOptimizedFloat;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(2)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float3D;\r\n                    this.formatValues = utils.erect3DArray2;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float2D;\r\n                    this.formatValues = utils.erect2DArray2;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray2Float;\r\n                    this.formatValues = utils.erectArray2;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(3)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float3D;\r\n                    this.formatValues = utils.erect3DArray3;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float2D;\r\n                    this.formatValues = utils.erect2DArray3;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray3Float;\r\n                    this.formatValues = utils.erectArray3;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(4)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float3D;\r\n                    this.formatValues = utils.erect3DArray4;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float2D;\r\n                    this.formatValues = utils.erect2DArray4;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray4Float;\r\n                    this.formatValues = utils.erectArray4;\r\n                    return null;\r\n                  }\r\n                }\r\n              }\r\n            } else {\r\n              switch (this.returnType) {\r\n                case 'LiteralInteger':\r\n                case 'Float':\r\n                case 'Number':\r\n                case 'Integer': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureFloat3D;\r\n                    this.formatValues = utils.erect3DFloat;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureFloat2D;\r\n                    this.formatValues = utils.erect2DFloat;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureFloat;\r\n                    this.formatValues = utils.erectFloat;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(2)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float3D;\r\n                    this.formatValues = utils.erect3DArray2;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float2D;\r\n                    this.formatValues = utils.erect2DArray2;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray2Float;\r\n                    this.formatValues = utils.erectArray2;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(3)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float3D;\r\n                    this.formatValues = utils.erect3DArray3;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float2D;\r\n                    this.formatValues = utils.erect2DArray3;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray3Float;\r\n                    this.formatValues = utils.erectArray3;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(4)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float3D;\r\n                    this.formatValues = utils.erect3DArray4;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float2D;\r\n                    this.formatValues = utils.erect2DArray4;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray4Float;\r\n                    this.formatValues = utils.erectArray4;\r\n                    return null;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          } else {\r\n            throw new Error(`unhandled precision of \"${this.precision}\"`);\r\n          }\r\n      \r\n          throw new Error(`unhandled return type \"${this.returnType}\"`);\r\n        }\r\n      \r\n        getKernelString() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n      \r\n        getMainResultTexture() {\r\n          switch (this.returnType) {\r\n            case 'LiteralInteger':\r\n            case 'Float':\r\n            case 'Integer':\r\n            case 'Number':\r\n              return this.getMainResultNumberTexture();\r\n            case 'Array(2)':\r\n              return this.getMainResultArray2Texture();\r\n            case 'Array(3)':\r\n              return this.getMainResultArray3Texture();\r\n            case 'Array(4)':\r\n              return this.getMainResultArray4Texture();\r\n            default:\r\n              throw new Error(`unhandled returnType type ${ this.returnType }`);\r\n          }\r\n        }\r\n      \r\n        getMainResultKernelNumberTexture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultSubKernelNumberTexture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultKernelArray2Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultSubKernelArray2Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultKernelArray3Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultSubKernelArray3Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultKernelArray4Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultSubKernelArray4Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultGraphical() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultMemoryOptimizedFloats() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultPackedPixels() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n      \r\n        getMainResultString() {\r\n          if (this.graphical) {\r\n            return this.getMainResultGraphical();\r\n          } else if (this.precision === 'single') {\r\n            if (this.optimizeFloatMemory) {\r\n              return this.getMainResultMemoryOptimizedFloats();\r\n            }\r\n            return this.getMainResultTexture();\r\n          } else {\r\n            return this.getMainResultPackedPixels();\r\n          }\r\n        }\r\n      \r\n        getMainResultNumberTexture() {\r\n          return utils.linesToString(this.getMainResultKernelNumberTexture()) +\r\n            utils.linesToString(this.getMainResultSubKernelNumberTexture());\r\n        }\r\n      \r\n        getMainResultArray2Texture() {\r\n          return utils.linesToString(this.getMainResultKernelArray2Texture()) +\r\n            utils.linesToString(this.getMainResultSubKernelArray2Texture());\r\n        }\r\n      \r\n        getMainResultArray3Texture() {\r\n          return utils.linesToString(this.getMainResultKernelArray3Texture()) +\r\n            utils.linesToString(this.getMainResultSubKernelArray3Texture());\r\n        }\r\n      \r\n        getMainResultArray4Texture() {\r\n          return utils.linesToString(this.getMainResultKernelArray4Texture()) +\r\n            utils.linesToString(this.getMainResultSubKernelArray4Texture());\r\n        }\r\n      \r\n        getFloatTacticDeclaration() {\r\n          const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);\r\n          return `precision ${variablePrecision} float;\\n`;\r\n        }\r\n      \r\n        getIntTacticDeclaration() {\r\n          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic, true)} int;\\n`;\r\n        }\r\n      \r\n        getSampler2DTacticDeclaration() {\r\n          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;\\n`;\r\n        }\r\n      \r\n        getSampler2DArrayTacticDeclaration() {\r\n          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;\\n`;\r\n        }\r\n      \r\n        renderTexture() {\r\n          return this.immutable ? this.texture.clone() : this.texture;\r\n        }\r\n        readPackedPixelsToUint8Array() {\r\n          if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be \"unsigned\"');\r\n          const {\r\n            texSize,\r\n            context: gl\r\n          } = this;\r\n          const result = new Uint8Array(texSize[0] * texSize[1] * 4);\r\n          gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);\r\n          return result;\r\n        }\r\n      \r\n        readPackedPixelsToFloat32Array() {\r\n          return new Float32Array(this.readPackedPixelsToUint8Array().buffer);\r\n        }\r\n      \r\n        readFloatPixelsToFloat32Array() {\r\n          if (this.precision !== 'single') throw new Error('Requires this.precision to be \"single\"');\r\n          const {\r\n            texSize,\r\n            context: gl\r\n          } = this;\r\n          const w = texSize[0];\r\n          const h = texSize[1];\r\n          const result = new Float32Array(w * h * 4);\r\n          gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);\r\n          return result;\r\n        }\r\n      \r\n        getPixels(flip) {\r\n          const {\r\n            context: gl,\r\n            output\r\n          } = this;\r\n          const [width, height] = output;\r\n          const pixels = new Uint8Array(width * height * 4);\r\n          gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\r\n          return new Uint8ClampedArray((flip ? pixels : utils.flipPixels(pixels, width, height)).buffer);\r\n        }\r\n      \r\n        renderKernelsToArrays() {\r\n          const result = {\r\n            result: this.renderOutput(),\r\n          };\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            result[this.subKernels[i].property] = this.mappedTextures[i].toArray();\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        renderKernelsToTextures() {\r\n          const result = {\r\n            result: this.renderOutput(),\r\n          };\r\n          if (this.immutable) {\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              result[this.subKernels[i].property] = this.mappedTextures[i].clone();\r\n            }\r\n          } else {\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              result[this.subKernels[i].property] = this.mappedTextures[i];\r\n            }\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        resetSwitchingKernels() {\r\n          const existingValue = this.switchingKernels;\r\n          this.switchingKernels = null;\r\n          return existingValue;\r\n        }\r\n      \r\n        setOutput(output) {\r\n          const newOutput = this.toKernelOutput(output);\r\n          if (this.program) {\r\n            if (!this.dynamicOutput) {\r\n              throw new Error('Resizing a kernel with dynamicOutput: false is not possible');\r\n            }\r\n            const newThreadDim = [newOutput[0], newOutput[1] || 1, newOutput[2] || 1];\r\n            const newTexSize = utils.getKernelTextureSize({\r\n              optimizeFloatMemory: this.optimizeFloatMemory,\r\n              precision: this.precision,\r\n            }, newThreadDim);\r\n            const oldTexSize = this.texSize;\r\n            if (oldTexSize) {\r\n              const oldPrecision = this.getVariablePrecisionString(oldTexSize, this.tactic);\r\n              const newPrecision = this.getVariablePrecisionString(newTexSize, this.tactic);\r\n              if (oldPrecision !== newPrecision) {\r\n                if (this.debug) {\r\n                  console.warn('Precision requirement changed, asking GPU instance to recompile');\r\n                }\r\n                this.switchKernels({\r\n                  type: 'outputPrecisionMismatch',\r\n                  precision: newPrecision,\r\n                  needed: output\r\n                });\r\n                return;\r\n              }\r\n            }\r\n            this.output = newOutput;\r\n            this.threadDim = newThreadDim;\r\n            this.texSize = newTexSize;\r\n            const { context: gl } = this;\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\r\n            this.updateMaxTexSize();\r\n            this.framebuffer.width = this.texSize[0];\r\n            this.framebuffer.height = this.texSize[1];\r\n            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);\r\n            this.canvas.width = this.maxTexSize[0];\r\n            this.canvas.height = this.maxTexSize[1];\r\n            if (this.texture) {\r\n              this.texture.delete();\r\n            }\r\n            this.texture = null;\r\n            this._setupOutputTexture();\r\n            if (this.mappedTextures && this.mappedTextures.length > 0) {\r\n              for (let i = 0; i < this.mappedTextures.length; i++) {\r\n                this.mappedTextures[i].delete();\r\n              }\r\n              this.mappedTextures = null;\r\n              this._setupSubOutputTextures();\r\n            }\r\n          } else {\r\n            this.output = newOutput;\r\n          }\r\n          return this;\r\n        }\r\n        renderValues() {\r\n          return this.formatValues(\r\n            this.transferValues(),\r\n            this.output[0],\r\n            this.output[1],\r\n            this.output[2]\r\n          );\r\n        }\r\n        switchKernels(reason) {\r\n          if (this.switchingKernels) {\r\n            this.switchingKernels.push(reason);\r\n          } else {\r\n            this.switchingKernels = [reason];\r\n          }\r\n        }\r\n        getVariablePrecisionString(textureSize = this.texSize, tactic = this.tactic, isInt = false) {\r\n          if (!tactic) {\r\n            if (!this.constructor.features.isSpeedTacticSupported) return 'highp';\r\n            const low = this.constructor.features[isInt ? 'lowIntPrecision' : 'lowFloatPrecision'];\r\n            const medium = this.constructor.features[isInt ? 'mediumIntPrecision' : 'mediumFloatPrecision'];\r\n            const high = this.constructor.features[isInt ? 'highIntPrecision' : 'highFloatPrecision'];\r\n            const requiredSize = Math.log2(textureSize[0] * textureSize[1]);\r\n            if (requiredSize <= low.rangeMax) {\r\n              return 'lowp';\r\n            } else if (requiredSize <= medium.rangeMax) {\r\n              return 'mediump';\r\n            } else if (requiredSize <= high.rangeMax) {\r\n              return 'highp';\r\n            } else {\r\n              throw new Error(`The required size exceeds that of the ability of your system`);\r\n            }\r\n          }\r\n          switch (tactic) {\r\n            case 'speed':\r\n              return 'lowp';\r\n            case 'balanced':\r\n              return 'mediump';\r\n            case 'precision':\r\n              return 'highp';\r\n            default:\r\n              throw new Error(`Unknown tactic \"${tactic}\" use \"speed\", \"balanced\", \"precision\", or empty for auto`);\r\n          }\r\n        }\r\n      \r\n        updateTextureArgumentRefs(kernelValue, arg) {\r\n          if (!this.immutable) return;\r\n          if (this.texture.texture === arg.texture) {\r\n            const { prevArg } = kernelValue;\r\n            if (prevArg) {\r\n              if (prevArg.texture._refs === 1) {\r\n                this.texture.delete();\r\n                this.texture = prevArg.clone();\r\n                this._textureSwitched = true;\r\n              }\r\n              prevArg.delete();\r\n            }\r\n            kernelValue.prevArg = arg.clone();\r\n          } else if (this.mappedTextures && this.mappedTextures.length > 0) {\r\n            const { mappedTextures } = this;\r\n            for (let i = 0; i < mappedTextures.length; i++) {\r\n              const mappedTexture = mappedTextures[i];\r\n              if (mappedTexture.texture === arg.texture) {\r\n                const { prevArg } = kernelValue;\r\n                if (prevArg) {\r\n                  if (prevArg.texture._refs === 1) {\r\n                    mappedTexture.delete();\r\n                    mappedTextures[i] = prevArg.clone();\r\n                    this._mappedTextureSwitched[i] = true;\r\n                  }\r\n                  prevArg.delete();\r\n                }\r\n                kernelValue.prevArg = arg.clone();\r\n                return;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      \r\n        onActivate(previousKernel) {\r\n          this._textureSwitched = true;\r\n          this.texture = previousKernel.texture;\r\n          if (this.mappedTextures) {\r\n            for (let i = 0; i < this.mappedTextures.length; i++) {\r\n              this._mappedTextureSwitched[i] = true;\r\n            }\r\n            this.mappedTextures = previousKernel.mappedTextures;\r\n          }\r\n        }\r\n      \r\n        initCanvas() {}\r\n      }\r\n      \r\n      const typeMap = {\r\n        int: 'Integer',\r\n        float: 'Number',\r\n        vec2: 'Array(2)',\r\n        vec3: 'Array(3)',\r\n        vec4: 'Array(4)',\r\n      };\r\n      \r\n      module.exports = {\r\n        GLKernel\r\n      };\r\n      },{\"../../utils\":114,\"../kernel\":36,\"./texture/array-2-float\":16,\"./texture/array-2-float-2d\":14,\"./texture/array-2-float-3d\":15,\"./texture/array-3-float\":19,\"./texture/array-3-float-2d\":17,\"./texture/array-3-float-3d\":18,\"./texture/array-4-float\":22,\"./texture/array-4-float-2d\":20,\"./texture/array-4-float-3d\":21,\"./texture/float\":25,\"./texture/float-2d\":23,\"./texture/float-3d\":24,\"./texture/graphical\":26,\"./texture/memory-optimized\":30,\"./texture/memory-optimized-2d\":28,\"./texture/memory-optimized-3d\":29,\"./texture/unsigned\":33,\"./texture/unsigned-2d\":31,\"./texture/unsigned-3d\":32}],14:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray2Float2D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(2)';\r\n        }\r\n        toArray() {\r\n          return utils.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray2Float2D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],15:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray2Float3D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(2)';\r\n        }\r\n        toArray() {\r\n          return utils.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray2Float3D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],16:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray2Float extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(2)';\r\n        }\r\n        toArray() {\r\n          return utils.erectArray2(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray2Float\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],17:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray3Float2D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(3)';\r\n        }\r\n        toArray() {\r\n          return utils.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray3Float2D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],18:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray3Float3D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(3)';\r\n        }\r\n        toArray() {\r\n          return utils.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray3Float3D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],19:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray3Float extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(3)';\r\n        }\r\n        toArray() {\r\n          return utils.erectArray3(this.renderValues(), this.output[0]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray3Float\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],20:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray4Float2D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(4)';\r\n        }\r\n        toArray() {\r\n          return utils.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray4Float2D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],21:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray4Float3D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(4)';\r\n        }\r\n        toArray() {\r\n          return utils.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray4Float3D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],22:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray4Float extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(4)';\r\n        }\r\n        toArray() {\r\n          return utils.erectArray4(this.renderValues(), this.output[0]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray4Float\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],23:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureFloat2D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(1)';\r\n        }\r\n        toArray() {\r\n          return utils.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureFloat2D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],24:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureFloat3D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(1)';\r\n        }\r\n        toArray() {\r\n          return utils.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureFloat3D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],25:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTexture } = require('./index');\r\n      \r\n      class GLTextureFloat extends GLTexture {\r\n        get textureType() {\r\n          return this.context.FLOAT;\r\n        }\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(1)';\r\n        }\r\n        renderRawOutput() {\r\n          const gl = this.context;\r\n          const size = this.size;\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\r\n          gl.framebufferTexture2D(\r\n            gl.FRAMEBUFFER,\r\n            gl.COLOR_ATTACHMENT0,\r\n            gl.TEXTURE_2D,\r\n            this.texture,\r\n            0\r\n          );\r\n          const result = new Float32Array(size[0] * size[1] * 4);\r\n          gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.FLOAT, result);\r\n          return result;\r\n        }\r\n        renderValues() {\r\n          if (this._deleted) return null;\r\n          return this.renderRawOutput();\r\n        }\r\n        toArray() {\r\n          return utils.erectFloat(this.renderValues(), this.output[0]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureFloat\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":27}],26:[function(require,module,exports){\r\n      const { GLTextureUnsigned } = require('./unsigned');\r\n      \r\n      class GLTextureGraphical extends GLTextureUnsigned {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(4)';\r\n        }\r\n        toArray() {\r\n          return this.renderValues();\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureGraphical\r\n      };\r\n      },{\"./unsigned\":33}],27:[function(require,module,exports){\r\n      const { Texture } = require('../../../texture');\r\n      \r\n      class GLTexture extends Texture {\r\n        get textureType() {\r\n          throw new Error(`\"textureType\" not implemented on ${ this.name }`);\r\n        }\r\n      \r\n        clone() {\r\n          return new this.constructor(this);\r\n        }\r\n      \r\n        beforeMutate() {\r\n          if (this.texture._refs > 1) {\r\n            this.newTexture();\r\n            return true;\r\n          }\r\n          return false;\r\n        }\r\n      \r\n        cloneTexture() {\r\n          this.texture._refs--;\r\n          const { context: gl, size, texture, kernel } = this;\r\n          if (kernel.debug) {\r\n            console.warn('cloning internal texture');\r\n          }\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\r\n          selectTexture(gl, texture);\r\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n          const target = gl.createTexture();\r\n          selectTexture(gl, target);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);\r\n          gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, size[0], size[1]);\r\n          target._refs = 1;\r\n          this.texture = target;\r\n        }\r\n      \r\n        newTexture() {\r\n          this.texture._refs--;\r\n          const gl = this.context;\r\n          const size = this.size;\r\n          const kernel = this.kernel;\r\n          if (kernel.debug) {\r\n            console.warn('new internal texture');\r\n          }\r\n          const target = gl.createTexture();\r\n          selectTexture(gl, target);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);\r\n          target._refs = 1;\r\n          this.texture = target;\r\n        }\r\n      \r\n        clear() {\r\n          if (this.texture._refs) {\r\n            this.texture._refs--;\r\n            const gl = this.context;\r\n            const target = this.texture = gl.createTexture();\r\n            selectTexture(gl, target);\r\n            const size = this.size;\r\n            target._refs = 1;\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);\r\n          }\r\n          const { context: gl, texture } = this;\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\r\n          gl.bindTexture(gl.TEXTURE_2D, texture);\r\n          selectTexture(gl, texture);\r\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n          gl.clearColor(0, 0, 0, 0);\r\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        }\r\n      \r\n        delete() {\r\n          if (this._deleted) return;\r\n          this._deleted = true;\r\n          if (this.texture._refs) {\r\n            this.texture._refs--;\r\n            if (this.texture._refs) return;\r\n          }\r\n          this.context.deleteTexture(this.texture);\r\n        }\r\n      \r\n        framebuffer() {\r\n          if (!this._framebuffer) {\r\n            this._framebuffer = this.kernel.getRawValueFramebuffer(this.size[0], this.size[1]);\r\n          }\r\n          return this._framebuffer;\r\n        }\r\n      }\r\n      \r\n      function selectTexture(gl, texture) {\r\n        gl.activeTexture(gl.TEXTURE15);\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n      }\r\n      \r\n      module.exports = { GLTexture };\r\n      },{\"../../../texture\":113}],28:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureMemoryOptimized2D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'MemoryOptimizedNumberTexture';\r\n        }\r\n        toArray() {\r\n          return utils.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureMemoryOptimized2D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],29:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureMemoryOptimized3D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'MemoryOptimizedNumberTexture';\r\n        }\r\n        toArray() {\r\n          return utils.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureMemoryOptimized3D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],30:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureMemoryOptimized extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'MemoryOptimizedNumberTexture';\r\n        }\r\n        toArray() {\r\n          return utils.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureMemoryOptimized\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],31:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureUnsigned } = require('./unsigned');\r\n      \r\n      class GLTextureUnsigned2D extends GLTextureUnsigned {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'NumberTexture';\r\n        }\r\n        toArray() {\r\n          return utils.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureUnsigned2D\r\n      };\r\n      },{\"../../../utils\":114,\"./unsigned\":33}],32:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureUnsigned } = require('./unsigned');\r\n      \r\n      class GLTextureUnsigned3D extends GLTextureUnsigned {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'NumberTexture';\r\n        }\r\n        toArray() {\r\n          return utils.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureUnsigned3D\r\n      };\r\n      },{\"../../../utils\":114,\"./unsigned\":33}],33:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTexture } = require('./index');\r\n      \r\n      class GLTextureUnsigned extends GLTexture {\r\n        get textureType() {\r\n          return this.context.UNSIGNED_BYTE;\r\n        }\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'NumberTexture';\r\n        }\r\n        renderRawOutput() {\r\n          const { context: gl } = this;\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\r\n          gl.framebufferTexture2D(\r\n            gl.FRAMEBUFFER,\r\n            gl.COLOR_ATTACHMENT0,\r\n            gl.TEXTURE_2D,\r\n            this.texture,\r\n            0\r\n          );\r\n          const result = new Uint8Array(this.size[0] * this.size[1] * 4);\r\n          gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);\r\n          return result;\r\n        }\r\n        renderValues() {\r\n          if (this._deleted) return null;\r\n          return new Float32Array(this.renderRawOutput().buffer);\r\n        }\r\n        toArray() {\r\n          return utils.erectPackedFloat(this.renderValues(), this.output[0]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureUnsigned\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":27}],34:[function(require,module,exports){\r\n      const getContext = require('gl');\r\n      const { WebGLKernel } = require('../web-gl/kernel');\r\n      const { glKernelString } = require('../gl/kernel-string');\r\n      \r\n      let isSupported = null;\r\n      let testCanvas = null;\r\n      let testContext = null;\r\n      let testExtensions = null;\r\n      let features = null;\r\n      \r\n      class HeadlessGLKernel extends WebGLKernel {\r\n        static get isSupported() {\r\n          if (isSupported !== null) return isSupported;\r\n          this.setupFeatureChecks();\r\n          isSupported = testContext !== null;\r\n          return isSupported;\r\n        }\r\n      \r\n        static setupFeatureChecks() {\r\n          testCanvas = null;\r\n          testExtensions = null;\r\n          if (typeof getContext !== 'function') return;\r\n          try { \r\n            testContext = getContext(2, 2, {\r\n              preserveDrawingBuffer: true\r\n            });\r\n            if (!testContext || !testContext.getExtension) return;\r\n            testExtensions = {\r\n              STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),\r\n              STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),\r\n              OES_texture_float: testContext.getExtension('OES_texture_float'),\r\n              OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),\r\n              OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),\r\n              WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),\r\n              WEBGL_color_buffer_float: testContext.getExtension('WEBGL_color_buffer_float'),\r\n            };\r\n            features = this.getFeatures();\r\n          } catch (e) {\r\n            console.warn(e);\r\n          }\r\n        }\r\n      \r\n        static isContextMatch(context) {\r\n          try {\r\n            return context.getParameter(context.RENDERER) === 'ANGLE';\r\n          } catch (e) {\r\n            return false;\r\n          }\r\n        }\r\n      \r\n        static getIsTextureFloat() {\r\n          return Boolean(testExtensions.OES_texture_float);\r\n        }\r\n      \r\n        static getIsDrawBuffers() {\r\n          return Boolean(testExtensions.WEBGL_draw_buffers);\r\n        }\r\n      \r\n        static getChannelCount() {\r\n          return testExtensions.WEBGL_draw_buffers ?\r\n            testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :\r\n            1;\r\n        }\r\n      \r\n        static getMaxTextureSize() {\r\n          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);\r\n        }\r\n      \r\n        static get testCanvas() {\r\n          return testCanvas;\r\n        }\r\n      \r\n        static get testContext() {\r\n          return testContext;\r\n        }\r\n      \r\n        static get features() {\r\n          return features;\r\n        }\r\n      \r\n        initCanvas() {\r\n          return {};\r\n        }\r\n      \r\n        initContext() {\r\n          return getContext(2, 2, {\r\n            preserveDrawingBuffer: true\r\n          });\r\n        }\r\n      \r\n        initExtensions() {\r\n          this.extensions = {\r\n            STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),\r\n            STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),\r\n            OES_texture_float: this.context.getExtension('OES_texture_float'),\r\n            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),\r\n            OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),\r\n            WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),\r\n          };\r\n        }\r\n      \r\n        build() {\r\n          super.build.apply(this, arguments);\r\n          if (!this.fallbackRequested) {\r\n            this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);\r\n          }\r\n        }\r\n      \r\n        destroyExtensions() {\r\n          this.extensions.STACKGL_resize_drawingbuffer = null;\r\n          this.extensions.STACKGL_destroy_context = null;\r\n          this.extensions.OES_texture_float = null;\r\n          this.extensions.OES_texture_float_linear = null;\r\n          this.extensions.OES_element_index_uint = null;\r\n          this.extensions.WEBGL_draw_buffers = null;\r\n        }\r\n      \r\n        static destroyContext(context) {\r\n          const extension = context.getExtension('STACKGL_destroy_context');\r\n          if (extension && extension.destroy) {\r\n            extension.destroy();\r\n          }\r\n        }\r\n      \r\n        toString() {\r\n          const setupContextString = `const gl = context || require('gl')(1, 1);\\n`;\r\n          const destroyContextString = `    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\\n`;\r\n          return glKernelString(this.constructor, arguments, this, setupContextString, destroyContextString);\r\n        }\r\n      \r\n        setOutput(output) {\r\n          super.setOutput(output);\r\n          if (this.graphical && this.extensions.STACKGL_resize_drawingbuffer) {\r\n            this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);\r\n          }\r\n          return this;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        HeadlessGLKernel\r\n      };\r\n      },{\"../gl/kernel-string\":12,\"../web-gl/kernel\":70,\"gl\":2}],35:[function(require,module,exports){\r\n      class KernelValue {\r\n        constructor(value, settings) {\r\n          const {\r\n            name,\r\n            kernel,\r\n            context,\r\n            checkContext,\r\n            onRequestContextHandle,\r\n            onUpdateValueMismatch,\r\n            origin,\r\n            strictIntegers,\r\n            type,\r\n            tactic,\r\n          } = settings;\r\n          if (!name) {\r\n            throw new Error('name not set');\r\n          }\r\n          if (!type) {\r\n            throw new Error('type not set');\r\n          }\r\n          if (!origin) {\r\n            throw new Error('origin not set');\r\n          }\r\n          if (origin !== 'user' && origin !== 'constants') {\r\n            throw new Error(`origin must be \"user\" or \"constants\" value is \"${ origin }\"`);\r\n          }\r\n          if (!onRequestContextHandle) {\r\n            throw new Error('onRequestContextHandle is not set');\r\n          }\r\n          this.name = name;\r\n          this.origin = origin;\r\n          this.tactic = tactic;\r\n          this.varName = origin === 'constants' ? `constants.${name}` : name;\r\n          this.kernel = kernel;\r\n          this.strictIntegers = strictIntegers;\r\n          this.type = value.type || type;\r\n          this.size = value.size || null;\r\n          this.index = null;\r\n          this.context = context;\r\n          this.checkContext = checkContext !== null && checkContext !== undefined ? checkContext : true;\r\n          this.contextHandle = null;\r\n          this.onRequestContextHandle = onRequestContextHandle;\r\n          this.onUpdateValueMismatch = onUpdateValueMismatch;\r\n          this.forceUploadEachRun = null;\r\n        }\r\n      \r\n        get id() {\r\n          return `${this.origin}_${name}`;\r\n        }\r\n      \r\n        getSource() {\r\n          throw new Error(`\"getSource\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          throw new Error(`\"updateValue\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        KernelValue\r\n      };\r\n      },{}],36:[function(require,module,exports){\r\n      const { utils } = require('../utils');\r\n      const { Input } = require('../input');\r\n      \r\n      class Kernel {\r\n        static get isSupported() {\r\n          throw new Error(`\"isSupported\" not implemented on ${ this.name }`);\r\n        }\r\n      \r\n        static isContextMatch(context) {\r\n          throw new Error(`\"isContextMatch\" not implemented on ${ this.name }`);\r\n        }\r\n      \r\n        static getFeatures() {\r\n          throw new Error(`\"getFeatures\" not implemented on ${ this.name }`);\r\n        }\r\n      \r\n        static destroyContext(context) {\r\n          throw new Error(`\"destroyContext\" called on ${ this.name }`);\r\n        }\r\n      \r\n        static nativeFunctionArguments() {\r\n          throw new Error(`\"nativeFunctionArguments\" called on ${ this.name }`);\r\n        }\r\n      \r\n        static nativeFunctionReturnType() {\r\n          throw new Error(`\"nativeFunctionReturnType\" called on ${ this.name }`);\r\n        }\r\n      \r\n        static combineKernels() {\r\n          throw new Error(`\"combineKernels\" called on ${ this.name }`);\r\n        }\r\n      \r\n        constructor(source, settings) {\r\n          if (typeof source !== 'object') {\r\n            if (typeof source !== 'string') {\r\n              throw new Error('source not a string');\r\n            }\r\n            if (!utils.isFunctionString(source)) {\r\n              throw new Error('source not a function string');\r\n            }\r\n          }\r\n          this.useLegacyEncoder = false;\r\n          this.fallbackRequested = false;\r\n          this.onRequestFallback = null;\r\n      \r\n          this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;\r\n          this.argumentTypes = null;\r\n          this.argumentSizes = null;\r\n          this.argumentBitRatios = null;\r\n          this.kernelArguments = null;\r\n          this.kernelConstants = null;\r\n          this.forceUploadKernelConstants = null;\r\n      \r\n      \r\n          this.source = source;\r\n      \r\n          this.output = null;\r\n      \r\n          this.debug = false;\r\n      \r\n          this.graphical = false;\r\n      \r\n          this.loopMaxIterations = 0;\r\n      \r\n          this.constants = null;\r\n      \r\n          this.constantTypes = null;\r\n      \r\n          this.constantBitRatios = null;\r\n      \r\n          this.dynamicArguments = false;\r\n      \r\n          this.dynamicOutput = false;\r\n      \r\n          this.canvas = null;\r\n      \r\n          this.context = null;\r\n      \r\n          this.checkContext = null;\r\n      \r\n          this.gpu = null;\r\n      \r\n          this.functions = null;\r\n      \r\n          this.nativeFunctions = null;\r\n      \r\n          this.injectedNative = null;\r\n      \r\n          this.subKernels = null;\r\n      \r\n          this.validate = true;\r\n      \r\n          this.immutable = false;\r\n      \r\n          this.pipeline = false;\r\n      \r\n          this.precision = null;\r\n      \r\n          this.tactic = null;\r\n      \r\n          this.plugins = null;\r\n      \r\n          this.returnType = null;\r\n          this.leadingReturnStatement = null;\r\n          this.followingReturnStatement = null;\r\n          this.optimizeFloatMemory = null;\r\n          this.strictIntegers = false;\r\n          this.fixIntegerDivisionAccuracy = null;\r\n          this.built = false;\r\n          this.signature = null;\r\n        }\r\n      \r\n        mergeSettings(settings) {\r\n          for (let p in settings) {\r\n            if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;\r\n            switch (p) {\r\n              case 'output':\r\n                if (!Array.isArray(settings.output)) {\r\n                  this.setOutput(settings.output); \r\n                  continue;\r\n                }\r\n                break;\r\n              case 'functions':\r\n                this.functions = [];\r\n                for (let i = 0; i < settings.functions.length; i++) {\r\n                  this.addFunction(settings.functions[i]);\r\n                }\r\n                continue;\r\n              case 'graphical':\r\n                if (settings[p] && !settings.hasOwnProperty('precision')) {\r\n                  this.precision = 'unsigned';\r\n                }\r\n                this[p] = settings[p];\r\n                continue;\r\n              case 'nativeFunctions':\r\n                if (!settings.nativeFunctions) continue;\r\n                this.nativeFunctions = [];\r\n                for (let i = 0; i < settings.nativeFunctions.length; i++) {\r\n                  const s = settings.nativeFunctions[i];\r\n                  const { name, source } = s;\r\n                  this.addNativeFunction(name, source, s);\r\n                }\r\n                continue;\r\n            }\r\n            this[p] = settings[p];\r\n          }\r\n      \r\n          if (!this.canvas) this.canvas = this.initCanvas();\r\n          if (!this.context) this.context = this.initContext();\r\n          if (!this.plugins) this.plugins = this.initPlugins(settings);\r\n        }\r\n        build() {\r\n          throw new Error(`\"build\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        run() {\r\n          throw new Error(`\"run\" not defined on ${ this.constructor.name }`)\r\n        }\r\n      \r\n        initCanvas() {\r\n          throw new Error(`\"initCanvas\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        initContext() {\r\n          throw new Error(`\"initContext\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        initPlugins(settings) {\r\n          throw new Error(`\"initPlugins\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        addFunction(source, settings = {}) {\r\n          if (source.name && source.source && source.argumentTypes && 'returnType' in source) {\r\n            this.functions.push(source);\r\n          } else if ('settings' in source && 'source' in source) {\r\n            this.functions.push(this.functionToIGPUFunction(source.source, source.settings));\r\n          } else if (typeof source === 'string' || typeof source === 'function') {\r\n            this.functions.push(this.functionToIGPUFunction(source, settings));\r\n          } else {\r\n            throw new Error(`function not properly defined`);\r\n          }\r\n          return this;\r\n        }\r\n      \r\n        addNativeFunction(name, source, settings = {}) {\r\n          const { argumentTypes, argumentNames } = settings.argumentTypes ?\r\n            splitArgumentTypes(settings.argumentTypes) :\r\n            this.constructor.nativeFunctionArguments(source) || {};\r\n          this.nativeFunctions.push({\r\n            name,\r\n            source,\r\n            settings,\r\n            argumentTypes,\r\n            argumentNames,\r\n            returnType: settings.returnType || this.constructor.nativeFunctionReturnType(source)\r\n          });\r\n          return this;\r\n        }\r\n      \r\n        setupArguments(args) {\r\n          this.kernelArguments = [];\r\n          if (!this.argumentTypes) {\r\n            if (!this.argumentTypes) {\r\n              this.argumentTypes = [];\r\n              for (let i = 0; i < args.length; i++) {\r\n                const argType = utils.getVariableType(args[i], this.strictIntegers);\r\n                const type = argType === 'Integer' ? 'Number' : argType;\r\n                this.argumentTypes.push(type);\r\n                this.kernelArguments.push({\r\n                  type\r\n                });\r\n              }\r\n            }\r\n          } else {\r\n            for (let i = 0; i < this.argumentTypes.length; i++) {\r\n              this.kernelArguments.push({\r\n                type: this.argumentTypes[i]\r\n              });\r\n            }\r\n          }\r\n      \r\n          this.argumentSizes = new Array(args.length);\r\n          this.argumentBitRatios = new Int32Array(args.length);\r\n      \r\n          for (let i = 0; i < args.length; i++) {\r\n            const arg = args[i];\r\n            this.argumentSizes[i] = arg.constructor === Input ? arg.size : null;\r\n            this.argumentBitRatios[i] = this.getBitRatio(arg);\r\n          }\r\n      \r\n          if (this.argumentNames.length !== args.length) {\r\n            throw new Error(`arguments are miss-aligned`);\r\n          }\r\n        }\r\n      \r\n        setupConstants() {\r\n          this.kernelConstants = [];\r\n          let needsConstantTypes = this.constantTypes === null;\r\n          if (needsConstantTypes) {\r\n            this.constantTypes = {};\r\n          }\r\n          this.constantBitRatios = {};\r\n          if (this.constants) {\r\n            for (let name in this.constants) {\r\n              if (needsConstantTypes) {\r\n                const type = utils.getVariableType(this.constants[name], this.strictIntegers);\r\n                this.constantTypes[name] = type;\r\n                this.kernelConstants.push({\r\n                  name,\r\n                  type\r\n                });\r\n              } else {\r\n                this.kernelConstants.push({\r\n                  name,\r\n                  type: this.constantTypes[name]\r\n                });\r\n              }\r\n              this.constantBitRatios[name] = this.getBitRatio(this.constants[name]);\r\n            }\r\n          }\r\n        }\r\n      \r\n        setOptimizeFloatMemory(flag) {\r\n          this.optimizeFloatMemory = flag;\r\n          return this;\r\n        }\r\n      \r\n        toKernelOutput(output) {\r\n          if (output.hasOwnProperty('x')) {\r\n            if (output.hasOwnProperty('y')) {\r\n              if (output.hasOwnProperty('z')) {\r\n                return [output.x, output.y, output.z];\r\n              } else {\r\n                return [output.x, output.y];\r\n              }\r\n            } else {\r\n              return [output.x];\r\n            }\r\n          } else {\r\n            return output;\r\n          }\r\n        }\r\n      \r\n        setOutput(output) {\r\n          this.output = this.toKernelOutput(output);\r\n          return this;\r\n        }\r\n      \r\n        setDebug(flag) {\r\n          this.debug = flag;\r\n          return this;\r\n        }\r\n      \r\n        setGraphical(flag) {\r\n          this.graphical = flag;\r\n          this.precision = 'unsigned';\r\n          return this;\r\n        }\r\n      \r\n        setLoopMaxIterations(max) {\r\n          this.loopMaxIterations = max;\r\n          return this;\r\n        }\r\n      \r\n        setConstants(constants) {\r\n          this.constants = constants;\r\n          return this;\r\n        }\r\n      \r\n        setConstantTypes(constantTypes) {\r\n          this.constantTypes = constantTypes;\r\n          return this;\r\n        }\r\n      \r\n        setFunctions(functions) {\r\n          for (let i = 0; i < functions.length; i++) {\r\n            this.addFunction(functions[i]);\r\n          }\r\n          return this;\r\n        }\r\n      \r\n        setNativeFunctions(nativeFunctions) {\r\n          for (let i = 0; i < nativeFunctions.length; i++) {\r\n            const settings = nativeFunctions[i];\r\n            const { name, source } = settings;\r\n            this.addNativeFunction(name, source, settings);\r\n          }\r\n          return this;\r\n        }\r\n      \r\n        setInjectedNative(injectedNative) {\r\n          this.injectedNative = injectedNative;\r\n          return this;\r\n        }\r\n      \r\n        setPipeline(flag) {\r\n          this.pipeline = flag;\r\n          return this;\r\n        }\r\n      \r\n        setPrecision(flag) {\r\n          this.precision = flag;\r\n          return this;\r\n        }\r\n      \r\n        setDimensions(flag) {\r\n          utils.warnDeprecated('method', 'setDimensions', 'setOutput');\r\n          this.output = flag;\r\n          return this;\r\n        }\r\n      \r\n        setOutputToTexture(flag) {\r\n          utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');\r\n          this.pipeline = flag;\r\n          return this;\r\n        }\r\n      \r\n        setImmutable(flag) {\r\n          this.immutable = flag;\r\n          return this;\r\n        }\r\n      \r\n        setCanvas(canvas) {\r\n          this.canvas = canvas;\r\n          return this;\r\n        }\r\n      \r\n        setStrictIntegers(flag) {\r\n          this.strictIntegers = flag;\r\n          return this;\r\n        }\r\n      \r\n        setDynamicOutput(flag) {\r\n          this.dynamicOutput = flag;\r\n          return this;\r\n        }\r\n      \r\n        setHardcodeConstants(flag) {\r\n          utils.warnDeprecated('method', 'setHardcodeConstants');\r\n          this.setDynamicOutput(flag);\r\n          this.setDynamicArguments(flag);\r\n          return this;\r\n        }\r\n      \r\n        setDynamicArguments(flag) {\r\n          this.dynamicArguments = flag;\r\n          return this;\r\n        }\r\n      \r\n        setUseLegacyEncoder(flag) {\r\n          this.useLegacyEncoder = flag;\r\n          return this;\r\n        }\r\n      \r\n        setWarnVarUsage(flag) {\r\n          utils.warnDeprecated('method', 'setWarnVarUsage');\r\n          return this;\r\n        }\r\n      \r\n        getCanvas() {\r\n          utils.warnDeprecated('method', 'getCanvas');\r\n          return this.canvas;\r\n        }\r\n      \r\n        getWebGl() {\r\n          utils.warnDeprecated('method', 'getWebGl');\r\n          return this.context;\r\n        }\r\n      \r\n        setContext(context) {\r\n          this.context = context;\r\n          return this;\r\n        }\r\n      \r\n        setArgumentTypes(argumentTypes) {\r\n          if (Array.isArray(argumentTypes)) {\r\n            this.argumentTypes = argumentTypes;\r\n          } else {\r\n            this.argumentTypes = [];\r\n            for (const p in argumentTypes) {\r\n              if (!argumentTypes.hasOwnProperty(p)) continue;\r\n              const argumentIndex = this.argumentNames.indexOf(p);\r\n              if (argumentIndex === -1) throw new Error(`unable to find argument ${ p }`);\r\n              this.argumentTypes[argumentIndex] = argumentTypes[p];\r\n            }\r\n          }\r\n          return this;\r\n        }\r\n      \r\n        setTactic(tactic) {\r\n          this.tactic = tactic;\r\n          return this;\r\n        }\r\n      \r\n        requestFallback(args) {\r\n          if (!this.onRequestFallback) {\r\n            throw new Error(`\"onRequestFallback\" not defined on ${ this.constructor.name }`);\r\n          }\r\n          this.fallbackRequested = true;\r\n          return this.onRequestFallback(args);\r\n        }\r\n      \r\n        validateSettings() {\r\n          throw new Error(`\"validateSettings\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        addSubKernel(subKernel) {\r\n          if (this.subKernels === null) {\r\n            this.subKernels = [];\r\n          }\r\n          if (!subKernel.source) throw new Error('subKernel missing \"source\" property');\r\n          if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing \"property\" property');\r\n          if (!subKernel.name) throw new Error('subKernel missing \"name\" property');\r\n          this.subKernels.push(subKernel);\r\n          return this;\r\n        }\r\n      \r\n        destroy(removeCanvasReferences) {\r\n          throw new Error(`\"destroy\" called on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        getBitRatio(value) {\r\n          if (this.precision === 'single') {\r\n            return 4;\r\n          } else if (Array.isArray(value[0])) {\r\n            return this.getBitRatio(value[0]);\r\n          } else if (value.constructor === Input) {\r\n            return this.getBitRatio(value.value);\r\n          }\r\n          switch (value.constructor) {\r\n            case Uint8ClampedArray:\r\n            case Uint8Array:\r\n            case Int8Array:\r\n              return 1;\r\n            case Uint16Array:\r\n            case Int16Array:\r\n              return 2;\r\n            case Float32Array:\r\n            case Int32Array:\r\n            default:\r\n              return 4;\r\n          }\r\n        }\r\n      \r\n        getPixels(flip) {\r\n          throw new Error(`\"getPixels\" called on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        checkOutput() {\r\n          if (!this.output || !utils.isArray(this.output)) throw new Error('kernel.output not an array');\r\n          if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');\r\n          for (let i = 0; i < this.output.length; i++) {\r\n            if (isNaN(this.output[i]) || this.output[i] < 1) {\r\n              throw new Error(`${ this.constructor.name }.output[${ i }] incorrectly defined as \\`${ this.output[i] }\\`, needs to be numeric, and greater than 0`);\r\n            }\r\n          }\r\n        }\r\n      \r\n        prependString(value) {\r\n          throw new Error(`\"prependString\" called on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        hasPrependString(value) {\r\n          throw new Error(`\"hasPrependString\" called on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        toJSON() {\r\n          return {\r\n            settings: {\r\n              output: this.output,\r\n              pipeline: this.pipeline,\r\n              argumentNames: this.argumentNames,\r\n              argumentsTypes: this.argumentTypes,\r\n              constants: this.constants,\r\n              pluginNames: this.plugins ? this.plugins.map(plugin => plugin.name) : null,\r\n              returnType: this.returnType,\r\n            }\r\n          };\r\n        }\r\n      \r\n        buildSignature(args) {\r\n          const Constructor = this.constructor;\r\n          this.signature = Constructor.getSignature(this, Constructor.getArgumentTypes(this, args));\r\n        }\r\n      \r\n        static getArgumentTypes(kernel, args) {\r\n          const argumentTypes = new Array(args.length);\r\n          for (let i = 0; i < args.length; i++) {\r\n            const arg = args[i];\r\n            const type = kernel.argumentTypes[i];\r\n            if (arg.type) {\r\n              argumentTypes[i] = arg.type;\r\n            } else {\r\n              switch (type) {\r\n                case 'Number':\r\n                case 'Integer':\r\n                case 'Float':\r\n                case 'ArrayTexture(1)':\r\n                  argumentTypes[i] = utils.getVariableType(arg);\r\n                  break;\r\n                default:\r\n                  argumentTypes[i] = type;\r\n              }\r\n            }\r\n          }\r\n          return argumentTypes;\r\n        }\r\n      \r\n        static getSignature(kernel, argumentTypes) {\r\n          throw new Error(`\"getSignature\" not implemented on ${ this.name }`);\r\n        }\r\n      \r\n        functionToIGPUFunction(source, settings = {}) {\r\n          if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');\r\n          const sourceString = typeof source === 'string' ? source : source.toString();\r\n          let argumentTypes = [];\r\n      \r\n          if (Array.isArray(settings.argumentTypes)) {\r\n            argumentTypes = settings.argumentTypes;\r\n          } else if (typeof settings.argumentTypes === 'object') {\r\n            argumentTypes = utils.getArgumentNamesFromString(sourceString)\r\n              .map(name => settings.argumentTypes[name]) || [];\r\n          } else {\r\n            argumentTypes = settings.argumentTypes || [];\r\n          }\r\n      \r\n          return {\r\n            name: utils.getFunctionNameFromString(sourceString) || null,\r\n            source: sourceString,\r\n            argumentTypes,\r\n            returnType: settings.returnType || null,\r\n          };\r\n        }\r\n      \r\n        onActivate(previousKernel) {}\r\n      }\r\n      \r\n      function splitArgumentTypes(argumentTypesObject) {\r\n        const argumentNames = Object.keys(argumentTypesObject);\r\n        const argumentTypes = [];\r\n        for (let i = 0; i < argumentNames.length; i++) {\r\n          const argumentName = argumentNames[i];\r\n          argumentTypes.push(argumentTypesObject[argumentName]);\r\n        }\r\n        return { argumentTypes, argumentNames };\r\n      }\r\n      \r\n      module.exports = {\r\n        Kernel\r\n      };\r\n      },{\"../input\":110,\"../utils\":114}],37:[function(require,module,exports){\r\n      const fragmentShader = `__HEADER__;\r\n      __FLOAT_TACTIC_DECLARATION__;\r\n      __INT_TACTIC_DECLARATION__;\r\n      __SAMPLER_2D_TACTIC_DECLARATION__;\r\n      \r\n      const int LOOP_MAX = __LOOP_MAX__;\r\n      \r\n      __PLUGINS__;\r\n      __CONSTANTS__;\r\n      \r\n      varying vec2 vTexCoord;\r\n      \r\n      float acosh(float x) {\r\n        return log(x + sqrt(x * x - 1.0));\r\n      }\r\n      \r\n      float sinh(float x) {\r\n        return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;\r\n      }\r\n      \r\n      float asinh(float x) {\r\n        return log(x + sqrt(x * x + 1.0));\r\n      }\r\n      \r\n      float atan2(float v1, float v2) {\r\n        if (v1 == 0.0 || v2 == 0.0) return 0.0;\r\n        return atan(v1 / v2);\r\n      }\r\n      \r\n      float atanh(float x) {\r\n        x = (x + 1.0) / (x - 1.0);\r\n        if (x < 0.0) {\r\n          return 0.5 * log(-x);\r\n        }\r\n        return 0.5 * log(x);\r\n      }\r\n      \r\n      float cbrt(float x) {\r\n        if (x >= 0.0) {\r\n          return pow(x, 1.0 / 3.0);\r\n        } else {\r\n          return -pow(x, 1.0 / 3.0);\r\n        }\r\n      }\r\n      \r\n      float cosh(float x) {\r\n        return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; \r\n      }\r\n      \r\n      float expm1(float x) {\r\n        return pow(${Math.E}, x) - 1.0; \r\n      }\r\n      \r\n      float fround(highp float x) {\r\n        return x;\r\n      }\r\n      \r\n      float imul(float v1, float v2) {\r\n        return float(int(v1) * int(v2));\r\n      }\r\n      \r\n      float log10(float x) {\r\n        return log2(x) * (1.0 / log2(10.0));\r\n      }\r\n      \r\n      float log1p(float x) {\r\n        return log(1.0 + x);\r\n      }\r\n      \r\n      float _pow(float v1, float v2) {\r\n        if (v2 == 0.0) return 1.0;\r\n        return pow(v1, v2);\r\n      }\r\n      \r\n      float tanh(float x) {\r\n        float e = exp(2.0 * x);\r\n        return (e - 1.0) / (e + 1.0);\r\n      }\r\n      \r\n      float trunc(float x) {\r\n        if (x >= 0.0) {\r\n          return floor(x); \r\n        } else {\r\n          return ceil(x);\r\n        }\r\n      }\r\n      \r\n      vec4 _round(vec4 x) {\r\n        return floor(x + 0.5);\r\n      }\r\n      \r\n      float _round(float x) {\r\n        return floor(x + 0.5);\r\n      }\r\n      \r\n      const int BIT_COUNT = 32;\r\n      int modi(int x, int y) {\r\n        return x - y * (x / y);\r\n      }\r\n      \r\n      int bitwiseOr(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 || b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseXOR(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 || b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseAnd(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 && b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseNot(int a) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (modi(a, 2) == 0) {\r\n            result += n;    \r\n          }\r\n          a = a / 2;\r\n          n = n * 2;\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseZeroFillLeftShift(int n, int shift) {\r\n        int maxBytes = BIT_COUNT;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (maxBytes >= n) {\r\n            break;\r\n          }\r\n          maxBytes *= 2;\r\n        }\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= shift) {\r\n            break;\r\n          }\r\n          n *= 2;\r\n        }\r\n      \r\n        int result = 0;\r\n        int byteVal = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= maxBytes) break;\r\n          if (modi(n, 2) > 0) { result += byteVal; }\r\n          n = int(n / 2);\r\n          byteVal *= 2;\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      int bitwiseSignedRightShift(int num, int shifts) {\r\n        return int(floor(float(num) / pow(2.0, float(shifts))));\r\n      }\r\n      \r\n      int bitwiseZeroFillRightShift(int n, int shift) {\r\n        int maxBytes = BIT_COUNT;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (maxBytes >= n) {\r\n            break;\r\n          }\r\n          maxBytes *= 2;\r\n        }\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= shift) {\r\n            break;\r\n          }\r\n          n /= 2;\r\n        }\r\n        int result = 0;\r\n        int byteVal = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= maxBytes) break;\r\n          if (modi(n, 2) > 0) { result += byteVal; }\r\n          n = int(n / 2);\r\n          byteVal *= 2;\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      vec2 integerMod(vec2 x, float y) {\r\n        vec2 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      vec3 integerMod(vec3 x, float y) {\r\n        vec3 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      vec4 integerMod(vec4 x, vec4 y) {\r\n        vec4 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      float integerMod(float x, float y) {\r\n        float res = floor(mod(x, y));\r\n        return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\r\n      }\r\n      \r\n      int integerMod(int x, int y) {\r\n        return x - (y * int(x / y));\r\n      }\r\n      \r\n      __DIVIDE_WITH_INTEGER_CHECK__;\r\n      \r\n      // Here be dragons!\r\n      // DO NOT OPTIMIZE THIS CODE\r\n      // YOU WILL BREAK SOMETHING ON SOMEBODY\\'S MACHINE\r\n      // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\r\n      const vec2 MAGIC_VEC = vec2(1.0, -256.0);\r\n      const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\r\n      const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\r\n      float decode32(vec4 texel) {\r\n        __DECODE32_ENDIANNESS__;\r\n        texel *= 255.0;\r\n        vec2 gte128;\r\n        gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;\r\n        gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\r\n        float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\r\n        float res = exp2(_round(exponent));\r\n        texel.b = texel.b - 128.0 * gte128.x;\r\n        res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;\r\n        res *= gte128.y * -2.0 + 1.0;\r\n        return res;\r\n      }\r\n      \r\n      float decode16(vec4 texel, int index) {\r\n        int channel = integerMod(index, 2);\r\n        if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;\r\n        if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;\r\n        return 0.0;\r\n      }\r\n      \r\n      float decode8(vec4 texel, int index) {\r\n        int channel = integerMod(index, 4);\r\n        if (channel == 0) return texel.r * 255.0;\r\n        if (channel == 1) return texel.g * 255.0;\r\n        if (channel == 2) return texel.b * 255.0;\r\n        if (channel == 3) return texel.a * 255.0;\r\n        return 0.0;\r\n      }\r\n      \r\n      vec4 legacyEncode32(float f) {\r\n        float F = abs(f);\r\n        float sign = f < 0.0 ? 1.0 : 0.0;\r\n        float exponent = floor(log2(F));\r\n        float mantissa = (exp2(-exponent) * F);\r\n        // exponent += floor(log2(mantissa));\r\n        vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\r\n        texel.rg = integerMod(texel.rg, 256.0);\r\n        texel.b = integerMod(texel.b, 128.0);\r\n        texel.a = exponent*0.5 + 63.5;\r\n        texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\r\n        texel = floor(texel);\r\n        texel *= 0.003921569; // 1/255\r\n        __ENCODE32_ENDIANNESS__;\r\n        return texel;\r\n      }\r\n      \r\n      // https://github.com/gpujs/gpu.js/wiki/Encoder-details\r\n      vec4 encode32(float value) {\r\n        if (value == 0.0) return vec4(0, 0, 0, 0);\r\n      \r\n        float exponent;\r\n        float mantissa;\r\n        vec4  result;\r\n        float sgn;\r\n      \r\n        sgn = step(0.0, -value);\r\n        value = abs(value);\r\n      \r\n        exponent = floor(log2(value));\r\n      \r\n        mantissa = value*pow(2.0, -exponent)-1.0;\r\n        exponent = exponent+127.0;\r\n        result   = vec4(0,0,0,0);\r\n      \r\n        result.a = floor(exponent/2.0);\r\n        exponent = exponent - result.a*2.0;\r\n        result.a = result.a + 128.0*sgn;\r\n      \r\n        result.b = floor(mantissa * 128.0);\r\n        mantissa = mantissa - result.b / 128.0;\r\n        result.b = result.b + exponent*128.0;\r\n      \r\n        result.g = floor(mantissa*32768.0);\r\n        mantissa = mantissa - result.g/32768.0;\r\n      \r\n        result.r = floor(mantissa*8388608.0);\r\n        return result/255.0;\r\n      }\r\n      // Dragons end here\r\n      \r\n      int index;\r\n      ivec3 threadId;\r\n      \r\n      ivec3 indexTo3D(int idx, ivec3 texDim) {\r\n        int z = int(idx / (texDim.x * texDim.y));\r\n        idx -= z * int(texDim.x * texDim.y);\r\n        int y = int(idx / texDim.x);\r\n        int x = int(integerMod(idx, texDim.x));\r\n        return ivec3(x, y, z);\r\n      }\r\n      \r\n      float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize));\r\n        return decode32(texel);\r\n      }\r\n      \r\n      float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x * 2;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));\r\n        return decode16(texel, index);\r\n      }\r\n      \r\n      float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x * 4;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));\r\n        return decode8(texel, index);\r\n      }\r\n      \r\n      float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int channel = integerMod(index, 4);\r\n        index = index / 4;\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize));\r\n        if (channel == 0) return texel.r;\r\n        if (channel == 1) return texel.g;\r\n        if (channel == 2) return texel.b;\r\n        if (channel == 3) return texel.a;\r\n        return 0.0;\r\n      }\r\n      \r\n      vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        return texture2D(tex, st / vec2(texSize));\r\n      }\r\n      \r\n      float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return result[0];\r\n      }\r\n      \r\n      vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return vec2(result[0], result[1]);\r\n      }\r\n      \r\n      vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + (texDim.x * (y + (texDim.y * z)));\r\n        int channel = integerMod(index, 2);\r\n        index = index / 2;\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize));\r\n        if (channel == 0) return vec2(texel.r, texel.g);\r\n        if (channel == 1) return vec2(texel.b, texel.a);\r\n        return vec2(0.0, 0.0);\r\n      }\r\n      \r\n      vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return vec3(result[0], result[1], result[2]);\r\n      }\r\n      \r\n      vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));\r\n        int vectorIndex = fieldIndex / 4;\r\n        int vectorOffset = fieldIndex - vectorIndex * 4;\r\n        int readY = vectorIndex / texSize.x;\r\n        int readX = vectorIndex - readY * texSize.x;\r\n        vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));\r\n        \r\n        if (vectorOffset == 0) {\r\n          return tex1.xyz;\r\n        } else if (vectorOffset == 1) {\r\n          return tex1.yzw;\r\n        } else {\r\n          readX++;\r\n          if (readX >= texSize.x) {\r\n            readX = 0;\r\n            readY++;\r\n          }\r\n          vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));\r\n          if (vectorOffset == 2) {\r\n            return vec3(tex1.z, tex1.w, tex2.x);\r\n          } else {\r\n            return vec3(tex1.w, tex2.x, tex2.y);\r\n          }\r\n        }\r\n      }\r\n      \r\n      vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        return getImage2D(tex, texSize, texDim, z, y, x);\r\n      }\r\n      \r\n      vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int channel = integerMod(index, 2);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize));\r\n        return vec4(texel.r, texel.g, texel.b, texel.a);\r\n      }\r\n      \r\n      vec4 actualColor;\r\n      void color(float r, float g, float b, float a) {\r\n        actualColor = vec4(r,g,b,a);\r\n      }\r\n      \r\n      void color(float r, float g, float b) {\r\n        color(r,g,b,1.0);\r\n      }\r\n      \r\n      void color(sampler2D image) {\r\n        actualColor = texture2D(image, vTexCoord);\r\n      }\r\n      \r\n      float modulo(float number, float divisor) {\r\n        if (number < 0.0) {\r\n          number = abs(number);\r\n          if (divisor < 0.0) {\r\n            divisor = abs(divisor);\r\n          }\r\n          return -mod(number, divisor);\r\n        }\r\n        if (divisor < 0.0) {\r\n          divisor = abs(divisor);\r\n        }\r\n        return mod(number, divisor);\r\n      }\r\n      \r\n      __INJECTED_NATIVE__;\r\n      __MAIN_CONSTANTS__;\r\n      __MAIN_ARGUMENTS__;\r\n      __KERNEL__;\r\n      \r\n      void main(void) {\r\n        index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\r\n        __MAIN_RESULT__;\r\n      }`;\r\n      \r\n      module.exports = {\r\n        fragmentShader\r\n      };\r\n      },{}],38:[function(require,module,exports){\r\n      const { utils } = require('../../utils');\r\n      const { FunctionNode } = require('../function-node');\r\n      \r\n      class WebGLFunctionNode extends FunctionNode {\r\n        constructor(source, settings) {\r\n          super(source, settings);\r\n          if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {\r\n            this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;\r\n          }\r\n        }\r\n      \r\n        astConditionalExpression(ast, retArr) {\r\n          if (ast.type !== 'ConditionalExpression') {\r\n            throw this.astErrorOutput('Not a conditional expression', ast);\r\n          }\r\n          const consequentType = this.getType(ast.consequent);\r\n          const alternateType = this.getType(ast.alternate);\r\n          if (consequentType === null && alternateType === null) {\r\n            retArr.push('if (');\r\n            this.astGeneric(ast.test, retArr);\r\n            retArr.push(') {');\r\n            this.astGeneric(ast.consequent, retArr);\r\n            retArr.push(';');\r\n            retArr.push('} else {');\r\n            this.astGeneric(ast.alternate, retArr);\r\n            retArr.push(';');\r\n            retArr.push('}');\r\n            return retArr;\r\n          }\r\n          retArr.push('(');\r\n          this.astGeneric(ast.test, retArr);\r\n          retArr.push('?');\r\n          this.astGeneric(ast.consequent, retArr);\r\n          retArr.push(':');\r\n          this.astGeneric(ast.alternate, retArr);\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        astFunction(ast, retArr) {\r\n          if (this.isRootKernel) {\r\n            retArr.push('void');\r\n          } else {\r\n            if (!this.returnType) {\r\n              const lastReturn = this.findLastReturn();\r\n              if (lastReturn) {\r\n                this.returnType = this.getType(ast.body);\r\n                if (this.returnType === 'LiteralInteger') {\r\n                  this.returnType = 'Number';\r\n                }\r\n              }\r\n            }\r\n      \r\n            const { returnType } = this;\r\n            if (!returnType) {\r\n              retArr.push('void');\r\n            } else {\r\n              const type = typeMap[returnType];\r\n              if (!type) {\r\n                throw new Error(`unknown type ${returnType}`);\r\n              }\r\n              retArr.push(type);\r\n            }\r\n          }\r\n          retArr.push(' ');\r\n          retArr.push(this.name);\r\n          retArr.push('(');\r\n      \r\n          if (!this.isRootKernel) {\r\n            for (let i = 0; i < this.argumentNames.length; ++i) {\r\n              const argumentName = this.argumentNames[i];\r\n      \r\n              if (i > 0) {\r\n                retArr.push(', ');\r\n              }\r\n              let argumentType = this.argumentTypes[this.argumentNames.indexOf(argumentName)];\r\n              if (!argumentType) {\r\n                throw this.astErrorOutput(`Unknown argument ${argumentName} type`, ast);\r\n              }\r\n              if (argumentType === 'LiteralInteger') {\r\n                this.argumentTypes[i] = argumentType = 'Number';\r\n              }\r\n              const type = typeMap[argumentType];\r\n              if (!type) {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              const name = utils.sanitizeName(argumentName);\r\n              if (type === 'sampler2D' || type === 'sampler2DArray') {\r\n                retArr.push(`${type} user_${name},ivec2 user_${name}Size,ivec3 user_${name}Dim`);\r\n              } else {\r\n                retArr.push(`${type} user_${name}`);\r\n              }\r\n            }\r\n          }\r\n      \r\n          retArr.push(') {\\n');\r\n      \r\n          for (let i = 0; i < ast.body.body.length; ++i) {\r\n            this.astGeneric(ast.body.body[i], retArr);\r\n            retArr.push('\\n');\r\n          }\r\n      \r\n          retArr.push('}\\n');\r\n          return retArr;\r\n        }\r\n      \r\n        astReturnStatement(ast, retArr) {\r\n          if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);\r\n          this.pushState('skip-literal-correction');\r\n          const type = this.getType(ast.argument);\r\n          this.popState('skip-literal-correction');\r\n      \r\n          const result = [];\r\n      \r\n          if (!this.returnType) {\r\n            if (type === 'LiteralInteger' || type === 'Integer') {\r\n              this.returnType = 'Number';\r\n            } else {\r\n              this.returnType = type;\r\n            }\r\n          }\r\n      \r\n          switch (this.returnType) {\r\n            case 'LiteralInteger':\r\n            case 'Number':\r\n            case 'Float':\r\n              switch (type) {\r\n                case 'Integer':\r\n                  result.push('float(');\r\n                  this.astGeneric(ast.argument, result);\r\n                  result.push(')');\r\n                  break;\r\n                case 'LiteralInteger':\r\n                  this.castLiteralToFloat(ast.argument, result);\r\n      \r\n                  if (this.getType(ast) === 'Integer') {\r\n                    result.unshift('float(');\r\n                    result.push(')');\r\n                  }\r\n                  break;\r\n                default:\r\n                  this.astGeneric(ast.argument, result);\r\n              }\r\n              break;\r\n            case 'Integer':\r\n              switch (type) {\r\n                case 'Float':\r\n                case 'Number':\r\n                  this.castValueToInteger(ast.argument, result);\r\n                  break;\r\n                case 'LiteralInteger':\r\n                  this.castLiteralToInteger(ast.argument, result);\r\n                  break;\r\n                default:\r\n                  this.astGeneric(ast.argument, result);\r\n              }\r\n              break;\r\n            case 'Array(4)':\r\n            case 'Array(3)':\r\n            case 'Array(2)':\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n            case 'Input':\r\n              this.astGeneric(ast.argument, result);\r\n              break;\r\n            default:\r\n              throw this.astErrorOutput(`unhandled return type ${this.returnType}`, ast);\r\n          }\r\n      \r\n          if (this.isRootKernel) {\r\n            retArr.push(`kernelResult = ${ result.join('') };`);\r\n            retArr.push('return;');\r\n          } else if (this.isSubKernel) {\r\n            retArr.push(`subKernelResult_${ this.name } = ${ result.join('') };`);\r\n            retArr.push(`return subKernelResult_${ this.name };`);\r\n          } else {\r\n            retArr.push(`return ${ result.join('') };`);\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astLiteral(ast, retArr) {\r\n          if (isNaN(ast.value)) {\r\n            throw this.astErrorOutput(\r\n              'Non-numeric literal not supported : ' + ast.value,\r\n              ast\r\n            );\r\n          }\r\n      \r\n          const key = this.astKey(ast);\r\n          if (Number.isInteger(ast.value)) {\r\n            if (this.isState('casting-to-integer') || this.isState('building-integer')) {\r\n              this.literalTypes[key] = 'Integer';\r\n              retArr.push(`${ast.value}`);\r\n            } else if (this.isState('casting-to-float') || this.isState('building-float')) {\r\n              this.literalTypes[key] = 'Number';\r\n              retArr.push(`${ast.value}.0`);\r\n            } else {\r\n              this.literalTypes[key] = 'Number';\r\n              retArr.push(`${ast.value}.0`);\r\n            }\r\n          } else if (this.isState('casting-to-integer') || this.isState('building-integer')) {\r\n            this.literalTypes[key] = 'Integer';\r\n            retArr.push(Math.round(ast.value));\r\n          } else {\r\n            this.literalTypes[key] = 'Number';\r\n            retArr.push(`${ast.value}`);\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astBinaryExpression(ast, retArr) {\r\n          if (this.checkAndUpconvertOperator(ast, retArr)) {\r\n            return retArr;\r\n          }\r\n      \r\n          if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {\r\n            retArr.push('divWithIntCheck(');\r\n            this.pushState('building-float');\r\n            switch (this.getType(ast.left)) {\r\n              case 'Integer':\r\n                this.castValueToFloat(ast.left, retArr);\r\n                break;\r\n              case 'LiteralInteger':\r\n                this.castLiteralToFloat(ast.left, retArr);\r\n                break;\r\n              default:\r\n                this.astGeneric(ast.left, retArr);\r\n            }\r\n            retArr.push(', ');\r\n            switch (this.getType(ast.right)) {\r\n              case 'Integer':\r\n                this.castValueToFloat(ast.right, retArr);\r\n                break;\r\n              case 'LiteralInteger':\r\n                this.castLiteralToFloat(ast.right, retArr);\r\n                break;\r\n              default:\r\n                this.astGeneric(ast.right, retArr);\r\n            }\r\n            this.popState('building-float');\r\n            retArr.push(')');\r\n            return retArr;\r\n          }\r\n      \r\n          retArr.push('(');\r\n          const leftType = this.getType(ast.left) || 'Number';\r\n          const rightType = this.getType(ast.right) || 'Number';\r\n          if (!leftType || !rightType) {\r\n            throw this.astErrorOutput(`Unhandled binary expression`, ast);\r\n          }\r\n          const key = leftType + ' & ' + rightType;\r\n          switch (key) {\r\n            case 'Integer & Integer':\r\n              this.pushState('building-integer');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.astGeneric(ast.right, retArr);\r\n              this.popState('building-integer');\r\n              break;\r\n            case 'Number & Float':\r\n            case 'Float & Number':\r\n            case 'Float & Float':\r\n            case 'Number & Number':\r\n              this.pushState('building-float');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.astGeneric(ast.right, retArr);\r\n              this.popState('building-float');\r\n              break;\r\n            case 'LiteralInteger & LiteralInteger':\r\n              if (this.isState('casting-to-integer') || this.isState('building-integer')) {\r\n                this.pushState('building-integer');\r\n                this.astGeneric(ast.left, retArr);\r\n                retArr.push(operatorMap[ast.operator] || ast.operator);\r\n                this.astGeneric(ast.right, retArr);\r\n                this.popState('building-integer');\r\n              } else {\r\n                this.pushState('building-float');\r\n                this.castLiteralToFloat(ast.left, retArr);\r\n                retArr.push(operatorMap[ast.operator] || ast.operator);\r\n                this.castLiteralToFloat(ast.right, retArr);\r\n                this.popState('building-float');\r\n              }\r\n              break;\r\n      \r\n            case 'Integer & Float':\r\n            case 'Integer & Number':\r\n              if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {\r\n                if (!Number.isInteger(ast.right.value)) {\r\n                  this.pushState('building-float');\r\n                  this.castValueToFloat(ast.left, retArr);\r\n                  retArr.push(operatorMap[ast.operator] || ast.operator);\r\n                  this.astGeneric(ast.right, retArr);\r\n                  this.popState('building-float');\r\n                  break;\r\n                }\r\n              }\r\n              this.pushState('building-integer');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.pushState('casting-to-integer');\r\n              if (ast.right.type === 'Literal') {\r\n                const literalResult = [];\r\n                this.astGeneric(ast.right, literalResult);\r\n                const literalType = this.getType(ast.right);\r\n                if (literalType === 'Integer') {\r\n                  retArr.push(literalResult.join(''));\r\n                } else {\r\n                  throw this.astErrorOutput(`Unhandled binary expression with literal`, ast);\r\n                }\r\n              } else {\r\n                retArr.push('int(');\r\n                this.astGeneric(ast.right, retArr);\r\n                retArr.push(')');\r\n              }\r\n              this.popState('casting-to-integer');\r\n              this.popState('building-integer');\r\n              break;\r\n            case 'Integer & LiteralInteger':\r\n              this.pushState('building-integer');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.castLiteralToInteger(ast.right, retArr);\r\n              this.popState('building-integer');\r\n              break;\r\n      \r\n            case 'Number & Integer':\r\n              this.pushState('building-float');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.castValueToFloat(ast.right, retArr);\r\n              this.popState('building-float');\r\n              break;\r\n            case 'Float & LiteralInteger':\r\n            case 'Number & LiteralInteger':\r\n              this.pushState('building-float');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.castLiteralToFloat(ast.right, retArr);\r\n              this.popState('building-float');\r\n              break;\r\n            case 'LiteralInteger & Float':\r\n            case 'LiteralInteger & Number':\r\n              if (this.isState('casting-to-integer')) {\r\n                this.pushState('building-integer');\r\n                this.castLiteralToInteger(ast.left, retArr);\r\n                retArr.push(operatorMap[ast.operator] || ast.operator);\r\n                this.castValueToInteger(ast.right, retArr);\r\n                this.popState('building-integer');\r\n              } else {\r\n                this.pushState('building-float');\r\n                this.astGeneric(ast.left, retArr);\r\n                retArr.push(operatorMap[ast.operator] || ast.operator);\r\n                this.pushState('casting-to-float');\r\n                this.astGeneric(ast.right, retArr);\r\n                this.popState('casting-to-float');\r\n                this.popState('building-float');\r\n              }\r\n              break;\r\n            case 'LiteralInteger & Integer':\r\n              this.pushState('building-integer');\r\n              this.castLiteralToInteger(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.astGeneric(ast.right, retArr);\r\n              this.popState('building-integer');\r\n              break;\r\n      \r\n            case 'Boolean & Boolean':\r\n              this.pushState('building-boolean');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.astGeneric(ast.right, retArr);\r\n              this.popState('building-boolean');\r\n              break;\r\n      \r\n            case 'Float & Integer':\r\n              this.pushState('building-float');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.castValueToFloat(ast.right, retArr);\r\n              this.popState('building-float');\r\n              break;\r\n      \r\n            default:\r\n              throw this.astErrorOutput(`Unhandled binary expression between ${key}`, ast);\r\n          }\r\n          retArr.push(')');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        checkAndUpconvertOperator(ast, retArr) {\r\n          const bitwiseResult = this.checkAndUpconvertBitwiseOperators(ast, retArr);\r\n          if (bitwiseResult) {\r\n            return bitwiseResult;\r\n          }\r\n          const upconvertableOperators = {\r\n            '%': this.fixIntegerDivisionAccuracy ? 'integerCorrectionModulo' : 'modulo',\r\n            '**': 'pow',\r\n          };\r\n          const foundOperator = upconvertableOperators[ast.operator];\r\n          if (!foundOperator) return null;\r\n          retArr.push(foundOperator);\r\n          retArr.push('(');\r\n          switch (this.getType(ast.left)) {\r\n            case 'Integer':\r\n              this.castValueToFloat(ast.left, retArr);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToFloat(ast.left, retArr);\r\n              break;\r\n            default:\r\n              this.astGeneric(ast.left, retArr);\r\n          }\r\n          retArr.push(',');\r\n          switch (this.getType(ast.right)) {\r\n            case 'Integer':\r\n              this.castValueToFloat(ast.right, retArr);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToFloat(ast.right, retArr);\r\n              break;\r\n            default:\r\n              this.astGeneric(ast.right, retArr);\r\n          }\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        checkAndUpconvertBitwiseOperators(ast, retArr) {\r\n          const upconvertableOperators = {\r\n            '&': 'bitwiseAnd',\r\n            '|': 'bitwiseOr',\r\n            '^': 'bitwiseXOR',\r\n            '<<': 'bitwiseZeroFillLeftShift',\r\n            '>>': 'bitwiseSignedRightShift',\r\n            '>>>': 'bitwiseZeroFillRightShift',\r\n          };\r\n          const foundOperator = upconvertableOperators[ast.operator];\r\n          if (!foundOperator) return null;\r\n          retArr.push(foundOperator);\r\n          retArr.push('(');\r\n          const leftType = this.getType(ast.left);\r\n          switch (leftType) {\r\n            case 'Number':\r\n            case 'Float':\r\n              this.castValueToInteger(ast.left, retArr);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToInteger(ast.left, retArr);\r\n              break;\r\n            default:\r\n              this.astGeneric(ast.left, retArr);\r\n          }\r\n          retArr.push(',');\r\n          const rightType = this.getType(ast.right);\r\n          switch (rightType) {\r\n            case 'Number':\r\n            case 'Float':\r\n              this.castValueToInteger(ast.right, retArr);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToInteger(ast.right, retArr);\r\n              break;\r\n            default:\r\n              this.astGeneric(ast.right, retArr);\r\n          }\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        checkAndUpconvertBitwiseUnary(ast, retArr) {\r\n          const upconvertableOperators = {\r\n            '~': 'bitwiseNot',\r\n          };\r\n          const foundOperator = upconvertableOperators[ast.operator];\r\n          if (!foundOperator) return null;\r\n          retArr.push(foundOperator);\r\n          retArr.push('(');\r\n          switch (this.getType(ast.argument)) {\r\n            case 'Number':\r\n            case 'Float':\r\n              this.castValueToInteger(ast.argument, retArr);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToInteger(ast.argument, retArr);\r\n              break;\r\n            default:\r\n              this.astGeneric(ast.argument, retArr);\r\n          }\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        castLiteralToInteger(ast, retArr) {\r\n          this.pushState('casting-to-integer');\r\n          this.astGeneric(ast, retArr);\r\n          this.popState('casting-to-integer');\r\n          return retArr;\r\n        }\r\n      \r\n        castLiteralToFloat(ast, retArr) {\r\n          this.pushState('casting-to-float');\r\n          this.astGeneric(ast, retArr);\r\n          this.popState('casting-to-float');\r\n          return retArr;\r\n        }\r\n      \r\n        castValueToInteger(ast, retArr) {\r\n          this.pushState('casting-to-integer');\r\n          retArr.push('int(');\r\n          this.astGeneric(ast, retArr);\r\n          retArr.push(')');\r\n          this.popState('casting-to-integer');\r\n          return retArr;\r\n        }\r\n      \r\n        castValueToFloat(ast, retArr) {\r\n          this.pushState('casting-to-float');\r\n          retArr.push('float(');\r\n          this.astGeneric(ast, retArr);\r\n          retArr.push(')');\r\n          this.popState('casting-to-float');\r\n          return retArr;\r\n        }\r\n      \r\n        astIdentifierExpression(idtNode, retArr) {\r\n          if (idtNode.type !== 'Identifier') {\r\n            throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);\r\n          }\r\n      \r\n          const type = this.getType(idtNode);\r\n      \r\n          const name = utils.sanitizeName(idtNode.name);\r\n          if (idtNode.name === 'Infinity') {\r\n            retArr.push('3.402823466e+38');\r\n          } else if (type === 'Boolean') {\r\n            if (this.argumentNames.indexOf(name) > -1) {\r\n              retArr.push(`bool(user_${name})`);\r\n            } else {\r\n              retArr.push(`user_${name}`);\r\n            }\r\n          } else {\r\n            retArr.push(`user_${name}`);\r\n          }\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astForStatement(forNode, retArr) {\r\n          if (forNode.type !== 'ForStatement') {\r\n            throw this.astErrorOutput('Invalid for statement', forNode);\r\n          }\r\n      \r\n          const initArr = [];\r\n          const testArr = [];\r\n          const updateArr = [];\r\n          const bodyArr = [];\r\n          let isSafe = null;\r\n      \r\n          if (forNode.init) {\r\n            const { declarations } = forNode.init;\r\n            if (declarations.length > 1) {\r\n              isSafe = false;\r\n            }\r\n            this.astGeneric(forNode.init, initArr);\r\n            for (let i = 0; i < declarations.length; i++) {\r\n              if (declarations[i].init && declarations[i].init.type !== 'Literal') {\r\n                isSafe = false;\r\n              }\r\n            }\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.test) {\r\n            this.astGeneric(forNode.test, testArr);\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.update) {\r\n            this.astGeneric(forNode.update, updateArr);\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.body) {\r\n            this.pushState('loop-body');\r\n            this.astGeneric(forNode.body, bodyArr);\r\n            this.popState('loop-body');\r\n          }\r\n      \r\n          if (isSafe === null) {\r\n            isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);\r\n          }\r\n      \r\n          if (isSafe) {\r\n            const initString = initArr.join('');\r\n            const initNeedsSemiColon = initString[initString.length - 1] !== ';';\r\n            retArr.push(`for (${initString}${initNeedsSemiColon ? ';' : ''}${testArr.join('')};${updateArr.join('')}){\\n`);\r\n            retArr.push(bodyArr.join(''));\r\n            retArr.push('}\\n');\r\n          } else {\r\n            const iVariableName = this.getInternalVariableName('safeI');\r\n            if (initArr.length > 0) {\r\n              retArr.push(initArr.join(''), '\\n');\r\n            }\r\n            retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\n`);\r\n            if (testArr.length > 0) {\r\n              retArr.push(`if (!${testArr.join('')}) break;\\n`);\r\n            }\r\n            retArr.push(bodyArr.join(''));\r\n            retArr.push(`\\n${updateArr.join('')};`);\r\n            retArr.push('}\\n');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astWhileStatement(whileNode, retArr) {\r\n          if (whileNode.type !== 'WhileStatement') {\r\n            throw this.astErrorOutput('Invalid while statement', whileNode);\r\n          }\r\n      \r\n          const iVariableName = this.getInternalVariableName('safeI');\r\n          retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\n`);\r\n          retArr.push('if (!');\r\n          this.astGeneric(whileNode.test, retArr);\r\n          retArr.push(') break;\\n');\r\n          this.astGeneric(whileNode.body, retArr);\r\n          retArr.push('}\\n');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astDoWhileStatement(doWhileNode, retArr) {\r\n          if (doWhileNode.type !== 'DoWhileStatement') {\r\n            throw this.astErrorOutput('Invalid while statement', doWhileNode);\r\n          }\r\n      \r\n          const iVariableName = this.getInternalVariableName('safeI');\r\n          retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\n`);\r\n          this.astGeneric(doWhileNode.body, retArr);\r\n          retArr.push('if (!');\r\n          this.astGeneric(doWhileNode.test, retArr);\r\n          retArr.push(') break;\\n');\r\n          retArr.push('}\\n');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n      \r\n        astAssignmentExpression(assNode, retArr) {\r\n          if (assNode.operator === '%=') {\r\n            this.astGeneric(assNode.left, retArr);\r\n            retArr.push('=');\r\n            retArr.push('mod(');\r\n            this.astGeneric(assNode.left, retArr);\r\n            retArr.push(',');\r\n            this.astGeneric(assNode.right, retArr);\r\n            retArr.push(')');\r\n          } else if (assNode.operator === '**=') {\r\n            this.astGeneric(assNode.left, retArr);\r\n            retArr.push('=');\r\n            retArr.push('pow(');\r\n            this.astGeneric(assNode.left, retArr);\r\n            retArr.push(',');\r\n            this.astGeneric(assNode.right, retArr);\r\n            retArr.push(')');\r\n          } else {\r\n            const leftType = this.getType(assNode.left);\r\n            const rightType = this.getType(assNode.right);\r\n            this.astGeneric(assNode.left, retArr);\r\n            retArr.push(assNode.operator);\r\n            if (leftType !== 'Integer' && rightType === 'Integer') {\r\n              retArr.push('float(');\r\n              this.astGeneric(assNode.right, retArr);\r\n              retArr.push(')');\r\n            } else {\r\n              this.astGeneric(assNode.right, retArr);\r\n            }\r\n            return retArr;\r\n          }\r\n        }\r\n      \r\n        astBlockStatement(bNode, retArr) {\r\n          if (this.isState('loop-body')) {\r\n            this.pushState('block-body'); \r\n            for (let i = 0; i < bNode.body.length; i++) {\r\n              this.astGeneric(bNode.body[i], retArr);\r\n            }\r\n            this.popState('block-body');\r\n          } else {\r\n            retArr.push('{\\n');\r\n            for (let i = 0; i < bNode.body.length; i++) {\r\n              this.astGeneric(bNode.body[i], retArr);\r\n            }\r\n            retArr.push('}\\n');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astVariableDeclaration(varDecNode, retArr) {\r\n          const declarations = varDecNode.declarations;\r\n          if (!declarations || !declarations[0] || !declarations[0].init) {\r\n            throw this.astErrorOutput('Unexpected expression', varDecNode);\r\n          }\r\n          const result = [];\r\n          let lastType = null;\r\n          const declarationSets = [];\r\n          let declarationSet = [];\r\n          for (let i = 0; i < declarations.length; i++) {\r\n            const declaration = declarations[i];\r\n            const init = declaration.init;\r\n            const info = this.getDeclaration(declaration.id);\r\n            const actualType = this.getType(declaration.init);\r\n            let type = actualType;\r\n            if (type === 'LiteralInteger') {\r\n              if (info.suggestedType === 'Integer') {\r\n                type = 'Integer';\r\n              } else {\r\n                type = 'Number';\r\n              }\r\n            }\r\n            const markupType = typeMap[type];\r\n            if (!markupType) {\r\n              throw this.astErrorOutput(`Markup type ${ type } not handled`, varDecNode);\r\n            }\r\n            const declarationResult = [];\r\n            if (actualType === 'Integer' && type === 'Integer') {\r\n              info.valueType = 'Number';\r\n              if (i === 0 || lastType === null) {\r\n                declarationResult.push('float ');\r\n              } else if (type !== lastType) {\r\n                throw new Error('Unhandled declaration');\r\n              }\r\n              lastType = type;\r\n              declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);\r\n              declarationResult.push('float(');\r\n              this.astGeneric(init, declarationResult);\r\n              declarationResult.push(')');\r\n            } else {\r\n              info.valueType = type;\r\n              if (i === 0 || lastType === null) {\r\n                declarationResult.push(`${markupType} `);\r\n              } else if (type !== lastType) {\r\n                declarationSets.push(declarationSet.join(','));\r\n                declarationSet = [];\r\n                declarationResult.push(`${markupType} `);\r\n              }\r\n              lastType = type;\r\n              declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);\r\n              if (actualType === 'Number' && type === 'Integer') {\r\n                if (init.left && init.left.type === 'Literal') {\r\n                  this.astGeneric(init, declarationResult);\r\n                } else {\r\n                  declarationResult.push('int(');\r\n                  this.astGeneric(init, declarationResult);\r\n                  declarationResult.push(')');\r\n                }\r\n              } else if (actualType === 'LiteralInteger' && type === 'Integer') {\r\n                this.castLiteralToInteger(init, declarationResult);\r\n              } else {\r\n                this.astGeneric(init, declarationResult);\r\n              }\r\n            }\r\n            declarationSet.push(declarationResult.join(''));\r\n          }\r\n      \r\n          if (declarationSet.length > 0) {\r\n            declarationSets.push(declarationSet.join(','));\r\n          }\r\n      \r\n          result.push(declarationSets.join(';'));\r\n      \r\n          retArr.push(result.join(''));\r\n          retArr.push(';');\r\n          return retArr;\r\n        }\r\n      \r\n        astIfStatement(ifNode, retArr) {\r\n          retArr.push('if (');\r\n          this.astGeneric(ifNode.test, retArr);\r\n          retArr.push(')');\r\n          if (ifNode.consequent.type === 'BlockStatement') {\r\n            this.astGeneric(ifNode.consequent, retArr);\r\n          } else {\r\n            retArr.push(' {\\n');\r\n            this.astGeneric(ifNode.consequent, retArr);\r\n            retArr.push('\\n}\\n');\r\n          }\r\n      \r\n          if (ifNode.alternate) {\r\n            retArr.push('else ');\r\n            if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {\r\n              this.astGeneric(ifNode.alternate, retArr);\r\n            } else {\r\n              retArr.push(' {\\n');\r\n              this.astGeneric(ifNode.alternate, retArr);\r\n              retArr.push('\\n}\\n');\r\n            }\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astSwitchStatement(ast, retArr) {\r\n          if (ast.type !== 'SwitchStatement') {\r\n            throw this.astErrorOutput('Invalid switch statement', ast);\r\n          }\r\n          const { discriminant, cases } = ast;\r\n          const type = this.getType(discriminant);\r\n          const varName = `switchDiscriminant${this.astKey(ast, '_')}`;\r\n          switch (type) {\r\n            case 'Float':\r\n            case 'Number':\r\n              retArr.push(`float ${varName} = `);\r\n              this.astGeneric(discriminant, retArr);\r\n              retArr.push(';\\n');\r\n              break;\r\n            case 'Integer':\r\n              retArr.push(`int ${varName} = `);\r\n              this.astGeneric(discriminant, retArr);\r\n              retArr.push(';\\n');\r\n              break;\r\n          }\r\n          if (cases.length === 1 && !cases[0].test) {\r\n            this.astGeneric(cases[0].consequent, retArr);\r\n            return retArr;\r\n          }\r\n      \r\n          let fallingThrough = false;\r\n          let defaultResult = [];\r\n          let movingDefaultToEnd = false;\r\n          let pastFirstIf = false;\r\n          for (let i = 0; i < cases.length; i++) {\r\n            if (!cases[i].test) {\r\n              if (cases.length > i + 1) {\r\n                movingDefaultToEnd = true;\r\n                this.astGeneric(cases[i].consequent, defaultResult);\r\n                continue;\r\n              } else {\r\n                retArr.push(' else {\\n');\r\n              }\r\n            } else {\r\n              if (i === 0 || !pastFirstIf) {\r\n                pastFirstIf = true;\r\n                retArr.push(`if (${varName} == `);\r\n              } else {\r\n                if (fallingThrough) {\r\n                  retArr.push(`${varName} == `);\r\n                  fallingThrough = false;\r\n                } else {\r\n                  retArr.push(` else if (${varName} == `);\r\n                }\r\n              }\r\n              if (type === 'Integer') {\r\n                const testType = this.getType(cases[i].test);\r\n                switch (testType) {\r\n                  case 'Number':\r\n                  case 'Float':\r\n                    this.castValueToInteger(cases[i].test, retArr);\r\n                    break;\r\n                  case 'LiteralInteger':\r\n                    this.castLiteralToInteger(cases[i].test, retArr);\r\n                    break;\r\n                }\r\n              } else if (type === 'Float') {\r\n                const testType = this.getType(cases[i].test);\r\n                switch (testType) {\r\n                  case 'LiteralInteger':\r\n                    this.castLiteralToFloat(cases[i].test, retArr);\r\n                    break;\r\n                  case 'Integer':\r\n                    this.castValueToFloat(cases[i].test, retArr);\r\n                    break;\r\n                }\r\n              } else {\r\n                throw new Error('unhanlded');\r\n              }\r\n              if (!cases[i].consequent || cases[i].consequent.length === 0) {\r\n                fallingThrough = true;\r\n                retArr.push(' || ');\r\n                continue;\r\n              }\r\n              retArr.push(`) {\\n`);\r\n            }\r\n            this.astGeneric(cases[i].consequent, retArr);\r\n            retArr.push('\\n}');\r\n          }\r\n          if (movingDefaultToEnd) {\r\n            retArr.push(' else {');\r\n            retArr.push(defaultResult.join(''));\r\n            retArr.push('}');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astThisExpression(tNode, retArr) {\r\n          retArr.push('this');\r\n          return retArr;\r\n        }\r\n      \r\n        astMemberExpression(mNode, retArr) {\r\n          const {\r\n            property,\r\n            name,\r\n            signature,\r\n            origin,\r\n            type,\r\n            xProperty,\r\n            yProperty,\r\n            zProperty\r\n          } = this.getMemberExpressionDetails(mNode);\r\n          switch (signature) {\r\n            case 'value.thread.value':\r\n            case 'this.thread.value':\r\n              if (name !== 'x' && name !== 'y' && name !== 'z') {\r\n                throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);\r\n              }\r\n              retArr.push(`threadId.${name}`);\r\n              return retArr;\r\n            case 'this.output.value':\r\n              if (this.dynamicOutput) {\r\n                switch (name) {\r\n                  case 'x':\r\n                    if (this.isState('casting-to-float')) {\r\n                      retArr.push('float(uOutputDim.x)');\r\n                    } else {\r\n                      retArr.push('uOutputDim.x');\r\n                    }\r\n                    break;\r\n                  case 'y':\r\n                    if (this.isState('casting-to-float')) {\r\n                      retArr.push('float(uOutputDim.y)');\r\n                    } else {\r\n                      retArr.push('uOutputDim.y');\r\n                    }\r\n                    break;\r\n                  case 'z':\r\n                    if (this.isState('casting-to-float')) {\r\n                      retArr.push('float(uOutputDim.z)');\r\n                    } else {\r\n                      retArr.push('uOutputDim.z');\r\n                    }\r\n                    break;\r\n                  default:\r\n                    throw this.astErrorOutput('Unexpected expression', mNode);\r\n                }\r\n              } else {\r\n                switch (name) {\r\n                  case 'x':\r\n                    if (this.isState('casting-to-integer')) {\r\n                      retArr.push(this.output[0]);\r\n                    } else {\r\n                      retArr.push(this.output[0], '.0');\r\n                    }\r\n                    break;\r\n                  case 'y':\r\n                    if (this.isState('casting-to-integer')) {\r\n                      retArr.push(this.output[1]);\r\n                    } else {\r\n                      retArr.push(this.output[1], '.0');\r\n                    }\r\n                    break;\r\n                  case 'z':\r\n                    if (this.isState('casting-to-integer')) {\r\n                      retArr.push(this.output[2]);\r\n                    } else {\r\n                      retArr.push(this.output[2], '.0');\r\n                    }\r\n                    break;\r\n                  default:\r\n                    throw this.astErrorOutput('Unexpected expression', mNode);\r\n                }\r\n              }\r\n              return retArr;\r\n            case 'value':\r\n              throw this.astErrorOutput('Unexpected expression', mNode);\r\n            case 'value[]':\r\n            case 'value[][]':\r\n            case 'value[][][]':\r\n            case 'value[][][][]':\r\n            case 'value.value':\r\n              if (origin === 'Math') {\r\n                retArr.push(Math[name]);\r\n                return retArr;\r\n              }\r\n              const cleanName = utils.sanitizeName(name);\r\n              switch (property) {\r\n                case 'r':\r\n                  retArr.push(`user_${ cleanName }.r`);\r\n                  return retArr;\r\n                case 'g':\r\n                  retArr.push(`user_${ cleanName }.g`);\r\n                  return retArr;\r\n                case 'b':\r\n                  retArr.push(`user_${ cleanName }.b`);\r\n                  return retArr;\r\n                case 'a':\r\n                  retArr.push(`user_${ cleanName }.a`);\r\n                  return retArr;\r\n              }\r\n              break;\r\n            case 'this.constants.value':\r\n              if (typeof xProperty === 'undefined') {\r\n                switch (type) {\r\n                  case 'Array(2)':\r\n                  case 'Array(3)':\r\n                  case 'Array(4)':\r\n                    retArr.push(`constants_${ utils.sanitizeName(name) }`);\r\n                    return retArr;\r\n                }\r\n              }\r\n              case 'this.constants.value[]':\r\n              case 'this.constants.value[][]':\r\n              case 'this.constants.value[][][]':\r\n              case 'this.constants.value[][][][]':\r\n                break;\r\n              case 'fn()[]':\r\n                this.astCallExpression(mNode.object, retArr);\r\n                retArr.push('[');\r\n                retArr.push(this.memberExpressionPropertyMarkup(property));\r\n                retArr.push(']');\r\n                return retArr;\r\n              case 'fn()[][]':\r\n                this.astCallExpression(mNode.object.object, retArr);\r\n                retArr.push('[');\r\n                retArr.push(this.memberExpressionPropertyMarkup(mNode.object.property));\r\n                retArr.push(']');\r\n                retArr.push('[');\r\n                retArr.push(this.memberExpressionPropertyMarkup(mNode.property));\r\n                retArr.push(']');\r\n                return retArr;\r\n              case '[][]':\r\n                this.astArrayExpression(mNode.object, retArr);\r\n                retArr.push('[');\r\n                retArr.push(this.memberExpressionPropertyMarkup(property));\r\n                retArr.push(']');\r\n                return retArr;\r\n              default:\r\n                throw this.astErrorOutput('Unexpected expression', mNode);\r\n          }\r\n      \r\n          if (mNode.computed === false) {\r\n            switch (type) {\r\n              case 'Number':\r\n              case 'Integer':\r\n              case 'Float':\r\n              case 'Boolean':\r\n                retArr.push(`${origin}_${utils.sanitizeName(name)}`);\r\n                return retArr;\r\n            }\r\n          }\r\n      \r\n          const markupName = `${origin}_${utils.sanitizeName(name)}`;\r\n      \r\n          switch (type) {\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n              this.astGeneric(mNode.object, retArr);\r\n              retArr.push('[');\r\n              retArr.push(this.memberExpressionPropertyMarkup(xProperty));\r\n              retArr.push(']');\r\n              break;\r\n            case 'HTMLImageArray':\r\n              retArr.push(`getImage3D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'ArrayTexture(1)':\r\n              retArr.push(`getFloatFromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'Array1D(2)':\r\n            case 'Array2D(2)':\r\n            case 'Array3D(2)':\r\n              retArr.push(`getMemoryOptimizedVec2(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'ArrayTexture(2)':\r\n              retArr.push(`getVec2FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'Array1D(3)':\r\n            case 'Array2D(3)':\r\n            case 'Array3D(3)':\r\n              retArr.push(`getMemoryOptimizedVec3(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'ArrayTexture(3)':\r\n              retArr.push(`getVec3FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'Array1D(4)':\r\n            case 'Array2D(4)':\r\n            case 'Array3D(4)':\r\n              retArr.push(`getMemoryOptimizedVec4(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'ArrayTexture(4)':\r\n            case 'HTMLCanvas':\r\n            case 'HTMLImage':\r\n            case 'HTMLVideo':\r\n              retArr.push(`getVec4FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'NumberTexture':\r\n            case 'Array':\r\n            case 'Array2D':\r\n            case 'Array3D':\r\n            case 'Array4D':\r\n            case 'Input':\r\n            case 'Number':\r\n            case 'Float':\r\n            case 'Integer':\r\n              if (this.precision === 'single') {\r\n                retArr.push(`getMemoryOptimized32(${markupName}, ${markupName}Size, ${markupName}Dim, `);\r\n                this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n                retArr.push(')');\r\n              } else {\r\n                const bitRatio = (origin === 'user' ?\r\n                  this.lookupFunctionArgumentBitRatio(this.name, name) :\r\n                  this.constantBitRatios[name]\r\n                );\r\n                switch (bitRatio) {\r\n                  case 1:\r\n                    retArr.push(`get8(${markupName}, ${markupName}Size, ${markupName}Dim, `);\r\n                    break;\r\n                  case 2:\r\n                    retArr.push(`get16(${markupName}, ${markupName}Size, ${markupName}Dim, `);\r\n                    break;\r\n                  case 4:\r\n                  case 0:\r\n                    retArr.push(`get32(${markupName}, ${markupName}Size, ${markupName}Dim, `);\r\n                    break;\r\n                  default:\r\n                    throw new Error(`unhandled bit ratio of ${bitRatio}`);\r\n                }\r\n                this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n                retArr.push(')');\r\n              }\r\n              break;\r\n            case 'MemoryOptimizedNumberTexture':\r\n              retArr.push(`getMemoryOptimized32(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n              retArr.push(`${markupName}[${this.memberExpressionPropertyMarkup(yProperty)}]`);\r\n              if (yProperty) {\r\n                retArr.push(`[${this.memberExpressionPropertyMarkup(xProperty)}]`);\r\n              }\r\n              break;\r\n            default:\r\n              throw new Error(`unhandled member expression \"${ type }\"`);\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astCallExpression(ast, retArr) {\r\n          if (!ast.callee) {\r\n            throw this.astErrorOutput('Unknown CallExpression', ast);\r\n          }\r\n      \r\n          let functionName = null;\r\n          const isMathFunction = this.isAstMathFunction(ast);\r\n      \r\n          if (isMathFunction || (ast.callee.object && ast.callee.object.type === 'ThisExpression')) {\r\n            functionName = ast.callee.property.name;\r\n          }\r\n          else if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[0].type === 'Literal' && !isNaN(ast.callee.expressions[0].raw)) {\r\n            functionName = ast.callee.expressions[1].property.name;\r\n          } else {\r\n            functionName = ast.callee.name;\r\n          }\r\n      \r\n          if (!functionName) {\r\n            throw this.astErrorOutput(`Unhandled function, couldn't find name`, ast);\r\n          }\r\n      \r\n          switch (functionName) {\r\n            case 'pow':\r\n              functionName = '_pow';\r\n              break;\r\n            case 'round':\r\n              functionName = '_round';\r\n              break;\r\n          }\r\n      \r\n          if (this.calledFunctions.indexOf(functionName) < 0) {\r\n            this.calledFunctions.push(functionName);\r\n          }\r\n      \r\n          if (functionName === 'random' && this.plugins && this.plugins.length > 0) {\r\n            for (let i = 0; i < this.plugins.length; i++) {\r\n              const plugin = this.plugins[i];\r\n              if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {\r\n                retArr.push(plugin.functionReplace);\r\n                return retArr;\r\n              }\r\n            }\r\n          }\r\n      \r\n          if (this.onFunctionCall) {\r\n            this.onFunctionCall(this.name, functionName, ast.arguments);\r\n          }\r\n      \r\n          retArr.push(functionName);\r\n      \r\n          retArr.push('(');\r\n      \r\n          if (isMathFunction) {\r\n            for (let i = 0; i < ast.arguments.length; ++i) {\r\n              const argument = ast.arguments[i];\r\n              const argumentType = this.getType(argument);\r\n              if (i > 0) {\r\n                retArr.push(', ');\r\n              }\r\n      \r\n              switch (argumentType) {\r\n                case 'Integer':\r\n                  this.castValueToFloat(argument, retArr);\r\n                  break;\r\n                default:\r\n                  this.astGeneric(argument, retArr);\r\n                  break;\r\n              }\r\n            }\r\n          } else {\r\n            const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];\r\n            for (let i = 0; i < ast.arguments.length; ++i) {\r\n              const argument = ast.arguments[i];\r\n              let targetType = targetTypes[i];\r\n              if (i > 0) {\r\n                retArr.push(', ');\r\n              }\r\n              const argumentType = this.getType(argument);\r\n              if (!targetType) {\r\n                this.triggerImplyArgumentType(functionName, i, argumentType, this);\r\n                targetType = argumentType;\r\n              }\r\n              switch (argumentType) {\r\n                case 'Boolean':\r\n                  this.astGeneric(argument, retArr);\r\n                  continue;\r\n                case 'Number':\r\n                case 'Float':\r\n                  if (targetType === 'Integer') {\r\n                    retArr.push('int(');\r\n                    this.astGeneric(argument, retArr);\r\n                    retArr.push(')');\r\n                    continue;\r\n                  } else if (targetType === 'Number' || targetType === 'Float') {\r\n                    this.astGeneric(argument, retArr);\r\n                    continue;\r\n                  } else if (targetType === 'LiteralInteger') {\r\n                    this.castLiteralToFloat(argument, retArr);\r\n                    continue;\r\n                  }\r\n                  break;\r\n                case 'Integer':\r\n                  if (targetType === 'Number' || targetType === 'Float') {\r\n                    retArr.push('float(');\r\n                    this.astGeneric(argument, retArr);\r\n                    retArr.push(')');\r\n                    continue;\r\n                  } else if (targetType === 'Integer') {\r\n                    this.astGeneric(argument, retArr);\r\n                    continue;\r\n                  }\r\n                  break;\r\n                case 'LiteralInteger':\r\n                  if (targetType === 'Integer') {\r\n                    this.castLiteralToInteger(argument, retArr);\r\n                    continue;\r\n                  } else if (targetType === 'Number' || targetType === 'Float') {\r\n                    this.castLiteralToFloat(argument, retArr);\r\n                    continue;\r\n                  } else if (targetType === 'LiteralInteger') {\r\n                    this.astGeneric(argument, retArr);\r\n                    continue;\r\n                  }\r\n                  break;\r\n                case 'Array(2)':\r\n                case 'Array(3)':\r\n                case 'Array(4)':\r\n                  if (targetType === argumentType) {\r\n                    if (argument.type === 'Identifier') {\r\n                      retArr.push(`user_${utils.sanitizeName(argument.name)}`);\r\n                    } else if (argument.type === 'ArrayExpression' || argument.type === 'MemberExpression' || argument.type === 'CallExpression') {\r\n                      this.astGeneric(argument, retArr);\r\n                    } else {\r\n                      throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);\r\n                    }\r\n                    continue;\r\n                  }\r\n                  break;\r\n                case 'HTMLCanvas':\r\n                case 'HTMLImage':\r\n                case 'HTMLImageArray':\r\n                case 'HTMLVideo':\r\n                case 'ArrayTexture(1)':\r\n                case 'ArrayTexture(2)':\r\n                case 'ArrayTexture(3)':\r\n                case 'ArrayTexture(4)':\r\n                case 'Array':\r\n                case 'Input':\r\n                  if (targetType === argumentType) {\r\n                    if (argument.type !== 'Identifier') throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);\r\n                    this.triggerImplyArgumentBitRatio(this.name, argument.name, functionName, i);\r\n                    const name = utils.sanitizeName(argument.name);\r\n                    retArr.push(`user_${name},user_${name}Size,user_${name}Dim`);\r\n                    continue;\r\n                  }\r\n                  break;\r\n              }\r\n              throw this.astErrorOutput(`Unhandled argument combination of ${ argumentType } and ${ targetType } for argument named \"${ argument.name }\"`, ast);\r\n            }\r\n          }\r\n          retArr.push(')');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astArrayExpression(arrNode, retArr) {\r\n          const returnType = this.getType(arrNode);\r\n      \r\n          const arrLen = arrNode.elements.length;\r\n      \r\n          switch (returnType) {\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n              retArr.push(`mat${arrLen}(`);\r\n              break;\r\n            default:\r\n              retArr.push(`vec${arrLen}(`);\r\n          }\r\n          for (let i = 0; i < arrLen; ++i) {\r\n            if (i > 0) {\r\n              retArr.push(', ');\r\n            }\r\n            const subNode = arrNode.elements[i];\r\n            this.astGeneric(subNode, retArr)\r\n          }\r\n          retArr.push(')');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        memberExpressionXYZ(x, y, z, retArr) {\r\n          if (z) {\r\n            retArr.push(this.memberExpressionPropertyMarkup(z), ', ');\r\n          } else {\r\n            retArr.push('0, ');\r\n          }\r\n          if (y) {\r\n            retArr.push(this.memberExpressionPropertyMarkup(y), ', ');\r\n          } else {\r\n            retArr.push('0, ');\r\n          }\r\n          retArr.push(this.memberExpressionPropertyMarkup(x));\r\n          return retArr;\r\n        }\r\n      \r\n        memberExpressionPropertyMarkup(property) {\r\n          if (!property) {\r\n            throw new Error('Property not set');\r\n          }\r\n          const type = this.getType(property);\r\n          const result = [];\r\n          switch (type) {\r\n            case 'Number':\r\n            case 'Float':\r\n              this.castValueToInteger(property, result);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToInteger(property, result);\r\n              break;\r\n            default:\r\n              this.astGeneric(property, result);\r\n          }\r\n          return result.join('');\r\n        }\r\n      }\r\n      \r\n      const typeMap = {\r\n        'Array': 'sampler2D',\r\n        'Array(2)': 'vec2',\r\n        'Array(3)': 'vec3',\r\n        'Array(4)': 'vec4',\r\n        'Matrix(2)': 'mat2',\r\n        'Matrix(3)': 'mat3',\r\n        'Matrix(4)': 'mat4',\r\n        'Array2D': 'sampler2D',\r\n        'Array3D': 'sampler2D',\r\n        'Boolean': 'bool',\r\n        'Float': 'float',\r\n        'Input': 'sampler2D',\r\n        'Integer': 'int',\r\n        'Number': 'float',\r\n        'LiteralInteger': 'float',\r\n        'NumberTexture': 'sampler2D',\r\n        'MemoryOptimizedNumberTexture': 'sampler2D',\r\n        'ArrayTexture(1)': 'sampler2D',\r\n        'ArrayTexture(2)': 'sampler2D',\r\n        'ArrayTexture(3)': 'sampler2D',\r\n        'ArrayTexture(4)': 'sampler2D',\r\n        'HTMLVideo': 'sampler2D',\r\n        'HTMLCanvas': 'sampler2D',\r\n        'HTMLImage': 'sampler2D',\r\n        'HTMLImageArray': 'sampler2DArray',\r\n      };\r\n      \r\n      const operatorMap = {\r\n        '===': '==',\r\n        '!==': '!='\r\n      };\r\n      \r\n      module.exports = {\r\n        WebGLFunctionNode\r\n      };\r\n      },{\"../../utils\":114,\"../function-node\":10}],39:[function(require,module,exports){\r\n      const { WebGLKernelValueBoolean } = require('./kernel-value/boolean');\r\n      const { WebGLKernelValueFloat } = require('./kernel-value/float');\r\n      const { WebGLKernelValueInteger } = require('./kernel-value/integer');\r\n      \r\n      const { WebGLKernelValueHTMLImage } = require('./kernel-value/html-image');\r\n      const { WebGLKernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');\r\n      \r\n      const { WebGLKernelValueHTMLVideo } = require('./kernel-value/html-video');\r\n      const { WebGLKernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');\r\n      \r\n      const { WebGLKernelValueSingleInput } = require('./kernel-value/single-input');\r\n      const { WebGLKernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');\r\n      \r\n      const { WebGLKernelValueUnsignedInput } = require('./kernel-value/unsigned-input');\r\n      const { WebGLKernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');\r\n      \r\n      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');\r\n      const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');\r\n      \r\n      const { WebGLKernelValueNumberTexture } = require('./kernel-value/number-texture');\r\n      const { WebGLKernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');\r\n      \r\n      const { WebGLKernelValueSingleArray } = require('./kernel-value/single-array');\r\n      const { WebGLKernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');\r\n      \r\n      const { WebGLKernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');\r\n      const { WebGLKernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');\r\n      \r\n      const { WebGLKernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');\r\n      const { WebGLKernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');\r\n      \r\n      const { WebGLKernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');\r\n      const { WebGLKernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');\r\n      \r\n      const { WebGLKernelValueSingleArray2 } = require('./kernel-value/single-array2');\r\n      const { WebGLKernelValueSingleArray3 } = require('./kernel-value/single-array3');\r\n      const { WebGLKernelValueSingleArray4 } = require('./kernel-value/single-array4');\r\n      \r\n      const { WebGLKernelValueUnsignedArray } = require('./kernel-value/unsigned-array');\r\n      const { WebGLKernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');\r\n      \r\n      const kernelValueMaps = {\r\n        unsigned: {\r\n          dynamic: {\r\n            'Boolean': WebGLKernelValueBoolean,\r\n            'Integer': WebGLKernelValueInteger,\r\n            'Float': WebGLKernelValueFloat,\r\n            'Array': WebGLKernelValueDynamicUnsignedArray,\r\n            'Array(2)': false,\r\n            'Array(3)': false,\r\n            'Array(4)': false,\r\n            'Array1D(2)': false,\r\n            'Array1D(3)': false,\r\n            'Array1D(4)': false,\r\n            'Array2D(2)': false,\r\n            'Array2D(3)': false,\r\n            'Array2D(4)': false,\r\n            'Array3D(2)': false,\r\n            'Array3D(3)': false,\r\n            'Array3D(4)': false,\r\n            'Input': WebGLKernelValueDynamicUnsignedInput,\r\n            'NumberTexture': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,\r\n            'HTMLImage': WebGLKernelValueDynamicHTMLImage,\r\n            'HTMLImageArray': false,\r\n            'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,\r\n          },\r\n          static: {\r\n            'Boolean': WebGLKernelValueBoolean,\r\n            'Float': WebGLKernelValueFloat,\r\n            'Integer': WebGLKernelValueInteger,\r\n            'Array': WebGLKernelValueUnsignedArray,\r\n            'Array(2)': false,\r\n            'Array(3)': false,\r\n            'Array(4)': false,\r\n            'Array1D(2)': false,\r\n            'Array1D(3)': false,\r\n            'Array1D(4)': false,\r\n            'Array2D(2)': false,\r\n            'Array2D(3)': false,\r\n            'Array2D(4)': false,\r\n            'Array3D(2)': false,\r\n            'Array3D(3)': false,\r\n            'Array3D(4)': false,\r\n            'Input': WebGLKernelValueUnsignedInput,\r\n            'NumberTexture': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(1)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(2)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(3)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(4)': WebGLKernelValueNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGLKernelValueHTMLImage,\r\n            'HTMLImage': WebGLKernelValueHTMLImage,\r\n            'HTMLImageArray': false,\r\n            'HTMLVideo': WebGLKernelValueHTMLVideo,\r\n          }\r\n        },\r\n        single: {\r\n          dynamic: {\r\n            'Boolean': WebGLKernelValueBoolean,\r\n            'Integer': WebGLKernelValueInteger,\r\n            'Float': WebGLKernelValueFloat,\r\n            'Array': WebGLKernelValueDynamicSingleArray,\r\n            'Array(2)': WebGLKernelValueSingleArray2,\r\n            'Array(3)': WebGLKernelValueSingleArray3,\r\n            'Array(4)': WebGLKernelValueSingleArray4,\r\n            'Array1D(2)': WebGLKernelValueDynamicSingleArray1DI,\r\n            'Array1D(3)': WebGLKernelValueDynamicSingleArray1DI,\r\n            'Array1D(4)': WebGLKernelValueDynamicSingleArray1DI,\r\n            'Array2D(2)': WebGLKernelValueDynamicSingleArray2DI,\r\n            'Array2D(3)': WebGLKernelValueDynamicSingleArray2DI,\r\n            'Array2D(4)': WebGLKernelValueDynamicSingleArray2DI,\r\n            'Array3D(2)': WebGLKernelValueDynamicSingleArray3DI,\r\n            'Array3D(3)': WebGLKernelValueDynamicSingleArray3DI,\r\n            'Array3D(4)': WebGLKernelValueDynamicSingleArray3DI,\r\n            'Input': WebGLKernelValueDynamicSingleInput,\r\n            'NumberTexture': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,\r\n            'HTMLImage': WebGLKernelValueDynamicHTMLImage,\r\n            'HTMLImageArray': false,\r\n            'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,\r\n          },\r\n          static: {\r\n            'Boolean': WebGLKernelValueBoolean,\r\n            'Float': WebGLKernelValueFloat,\r\n            'Integer': WebGLKernelValueInteger,\r\n            'Array': WebGLKernelValueSingleArray,\r\n            'Array(2)': WebGLKernelValueSingleArray2,\r\n            'Array(3)': WebGLKernelValueSingleArray3,\r\n            'Array(4)': WebGLKernelValueSingleArray4,\r\n            'Array1D(2)': WebGLKernelValueSingleArray1DI,\r\n            'Array1D(3)': WebGLKernelValueSingleArray1DI,\r\n            'Array1D(4)': WebGLKernelValueSingleArray1DI,\r\n            'Array2D(2)': WebGLKernelValueSingleArray2DI,\r\n            'Array2D(3)': WebGLKernelValueSingleArray2DI,\r\n            'Array2D(4)': WebGLKernelValueSingleArray2DI,\r\n            'Array3D(2)': WebGLKernelValueSingleArray3DI,\r\n            'Array3D(3)': WebGLKernelValueSingleArray3DI,\r\n            'Array3D(4)': WebGLKernelValueSingleArray3DI,\r\n            'Input': WebGLKernelValueSingleInput,\r\n            'NumberTexture': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(1)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(2)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(3)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(4)': WebGLKernelValueNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGLKernelValueHTMLImage,\r\n            'HTMLImage': WebGLKernelValueHTMLImage,\r\n            'HTMLImageArray': false,\r\n            'HTMLVideo': WebGLKernelValueHTMLVideo,\r\n          }\r\n        },\r\n      };\r\n      \r\n      function lookupKernelValueType(type, dynamic, precision, value) {\r\n        if (!type) {\r\n          throw new Error('type missing');\r\n        }\r\n        if (!dynamic) {\r\n          throw new Error('dynamic missing');\r\n        }\r\n        if (!precision) {\r\n          throw new Error('precision missing');\r\n        }\r\n        if (value.type) {\r\n          type = value.type;\r\n        }\r\n        const types = kernelValueMaps[precision][dynamic];\r\n        if (types[type] === false) {\r\n          return null;\r\n        } else if (types[type] === undefined) {\r\n          throw new Error(`Could not find a KernelValue for ${ type }`);\r\n        }\r\n        return types[type];\r\n      }\r\n      \r\n      module.exports = {\r\n        lookupKernelValueType,\r\n        kernelValueMaps,\r\n      };\r\n      },{\"./kernel-value/boolean\":41,\"./kernel-value/dynamic-html-image\":42,\"./kernel-value/dynamic-html-video\":43,\"./kernel-value/dynamic-memory-optimized-number-texture\":44,\"./kernel-value/dynamic-number-texture\":45,\"./kernel-value/dynamic-single-array\":46,\"./kernel-value/dynamic-single-array1d-i\":47,\"./kernel-value/dynamic-single-array2d-i\":48,\"./kernel-value/dynamic-single-array3d-i\":49,\"./kernel-value/dynamic-single-input\":50,\"./kernel-value/dynamic-unsigned-array\":51,\"./kernel-value/dynamic-unsigned-input\":52,\"./kernel-value/float\":53,\"./kernel-value/html-image\":54,\"./kernel-value/html-video\":55,\"./kernel-value/integer\":57,\"./kernel-value/memory-optimized-number-texture\":58,\"./kernel-value/number-texture\":59,\"./kernel-value/single-array\":60,\"./kernel-value/single-array1d-i\":61,\"./kernel-value/single-array2\":62,\"./kernel-value/single-array2d-i\":63,\"./kernel-value/single-array3\":64,\"./kernel-value/single-array3d-i\":65,\"./kernel-value/single-array4\":66,\"./kernel-value/single-input\":67,\"./kernel-value/unsigned-array\":68,\"./kernel-value/unsigned-input\":69}],40:[function(require,module,exports){\r\n      const { WebGLKernelValue } = require('./index');\r\n      const { Input } = require('../../../input');\r\n      \r\n      class WebGLKernelArray extends WebGLKernelValue {\r\n        checkSize(width, height) {\r\n          if (!this.kernel.validate) return;\r\n          const { maxTextureSize } = this.kernel.constructor.features;\r\n          if (width > maxTextureSize || height > maxTextureSize) {\r\n            if (width > height) {\r\n              throw new Error(`Argument texture width of ${width} larger than maximum size of ${maxTextureSize} for your GPU`);\r\n            } else if (width < height) {\r\n              throw new Error(`Argument texture height of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);\r\n            } else {\r\n              throw new Error(`Argument texture height and width of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);\r\n            }\r\n          }\r\n        }\r\n      \r\n        setup() {\r\n          this.requestTexture();\r\n          this.setupTexture();\r\n          this.defineTexture();\r\n        }\r\n      \r\n        requestTexture() {\r\n          this.texture = this.onRequestTexture();\r\n        }\r\n      \r\n        defineTexture() {\r\n          const { context: gl } = this;\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        }\r\n      \r\n        setupTexture() {\r\n          this.contextHandle = this.onRequestContextHandle();\r\n          this.index = this.onRequestIndex();\r\n          this.dimensionsId = this.id + 'Dim';\r\n          this.sizeId = this.id + 'Size';\r\n        }\r\n      \r\n        getBitRatio(value) {\r\n          if (Array.isArray(value[0])) {\r\n            return this.getBitRatio(value[0]);\r\n          } else if (value.constructor === Input) {\r\n            return this.getBitRatio(value.value);\r\n          }\r\n          switch (value.constructor) {\r\n            case Uint8ClampedArray:\r\n            case Uint8Array:\r\n            case Int8Array:\r\n              return 1;\r\n            case Uint16Array:\r\n            case Int16Array:\r\n              return 2;\r\n            case Float32Array:\r\n            case Int32Array:\r\n            default:\r\n              return 4;\r\n          }\r\n        }\r\n      \r\n        destroy() {\r\n          if (this.prevArg) {\r\n            this.prevArg.delete();\r\n          }\r\n          this.context.deleteTexture(this.texture);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelArray\r\n      };\r\n      },{\"../../../input\":110,\"./index\":56}],41:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueBoolean extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            return `const bool ${this.id} = ${value};\\n`;\r\n          }\r\n          return `uniform bool ${this.id};\\n`;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform1i(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueBoolean\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],42:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueHTMLImage } = require('./html-image');\r\n      \r\n      class WebGLKernelValueDynamicHTMLImage extends WebGLKernelValueHTMLImage {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          const { width, height } = value;\r\n          this.checkSize(width, height);\r\n          this.dimensions = [width, height, 1];\r\n          this.textureSize = [width, height];\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicHTMLImage\r\n      };\r\n      },{\"../../../utils\":114,\"./html-image\":54}],43:[function(require,module,exports){\r\n      const { WebGLKernelValueDynamicHTMLImage } = require('./dynamic-html-image');\r\n      \r\n      class WebGLKernelValueDynamicHTMLVideo extends WebGLKernelValueDynamicHTMLImage {}\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicHTMLVideo\r\n      };\r\n      },{\"./dynamic-html-image\":42}],44:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./memory-optimized-number-texture');\r\n      \r\n      class WebGLKernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(inputTexture) {\r\n          this.dimensions = inputTexture.dimensions;\r\n          this.checkSize(inputTexture.size[0], inputTexture.size[1]);\r\n          this.textureSize = inputTexture.size;\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(inputTexture);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicMemoryOptimizedNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"./memory-optimized-number-texture\":58}],45:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueNumberTexture } = require('./number-texture');\r\n      \r\n      class WebGLKernelValueDynamicNumberTexture extends WebGLKernelValueNumberTexture {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.dimensions = value.dimensions;\r\n          this.checkSize(value.size[0], value.size[1]);\r\n          this.textureSize = value.size;\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"./number-texture\":59}],46:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray } = require('./single-array');\r\n      \r\n      class WebGLKernelValueDynamicSingleArray extends WebGLKernelValueSingleArray {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.dimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicSingleArray\r\n      };\r\n      },{\"../../../utils\":114,\"./single-array\":60}],47:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray1DI } = require('./single-array1d-i');\r\n      \r\n      class WebGLKernelValueDynamicSingleArray1DI extends WebGLKernelValueSingleArray1DI {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicSingleArray1DI\r\n      };\r\n      },{\"../../../utils\":114,\"./single-array1d-i\":61}],48:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray2DI } = require('./single-array2d-i');\r\n      \r\n      class WebGLKernelValueDynamicSingleArray2DI extends WebGLKernelValueSingleArray2DI {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicSingleArray2DI\r\n      };\r\n      },{\"../../../utils\":114,\"./single-array2d-i\":63}],49:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray3DI } = require('./single-array3d-i');\r\n      \r\n      class WebGLKernelValueDynamicSingleArray3DI extends WebGLKernelValueSingleArray3DI {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicSingleArray3DI\r\n      };\r\n      },{\"../../../utils\":114,\"./single-array3d-i\":65}],50:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleInput } = require('./single-input');\r\n      \r\n      class WebGLKernelValueDynamicSingleInput extends WebGLKernelValueSingleInput {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          let [w, h, d] = value.size;\r\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicSingleInput\r\n      };\r\n      },{\"../../../utils\":114,\"./single-input\":67}],51:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueUnsignedArray } = require('./unsigned-array');\r\n      \r\n      class WebGLKernelValueDynamicUnsignedArray extends WebGLKernelValueUnsignedArray {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.dimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          const Type = this.getTransferArrayType(value);\r\n          this.preUploadValue = new Type(this.uploadArrayLength);\r\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicUnsignedArray\r\n      };\r\n      },{\"../../../utils\":114,\"./unsigned-array\":68}],52:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueUnsignedInput } = require('./unsigned-input');\r\n      \r\n      class WebGLKernelValueDynamicUnsignedInput extends WebGLKernelValueUnsignedInput {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          let [w, h, d] = value.size;\r\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\r\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          const Type = this.getTransferArrayType(value.value);\r\n          this.preUploadValue = new Type(this.uploadArrayLength);\r\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicUnsignedInput\r\n      };\r\n      },{\"../../../utils\":114,\"./unsigned-input\":69}],53:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueFloat extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            if (Number.isInteger(value)) {\r\n              return `const float ${this.id} = ${value}.0;\\n`;\r\n            }\r\n            return `const float ${this.id} = ${value};\\n`;\r\n          }\r\n          return `uniform float ${this.id};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform1f(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueFloat\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],54:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueHTMLImage extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          const { width, height } = value;\r\n          this.checkSize(width, height);\r\n          this.dimensions = [width, height, 1];\r\n          this.textureSize = [width, height];\r\n          this.uploadValue = value;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(inputImage) {\r\n          if (inputImage.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(inputImage.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = inputImage);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueHTMLImage\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],55:[function(require,module,exports){\r\n      const { WebGLKernelValueHTMLImage } = require('./html-image');\r\n      \r\n      class WebGLKernelValueHTMLVideo extends WebGLKernelValueHTMLImage {}\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueHTMLVideo\r\n      };\r\n      },{\"./html-image\":54}],56:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { KernelValue } = require('../../kernel-value');\r\n      \r\n      class WebGLKernelValue extends KernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.dimensionsId = null;\r\n          this.sizeId = null;\r\n          this.initialValueConstructor = value.constructor;\r\n          this.onRequestTexture = settings.onRequestTexture;\r\n          this.onRequestIndex = settings.onRequestIndex;\r\n          this.uploadValue = null;\r\n          this.textureSize = null;\r\n          this.bitRatio = null;\r\n          this.prevArg = null;\r\n        }\r\n      \r\n        get id() {\r\n          return `${this.origin}_${utils.sanitizeName(this.name)}`;\r\n        }\r\n      \r\n        setup() {}\r\n      \r\n        getTransferArrayType(value) {\r\n          if (Array.isArray(value[0])) {\r\n            return this.getTransferArrayType(value[0]);\r\n          }\r\n          switch (value.constructor) {\r\n            case Array:\r\n            case Int32Array:\r\n            case Int16Array:\r\n            case Int8Array:\r\n              return Float32Array;\r\n            case Uint8ClampedArray:\r\n            case Uint8Array:\r\n            case Uint16Array:\r\n            case Uint32Array:\r\n            case Float32Array:\r\n            case Float64Array:\r\n              return value.constructor;\r\n          }\r\n          console.warn('Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros');\r\n          return value.constructor;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          throw new Error(`\"getStringValueHandler\" not implemented on ${this.constructor.name}`);\r\n        }\r\n      \r\n        getVariablePrecisionString() {\r\n          return this.kernel.getVariablePrecisionString(this.textureSize || undefined, this.tactic || undefined);\r\n        }\r\n      \r\n        destroy() {}\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValue\r\n      };\r\n      },{\"../../../utils\":114,\"../../kernel-value\":35}],57:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueInteger extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            return `const int ${this.id} = ${ parseInt(value) };\\n`;\r\n          }\r\n          return `uniform int ${this.id};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform1i(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueInteger\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],58:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      const sameError = `Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()`;\r\n      \r\n      class WebGLKernelValueMemoryOptimizedNumberTexture extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          const [width, height] = value.size;\r\n          this.checkSize(width, height);\r\n          this.dimensions = value.dimensions;\r\n          this.textureSize = value.size;\r\n          this.uploadValue = value.texture;\r\n          this.forceUploadEachRun = true;\r\n        }\r\n      \r\n        setup() {\r\n          this.setupTexture();\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName}.texture;\\n`;\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(inputTexture) {\r\n          if (inputTexture.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(inputTexture.constructor);\r\n            return;\r\n          }\r\n          if (this.checkContext && inputTexture.context !== this.context) {\r\n            throw new Error(`Value ${this.name} (${this.type}) must be from same context`);\r\n          }\r\n      \r\n          const { kernel, context: gl } = this;\r\n          if (kernel.pipeline) {\r\n            if (kernel.immutable) {\r\n              kernel.updateTextureArgumentRefs(this, inputTexture);\r\n            } else {\r\n              if (kernel.texture.texture === inputTexture.texture) {\r\n                throw new Error(sameError);\r\n              } else if (kernel.mappedTextures) {\r\n                const { mappedTextures } = kernel;\r\n                for (let i = 0; i < mappedTextures.length; i++) {\r\n                  if (mappedTextures[i].texture === inputTexture.texture) {\r\n                    throw new Error(sameError);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n      \r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueMemoryOptimizedNumberTexture,\r\n        sameError\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],59:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      const { sameError } = require('./memory-optimized-number-texture');\r\n      \r\n      class WebGLKernelValueNumberTexture extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          const [width, height] = value.size;\r\n          this.checkSize(width, height);\r\n          const { size: textureSize, dimensions } = value;\r\n          this.bitRatio = this.getBitRatio(value);\r\n          this.dimensions = dimensions;\r\n          this.textureSize = textureSize;\r\n          this.uploadValue = value.texture;\r\n          this.forceUploadEachRun = true;\r\n        }\r\n      \r\n        setup() {\r\n          this.setupTexture();\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName}.texture;\\n`;\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(inputTexture) {\r\n          if (inputTexture.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(inputTexture.constructor);\r\n            return;\r\n          }\r\n          if (this.checkContext && inputTexture.context !== this.context) {\r\n            throw new Error(`Value ${this.name} (${this.type}) must be from same context`);\r\n          }\r\n      \r\n          const { kernel, context: gl } = this;\r\n          if (kernel.pipeline) {\r\n            if (kernel.immutable) {\r\n              kernel.updateTextureArgumentRefs(this, inputTexture);\r\n            } else {\r\n              if (kernel.texture.texture === inputTexture.texture) {\r\n                throw new Error(sameError);\r\n              } else if (kernel.mappedTextures) {\r\n                const { mappedTextures } = kernel;\r\n                for (let i = 0; i < mappedTextures.length; i++) {\r\n                  if (mappedTextures[i].texture === inputTexture.texture) {\r\n                    throw new Error(sameError);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n      \r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40,\"./memory-optimized-number-texture\":58}],60:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueSingleArray extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = 4;\r\n          this.dimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\r\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],61:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueSingleArray1DI extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = 4;\r\n          this.setShape(value);\r\n        }\r\n      \r\n        setShape(value) {\r\n          const valueDimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);\r\n          this.dimensions = new Int32Array([valueDimensions[1], 1, 1]);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\r\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flatten2dArrayTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray1DI\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],62:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueSingleArray2 extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            return `const vec2 ${this.id} = vec2(${value[0]},${value[1]});\\n`;\r\n          }\r\n          return `uniform vec2 ${this.id};\\n`;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          if (this.origin === 'constants') return '';\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform2fv(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray2\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],63:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueSingleArray2DI extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = 4;\r\n          this.setShape(value);\r\n        }\r\n      \r\n        setShape(value) {\r\n          const valueDimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);\r\n          this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], 1]);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\r\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flatten3dArrayTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray2DI\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],64:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueSingleArray3 extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            return `const vec3 ${this.id} = vec3(${value[0]},${value[1]},${value[2]});\\n`;\r\n          }\r\n          return `uniform vec3 ${this.id};\\n`;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          if (this.origin === 'constants') return '';\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform3fv(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray3\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],65:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueSingleArray3DI extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = 4;\r\n          this.setShape(value);\r\n        }\r\n      \r\n        setShape(value) {\r\n          const valueDimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);\r\n          this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], valueDimensions[3]]);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\r\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flatten4dArrayTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray3DI\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],66:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueSingleArray4 extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            return `const vec4 ${this.id} = vec4(${value[0]},${value[1]},${value[2]},${value[3]});\\n`;\r\n          }\r\n          return `uniform vec4 ${this.id};\\n`;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          if (this.origin === 'constants') return '';\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform4fv(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray4\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],67:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueSingleInput extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = 4;\r\n          let [w, h, d] = value.size;\r\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\r\n            `flattenTo(${this.varName}.value, uploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(input) {\r\n          if (input.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(input.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(input.value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleInput\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],68:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueUnsignedArray extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = this.getBitRatio(value);\r\n          this.dimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.TranserArrayType = this.getTransferArrayType(value);\r\n          this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);\r\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,\r\n            `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,\r\n            `flattenTo(${this.varName}, preUploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.preUploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueUnsignedArray\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],69:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueUnsignedInput extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = this.getBitRatio(value);\r\n          const [w, h, d] = value.size;\r\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\r\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.TranserArrayType = this.getTransferArrayType(value.value);\r\n          this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);\r\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,\r\n            `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,\r\n            `flattenTo(${this.varName}.value, preUploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(input) {\r\n          if (input.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(input.value, this.preUploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueUnsignedInput\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],70:[function(require,module,exports){\r\n      const { GLKernel } = require('../gl/kernel');\r\n      const { FunctionBuilder } = require('../function-builder');\r\n      const { WebGLFunctionNode } = require('./function-node');\r\n      const { utils } = require('../../utils');\r\n      const mrud = require('../../plugins/math-random-uniformly-distributed');\r\n      const { fragmentShader } = require('./fragment-shader');\r\n      const { vertexShader } = require('./vertex-shader');\r\n      const { glKernelString } = require('../gl/kernel-string');\r\n      const { lookupKernelValueType } = require('./kernel-value-maps');\r\n      \r\n      let isSupported = null;\r\n      let testCanvas = null;\r\n      let testContext = null;\r\n      let testExtensions = null;\r\n      let features = null;\r\n      \r\n      const plugins = [mrud];\r\n      const canvases = [];\r\n      const maxTexSizes = {};\r\n      \r\n      \r\n      class WebGLKernel extends GLKernel {\r\n        static get isSupported() {\r\n          if (isSupported !== null) {\r\n            return isSupported;\r\n          }\r\n          this.setupFeatureChecks();\r\n          isSupported = this.isContextMatch(testContext);\r\n          return isSupported;\r\n        }\r\n      \r\n        static setupFeatureChecks() {\r\n          if (typeof document !== 'undefined') {\r\n            testCanvas = document.createElement('canvas');\r\n          } else if (typeof OffscreenCanvas !== 'undefined') {\r\n            testCanvas = new OffscreenCanvas(0, 0);\r\n          }\r\n          if (!testCanvas) return;\r\n          testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');\r\n          if (!testContext || !testContext.getExtension) return;\r\n          testExtensions = {\r\n            OES_texture_float: testContext.getExtension('OES_texture_float'),\r\n            OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),\r\n            OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),\r\n            WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),\r\n          };\r\n          features = this.getFeatures();\r\n        }\r\n      \r\n        static isContextMatch(context) {\r\n          if (typeof WebGLRenderingContext !== 'undefined') {\r\n            return context instanceof WebGLRenderingContext;\r\n          }\r\n          return false;\r\n        }\r\n      \r\n        static getIsTextureFloat() {\r\n          return Boolean(testExtensions.OES_texture_float);\r\n        }\r\n      \r\n        static getIsDrawBuffers() {\r\n          return Boolean(testExtensions.WEBGL_draw_buffers);\r\n        }\r\n      \r\n        static getChannelCount() {\r\n          return testExtensions.WEBGL_draw_buffers ?\r\n            testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :\r\n            1;\r\n        }\r\n      \r\n        static getMaxTextureSize() {\r\n          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);\r\n        }\r\n      \r\n        static lookupKernelValueType(type, dynamic, precision, value) {\r\n          return lookupKernelValueType(type, dynamic, precision, value);\r\n        }\r\n      \r\n        static get testCanvas() {\r\n          return testCanvas;\r\n        }\r\n      \r\n        static get testContext() {\r\n          return testContext;\r\n        }\r\n      \r\n        static get features() {\r\n          return features;\r\n        }\r\n      \r\n        static get fragmentShader() {\r\n          return fragmentShader;\r\n        }\r\n      \r\n        static get vertexShader() {\r\n          return vertexShader;\r\n        }\r\n      \r\n        constructor(source, settings) {\r\n          super(source, settings);\r\n          this.program = null;\r\n          this.pipeline = settings.pipeline;\r\n          this.endianness = utils.systemEndianness();\r\n          this.extensions = {};\r\n          this.argumentTextureCount = 0;\r\n          this.constantTextureCount = 0;\r\n          this.fragShader = null;\r\n          this.vertShader = null;\r\n          this.drawBuffersMap = null;\r\n      \r\n          this.maxTexSize = null;\r\n          this.onRequestSwitchKernel = null;\r\n      \r\n          this.texture = null;\r\n          this.mappedTextures = null;\r\n          this.mergeSettings(source.settings || settings);\r\n      \r\n          this.threadDim = null;\r\n          this.framebuffer = null;\r\n          this.buffer = null;\r\n      \r\n          this.textureCache = [];\r\n          this.programUniformLocationCache = {};\r\n          this.uniform1fCache = {};\r\n          this.uniform1iCache = {};\r\n          this.uniform2fCache = {};\r\n          this.uniform2fvCache = {};\r\n          this.uniform2ivCache = {};\r\n          this.uniform3fvCache = {};\r\n          this.uniform3ivCache = {};\r\n          this.uniform4fvCache = {};\r\n          this.uniform4ivCache = {};\r\n        }\r\n      \r\n        initCanvas() {\r\n          if (typeof document !== 'undefined') {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = 2;\r\n            canvas.height = 2;\r\n            return canvas;\r\n          } else if (typeof OffscreenCanvas !== 'undefined') {\r\n            return new OffscreenCanvas(0, 0);\r\n          }\r\n        }\r\n      \r\n        initContext() {\r\n          const settings = {\r\n            alpha: false,\r\n            depth: false,\r\n            antialias: false\r\n          };\r\n          return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);\r\n        }\r\n      \r\n        initPlugins(settings) {\r\n          const pluginsToUse = [];\r\n          const { source } = this;\r\n          if (typeof source === 'string') {\r\n            for (let i = 0; i < plugins.length; i++) {\r\n              const plugin = plugins[i];\r\n              if (source.match(plugin.functionMatch)) {\r\n                pluginsToUse.push(plugin);\r\n              }\r\n            }\r\n          } else if (typeof source === 'object') {\r\n            if (settings.pluginNames) { \r\n              for (let i = 0; i < plugins.length; i++) {\r\n                const plugin = plugins[i];\r\n                const usePlugin = settings.pluginNames.some(pluginName => pluginName === plugin.name);\r\n                if (usePlugin) {\r\n                  pluginsToUse.push(plugin);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          return pluginsToUse;\r\n        }\r\n      \r\n        initExtensions() {\r\n          this.extensions = {\r\n            OES_texture_float: this.context.getExtension('OES_texture_float'),\r\n            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),\r\n            OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),\r\n            WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),\r\n            WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float'),\r\n          };\r\n        }\r\n      \r\n        validateSettings(args) {\r\n          if (!this.validate) {\r\n            this.texSize = utils.getKernelTextureSize({\r\n              optimizeFloatMemory: this.optimizeFloatMemory,\r\n              precision: this.precision,\r\n            }, this.output);\r\n            return;\r\n          }\r\n      \r\n          const { features } = this.constructor;\r\n      \r\n          if (this.optimizeFloatMemory === true && !features.isTextureFloat) {\r\n            throw new Error('Float textures are not supported');\r\n          } else if (this.precision === 'single' && !features.isFloatRead) {\r\n            throw new Error('Single precision not supported');\r\n          } else if (!this.graphical && this.precision === null && features.isTextureFloat) {\r\n            this.precision = features.isFloatRead ? 'single' : 'unsigned';\r\n          }\r\n      \r\n          if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {\r\n            throw new Error('could not instantiate draw buffers extension');\r\n          }\r\n      \r\n          if (this.fixIntegerDivisionAccuracy === null) {\r\n            this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;\r\n          } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {\r\n            this.fixIntegerDivisionAccuracy = false;\r\n          }\r\n      \r\n          this.checkOutput();\r\n      \r\n          if (!this.output || this.output.length === 0) {\r\n            if (args.length !== 1) {\r\n              throw new Error('Auto output only supported for kernels with only one input');\r\n            }\r\n      \r\n            const argType = utils.getVariableType(args[0], this.strictIntegers);\r\n            switch (argType) {\r\n              case 'Array':\r\n                this.output = utils.getDimensions(argType);\r\n                break;\r\n              case 'NumberTexture':\r\n              case 'MemoryOptimizedNumberTexture':\r\n              case 'ArrayTexture(1)':\r\n              case 'ArrayTexture(2)':\r\n              case 'ArrayTexture(3)':\r\n              case 'ArrayTexture(4)':\r\n                this.output = args[0].output;\r\n                break;\r\n              default:\r\n                throw new Error('Auto output not supported for input type: ' + argType);\r\n            }\r\n          }\r\n      \r\n          if (this.graphical) {\r\n            if (this.output.length !== 2) {\r\n              throw new Error('Output must have 2 dimensions on graphical mode');\r\n            }\r\n      \r\n            if (this.precision === 'precision') {\r\n              this.precision = 'unsigned';\r\n              console.warn('Cannot use graphical mode and single precision at the same time');\r\n            }\r\n      \r\n            this.texSize = utils.clone(this.output);\r\n            return;\r\n          } else if (this.precision === null && features.isTextureFloat) {\r\n            this.precision = 'single';\r\n          }\r\n      \r\n          this.texSize = utils.getKernelTextureSize({\r\n            optimizeFloatMemory: this.optimizeFloatMemory,\r\n            precision: this.precision,\r\n          }, this.output);\r\n      \r\n          this.checkTextureSize();\r\n        }\r\n      \r\n        updateMaxTexSize() {\r\n          const { texSize, canvas } = this;\r\n          if (this.maxTexSize === null) {\r\n            let canvasIndex = canvases.indexOf(canvas);\r\n            if (canvasIndex === -1) {\r\n              canvasIndex = canvases.length;\r\n              canvases.push(canvas);\r\n              maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];\r\n            }\r\n            this.maxTexSize = maxTexSizes[canvasIndex];\r\n          }\r\n          if (this.maxTexSize[0] < texSize[0]) {\r\n            this.maxTexSize[0] = texSize[0];\r\n          }\r\n          if (this.maxTexSize[1] < texSize[1]) {\r\n            this.maxTexSize[1] = texSize[1];\r\n          }\r\n        }\r\n      \r\n        setupArguments(args) {\r\n          this.kernelArguments = [];\r\n          this.argumentTextureCount = 0;\r\n          const needsArgumentTypes = this.argumentTypes === null;\r\n          if (needsArgumentTypes) {\r\n            this.argumentTypes = [];\r\n          }\r\n          this.argumentSizes = [];\r\n          this.argumentBitRatios = [];\r\n      \r\n          if (args.length < this.argumentNames.length) {\r\n            throw new Error('not enough arguments for kernel');\r\n          } else if (args.length > this.argumentNames.length) {\r\n            throw new Error('too many arguments for kernel');\r\n          }\r\n      \r\n          const { context: gl } = this;\r\n          let textureIndexes = 0;\r\n      \r\n          const onRequestTexture = () => {\r\n            return this.createTexture();\r\n          };\r\n          const onRequestIndex = () => {\r\n            return this.constantTextureCount + textureIndexes++;\r\n          };\r\n          const onUpdateValueMismatch = (constructor) => {\r\n            this.switchKernels({\r\n              type: 'argumentMismatch',\r\n              needed: constructor\r\n            });\r\n          };\r\n          const onRequestContextHandle = () => {\r\n            return gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;\r\n          };\r\n      \r\n          for (let index = 0; index < args.length; index++) {\r\n            const value = args[index];\r\n            const name = this.argumentNames[index];\r\n            let type;\r\n            if (needsArgumentTypes) {\r\n              type = utils.getVariableType(value, this.strictIntegers);\r\n              this.argumentTypes.push(type);\r\n            } else {\r\n              type = this.argumentTypes[index];\r\n            }\r\n            const KernelValue = this.constructor.lookupKernelValueType(type, this.dynamicArguments ? 'dynamic' : 'static', this.precision, args[index]);\r\n            if (KernelValue === null) {\r\n              return this.requestFallback(args);\r\n            }\r\n            const kernelArgument = new KernelValue(value, {\r\n              name,\r\n              type,\r\n              tactic: this.tactic,\r\n              origin: 'user',\r\n              context: gl,\r\n              checkContext: this.checkContext,\r\n              kernel: this,\r\n              strictIntegers: this.strictIntegers,\r\n              onRequestTexture,\r\n              onRequestIndex,\r\n              onUpdateValueMismatch,\r\n              onRequestContextHandle,\r\n            });\r\n            this.kernelArguments.push(kernelArgument);\r\n            kernelArgument.setup();\r\n            this.argumentSizes.push(kernelArgument.textureSize);\r\n            this.argumentBitRatios[index] = kernelArgument.bitRatio;\r\n          }\r\n        }\r\n      \r\n        createTexture() {\r\n          const texture = this.context.createTexture();\r\n          this.textureCache.push(texture);\r\n          return texture;\r\n        }\r\n      \r\n        setupConstants(args) {\r\n          const { context: gl } = this;\r\n          this.kernelConstants = [];\r\n          this.forceUploadKernelConstants = [];\r\n          let needsConstantTypes = this.constantTypes === null;\r\n          if (needsConstantTypes) {\r\n            this.constantTypes = {};\r\n          }\r\n          this.constantBitRatios = {};\r\n          let textureIndexes = 0;\r\n          for (const name in this.constants) {\r\n            const value = this.constants[name];\r\n            let type;\r\n            if (needsConstantTypes) {\r\n              type = utils.getVariableType(value, this.strictIntegers);\r\n              this.constantTypes[name] = type;\r\n            } else {\r\n              type = this.constantTypes[name];\r\n            }\r\n            const KernelValue = this.constructor.lookupKernelValueType(type, 'static', this.precision, value);\r\n            if (KernelValue === null) {\r\n              return this.requestFallback(args);\r\n            }\r\n            const kernelValue = new KernelValue(value, {\r\n              name,\r\n              type,\r\n              tactic: this.tactic,\r\n              origin: 'constants',\r\n              context: this.context,\r\n              checkContext: this.checkContext,\r\n              kernel: this,\r\n              strictIntegers: this.strictIntegers,\r\n              onRequestTexture: () => {\r\n                return this.createTexture();\r\n              },\r\n              onRequestIndex: () => {\r\n                return textureIndexes++;\r\n              },\r\n              onRequestContextHandle: () => {\r\n                return gl.TEXTURE0 + this.constantTextureCount++;\r\n              }\r\n            });\r\n            this.constantBitRatios[name] = kernelValue.bitRatio;\r\n            this.kernelConstants.push(kernelValue);\r\n            kernelValue.setup();\r\n            if (kernelValue.forceUploadEachRun) {\r\n              this.forceUploadKernelConstants.push(kernelValue);\r\n            }\r\n          }\r\n        }\r\n      \r\n        build() {\r\n          if (this.built) return;\r\n          this.initExtensions();\r\n          this.validateSettings(arguments);\r\n          this.setupConstants(arguments);\r\n          if (this.fallbackRequested) return;\r\n          this.setupArguments(arguments);\r\n          if (this.fallbackRequested) return;\r\n          this.updateMaxTexSize();\r\n          this.translateSource();\r\n          const failureResult = this.pickRenderStrategy(arguments);\r\n          if (failureResult) {\r\n            return failureResult;\r\n          }\r\n          const { texSize, context: gl, canvas } = this;\r\n          gl.enable(gl.SCISSOR_TEST);\r\n          if (this.pipeline && this.precision === 'single') {\r\n            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);\r\n            canvas.width = this.maxTexSize[0];\r\n            canvas.height = this.maxTexSize[1];\r\n          } else {\r\n            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);\r\n            canvas.width = this.maxTexSize[0];\r\n            canvas.height = this.maxTexSize[1];\r\n          }\r\n          const threadDim = this.threadDim = Array.from(this.output);\r\n          while (threadDim.length < 3) {\r\n            threadDim.push(1);\r\n          }\r\n      \r\n          const compiledVertexShader = this.getVertexShader(arguments);\r\n          const vertShader = gl.createShader(gl.VERTEX_SHADER);\r\n          gl.shaderSource(vertShader, compiledVertexShader);\r\n          gl.compileShader(vertShader);\r\n          this.vertShader = vertShader;\r\n      \r\n          const compiledFragmentShader = this.getFragmentShader(arguments);\r\n          const fragShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n          gl.shaderSource(fragShader, compiledFragmentShader);\r\n          gl.compileShader(fragShader);\r\n          this.fragShader = fragShader;\r\n      \r\n          if (this.debug) {\r\n            console.log('GLSL Shader Output:');\r\n            console.log(compiledFragmentShader);\r\n          }\r\n      \r\n          if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {\r\n            throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));\r\n          }\r\n          if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {\r\n            throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));\r\n          }\r\n      \r\n          const program = this.program = gl.createProgram();\r\n          gl.attachShader(program, vertShader);\r\n          gl.attachShader(program, fragShader);\r\n          gl.linkProgram(program);\r\n          this.framebuffer = gl.createFramebuffer();\r\n          this.framebuffer.width = texSize[0];\r\n          this.framebuffer.height = texSize[1];\r\n          this.rawValueFramebuffers = {};\r\n      \r\n          const vertices = new Float32Array([-1, -1,\r\n            1, -1, -1, 1,\r\n            1, 1\r\n          ]);\r\n          const texCoords = new Float32Array([\r\n            0, 0,\r\n            1, 0,\r\n            0, 1,\r\n            1, 1\r\n          ]);\r\n      \r\n          const texCoordOffset = vertices.byteLength;\r\n      \r\n          let buffer = this.buffer;\r\n          if (!buffer) {\r\n            buffer = this.buffer = gl.createBuffer();\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);\r\n          } else {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n          }\r\n      \r\n          gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);\r\n          gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);\r\n      \r\n          const aPosLoc = gl.getAttribLocation(this.program, 'aPos');\r\n          gl.enableVertexAttribArray(aPosLoc);\r\n          gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);\r\n          const aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');\r\n          gl.enableVertexAttribArray(aTexCoordLoc);\r\n          gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\r\n      \r\n          let i = 0;\r\n          gl.useProgram(this.program);\r\n          for (let p in this.constants) {\r\n            this.kernelConstants[i++].updateValue(this.constants[p]);\r\n          }\r\n      \r\n          this._setupOutputTexture();\r\n          if (\r\n            this.subKernels !== null &&\r\n            this.subKernels.length > 0\r\n          ) {\r\n            this._mappedTextureSwitched = {};\r\n            this._setupSubOutputTextures();\r\n          }\r\n          this.buildSignature(arguments);\r\n          this.built = true;\r\n        }\r\n      \r\n        translateSource() {\r\n          const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {\r\n            fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy\r\n          });\r\n          this.translatedSource = functionBuilder.getPrototypeString('kernel');\r\n          this.setupReturnTypes(functionBuilder);\r\n        }\r\n      \r\n        setupReturnTypes(functionBuilder) {\r\n          if (!this.graphical && !this.returnType) {\r\n            this.returnType = functionBuilder.getKernelResultType();\r\n          }\r\n      \r\n          if (this.subKernels && this.subKernels.length > 0) {\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              const subKernel = this.subKernels[i];\r\n              if (!subKernel.returnType) {\r\n                subKernel.returnType = functionBuilder.getSubKernelResultType(i);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      \r\n        run() {\r\n          const { kernelArguments, texSize, forceUploadKernelConstants, context: gl } = this;\r\n      \r\n          gl.useProgram(this.program);\r\n          gl.scissor(0, 0, texSize[0], texSize[1]);\r\n          if (this.dynamicOutput) {\r\n            this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));\r\n            this.setUniform2iv('uTexSize', texSize);\r\n          }\r\n      \r\n          this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);\r\n      \r\n          for (let i = 0; i < forceUploadKernelConstants.length; i++) {\r\n            const constant = forceUploadKernelConstants[i];\r\n            constant.updateValue(this.constants[constant.name]);\r\n            if (this.switchingKernels) return;\r\n          }\r\n          for (let i = 0; i < kernelArguments.length; i++) {\r\n            kernelArguments[i].updateValue(arguments[i]);\r\n            if (this.switchingKernels) return;\r\n          }\r\n      \r\n          if (this.plugins) {\r\n            for (let i = 0; i < this.plugins.length; i++) {\r\n              const plugin = this.plugins[i];\r\n              if (plugin.onBeforeRun) {\r\n                plugin.onBeforeRun(this);\r\n              }\r\n            }\r\n          }\r\n      \r\n          if (this.graphical) {\r\n            if (this.pipeline) {\r\n              gl.bindRenderbuffer(gl.RENDERBUFFER, null);\r\n              gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\r\n              if (this.immutable) {\r\n                this._replaceOutputTexture();\r\n              }\r\n              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n              return this.immutable ? this.texture.clone() : this.texture;\r\n            }\r\n            gl.bindRenderbuffer(gl.RENDERBUFFER, null);\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n            return;\r\n          }\r\n      \r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\r\n          if (this.immutable) {\r\n            this._replaceOutputTexture();\r\n          }\r\n      \r\n          if (this.subKernels !== null) {\r\n            if (this.immutable) {\r\n              this._replaceSubOutputTextures();\r\n            }\r\n            this.drawBuffers();\r\n          }\r\n      \r\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n        }\r\n      \r\n        drawBuffers() {\r\n          this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);\r\n        }\r\n      \r\n        getInternalFormat() {\r\n          return this.context.RGBA;\r\n        }\r\n        getTextureFormat() {\r\n          const { context: gl } = this;\r\n          switch (this.getInternalFormat()) {\r\n            case gl.RGBA:\r\n              return gl.RGBA;\r\n            default:\r\n              throw new Error('Unknown internal format');\r\n          }\r\n        }\r\n      \r\n        _replaceOutputTexture() {\r\n          if (this.texture.beforeMutate() || this._textureSwitched) {\r\n            const gl = this.context;\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);\r\n            this._textureSwitched = false;\r\n          }\r\n        }\r\n      \r\n        _setupOutputTexture() {\r\n          const gl = this.context;\r\n          const texSize = this.texSize;\r\n          if (this.texture) {\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);\r\n            return;\r\n          }\r\n          const texture = this.createTexture();\r\n          gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);\r\n          gl.bindTexture(gl.TEXTURE_2D, texture);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n          const format = this.getInternalFormat();\r\n          if (this.precision === 'single') {\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);\r\n          } else {\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);\r\n          }\r\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n          this.texture = new this.TextureConstructor({\r\n            texture,\r\n            size: texSize,\r\n            dimensions: this.threadDim,\r\n            output: this.output,\r\n            context: this.context,\r\n            internalFormat: this.getInternalFormat(),\r\n            textureFormat: this.getTextureFormat(),\r\n            kernel: this,\r\n          });\r\n        }\r\n      \r\n        _replaceSubOutputTextures() {\r\n          const gl = this.context;\r\n          for (let i = 0; i < this.mappedTextures.length; i++) {\r\n            const mappedTexture = this.mappedTextures[i];\r\n            if (mappedTexture.beforeMutate() || this._mappedTextureSwitched[i]) {\r\n              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, mappedTexture.texture, 0);\r\n              this._mappedTextureSwitched[i] = false;\r\n            }\r\n          }\r\n        }\r\n      \r\n        _setupSubOutputTextures() {\r\n          const gl = this.context;\r\n          if (this.mappedTextures) {\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);\r\n            }\r\n            return;\r\n          }\r\n          const texSize = this.texSize;\r\n          this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];\r\n          this.mappedTextures = [];\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const texture = this.createTexture();\r\n            this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);\r\n            gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n            if (this.precision === 'single') {\r\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);\r\n            } else {\r\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n            }\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);\r\n      \r\n            this.mappedTextures.push(new this.TextureConstructor({\r\n              texture,\r\n              size: texSize,\r\n              dimensions: this.threadDim,\r\n              output: this.output,\r\n              context: this.context,\r\n              internalFormat: this.getInternalFormat(),\r\n              textureFormat: this.getTextureFormat(),\r\n              kernel: this,\r\n            }));\r\n          }\r\n        }\r\n      \r\n        setUniform1f(name, value) {\r\n          if (this.uniform1fCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform1fCache[name];\r\n            if (value === cache) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform1fCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform1f(loc, value);\r\n        }\r\n      \r\n        setUniform1i(name, value) {\r\n          if (this.uniform1iCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform1iCache[name];\r\n            if (value === cache) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform1iCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform1i(loc, value);\r\n        }\r\n      \r\n        setUniform2f(name, value1, value2) {\r\n          if (this.uniform2fCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform2fCache[name];\r\n            if (\r\n              value1 === cache[0] &&\r\n              value2 === cache[1]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform2fCache[name] = [value1, value2];\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform2f(loc, value1, value2);\r\n        }\r\n      \r\n        setUniform2fv(name, value) {\r\n          if (this.uniform2fvCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform2fvCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform2fvCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform2fv(loc, value);\r\n        }\r\n      \r\n        setUniform2iv(name, value) {\r\n          if (this.uniform2ivCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform2ivCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform2ivCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform2iv(loc, value);\r\n        }\r\n      \r\n        setUniform3fv(name, value) {\r\n          if (this.uniform3fvCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform3fvCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1] &&\r\n              value[2] === cache[2]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform3fvCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform3fv(loc, value);\r\n        }\r\n      \r\n        setUniform3iv(name, value) {\r\n          if (this.uniform3ivCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform3ivCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1] &&\r\n              value[2] === cache[2]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform3ivCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform3iv(loc, value);\r\n        }\r\n      \r\n        setUniform4fv(name, value) {\r\n          if (this.uniform4fvCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform4fvCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1] &&\r\n              value[2] === cache[2] &&\r\n              value[3] === cache[3]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform4fvCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform4fv(loc, value);\r\n        }\r\n      \r\n        setUniform4iv(name, value) {\r\n          if (this.uniform4ivCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform4ivCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1] &&\r\n              value[2] === cache[2] &&\r\n              value[3] === cache[3]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform4ivCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform4iv(loc, value);\r\n        }\r\n      \r\n        getUniformLocation(name) {\r\n          if (this.programUniformLocationCache.hasOwnProperty(name)) {\r\n            return this.programUniformLocationCache[name];\r\n          }\r\n          return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);\r\n        }\r\n      \r\n        _getFragShaderArtifactMap(args) {\r\n          return {\r\n            HEADER: this._getHeaderString(),\r\n            LOOP_MAX: this._getLoopMaxString(),\r\n            PLUGINS: this._getPluginsString(),\r\n            CONSTANTS: this._getConstantsString(),\r\n            DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),\r\n            ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),\r\n            DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),\r\n            INJECTED_NATIVE: this._getInjectedNative(),\r\n            MAIN_CONSTANTS: this._getMainConstantsString(),\r\n            MAIN_ARGUMENTS: this._getMainArgumentsString(args),\r\n            KERNEL: this.getKernelString(),\r\n            MAIN_RESULT: this.getMainResultString(),\r\n            FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),\r\n            INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),\r\n            SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),\r\n            SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),\r\n          };\r\n        }\r\n      \r\n        _getVertShaderArtifactMap(args) {\r\n          return {\r\n            FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),\r\n            INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),\r\n            SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),\r\n            SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),\r\n          };\r\n        }\r\n      \r\n        _getHeaderString() {\r\n          return (\r\n            this.subKernels !== null ?\r\n            '#extension GL_EXT_draw_buffers : require\\n' :\r\n            ''\r\n          );\r\n        }\r\n      \r\n        _getLoopMaxString() {\r\n          return (\r\n            this.loopMaxIterations ?\r\n            ` ${parseInt(this.loopMaxIterations)};\\n` :\r\n            ' 1000;\\n'\r\n          );\r\n        }\r\n      \r\n        _getPluginsString() {\r\n          if (!this.plugins) return '\\n';\r\n          return this.plugins.map(plugin => plugin.source && this.source.match(plugin.functionMatch) ? plugin.source : '').join('\\n');\r\n        }\r\n      \r\n        _getConstantsString() {\r\n          const result = [];\r\n          const { threadDim, texSize } = this;\r\n          if (this.dynamicOutput) {\r\n            result.push(\r\n              'uniform ivec3 uOutputDim',\r\n              'uniform ivec2 uTexSize'\r\n            );\r\n          } else {\r\n            result.push(\r\n              `ivec3 uOutputDim = ivec3(${threadDim[0]}, ${threadDim[1]}, ${threadDim[2]})`,\r\n              `ivec2 uTexSize = ivec2(${texSize[0]}, ${texSize[1]})`\r\n            );\r\n          }\r\n          return utils.linesToString(result);\r\n        }\r\n      \r\n        _getTextureCoordinate() {\r\n          const subKernels = this.subKernels;\r\n          if (subKernels === null || subKernels.length < 1) {\r\n            return 'varying vec2 vTexCoord;\\n';\r\n          } else {\r\n            return 'out vec2 vTexCoord;\\n';\r\n          }\r\n        }\r\n      \r\n        _getDecode32EndiannessString() {\r\n          return (\r\n            this.endianness === 'LE' ?\r\n            '' :\r\n            '  texel.rgba = texel.abgr;\\n'\r\n          );\r\n        }\r\n      \r\n        _getEncode32EndiannessString() {\r\n          return (\r\n            this.endianness === 'LE' ?\r\n            '' :\r\n            '  texel.rgba = texel.abgr;\\n'\r\n          );\r\n        }\r\n      \r\n        _getDivideWithIntegerCheckString() {\r\n          return this.fixIntegerDivisionAccuracy ?\r\n            `float divWithIntCheck(float x, float y) {\r\n        if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {\r\n          return float(int(x) / int(y));\r\n        }\r\n        return x / y;\r\n      }\r\n      \r\n      float integerCorrectionModulo(float number, float divisor) {\r\n        if (number < 0.0) {\r\n          number = abs(number);\r\n          if (divisor < 0.0) {\r\n            divisor = abs(divisor);\r\n          }\r\n          return -(number - (divisor * floor(divWithIntCheck(number, divisor))));\r\n        }\r\n        if (divisor < 0.0) {\r\n          divisor = abs(divisor);\r\n        }\r\n        return number - (divisor * floor(divWithIntCheck(number, divisor)));\r\n      }` :\r\n            '';\r\n        }\r\n      \r\n        _getMainArgumentsString(args) {\r\n          const results = [];\r\n          const { argumentNames } = this;\r\n          for (let i = 0; i < argumentNames.length; i++) {\r\n            results.push(this.kernelArguments[i].getSource(args[i]));\r\n          }\r\n          return results.join('');\r\n        }\r\n      \r\n        _getInjectedNative() {\r\n          return this.injectedNative || '';\r\n        }\r\n      \r\n        _getMainConstantsString() {\r\n          const result = [];\r\n          const { constants } = this;\r\n          if (constants) {\r\n            let i = 0;\r\n            for (const name in constants) {\r\n              if (!this.constants.hasOwnProperty(name)) continue;\r\n              result.push(this.kernelConstants[i++].getSource(this.constants[name]));\r\n            }\r\n          }\r\n          return result.join('');\r\n        }\r\n      \r\n        getRawValueFramebuffer(width, height) {\r\n          if (!this.rawValueFramebuffers[width]) {\r\n            this.rawValueFramebuffers[width] = {};\r\n          }\r\n          if (!this.rawValueFramebuffers[width][height]) {\r\n            const framebuffer = this.context.createFramebuffer();\r\n            framebuffer.width = width;\r\n            framebuffer.height = height;\r\n            this.rawValueFramebuffers[width][height] = framebuffer;\r\n          }\r\n          return this.rawValueFramebuffers[width][height];\r\n        }\r\n      \r\n        getKernelResultDeclaration() {\r\n          switch (this.returnType) {\r\n            case 'Array(2)':\r\n              return 'vec2 kernelResult';\r\n            case 'Array(3)':\r\n              return 'vec3 kernelResult';\r\n            case 'Array(4)':\r\n              return 'vec4 kernelResult';\r\n            case 'LiteralInteger':\r\n            case 'Float':\r\n            case 'Number':\r\n            case 'Integer':\r\n              return 'float kernelResult';\r\n            default:\r\n              if (this.graphical) {\r\n                return 'float kernelResult';\r\n              } else {\r\n                throw new Error(`unrecognized output type \"${ this.returnType }\"`);\r\n              }\r\n          }\r\n        }\r\n        getKernelString() {\r\n          const result = [this.getKernelResultDeclaration()];\r\n          const { subKernels } = this;\r\n          if (subKernels !== null) {\r\n            switch (this.returnType) {\r\n              case 'Number':\r\n              case 'Float':\r\n              case 'Integer':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  const subKernel = subKernels[i];\r\n                  result.push(\r\n                    subKernel.returnType === 'Integer' ?\r\n                    `int subKernelResult_${ subKernel.name } = 0` :\r\n                    `float subKernelResult_${ subKernel.name } = 0.0`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(2)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec2 subKernelResult_${ subKernels[i].name }`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(3)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec3 subKernelResult_${ subKernels[i].name }`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(4)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec4 subKernelResult_${ subKernels[i].name }`\r\n                  );\r\n                }\r\n                break;\r\n            }\r\n          }\r\n      \r\n          return utils.linesToString(result) + this.translatedSource;\r\n        }\r\n      \r\n        getMainResultGraphical() {\r\n          return utils.linesToString([\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  gl_FragColor = actualColor',\r\n          ]);\r\n        }\r\n      \r\n        getMainResultPackedPixels() {\r\n          switch (this.returnType) {\r\n            case 'LiteralInteger':\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n              return this.getMainResultKernelPackedPixels() +\r\n                this.getMainResultSubKernelPackedPixels();\r\n            default:\r\n              throw new Error(`packed output only usable with Numbers, \"${this.returnType}\" specified`);\r\n          }\r\n        }\r\n      \r\n        getMainResultKernelPackedPixels() {\r\n          return utils.linesToString([\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            `  gl_FragData[0] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`\r\n          ]);\r\n        }\r\n      \r\n        getMainResultSubKernelPackedPixels() {\r\n          const result = [];\r\n          if (!this.subKernels) return '';\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`\r\n              );\r\n            }\r\n          }\r\n          return utils.linesToString(result);\r\n        }\r\n      \r\n        getMainResultMemoryOptimizedFloats() {\r\n          const result = [\r\n            '  index *= 4',\r\n          ];\r\n      \r\n          switch (this.returnType) {\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n              const channels = ['r', 'g', 'b', 'a'];\r\n              for (let i = 0; i < channels.length; i++) {\r\n                const channel = channels[i];\r\n                this.getMainResultKernelMemoryOptimizedFloats(result, channel);\r\n                this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);\r\n                if (i + 1 < channels.length) {\r\n                  result.push('  index += 1');\r\n                }\r\n              }\r\n              break;\r\n            default:\r\n              throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);\r\n          }\r\n      \r\n          return utils.linesToString(result);\r\n        }\r\n      \r\n        getMainResultKernelMemoryOptimizedFloats(result, channel) {\r\n          result.push(\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            `  gl_FragData[0].${channel} = kernelResult`\r\n          );\r\n        }\r\n      \r\n        getMainResultSubKernelMemoryOptimizedFloats(result, channel) {\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}].${channel} = float(subKernelResult_${this.subKernels[i].name})`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}].${channel} = subKernelResult_${this.subKernels[i].name}`\r\n              );\r\n            }\r\n          }\r\n        }\r\n      \r\n        getMainResultKernelNumberTexture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  gl_FragData[0][0] = kernelResult',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelNumberTexture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}][0] = float(subKernelResult_${subKernel.name})`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}][0] = subKernelResult_${subKernel.name}`\r\n              );\r\n            }\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray2Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  gl_FragData[0][0] = kernelResult[0]',\r\n            '  gl_FragData[0][1] = kernelResult[1]',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray2Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            result.push(\r\n              `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\r\n              `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`\r\n            );\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray3Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  gl_FragData[0][0] = kernelResult[0]',\r\n            '  gl_FragData[0][1] = kernelResult[1]',\r\n            '  gl_FragData[0][2] = kernelResult[2]',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray3Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            result.push(\r\n              `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\r\n              `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,\r\n              `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`\r\n            );\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray4Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  gl_FragData[0] = kernelResult',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray4Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          switch (this.returnType) {\r\n            case 'Number':\r\n            case 'Float':\r\n            case 'Integer':\r\n              for (let i = 0; i < this.subKernels.length; ++i) {\r\n                const subKernel = this.subKernels[i];\r\n                if (subKernel.returnType === 'Integer') {\r\n                  result.push(\r\n                    `  gl_FragData[${i + 1}] = float(subKernelResult_${this.subKernels[i].name})`\r\n                  );\r\n                } else {\r\n                  result.push(\r\n                    `  gl_FragData[${i + 1}] = subKernelResult_${this.subKernels[i].name}`\r\n                  );\r\n                }\r\n              }\r\n              break;\r\n            case 'Array(2)':\r\n              for (let i = 0; i < this.subKernels.length; ++i) {\r\n                result.push(\r\n                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\r\n                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`\r\n                );\r\n              }\r\n              break;\r\n            case 'Array(3)':\r\n              for (let i = 0; i < this.subKernels.length; ++i) {\r\n                result.push(\r\n                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\r\n                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,\r\n                  `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`\r\n                );\r\n              }\r\n              break;\r\n            case 'Array(4)':\r\n              for (let i = 0; i < this.subKernels.length; ++i) {\r\n                result.push(\r\n                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\r\n                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,\r\n                  `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,\r\n                  `  gl_FragData[${i + 1}][3] = subKernelResult_${this.subKernels[i].name}[3]`\r\n                );\r\n              }\r\n              break;\r\n          }\r\n      \r\n          return result;\r\n        }\r\n      \r\n        replaceArtifacts(src, map) {\r\n          return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\\n/g, (match, artifact) => {\r\n            if (map.hasOwnProperty(artifact)) {\r\n              return map[artifact];\r\n            }\r\n            throw `unhandled artifact ${artifact}`;\r\n          });\r\n        }\r\n      \r\n        getFragmentShader(args) {\r\n          if (this.compiledFragmentShader !== null) {\r\n            return this.compiledFragmentShader;\r\n          }\r\n          return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));\r\n        }\r\n      \r\n        getVertexShader(args) {\r\n          if (this.compiledVertexShader !== null) {\r\n            return this.compiledVertexShader;\r\n          }\r\n          return this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(args));\r\n        }\r\n      \r\n        toString() {\r\n          const setupContextString = utils.linesToString([\r\n            `const gl = context`,\r\n          ]);\r\n          return glKernelString(this.constructor, arguments, this, setupContextString);\r\n        }\r\n      \r\n        destroy(removeCanvasReferences) {\r\n          if (!this.context) return;\r\n          if (this.buffer) {\r\n            this.context.deleteBuffer(this.buffer);\r\n          }\r\n          if (this.framebuffer) {\r\n            this.context.deleteFramebuffer(this.framebuffer);\r\n          }\r\n          for (const width in this.rawValueFramebuffers) {\r\n            for (const height in this.rawValueFramebuffers[width]) {\r\n              this.context.deleteFramebuffer(this.rawValueFramebuffers[width][height]);\r\n              delete this.rawValueFramebuffers[width][height];\r\n            }\r\n            delete this.rawValueFramebuffers[width];\r\n          }\r\n          if (this.vertShader) {\r\n            this.context.deleteShader(this.vertShader);\r\n          }\r\n          if (this.fragShader) {\r\n            this.context.deleteShader(this.fragShader);\r\n          }\r\n          if (this.program) {\r\n            this.context.deleteProgram(this.program);\r\n          }\r\n          if (this.texture) {\r\n            this.texture.delete();\r\n            const textureCacheIndex = this.textureCache.indexOf(this.texture.texture);\r\n            if (textureCacheIndex > -1) {\r\n              this.textureCache.splice(textureCacheIndex, 1);\r\n            }\r\n            this.texture = null;\r\n          }\r\n          if (this.mappedTextures && this.mappedTextures.length) {\r\n            for (let i = 0; i < this.mappedTextures.length; i++) {\r\n              const mappedTexture = this.mappedTextures[i];\r\n              mappedTexture.delete();\r\n              const textureCacheIndex = this.textureCache.indexOf(mappedTexture.texture);\r\n              if (textureCacheIndex > -1) {\r\n                this.textureCache.splice(textureCacheIndex, 1);\r\n              }\r\n            }\r\n            this.mappedTextures = null;\r\n          }\r\n          if (this.kernelArguments) {\r\n            for (let i = 0; i < this.kernelArguments.length; i++) {\r\n              this.kernelArguments[i].destroy();\r\n            }\r\n          }\r\n          if (this.kernelConstants) {\r\n            for (let i = 0; i < this.kernelConstants.length; i++) {\r\n              this.kernelConstants[i].destroy();\r\n            }\r\n          }\r\n          while (this.textureCache.length > 0) {\r\n            const texture = this.textureCache.pop();\r\n            this.context.deleteTexture(texture);\r\n          }\r\n          if (removeCanvasReferences) {\r\n            const idx = canvases.indexOf(this.canvas);\r\n            if (idx >= 0) {\r\n              canvases[idx] = null;\r\n              maxTexSizes[idx] = null;\r\n            }\r\n          }\r\n          this.destroyExtensions();\r\n          delete this.context;\r\n          delete this.canvas;\r\n          if (!this.gpu) return;\r\n          const i = this.gpu.kernels.indexOf(this);\r\n          if (i === -1) return;\r\n          this.gpu.kernels.splice(i, 1);\r\n        }\r\n      \r\n        destroyExtensions() {\r\n          this.extensions.OES_texture_float = null;\r\n          this.extensions.OES_texture_float_linear = null;\r\n          this.extensions.OES_element_index_uint = null;\r\n          this.extensions.WEBGL_draw_buffers = null;\r\n        }\r\n      \r\n        static destroyContext(context) {\r\n          const extension = context.getExtension('WEBGL_lose_context');\r\n          if (extension) {\r\n            extension.loseContext();\r\n          }\r\n        }\r\n      \r\n        toJSON() {\r\n          const json = super.toJSON();\r\n          json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();\r\n          json.settings.threadDim = this.threadDim;\r\n          return json;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernel\r\n      };\r\n      },{\"../../plugins/math-random-uniformly-distributed\":112,\"../../utils\":114,\"../function-builder\":9,\"../gl/kernel\":13,\"../gl/kernel-string\":12,\"./fragment-shader\":37,\"./function-node\":38,\"./kernel-value-maps\":39,\"./vertex-shader\":71}],71:[function(require,module,exports){\r\n      const vertexShader = `__FLOAT_TACTIC_DECLARATION__;\r\n      __INT_TACTIC_DECLARATION__;\r\n      __SAMPLER_2D_TACTIC_DECLARATION__;\r\n      \r\n      attribute vec2 aPos;\r\n      attribute vec2 aTexCoord;\r\n      \r\n      varying vec2 vTexCoord;\r\n      uniform vec2 ratio;\r\n      \r\n      void main(void) {\r\n        gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\r\n        vTexCoord = aTexCoord;\r\n      }`;\r\n      \r\n      module.exports = {\r\n        vertexShader\r\n      };\r\n      },{}],72:[function(require,module,exports){\r\n      const fragmentShader = `#version 300 es\r\n      __HEADER__;\r\n      __FLOAT_TACTIC_DECLARATION__;\r\n      __INT_TACTIC_DECLARATION__;\r\n      __SAMPLER_2D_TACTIC_DECLARATION__;\r\n      __SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;\r\n      \r\n      const int LOOP_MAX = __LOOP_MAX__;\r\n      \r\n      __PLUGINS__;\r\n      __CONSTANTS__;\r\n      \r\n      in vec2 vTexCoord;\r\n      \r\n      float atan2(float v1, float v2) {\r\n        if (v1 == 0.0 || v2 == 0.0) return 0.0;\r\n        return atan(v1 / v2);\r\n      }\r\n      \r\n      float cbrt(float x) {\r\n        if (x >= 0.0) {\r\n          return pow(x, 1.0 / 3.0);\r\n        } else {\r\n          return -pow(x, 1.0 / 3.0);\r\n        }\r\n      }\r\n      \r\n      float expm1(float x) {\r\n        return pow(${Math.E}, x) - 1.0; \r\n      }\r\n      \r\n      float fround(highp float x) {\r\n        return x;\r\n      }\r\n      \r\n      float imul(float v1, float v2) {\r\n        return float(int(v1) * int(v2));\r\n      }\r\n      \r\n      float log10(float x) {\r\n        return log2(x) * (1.0 / log2(10.0));\r\n      }\r\n      \r\n      float log1p(float x) {\r\n        return log(1.0 + x);\r\n      }\r\n      \r\n      float _pow(float v1, float v2) {\r\n        if (v2 == 0.0) return 1.0;\r\n        return pow(v1, v2);\r\n      }\r\n      \r\n      float _round(float x) {\r\n        return floor(x + 0.5);\r\n      }\r\n      \r\n      \r\n      const int BIT_COUNT = 32;\r\n      int modi(int x, int y) {\r\n        return x - y * (x / y);\r\n      }\r\n      \r\n      int bitwiseOr(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 || b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseXOR(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 || b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseAnd(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 && b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseNot(int a) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (modi(a, 2) == 0) {\r\n            result += n;    \r\n          }\r\n          a = a / 2;\r\n          n = n * 2;\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseZeroFillLeftShift(int n, int shift) {\r\n        int maxBytes = BIT_COUNT;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (maxBytes >= n) {\r\n            break;\r\n          }\r\n          maxBytes *= 2;\r\n        }\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= shift) {\r\n            break;\r\n          }\r\n          n *= 2;\r\n        }\r\n      \r\n        int result = 0;\r\n        int byteVal = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= maxBytes) break;\r\n          if (modi(n, 2) > 0) { result += byteVal; }\r\n          n = int(n / 2);\r\n          byteVal *= 2;\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      int bitwiseSignedRightShift(int num, int shifts) {\r\n        return int(floor(float(num) / pow(2.0, float(shifts))));\r\n      }\r\n      \r\n      int bitwiseZeroFillRightShift(int n, int shift) {\r\n        int maxBytes = BIT_COUNT;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (maxBytes >= n) {\r\n            break;\r\n          }\r\n          maxBytes *= 2;\r\n        }\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= shift) {\r\n            break;\r\n          }\r\n          n /= 2;\r\n        }\r\n        int result = 0;\r\n        int byteVal = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= maxBytes) break;\r\n          if (modi(n, 2) > 0) { result += byteVal; }\r\n          n = int(n / 2);\r\n          byteVal *= 2;\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      vec2 integerMod(vec2 x, float y) {\r\n        vec2 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      vec3 integerMod(vec3 x, float y) {\r\n        vec3 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      vec4 integerMod(vec4 x, vec4 y) {\r\n        vec4 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      float integerMod(float x, float y) {\r\n        float res = floor(mod(x, y));\r\n        return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\r\n      }\r\n      \r\n      int integerMod(int x, int y) {\r\n        return x - (y * int(x/y));\r\n      }\r\n      \r\n      __DIVIDE_WITH_INTEGER_CHECK__;\r\n      \r\n      // Here be dragons!\r\n      // DO NOT OPTIMIZE THIS CODE\r\n      // YOU WILL BREAK SOMETHING ON SOMEBODY\\'S MACHINE\r\n      // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\r\n      const vec2 MAGIC_VEC = vec2(1.0, -256.0);\r\n      const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\r\n      const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\r\n      float decode32(vec4 texel) {\r\n        __DECODE32_ENDIANNESS__;\r\n        texel *= 255.0;\r\n        vec2 gte128;\r\n        gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;\r\n        gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\r\n        float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\r\n        float res = exp2(round(exponent));\r\n        texel.b = texel.b - 128.0 * gte128.x;\r\n        res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;\r\n        res *= gte128.y * -2.0 + 1.0;\r\n        return res;\r\n      }\r\n      \r\n      float decode16(vec4 texel, int index) {\r\n        int channel = integerMod(index, 2);\r\n        return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;\r\n      }\r\n      \r\n      float decode8(vec4 texel, int index) {\r\n        int channel = integerMod(index, 4);\r\n        return texel[channel] * 255.0;\r\n      }\r\n      \r\n      vec4 legacyEncode32(float f) {\r\n        float F = abs(f);\r\n        float sign = f < 0.0 ? 1.0 : 0.0;\r\n        float exponent = floor(log2(F));\r\n        float mantissa = (exp2(-exponent) * F);\r\n        // exponent += floor(log2(mantissa));\r\n        vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\r\n        texel.rg = integerMod(texel.rg, 256.0);\r\n        texel.b = integerMod(texel.b, 128.0);\r\n        texel.a = exponent*0.5 + 63.5;\r\n        texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\r\n        texel = floor(texel);\r\n        texel *= 0.003921569; // 1/255\r\n        __ENCODE32_ENDIANNESS__;\r\n        return texel;\r\n      }\r\n      \r\n      // https://github.com/gpujs/gpu.js/wiki/Encoder-details\r\n      vec4 encode32(float value) {\r\n        if (value == 0.0) return vec4(0, 0, 0, 0);\r\n      \r\n        float exponent;\r\n        float mantissa;\r\n        vec4  result;\r\n        float sgn;\r\n      \r\n        sgn = step(0.0, -value);\r\n        value = abs(value);\r\n      \r\n        exponent = floor(log2(value));\r\n      \r\n        mantissa = value*pow(2.0, -exponent)-1.0;\r\n        exponent = exponent+127.0;\r\n        result   = vec4(0,0,0,0);\r\n      \r\n        result.a = floor(exponent/2.0);\r\n        exponent = exponent - result.a*2.0;\r\n        result.a = result.a + 128.0*sgn;\r\n      \r\n        result.b = floor(mantissa * 128.0);\r\n        mantissa = mantissa - result.b / 128.0;\r\n        result.b = result.b + exponent*128.0;\r\n      \r\n        result.g = floor(mantissa*32768.0);\r\n        mantissa = mantissa - result.g/32768.0;\r\n      \r\n        result.r = floor(mantissa*8388608.0);\r\n        return result/255.0;\r\n      }\r\n      // Dragons end here\r\n      \r\n      int index;\r\n      ivec3 threadId;\r\n      \r\n      ivec3 indexTo3D(int idx, ivec3 texDim) {\r\n        int z = int(idx / (texDim.x * texDim.y));\r\n        idx -= z * int(texDim.x * texDim.y);\r\n        int y = int(idx / texDim.x);\r\n        int x = int(integerMod(idx, texDim.x));\r\n        return ivec3(x, y, z);\r\n      }\r\n      \r\n      float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture(tex, st / vec2(texSize));\r\n        return decode32(texel);\r\n      }\r\n      \r\n      float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + (texDim.x * (y + (texDim.y * z)));\r\n        int w = texSize.x * 2;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));\r\n        return decode16(texel, index);\r\n      }\r\n      \r\n      float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + (texDim.x * (y + (texDim.y * z)));\r\n        int w = texSize.x * 4;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));\r\n        return decode8(texel, index);\r\n      }\r\n      \r\n      float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + (texDim.x * (y + (texDim.y * z)));\r\n        int channel = integerMod(index, 4);\r\n        index = index / 4;\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        index = index / 4;\r\n        vec4 texel = texture(tex, st / vec2(texSize));\r\n        return texel[channel];\r\n      }\r\n      \r\n      vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        return texture(tex, st / vec2(texSize));\r\n      }\r\n      \r\n      vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        return texture(tex, vec3(st / vec2(texSize), z));\r\n      }\r\n      \r\n      float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return result[0];\r\n      }\r\n      \r\n      vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return vec2(result[0], result[1]);\r\n      }\r\n      \r\n      vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int channel = integerMod(index, 2);\r\n        index = index / 2;\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture(tex, st / vec2(texSize));\r\n        if (channel == 0) return vec2(texel.r, texel.g);\r\n        if (channel == 1) return vec2(texel.b, texel.a);\r\n        return vec2(0.0, 0.0);\r\n      }\r\n      \r\n      vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return vec3(result[0], result[1], result[2]);\r\n      }\r\n      \r\n      vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));\r\n        int vectorIndex = fieldIndex / 4;\r\n        int vectorOffset = fieldIndex - vectorIndex * 4;\r\n        int readY = vectorIndex / texSize.x;\r\n        int readX = vectorIndex - readY * texSize.x;\r\n        vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));\r\n      \r\n        if (vectorOffset == 0) {\r\n          return tex1.xyz;\r\n        } else if (vectorOffset == 1) {\r\n          return tex1.yzw;\r\n        } else {\r\n          readX++;\r\n          if (readX >= texSize.x) {\r\n            readX = 0;\r\n            readY++;\r\n          }\r\n          vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));\r\n          if (vectorOffset == 2) {\r\n            return vec3(tex1.z, tex1.w, tex2.x);\r\n          } else {\r\n            return vec3(tex1.w, tex2.x, tex2.y);\r\n          }\r\n        }\r\n      }\r\n      \r\n      vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        return getImage2D(tex, texSize, texDim, z, y, x);\r\n      }\r\n      \r\n      vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int channel = integerMod(index, 2);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture(tex, st / vec2(texSize));\r\n        return vec4(texel.r, texel.g, texel.b, texel.a);\r\n      }\r\n      \r\n      vec4 actualColor;\r\n      void color(float r, float g, float b, float a) {\r\n        actualColor = vec4(r,g,b,a);\r\n      }\r\n      \r\n      void color(float r, float g, float b) {\r\n        color(r,g,b,1.0);\r\n      }\r\n      \r\n      float modulo(float number, float divisor) {\r\n        if (number < 0.0) {\r\n          number = abs(number);\r\n          if (divisor < 0.0) {\r\n            divisor = abs(divisor);\r\n          }\r\n          return -mod(number, divisor);\r\n        }\r\n        if (divisor < 0.0) {\r\n          divisor = abs(divisor);\r\n        }\r\n        return mod(number, divisor);\r\n      }\r\n      \r\n      __INJECTED_NATIVE__;\r\n      __MAIN_CONSTANTS__;\r\n      __MAIN_ARGUMENTS__;\r\n      __KERNEL__;\r\n      \r\n      void main(void) {\r\n        index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\r\n        __MAIN_RESULT__;\r\n      }`;\r\n      \r\n      module.exports = {\r\n        fragmentShader\r\n      };\r\n      },{}],73:[function(require,module,exports){\r\n      const { utils } = require('../../utils');\r\n      const { WebGLFunctionNode } = require('../web-gl/function-node');\r\n      \r\n      class WebGL2FunctionNode extends WebGLFunctionNode {\r\n      \r\n        astIdentifierExpression(idtNode, retArr) {\r\n          if (idtNode.type !== 'Identifier') {\r\n            throw this.astErrorOutput(\r\n              'IdentifierExpression - not an Identifier',\r\n              idtNode\r\n            );\r\n          }\r\n      \r\n          const type = this.getType(idtNode);\r\n      \r\n          const name = utils.sanitizeName(idtNode.name);\r\n          if (idtNode.name === 'Infinity') {\r\n            retArr.push('intBitsToFloat(2139095039)');\r\n          } else if (type === 'Boolean') {\r\n            if (this.argumentNames.indexOf(name) > -1) {\r\n              retArr.push(`bool(user_${name})`);\r\n            } else {\r\n              retArr.push(`user_${name}`);\r\n            }\r\n          } else {\r\n            retArr.push(`user_${name}`);\r\n          }\r\n      \r\n          return retArr;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2FunctionNode\r\n      };\r\n      },{\"../../utils\":114,\"../web-gl/function-node\":38}],74:[function(require,module,exports){\r\n      const { WebGL2KernelValueBoolean } = require('./kernel-value/boolean');\r\n      const { WebGL2KernelValueFloat } = require('./kernel-value/float');\r\n      const { WebGL2KernelValueInteger } = require('./kernel-value/integer');\r\n      \r\n      const { WebGL2KernelValueHTMLImage } = require('./kernel-value/html-image');\r\n      const { WebGL2KernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');\r\n      \r\n      const { WebGL2KernelValueHTMLImageArray } = require('./kernel-value/html-image-array');\r\n      const { WebGL2KernelValueDynamicHTMLImageArray } = require('./kernel-value/dynamic-html-image-array');\r\n      \r\n      const { WebGL2KernelValueHTMLVideo } = require('./kernel-value/html-video');\r\n      const { WebGL2KernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');\r\n      \r\n      const { WebGL2KernelValueSingleInput } = require('./kernel-value/single-input');\r\n      const { WebGL2KernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');\r\n      \r\n      const { WebGL2KernelValueUnsignedInput } = require('./kernel-value/unsigned-input');\r\n      const { WebGL2KernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');\r\n      \r\n      const { WebGL2KernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');\r\n      const { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');\r\n      \r\n      const { WebGL2KernelValueNumberTexture } = require('./kernel-value/number-texture');\r\n      const { WebGL2KernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');\r\n      \r\n      const { WebGL2KernelValueSingleArray } = require('./kernel-value/single-array');\r\n      const { WebGL2KernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');\r\n      \r\n      const { WebGL2KernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');\r\n      const { WebGL2KernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');\r\n      \r\n      const { WebGL2KernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');\r\n      const { WebGL2KernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');\r\n      \r\n      const { WebGL2KernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');\r\n      const { WebGL2KernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');\r\n      \r\n      const { WebGL2KernelValueSingleArray2 } = require('./kernel-value/single-array2');\r\n      const { WebGL2KernelValueSingleArray3 } = require('./kernel-value/single-array3');\r\n      const { WebGL2KernelValueSingleArray4 } = require('./kernel-value/single-array4');\r\n      \r\n      const { WebGL2KernelValueUnsignedArray } = require('./kernel-value/unsigned-array');\r\n      const { WebGL2KernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');\r\n      \r\n      const kernelValueMaps = {\r\n        unsigned: {\r\n          dynamic: {\r\n            'Boolean': WebGL2KernelValueBoolean,\r\n            'Integer': WebGL2KernelValueInteger,\r\n            'Float': WebGL2KernelValueFloat,\r\n            'Array': WebGL2KernelValueDynamicUnsignedArray,\r\n            'Array(2)': false,\r\n            'Array(3)': false,\r\n            'Array(4)': false,\r\n            'Array1D(2)': false,\r\n            'Array1D(3)': false,\r\n            'Array1D(4)': false,\r\n            'Array2D(2)': false,\r\n            'Array2D(3)': false,\r\n            'Array2D(4)': false,\r\n            'Array3D(2)': false,\r\n            'Array3D(3)': false,\r\n            'Array3D(4)': false,\r\n            'Input': WebGL2KernelValueDynamicUnsignedInput,\r\n            'NumberTexture': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,\r\n            'HTMLImage': WebGL2KernelValueDynamicHTMLImage,\r\n            'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,\r\n            'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,\r\n          },\r\n          static: {\r\n            'Boolean': WebGL2KernelValueBoolean,\r\n            'Float': WebGL2KernelValueFloat,\r\n            'Integer': WebGL2KernelValueInteger,\r\n            'Array': WebGL2KernelValueUnsignedArray,\r\n            'Array(2)': false,\r\n            'Array(3)': false,\r\n            'Array(4)': false,\r\n            'Array1D(2)': false,\r\n            'Array1D(3)': false,\r\n            'Array1D(4)': false,\r\n            'Array2D(2)': false,\r\n            'Array2D(3)': false,\r\n            'Array2D(4)': false,\r\n            'Array3D(2)': false,\r\n            'Array3D(3)': false,\r\n            'Array3D(4)': false,\r\n            'Input': WebGL2KernelValueUnsignedInput,\r\n            'NumberTexture': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(1)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(2)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(3)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(4)': WebGL2KernelValueNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGL2KernelValueHTMLImage,\r\n            'HTMLImage': WebGL2KernelValueHTMLImage,\r\n            'HTMLImageArray': WebGL2KernelValueHTMLImageArray,\r\n            'HTMLVideo': WebGL2KernelValueHTMLVideo,\r\n          }\r\n        },\r\n        single: {\r\n          dynamic: {\r\n            'Boolean': WebGL2KernelValueBoolean,\r\n            'Integer': WebGL2KernelValueInteger,\r\n            'Float': WebGL2KernelValueFloat,\r\n            'Array': WebGL2KernelValueDynamicSingleArray,\r\n            'Array(2)': WebGL2KernelValueSingleArray2,\r\n            'Array(3)': WebGL2KernelValueSingleArray3,\r\n            'Array(4)': WebGL2KernelValueSingleArray4,\r\n            'Array1D(2)': WebGL2KernelValueDynamicSingleArray1DI,\r\n            'Array1D(3)': WebGL2KernelValueDynamicSingleArray1DI,\r\n            'Array1D(4)': WebGL2KernelValueDynamicSingleArray1DI,\r\n            'Array2D(2)': WebGL2KernelValueDynamicSingleArray2DI,\r\n            'Array2D(3)': WebGL2KernelValueDynamicSingleArray2DI,\r\n            'Array2D(4)': WebGL2KernelValueDynamicSingleArray2DI,\r\n            'Array3D(2)': WebGL2KernelValueDynamicSingleArray3DI,\r\n            'Array3D(3)': WebGL2KernelValueDynamicSingleArray3DI,\r\n            'Array3D(4)': WebGL2KernelValueDynamicSingleArray3DI,\r\n            'Input': WebGL2KernelValueDynamicSingleInput,\r\n            'NumberTexture': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,\r\n            'HTMLImage': WebGL2KernelValueDynamicHTMLImage,\r\n            'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,\r\n            'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,\r\n          },\r\n          static: {\r\n            'Boolean': WebGL2KernelValueBoolean,\r\n            'Float': WebGL2KernelValueFloat,\r\n            'Integer': WebGL2KernelValueInteger,\r\n            'Array': WebGL2KernelValueSingleArray,\r\n            'Array(2)': WebGL2KernelValueSingleArray2,\r\n            'Array(3)': WebGL2KernelValueSingleArray3,\r\n            'Array(4)': WebGL2KernelValueSingleArray4,\r\n            'Array1D(2)': WebGL2KernelValueSingleArray1DI,\r\n            'Array1D(3)': WebGL2KernelValueSingleArray1DI,\r\n            'Array1D(4)': WebGL2KernelValueSingleArray1DI,\r\n            'Array2D(2)': WebGL2KernelValueSingleArray2DI,\r\n            'Array2D(3)': WebGL2KernelValueSingleArray2DI,\r\n            'Array2D(4)': WebGL2KernelValueSingleArray2DI,\r\n            'Array3D(2)': WebGL2KernelValueSingleArray3DI,\r\n            'Array3D(3)': WebGL2KernelValueSingleArray3DI,\r\n            'Array3D(4)': WebGL2KernelValueSingleArray3DI,\r\n            'Input': WebGL2KernelValueSingleInput,\r\n            'NumberTexture': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(1)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(2)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(3)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(4)': WebGL2KernelValueNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGL2KernelValueHTMLImage,\r\n            'HTMLImage': WebGL2KernelValueHTMLImage,\r\n            'HTMLImageArray': WebGL2KernelValueHTMLImageArray,\r\n            'HTMLVideo': WebGL2KernelValueHTMLVideo,\r\n          }\r\n        },\r\n      };\r\n      \r\n      function lookupKernelValueType(type, dynamic, precision, value) {\r\n        if (!type) {\r\n          throw new Error('type missing');\r\n        }\r\n        if (!dynamic) {\r\n          throw new Error('dynamic missing');\r\n        }\r\n        if (!precision) {\r\n          throw new Error('precision missing');\r\n        }\r\n        if (value.type) {\r\n          type = value.type;\r\n        }\r\n        const types = kernelValueMaps[precision][dynamic];\r\n        if (types[type] === false) {\r\n          return null;\r\n        } else if (types[type] === undefined) {\r\n          throw new Error(`Could not find a KernelValue for ${ type }`);\r\n        }\r\n        return types[type];\r\n      }\r\n      \r\n      module.exports = {\r\n        kernelValueMaps,\r\n        lookupKernelValueType\r\n      };\r\n      },{\"./kernel-value/boolean\":75,\"./kernel-value/dynamic-html-image\":77,\"./kernel-value/dynamic-html-image-array\":76,\"./kernel-value/dynamic-html-video\":78,\"./kernel-value/dynamic-memory-optimized-number-texture\":79,\"./kernel-value/dynamic-number-texture\":80,\"./kernel-value/dynamic-single-array\":81,\"./kernel-value/dynamic-single-array1d-i\":82,\"./kernel-value/dynamic-single-array2d-i\":83,\"./kernel-value/dynamic-single-array3d-i\":84,\"./kernel-value/dynamic-single-input\":85,\"./kernel-value/dynamic-unsigned-array\":86,\"./kernel-value/dynamic-unsigned-input\":87,\"./kernel-value/float\":88,\"./kernel-value/html-image\":90,\"./kernel-value/html-image-array\":89,\"./kernel-value/html-video\":91,\"./kernel-value/integer\":92,\"./kernel-value/memory-optimized-number-texture\":93,\"./kernel-value/number-texture\":94,\"./kernel-value/single-array\":95,\"./kernel-value/single-array1d-i\":96,\"./kernel-value/single-array2\":97,\"./kernel-value/single-array2d-i\":98,\"./kernel-value/single-array3\":99,\"./kernel-value/single-array3d-i\":100,\"./kernel-value/single-array4\":101,\"./kernel-value/single-input\":102,\"./kernel-value/unsigned-array\":103,\"./kernel-value/unsigned-input\":104}],75:[function(require,module,exports){\r\n      const { WebGLKernelValueBoolean } = require('../../web-gl/kernel-value/boolean');\r\n      \r\n      class WebGL2KernelValueBoolean extends WebGLKernelValueBoolean {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueBoolean\r\n      };\r\n      },{\"../../web-gl/kernel-value/boolean\":41}],76:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueHTMLImageArray } = require('./html-image-array');\r\n      \r\n      class WebGL2KernelValueDynamicHTMLImageArray extends WebGL2KernelValueHTMLImageArray {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2DArray ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(images) {\r\n          const { width, height } = images[0];\r\n          this.checkSize(width, height);\r\n          this.dimensions = [width, height, images.length];\r\n          this.textureSize = [width, height];\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(images);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicHTMLImageArray\r\n      };\r\n      },{\"../../../utils\":114,\"./html-image-array\":89}],77:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueDynamicHTMLImage } = require('../../web-gl/kernel-value/dynamic-html-image');\r\n      \r\n      class WebGL2KernelValueDynamicHTMLImage extends WebGLKernelValueDynamicHTMLImage {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicHTMLImage\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/dynamic-html-image\":42}],78:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueDynamicHTMLImage } = require('./dynamic-html-image');\r\n      \r\n      class WebGL2KernelValueDynamicHTMLVideo extends WebGL2KernelValueDynamicHTMLImage {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicHTMLVideo\r\n      };\r\n      },{\"../../../utils\":114,\"./dynamic-html-image\":77}],79:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/dynamic-memory-optimized-number-texture');\r\n      \r\n      class WebGL2KernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueDynamicMemoryOptimizedNumberTexture {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicMemoryOptimizedNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture\":44}],80:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueDynamicNumberTexture } = require('../../web-gl/kernel-value/dynamic-number-texture');\r\n      \r\n      class WebGL2KernelValueDynamicNumberTexture extends WebGLKernelValueDynamicNumberTexture {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/dynamic-number-texture\":45}],81:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueSingleArray } = require('../../web-gl2/kernel-value/single-array');\r\n      \r\n      class WebGL2KernelValueDynamicSingleArray extends WebGL2KernelValueSingleArray {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.dimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicSingleArray\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl2/kernel-value/single-array\":95}],82:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueSingleArray1DI } = require('../../web-gl2/kernel-value/single-array1d-i');\r\n      \r\n      class WebGL2KernelValueDynamicSingleArray1DI extends WebGL2KernelValueSingleArray1DI {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicSingleArray1DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl2/kernel-value/single-array1d-i\":96}],83:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueSingleArray2DI } = require('../../web-gl2/kernel-value/single-array2d-i');\r\n      \r\n      class WebGL2KernelValueDynamicSingleArray2DI extends WebGL2KernelValueSingleArray2DI {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicSingleArray2DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl2/kernel-value/single-array2d-i\":98}],84:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueSingleArray3DI } = require('../../web-gl2/kernel-value/single-array3d-i');\r\n      \r\n      class WebGL2KernelValueDynamicSingleArray3DI extends WebGL2KernelValueSingleArray3DI {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicSingleArray3DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl2/kernel-value/single-array3d-i\":100}],85:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueSingleInput } = require('../../web-gl2/kernel-value/single-input');\r\n      \r\n      class WebGL2KernelValueDynamicSingleInput extends WebGL2KernelValueSingleInput {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          let [w, h, d] = value.size;\r\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicSingleInput\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl2/kernel-value/single-input\":102}],86:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueDynamicUnsignedArray } = require('../../web-gl/kernel-value/dynamic-unsigned-array');\r\n      \r\n      class WebGL2KernelValueDynamicUnsignedArray extends WebGLKernelValueDynamicUnsignedArray {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicUnsignedArray\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/dynamic-unsigned-array\":51}],87:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueDynamicUnsignedInput } = require('../../web-gl/kernel-value/dynamic-unsigned-input');\r\n      \r\n      class WebGL2KernelValueDynamicUnsignedInput extends WebGLKernelValueDynamicUnsignedInput {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicUnsignedInput\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/dynamic-unsigned-input\":52}],88:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueFloat } = require('../../web-gl/kernel-value/float');\r\n      \r\n      class WebGL2KernelValueFloat extends WebGLKernelValueFloat {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueFloat\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/float\":53}],89:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('../../web-gl/kernel-value/array');\r\n      \r\n      class WebGL2KernelValueHTMLImageArray extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.checkSize(value[0].width, value[0].height);\r\n          this.dimensions = [value[0].width, value[0].height, value.length];\r\n          this.textureSize = [value[0].width, value[0].height];\r\n        }\r\n        defineTexture() {\r\n          const { context: gl } = this;\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);\r\n          gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n          gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2DArray ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(images) {\r\n          const { context: gl } = this;\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n          gl.texImage3D(\r\n            gl.TEXTURE_2D_ARRAY,\r\n            0,\r\n            gl.RGBA,\r\n            images[0].width,\r\n            images[0].height,\r\n            images.length,\r\n            0,\r\n            gl.RGBA,\r\n            gl.UNSIGNED_BYTE,\r\n            null\r\n          );\r\n          for (let i = 0; i < images.length; i++) {\r\n            const xOffset = 0;\r\n            const yOffset = 0;\r\n            const imageDepth = 1;\r\n            gl.texSubImage3D(\r\n              gl.TEXTURE_2D_ARRAY,\r\n              0,\r\n              xOffset,\r\n              yOffset,\r\n              i,\r\n              images[i].width,\r\n              images[i].height,\r\n              imageDepth,\r\n              gl.RGBA,\r\n              gl.UNSIGNED_BYTE,\r\n              this.uploadValue = images[i]\r\n            );\r\n          }\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueHTMLImageArray\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/array\":40}],90:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueHTMLImage } = require('../../web-gl/kernel-value/html-image');\r\n      \r\n      class WebGL2KernelValueHTMLImage extends WebGLKernelValueHTMLImage {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueHTMLImage\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/html-image\":54}],91:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueHTMLImage } = require('./html-image');\r\n      \r\n      class WebGL2KernelValueHTMLVideo extends WebGL2KernelValueHTMLImage {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueHTMLVideo\r\n      };\r\n      },{\"../../../utils\":114,\"./html-image\":90}],92:[function(require,module,exports){\r\n      const { WebGLKernelValueInteger } = require('../../web-gl/kernel-value/integer');\r\n      \r\n      class WebGL2KernelValueInteger extends WebGLKernelValueInteger {\r\n        getSource(value) {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          if (this.origin === 'constants') {\r\n            return `const ${ variablePrecision } int ${this.id} = ${ parseInt(value) };\\n`;\r\n          }\r\n          return `uniform ${ variablePrecision } int ${this.id};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform1i(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueInteger\r\n      };\r\n      },{\"../../web-gl/kernel-value/integer\":57}],93:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/memory-optimized-number-texture');\r\n      \r\n      class WebGL2KernelValueMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {\r\n        getSource() {\r\n          const { id, sizeId, textureSize, dimensionsId, dimensions } = this;\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${id}`,\r\n            `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueMemoryOptimizedNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/memory-optimized-number-texture\":58}],94:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueNumberTexture } = require('../../web-gl/kernel-value/number-texture');\r\n      \r\n      class WebGL2KernelValueNumberTexture extends WebGLKernelValueNumberTexture {\r\n        getSource() {\r\n          const { id, sizeId, textureSize, dimensionsId, dimensions } = this;\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${id}`,\r\n            `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/number-texture\":59}],95:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray } = require('../../web-gl/kernel-value/single-array');\r\n      \r\n      class WebGL2KernelValueSingleArray extends WebGLKernelValueSingleArray {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/single-array\":60}],96:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray1DI } = require('../../web-gl/kernel-value/single-array1d-i');\r\n      \r\n      class WebGL2KernelValueSingleArray1DI extends WebGLKernelValueSingleArray1DI {\r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray1DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/single-array1d-i\":61}],97:[function(require,module,exports){\r\n      const { WebGLKernelValueSingleArray2 } = require('../../web-gl/kernel-value/single-array2');\r\n      \r\n      class WebGL2KernelValueSingleArray2 extends WebGLKernelValueSingleArray2 {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray2\r\n      };\r\n      },{\"../../web-gl/kernel-value/single-array2\":62}],98:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray2DI } = require('../../web-gl/kernel-value/single-array2d-i');\r\n      \r\n      class WebGL2KernelValueSingleArray2DI extends WebGLKernelValueSingleArray2DI {\r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray2DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/single-array2d-i\":63}],99:[function(require,module,exports){\r\n      const { WebGLKernelValueSingleArray3 } = require('../../web-gl/kernel-value/single-array3');\r\n      \r\n      class WebGL2KernelValueSingleArray3 extends WebGLKernelValueSingleArray3 {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray3\r\n      };\r\n      },{\"../../web-gl/kernel-value/single-array3\":64}],100:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray3DI } = require('../../web-gl/kernel-value/single-array3d-i');\r\n      \r\n      class WebGL2KernelValueSingleArray3DI extends WebGLKernelValueSingleArray3DI {\r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray3DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/single-array3d-i\":65}],101:[function(require,module,exports){\r\n      const { WebGLKernelValueSingleArray4 } = require('../../web-gl/kernel-value/single-array4');\r\n      \r\n      class WebGL2KernelValueSingleArray4 extends WebGLKernelValueSingleArray4 {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray4\r\n      };\r\n      },{\"../../web-gl/kernel-value/single-array4\":66}],102:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleInput } = require('../../web-gl/kernel-value/single-input');\r\n      \r\n      class WebGL2KernelValueSingleInput extends WebGLKernelValueSingleInput {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(input) {\r\n          const { context: gl } = this;\r\n          utils.flattenTo(input.value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleInput\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/single-input\":67}],103:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueUnsignedArray } = require('../../web-gl/kernel-value/unsigned-array');\r\n      \r\n      class WebGL2KernelValueUnsignedArray extends WebGLKernelValueUnsignedArray {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueUnsignedArray\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/unsigned-array\":68}],104:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueUnsignedInput } = require('../../web-gl/kernel-value/unsigned-input');\r\n      \r\n      class WebGL2KernelValueUnsignedInput extends WebGLKernelValueUnsignedInput {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueUnsignedInput\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/unsigned-input\":69}],105:[function(require,module,exports){\r\n      const { WebGLKernel } = require('../web-gl/kernel');\r\n      const { WebGL2FunctionNode } = require('./function-node');\r\n      const { FunctionBuilder } = require('../function-builder');\r\n      const { utils } = require('../../utils');\r\n      const { fragmentShader } = require('./fragment-shader');\r\n      const { vertexShader } = require('./vertex-shader');\r\n      const { lookupKernelValueType } = require('./kernel-value-maps');\r\n      \r\n      let isSupported = null;\r\n      let testCanvas = null;\r\n      let testContext = null;\r\n      let testExtensions = null;\r\n      \r\n      let features = null;\r\n      \r\n      class WebGL2Kernel extends WebGLKernel {\r\n        static get isSupported() {\r\n          if (isSupported !== null) {\r\n            return isSupported;\r\n          }\r\n          this.setupFeatureChecks();\r\n          isSupported = this.isContextMatch(testContext);\r\n          return isSupported;\r\n        }\r\n      \r\n        static setupFeatureChecks() {\r\n          if (typeof document !== 'undefined') {\r\n            testCanvas = document.createElement('canvas');\r\n          } else if (typeof OffscreenCanvas !== 'undefined') {\r\n            testCanvas = new OffscreenCanvas(0, 0);\r\n          }\r\n          if (!testCanvas) return;\r\n          testContext = testCanvas.getContext('webgl2');\r\n          if (!testContext || !testContext.getExtension) return;\r\n          testExtensions = {\r\n            EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),\r\n            OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),\r\n          };\r\n          features = this.getFeatures();\r\n        }\r\n      \r\n        static isContextMatch(context) {\r\n          if (typeof WebGL2RenderingContext !== 'undefined') {\r\n            return context instanceof WebGL2RenderingContext;\r\n          }\r\n          return false;\r\n        }\r\n      \r\n        static getFeatures() {\r\n          const gl = this.testContext;\r\n          return Object.freeze({\r\n            isFloatRead: this.getIsFloatRead(),\r\n            isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),\r\n            isSpeedTacticSupported: this.getIsSpeedTacticSupported(),\r\n            kernelMap: true,\r\n            isTextureFloat: true,\r\n            isDrawBuffers: true,\r\n            channelCount: this.getChannelCount(),\r\n            maxTextureSize: this.getMaxTextureSize(),\r\n            lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),\r\n            lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),\r\n            mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),\r\n            mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),\r\n            highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),\r\n            highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),\r\n          });\r\n        }\r\n      \r\n        static getIsTextureFloat() {\r\n          return true;\r\n        }\r\n      \r\n        static getChannelCount() {\r\n          return testContext.getParameter(testContext.MAX_DRAW_BUFFERS);\r\n        }\r\n      \r\n        static getMaxTextureSize() {\r\n          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);\r\n        }\r\n      \r\n        static lookupKernelValueType(type, dynamic, precision, value) {\r\n          return lookupKernelValueType(type, dynamic, precision, value);\r\n        }\r\n      \r\n        static get testCanvas() {\r\n          return testCanvas;\r\n        }\r\n      \r\n        static get testContext() {\r\n          return testContext;\r\n        }\r\n      \r\n        static get features() {\r\n          return features;\r\n        }\r\n      \r\n        static get fragmentShader() {\r\n          return fragmentShader;\r\n        }\r\n        static get vertexShader() {\r\n          return vertexShader;\r\n        }\r\n      \r\n        initContext() {\r\n          const settings = {\r\n            alpha: false,\r\n            depth: false,\r\n            antialias: false\r\n          };\r\n          return this.canvas.getContext('webgl2', settings);\r\n        }\r\n      \r\n        initExtensions() {\r\n          this.extensions = {\r\n            EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),\r\n            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),\r\n          };\r\n        }\r\n      \r\n        validateSettings(args) {\r\n          if (!this.validate) {\r\n            this.texSize = utils.getKernelTextureSize({\r\n              optimizeFloatMemory: this.optimizeFloatMemory,\r\n              precision: this.precision,\r\n            }, this.output);\r\n            return;\r\n          }\r\n      \r\n          const { features } = this.constructor;\r\n          if (this.precision === 'single' && !features.isFloatRead) {\r\n            throw new Error('Float texture outputs are not supported');\r\n          } else if (!this.graphical && this.precision === null) {\r\n            this.precision = features.isFloatRead ? 'single' : 'unsigned';\r\n          }\r\n      \r\n          if (this.fixIntegerDivisionAccuracy === null) {\r\n            this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;\r\n          } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {\r\n            this.fixIntegerDivisionAccuracy = false;\r\n          }\r\n      \r\n          this.checkOutput();\r\n      \r\n          if (!this.output || this.output.length === 0) {\r\n            if (args.length !== 1) {\r\n              throw new Error('Auto output only supported for kernels with only one input');\r\n            }\r\n      \r\n            const argType = utils.getVariableType(args[0], this.strictIntegers);\r\n            switch (argType) {\r\n              case 'Array':\r\n                this.output = utils.getDimensions(argType);\r\n                break;\r\n              case 'NumberTexture':\r\n              case 'MemoryOptimizedNumberTexture':\r\n              case 'ArrayTexture(1)':\r\n              case 'ArrayTexture(2)':\r\n              case 'ArrayTexture(3)':\r\n              case 'ArrayTexture(4)':\r\n                this.output = args[0].output;\r\n                break;\r\n              default:\r\n                throw new Error('Auto output not supported for input type: ' + argType);\r\n            }\r\n          }\r\n      \r\n          if (this.graphical) {\r\n            if (this.output.length !== 2) {\r\n              throw new Error('Output must have 2 dimensions on graphical mode');\r\n            }\r\n      \r\n            if (this.precision === 'single') {\r\n              console.warn('Cannot use graphical mode and single precision at the same time');\r\n              this.precision = 'unsigned';\r\n            }\r\n      \r\n            this.texSize = utils.clone(this.output);\r\n            return;\r\n          } else if (!this.graphical && this.precision === null && features.isTextureFloat) {\r\n            this.precision = 'single';\r\n          }\r\n      \r\n          this.texSize = utils.getKernelTextureSize({\r\n            optimizeFloatMemory: this.optimizeFloatMemory,\r\n            precision: this.precision,\r\n          }, this.output);\r\n      \r\n          this.checkTextureSize();\r\n        }\r\n      \r\n        translateSource() {\r\n          const functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {\r\n            fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy\r\n          });\r\n          this.translatedSource = functionBuilder.getPrototypeString('kernel');\r\n          this.setupReturnTypes(functionBuilder);\r\n        }\r\n      \r\n        drawBuffers() {\r\n          this.context.drawBuffers(this.drawBuffersMap);\r\n        }\r\n      \r\n        getTextureFormat() {\r\n          const { context: gl } = this;\r\n          switch (this.getInternalFormat()) {\r\n            case gl.R32F:\r\n              return gl.RED;\r\n            case gl.RG32F:\r\n              return gl.RG;\r\n            case gl.RGBA32F:\r\n              return gl.RGBA;\r\n            case gl.RGBA:\r\n              return gl.RGBA;\r\n            default:\r\n              throw new Error('Unknown internal format');\r\n          }\r\n        }\r\n        getInternalFormat() {\r\n          const { context: gl } = this;\r\n      \r\n          if (this.precision === 'single') {\r\n            if (this.pipeline) {\r\n              switch (this.returnType) {\r\n                case 'Number':\r\n                case 'Float':\r\n                case 'Integer':\r\n                  if (this.optimizeFloatMemory) {\r\n                    return gl.RGBA32F;\r\n                  } else {\r\n                    return gl.R32F;\r\n                  }\r\n                  case 'Array(2)':\r\n                    return gl.RG32F;\r\n                  case 'Array(3)': \r\n                  case 'Array(4)':\r\n                    return gl.RGBA32F;\r\n                  default:\r\n                    throw new Error('Unhandled return type');\r\n              }\r\n            }\r\n            return gl.RGBA32F;\r\n          }\r\n          return gl.RGBA;\r\n        }\r\n      \r\n        _setupOutputTexture() {\r\n          const gl = this.context;\r\n          if (this.texture) {\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);\r\n            return;\r\n          }\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\r\n          const texture = gl.createTexture();\r\n          const texSize = this.texSize;\r\n          gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);\r\n          gl.bindTexture(gl.TEXTURE_2D, texture);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n          const format = this.getInternalFormat();\r\n          if (this.precision === 'single') {\r\n            gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);\r\n          } else {\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);\r\n          }\r\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n          this.texture = new this.TextureConstructor({\r\n            texture,\r\n            size: texSize,\r\n            dimensions: this.threadDim,\r\n            output: this.output,\r\n            context: this.context,\r\n            internalFormat: this.getInternalFormat(),\r\n            textureFormat: this.getTextureFormat(),\r\n            kernel: this,\r\n          });\r\n        }\r\n      \r\n        _setupSubOutputTextures() {\r\n          const gl = this.context;\r\n          if (this.mappedTextures) {\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);\r\n            }\r\n            return;\r\n          }\r\n          const texSize = this.texSize;\r\n          this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];\r\n          this.mappedTextures = [];\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const texture = this.createTexture();\r\n            this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);\r\n            gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n            const format = this.getInternalFormat();\r\n            if (this.precision === 'single') {\r\n              gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);\r\n            } else {\r\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n            }\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);\r\n      \r\n            this.mappedTextures.push(new this.TextureConstructor({\r\n              texture,\r\n              size: texSize,\r\n              dimensions: this.threadDim,\r\n              output: this.output,\r\n              context: this.context,\r\n              internalFormat: this.getInternalFormat(),\r\n              textureFormat: this.getTextureFormat(),\r\n              kernel: this,\r\n            }));\r\n          }\r\n        }\r\n      \r\n        _getHeaderString() {\r\n          return '';\r\n        }\r\n      \r\n        _getTextureCoordinate() {\r\n          const subKernels = this.subKernels;\r\n          const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);\r\n          if (subKernels === null || subKernels.length < 1) {\r\n            return `in ${ variablePrecision } vec2 vTexCoord;\\n`;\r\n          } else {\r\n            return `out ${ variablePrecision } vec2 vTexCoord;\\n`;\r\n          }\r\n        }\r\n      \r\n        _getMainArgumentsString(args) {\r\n          const result = [];\r\n          const argumentNames = this.argumentNames;\r\n          for (let i = 0; i < argumentNames.length; i++) {\r\n            result.push(this.kernelArguments[i].getSource(args[i]));\r\n          }\r\n          return result.join('');\r\n        }\r\n      \r\n        getKernelString() {\r\n          const result = [this.getKernelResultDeclaration()];\r\n          const subKernels = this.subKernels;\r\n          if (subKernels !== null) {\r\n            result.push(\r\n              'layout(location = 0) out vec4 data0'\r\n            );\r\n            switch (this.returnType) {\r\n              case 'Number':\r\n              case 'Float':\r\n              case 'Integer':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  const subKernel = subKernels[i];\r\n                  result.push(\r\n                    subKernel.returnType === 'Integer' ?\r\n                    `int subKernelResult_${ subKernel.name } = 0` :\r\n                    `float subKernelResult_${ subKernel.name } = 0.0`,\r\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(2)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec2 subKernelResult_${ subKernels[i].name }`,\r\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(3)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec3 subKernelResult_${ subKernels[i].name }`,\r\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(4)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec4 subKernelResult_${ subKernels[i].name }`,\r\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\r\n                  );\r\n                }\r\n                break;\r\n            }\r\n          } else {\r\n            result.push(\r\n              'out vec4 data0'\r\n            );\r\n          }\r\n      \r\n          return utils.linesToString(result) + this.translatedSource;\r\n        }\r\n      \r\n        getMainResultGraphical() {\r\n          return utils.linesToString([\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  data0 = actualColor',\r\n          ]);\r\n        }\r\n      \r\n        getMainResultPackedPixels() {\r\n          switch (this.returnType) {\r\n            case 'LiteralInteger':\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n              return this.getMainResultKernelPackedPixels() +\r\n                this.getMainResultSubKernelPackedPixels();\r\n            default:\r\n              throw new Error(`packed output only usable with Numbers, \"${this.returnType}\" specified`);\r\n          }\r\n        }\r\n      \r\n        getMainResultKernelPackedPixels() {\r\n          return utils.linesToString([\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            `  data0 = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`\r\n          ]);\r\n        }\r\n      \r\n        getMainResultSubKernelPackedPixels() {\r\n          const result = [];\r\n          if (!this.subKernels) return '';\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`\r\n              );\r\n            }\r\n          }\r\n          return utils.linesToString(result);\r\n        }\r\n      \r\n        getMainResultKernelMemoryOptimizedFloats(result, channel) {\r\n          result.push(\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            `  data0.${channel} = kernelResult`\r\n          );\r\n        }\r\n      \r\n        getMainResultSubKernelMemoryOptimizedFloats(result, channel) {\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  data${i + 1}.${channel} = float(subKernelResult_${subKernel.name})`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  data${i + 1}.${channel} = subKernelResult_${subKernel.name}`\r\n              );\r\n            }\r\n          }\r\n        }\r\n      \r\n        getMainResultKernelNumberTexture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  data0[0] = kernelResult',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelNumberTexture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  data${i + 1}[0] = float(subKernelResult_${subKernel.name})`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  data${i + 1}[0] = subKernelResult_${subKernel.name}`\r\n              );\r\n            }\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray2Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  data0[0] = kernelResult[0]',\r\n            '  data0[1] = kernelResult[1]',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray2Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            const subKernel = this.subKernels[i];\r\n            result.push(\r\n              `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,\r\n              `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`\r\n            );\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray3Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  data0[0] = kernelResult[0]',\r\n            '  data0[1] = kernelResult[1]',\r\n            '  data0[2] = kernelResult[2]',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray3Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            const subKernel = this.subKernels[i];\r\n            result.push(\r\n              `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,\r\n              `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,\r\n              `  data${i + 1}[2] = subKernelResult_${subKernel.name}[2]`\r\n            );\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray4Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  data0 = kernelResult',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray4Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            result.push(\r\n              `  data${i + 1} = subKernelResult_${this.subKernels[i].name}`\r\n            );\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        destroyExtensions() {\r\n          this.extensions.EXT_color_buffer_float = null;\r\n          this.extensions.OES_texture_float_linear = null;\r\n        }\r\n      \r\n        toJSON() {\r\n          const json = super.toJSON();\r\n          json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();\r\n          json.settings.threadDim = this.threadDim;\r\n          return json;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2Kernel\r\n      };\r\n      },{\"../../utils\":114,\"../function-builder\":9,\"../web-gl/kernel\":70,\"./fragment-shader\":72,\"./function-node\":73,\"./kernel-value-maps\":74,\"./vertex-shader\":106}],106:[function(require,module,exports){\r\n      const vertexShader = `#version 300 es\r\n      __FLOAT_TACTIC_DECLARATION__;\r\n      __INT_TACTIC_DECLARATION__;\r\n      __SAMPLER_2D_TACTIC_DECLARATION__;\r\n      \r\n      in vec2 aPos;\r\n      in vec2 aTexCoord;\r\n      \r\n      out vec2 vTexCoord;\r\n      uniform vec2 ratio;\r\n      \r\n      void main(void) {\r\n        gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\r\n        vTexCoord = aTexCoord;\r\n      }`;\r\n      \r\n      module.exports = {\r\n        vertexShader\r\n      };\r\n      },{}],107:[function(require,module,exports){\r\n      const lib = require('./index');\r\n      const GPU = lib.GPU;\r\n      for (const p in lib) {\r\n        if (!lib.hasOwnProperty(p)) continue;\r\n        if (p === 'GPU') continue; \r\n        GPU[p] = lib[p];\r\n      }\r\n      \r\n      if (typeof window !== 'undefined') {\r\n        bindTo(window);\r\n      }\r\n      if (typeof self !== 'undefined') {\r\n        bindTo(self);\r\n      }\r\n      \r\n      function bindTo(target) {\r\n        if (target.GPU) return;\r\n        Object.defineProperty(target, 'GPU', {\r\n          get() {\r\n            return GPU;\r\n          }\r\n        });\r\n      }\r\n      \r\n      module.exports = lib;\r\n      },{\"./index\":109}],108:[function(require,module,exports){\r\n      const { gpuMock } = require('gpu-mock.js');\r\n      const { utils } = require('./utils');\r\n      const { Kernel } = require('./backend/kernel');\r\n      const { CPUKernel } = require('./backend/cpu/kernel');\r\n      const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');\r\n      const { WebGL2Kernel } = require('./backend/web-gl2/kernel');\r\n      const { WebGLKernel } = require('./backend/web-gl/kernel');\r\n      const { kernelRunShortcut } = require('./kernel-run-shortcut');\r\n      \r\n      \r\n      const kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];\r\n      \r\n      const kernelTypes = ['gpu', 'cpu'];\r\n      \r\n      const internalKernels = {\r\n        'headlessgl': HeadlessGLKernel,\r\n        'webgl2': WebGL2Kernel,\r\n        'webgl': WebGLKernel,\r\n      };\r\n      \r\n      let validate = true;\r\n      \r\n      class GPU {\r\n        static disableValidation() {\r\n          validate = false;\r\n        }\r\n      \r\n        static enableValidation() {\r\n          validate = true;\r\n        }\r\n      \r\n        static get isGPUSupported() {\r\n          return kernelOrder.some(Kernel => Kernel.isSupported);\r\n        }\r\n      \r\n        static get isKernelMapSupported() {\r\n          return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.kernelMap);\r\n        }\r\n      \r\n        static get isOffscreenCanvasSupported() {\r\n          return (typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined') || typeof importScripts !== 'undefined';\r\n        }\r\n      \r\n        static get isWebGLSupported() {\r\n          return WebGLKernel.isSupported;\r\n        }\r\n      \r\n        static get isWebGL2Supported() {\r\n          return WebGL2Kernel.isSupported;\r\n        }\r\n      \r\n        static get isHeadlessGLSupported() {\r\n          return HeadlessGLKernel.isSupported;\r\n        }\r\n      \r\n        static get isCanvasSupported() {\r\n          return typeof HTMLCanvasElement !== 'undefined';\r\n        }\r\n      \r\n        static get isGPUHTMLImageArraySupported() {\r\n          return WebGL2Kernel.isSupported;\r\n        }\r\n      \r\n        static get isSinglePrecisionSupported() {\r\n          return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat);\r\n        }\r\n      \r\n        constructor(settings) {\r\n          settings = settings || {};\r\n          this.canvas = settings.canvas || null;\r\n          this.context = settings.context || null;\r\n          this.mode = settings.mode;\r\n          this.Kernel = null;\r\n          this.kernels = [];\r\n          this.functions = [];\r\n          this.nativeFunctions = [];\r\n          this.injectedNative = null;\r\n          if (this.mode === 'dev') return;\r\n          this.chooseKernel();\r\n          if (settings.functions) {\r\n            for (let i = 0; i < settings.functions.length; i++) {\r\n              this.addFunction(settings.functions[i]);\r\n            }\r\n          }\r\n      \r\n          if (settings.nativeFunctions) {\r\n            for (const p in settings.nativeFunctions) {\r\n              if (!settings.nativeFunctions.hasOwnProperty(p)) continue;\r\n              const s = settings.nativeFunctions[p];\r\n              const { name, source } = s;\r\n              this.addNativeFunction(name, source, s);\r\n            }\r\n          }\r\n        }\r\n      \r\n        chooseKernel() {\r\n          if (this.Kernel) return;\r\n      \r\n          let Kernel = null;\r\n      \r\n          if (this.context) {\r\n            for (let i = 0; i < kernelOrder.length; i++) {\r\n              const ExternalKernel = kernelOrder[i];\r\n              if (ExternalKernel.isContextMatch(this.context)) {\r\n                if (!ExternalKernel.isSupported) {\r\n                  throw new Error(`Kernel type ${ExternalKernel.name} not supported`);\r\n                }\r\n                Kernel = ExternalKernel;\r\n                break;\r\n              }\r\n            }\r\n            if (Kernel === null) {\r\n              throw new Error('unknown Context');\r\n            }\r\n          } else if (this.mode) {\r\n            if (this.mode in internalKernels) {\r\n              if (!validate || internalKernels[this.mode].isSupported) {\r\n                Kernel = internalKernels[this.mode];\r\n              }\r\n            } else if (this.mode === 'gpu') {\r\n              for (let i = 0; i < kernelOrder.length; i++) {\r\n                if (kernelOrder[i].isSupported) {\r\n                  Kernel = kernelOrder[i];\r\n                  break;\r\n                }\r\n              }\r\n            } else if (this.mode === 'cpu') {\r\n              Kernel = CPUKernel;\r\n            }\r\n            if (!Kernel) {\r\n              throw new Error(`A requested mode of \"${this.mode}\" and is not supported`);\r\n            }\r\n          } else {\r\n            for (let i = 0; i < kernelOrder.length; i++) {\r\n              if (kernelOrder[i].isSupported) {\r\n                Kernel = kernelOrder[i];\r\n                break;\r\n              }\r\n            }\r\n            if (!Kernel) {\r\n              Kernel = CPUKernel;\r\n            }\r\n          }\r\n      \r\n          if (!this.mode) {\r\n            this.mode = Kernel.mode;\r\n          }\r\n          this.Kernel = Kernel;\r\n        }\r\n      \r\n        createKernel(source, settings) {\r\n          if (typeof source === 'undefined') {\r\n            throw new Error('Missing source parameter');\r\n          }\r\n          if (typeof source !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {\r\n            throw new Error('source parameter not a function');\r\n          }\r\n      \r\n          const kernels = this.kernels;\r\n          if (this.mode === 'dev') {\r\n            const devKernel = gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));\r\n            kernels.push(devKernel);\r\n            return devKernel;\r\n          }\r\n      \r\n          source = typeof source === 'function' ? source.toString() : source;\r\n          const switchableKernels = {};\r\n          const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings) || {};\r\n          if (settings && typeof settings.argumentTypes === 'object') {\r\n            settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);\r\n          }\r\n      \r\n          function onRequestFallback(args) {\r\n            console.warn('Falling back to CPU');\r\n            const fallbackKernel = new CPUKernel(source, {\r\n              argumentTypes: kernelRun.argumentTypes,\r\n              constantTypes: kernelRun.constantTypes,\r\n              graphical: kernelRun.graphical,\r\n              loopMaxIterations: kernelRun.loopMaxIterations,\r\n              constants: kernelRun.constants,\r\n              dynamicOutput: kernelRun.dynamicOutput,\r\n              dynamicArgument: kernelRun.dynamicArguments,\r\n              output: kernelRun.output,\r\n              precision: kernelRun.precision,\r\n              pipeline: kernelRun.pipeline,\r\n              immutable: kernelRun.immutable,\r\n              optimizeFloatMemory: kernelRun.optimizeFloatMemory,\r\n              fixIntegerDivisionAccuracy: kernelRun.fixIntegerDivisionAccuracy,\r\n              functions: kernelRun.functions,\r\n              nativeFunctions: kernelRun.nativeFunctions,\r\n              injectedNative: kernelRun.injectedNative,\r\n              subKernels: kernelRun.subKernels,\r\n              strictIntegers: kernelRun.strictIntegers,\r\n              debug: kernelRun.debug,\r\n            });\r\n            fallbackKernel.build.apply(fallbackKernel, args);\r\n            const result = fallbackKernel.run.apply(fallbackKernel, args);\r\n            kernelRun.replaceKernel(fallbackKernel);\r\n            return result;\r\n          }\r\n      \r\n          function onRequestSwitchKernel(reasons, args, _kernel) {\r\n            if (_kernel.debug) {\r\n              console.warn('Switching kernels');\r\n            }\r\n            let newOutput = null;\r\n            if (_kernel.signature && !switchableKernels[_kernel.signature]) {\r\n              switchableKernels[_kernel.signature] = _kernel;\r\n            }\r\n            if (_kernel.dynamicOutput) {\r\n              for (let i = reasons.length - 1; i >= 0; i--) {\r\n                const reason = reasons[i];\r\n                if (reason.type === 'outputPrecisionMismatch') {\r\n                  newOutput = reason.needed;\r\n                }\r\n              }\r\n            }\r\n      \r\n            const Constructor = _kernel.constructor;\r\n            const argumentTypes = Constructor.getArgumentTypes(_kernel, args);\r\n            const signature = Constructor.getSignature(_kernel, argumentTypes);\r\n            const existingKernel = switchableKernels[signature];\r\n            if (existingKernel) {\r\n              existingKernel.onActivate(_kernel);\r\n              return existingKernel;\r\n            }\r\n      \r\n            const newKernel = switchableKernels[signature] = new Constructor(source, {\r\n              argumentTypes,\r\n              constantTypes: _kernel.constantTypes,\r\n              graphical: _kernel.graphical,\r\n              loopMaxIterations: _kernel.loopMaxIterations,\r\n              constants: _kernel.constants,\r\n              dynamicOutput: _kernel.dynamicOutput,\r\n              dynamicArgument: _kernel.dynamicArguments,\r\n              context: _kernel.context,\r\n              canvas: _kernel.canvas,\r\n              output: newOutput || _kernel.output,\r\n              precision: _kernel.precision,\r\n              pipeline: _kernel.pipeline,\r\n              immutable: _kernel.immutable,\r\n              optimizeFloatMemory: _kernel.optimizeFloatMemory,\r\n              fixIntegerDivisionAccuracy: _kernel.fixIntegerDivisionAccuracy,\r\n              functions: _kernel.functions,\r\n              nativeFunctions: _kernel.nativeFunctions,\r\n              injectedNative: _kernel.injectedNative,\r\n              subKernels: _kernel.subKernels,\r\n              strictIntegers: _kernel.strictIntegers,\r\n              debug: _kernel.debug,\r\n              gpu: _kernel.gpu,\r\n              validate,\r\n              returnType: _kernel.returnType,\r\n              tactic: _kernel.tactic,\r\n              onRequestFallback,\r\n              onRequestSwitchKernel,\r\n              texture: _kernel.texture,\r\n              mappedTextures: _kernel.mappedTextures,\r\n              drawBuffersMap: _kernel.drawBuffersMap,\r\n            });\r\n            newKernel.build.apply(newKernel, args);\r\n            kernelRun.replaceKernel(newKernel);\r\n            kernels.push(newKernel);\r\n            return newKernel;\r\n          }\r\n          const mergedSettings = Object.assign({\r\n            context: this.context,\r\n            canvas: this.canvas,\r\n            functions: this.functions,\r\n            nativeFunctions: this.nativeFunctions,\r\n            injectedNative: this.injectedNative,\r\n            gpu: this,\r\n            validate,\r\n            onRequestFallback,\r\n            onRequestSwitchKernel\r\n          }, settingsCopy);\r\n      \r\n          const kernel = new this.Kernel(source, mergedSettings);\r\n          const kernelRun = kernelRunShortcut(kernel);\r\n      \r\n          if (!this.canvas) {\r\n            this.canvas = kernel.canvas;\r\n          }\r\n      \r\n          if (!this.context) {\r\n            this.context = kernel.context;\r\n          }\r\n      \r\n          kernels.push(kernel);\r\n      \r\n          return kernelRun;\r\n        }\r\n      \r\n        createKernelMap() {\r\n          let fn;\r\n          let settings;\r\n          const argument2Type = typeof arguments[arguments.length - 2];\r\n          if (argument2Type === 'function' || argument2Type === 'string') {\r\n            fn = arguments[arguments.length - 2];\r\n            settings = arguments[arguments.length - 1];\r\n          } else {\r\n            fn = arguments[arguments.length - 1];\r\n          }\r\n      \r\n          if (this.mode !== 'dev') {\r\n            if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {\r\n              if (this.mode && kernelTypes.indexOf(this.mode) < 0) {\r\n                throw new Error(`kernelMap not supported on ${this.Kernel.name}`);\r\n              }\r\n            }\r\n          }\r\n      \r\n          const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings);\r\n          if (settings && typeof settings.argumentTypes === 'object') {\r\n            settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);\r\n          }\r\n      \r\n          if (Array.isArray(arguments[0])) {\r\n            settingsCopy.subKernels = [];\r\n            const functions = arguments[0];\r\n            for (let i = 0; i < functions.length; i++) {\r\n              const source = functions[i].toString();\r\n              const name = utils.getFunctionNameFromString(source);\r\n              settingsCopy.subKernels.push({\r\n                name,\r\n                source,\r\n                property: i,\r\n              });\r\n            }\r\n          } else {\r\n            settingsCopy.subKernels = [];\r\n            const functions = arguments[0];\r\n            for (let p in functions) {\r\n              if (!functions.hasOwnProperty(p)) continue;\r\n              const source = functions[p].toString();\r\n              const name = utils.getFunctionNameFromString(source);\r\n              settingsCopy.subKernels.push({\r\n                name: name || p,\r\n                source,\r\n                property: p,\r\n              });\r\n            }\r\n          }\r\n          return this.createKernel(fn, settingsCopy);\r\n        }\r\n      \r\n        combineKernels() {\r\n          const firstKernel = arguments[0];\r\n          const combinedKernel = arguments[arguments.length - 1];\r\n          if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;\r\n          const canvas = arguments[0].canvas;\r\n          const context = arguments[0].context;\r\n          const max = arguments.length - 1;\r\n          for (let i = 0; i < max; i++) {\r\n            arguments[i]\r\n              .setCanvas(canvas)\r\n              .setContext(context)\r\n              .setPipeline(true);\r\n          }\r\n      \r\n          return function() {\r\n            const texture = combinedKernel.apply(this, arguments);\r\n            if (texture.toArray) {\r\n              return texture.toArray();\r\n            }\r\n            return texture;\r\n          };\r\n        }\r\n      \r\n        setFunctions(functions) {\r\n          this.functions = functions;\r\n          return this;\r\n        }\r\n      \r\n        setNativeFunctions(nativeFunctions) {\r\n          this.nativeFunctions = nativeFunctions;\r\n          return this;\r\n        }\r\n      \r\n        addFunction(source, settings) {\r\n          this.functions.push({ source, settings });\r\n          return this;\r\n        }\r\n      \r\n        addNativeFunction(name, source, settings) {\r\n          if (this.kernels.length > 0) {\r\n            throw new Error('Cannot call \"addNativeFunction\" after \"createKernels\" has been called.');\r\n          }\r\n          this.nativeFunctions.push(Object.assign({ name, source }, settings));\r\n          return this;\r\n        }\r\n      \r\n        injectNative(source) {\r\n          this.injectedNative = source;\r\n          return this;\r\n        }\r\n      \r\n        destroy() {\r\n          return new Promise((resolve, reject) => {\r\n            if (!this.kernels) {\r\n              resolve();\r\n            }\r\n            setTimeout(() => {\r\n              try {\r\n                for (let i = 0; i < this.kernels.length; i++) {\r\n                  this.kernels[i].destroy(true); \r\n                }\r\n                let firstKernel = this.kernels[0];\r\n                if (firstKernel) {\r\n                  if (firstKernel.kernel) {\r\n                    firstKernel = firstKernel.kernel;\r\n                  }\r\n                  if (firstKernel.constructor.destroyContext) {\r\n                    firstKernel.constructor.destroyContext(this.context);\r\n                  }\r\n                }\r\n              } catch (e) {\r\n                reject(e);\r\n              }\r\n              resolve();\r\n            }, 0);\r\n          });\r\n        }\r\n      }\r\n      \r\n      \r\n      function upgradeDeprecatedCreateKernelSettings(settings) {\r\n        if (!settings) {\r\n          return {};\r\n        }\r\n        const upgradedSettings = Object.assign({}, settings);\r\n      \r\n        if (settings.hasOwnProperty('floatOutput')) {\r\n          utils.warnDeprecated('setting', 'floatOutput', 'precision');\r\n          upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';\r\n        }\r\n        if (settings.hasOwnProperty('outputToTexture')) {\r\n          utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');\r\n          upgradedSettings.pipeline = Boolean(settings.outputToTexture);\r\n        }\r\n        if (settings.hasOwnProperty('outputImmutable')) {\r\n          utils.warnDeprecated('setting', 'outputImmutable', 'immutable');\r\n          upgradedSettings.immutable = Boolean(settings.outputImmutable);\r\n        }\r\n        if (settings.hasOwnProperty('floatTextures')) {\r\n          utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');\r\n          upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);\r\n        }\r\n        return upgradedSettings;\r\n      }\r\n      \r\n      module.exports = {\r\n        GPU,\r\n        kernelOrder,\r\n        kernelTypes\r\n      };\r\n      },{\"./backend/cpu/kernel\":8,\"./backend/headless-gl/kernel\":34,\"./backend/kernel\":36,\"./backend/web-gl/kernel\":70,\"./backend/web-gl2/kernel\":105,\"./kernel-run-shortcut\":111,\"./utils\":114,\"gpu-mock.js\":4}],109:[function(require,module,exports){\r\n      const { GPU } = require('./gpu');\r\n      const { alias } = require('./alias');\r\n      const { utils } = require('./utils');\r\n      const { Input, input } = require('./input');\r\n      const { Texture } = require('./texture');\r\n      const { FunctionBuilder } = require('./backend/function-builder');\r\n      const { FunctionNode } = require('./backend/function-node');\r\n      const { CPUFunctionNode } = require('./backend/cpu/function-node');\r\n      const { CPUKernel } = require('./backend/cpu/kernel');\r\n      \r\n      const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');\r\n      \r\n      const { WebGLFunctionNode } = require('./backend/web-gl/function-node');\r\n      const { WebGLKernel } = require('./backend/web-gl/kernel');\r\n      const { kernelValueMaps: webGLKernelValueMaps } = require('./backend/web-gl/kernel-value-maps');\r\n      \r\n      const { WebGL2FunctionNode } = require('./backend/web-gl2/function-node');\r\n      const { WebGL2Kernel } = require('./backend/web-gl2/kernel');\r\n      const { kernelValueMaps: webGL2KernelValueMaps } = require('./backend/web-gl2/kernel-value-maps');\r\n      \r\n      const { GLKernel } = require('./backend/gl/kernel');\r\n      \r\n      const { Kernel } = require('./backend/kernel');\r\n      \r\n      const { FunctionTracer } = require('./backend/function-tracer');\r\n      \r\n      const mathRandom = require('./plugins/math-random-uniformly-distributed');\r\n      \r\n      module.exports = {\r\n        alias,\r\n        CPUFunctionNode,\r\n        CPUKernel,\r\n        GPU,\r\n        FunctionBuilder,\r\n        FunctionNode,\r\n        HeadlessGLKernel,\r\n        Input,\r\n        input,\r\n        Texture,\r\n        utils,\r\n      \r\n        WebGL2FunctionNode,\r\n        WebGL2Kernel,\r\n        webGL2KernelValueMaps,\r\n      \r\n        WebGLFunctionNode,\r\n        WebGLKernel,\r\n        webGLKernelValueMaps,\r\n      \r\n        GLKernel,\r\n        Kernel,\r\n        FunctionTracer,\r\n      \r\n        plugins: {\r\n          mathRandom\r\n        }\r\n      };\r\n      },{\"./alias\":5,\"./backend/cpu/function-node\":6,\"./backend/cpu/kernel\":8,\"./backend/function-builder\":9,\"./backend/function-node\":10,\"./backend/function-tracer\":11,\"./backend/gl/kernel\":13,\"./backend/headless-gl/kernel\":34,\"./backend/kernel\":36,\"./backend/web-gl/function-node\":38,\"./backend/web-gl/kernel\":70,\"./backend/web-gl/kernel-value-maps\":39,\"./backend/web-gl2/function-node\":73,\"./backend/web-gl2/kernel\":105,\"./backend/web-gl2/kernel-value-maps\":74,\"./gpu\":108,\"./input\":110,\"./plugins/math-random-uniformly-distributed\":112,\"./texture\":113,\"./utils\":114}],110:[function(require,module,exports){\r\n      class Input {\r\n        constructor(value, size) {\r\n          this.value = value;\r\n          if (Array.isArray(size)) {\r\n            this.size = size;\r\n          } else {\r\n            this.size = new Int32Array(3);\r\n            if (size.z) {\r\n              this.size = new Int32Array([size.x, size.y, size.z]);\r\n            } else if (size.y) {\r\n              this.size = new Int32Array([size.x, size.y]);\r\n            } else {\r\n              this.size = new Int32Array([size.x]);\r\n            }\r\n          }\r\n      \r\n          const [w, h, d] = this.size;\r\n          if (d) {\r\n            if (this.value.length !== (w * h * d)) {\r\n              throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} * ${d} = ${(h * w * d)}`);\r\n            }\r\n          } else if (h) {\r\n            if (this.value.length !== (w * h)) {\r\n              throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} = ${(h * w)}`);\r\n            }\r\n          } else {\r\n            if (this.value.length !== w) {\r\n              throw new Error(`Input size ${this.value.length} does not match ${w}`);\r\n            }\r\n          }\r\n      \r\n        }\r\n      \r\n        toArray() {\r\n          const { utils } = require('./utils');\r\n          const [w, h, d] = this.size;\r\n          if (d) {\r\n            return utils.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h, d);\r\n          } else if (h) {\r\n            return utils.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h);\r\n          } else {\r\n            return this.value;\r\n          }\r\n        }\r\n      }\r\n      \r\n      function input(value, size) {\r\n        return new Input(value, size);\r\n      }\r\n      \r\n      module.exports = {\r\n        Input,\r\n        input\r\n      };\r\n      },{\"./utils\":114}],111:[function(require,module,exports){\r\n      const { utils } = require('./utils');\r\n      \r\n      function kernelRunShortcut(kernel) {\r\n        let run = function() {\r\n          kernel.build.apply(kernel, arguments);\r\n          run = function() {\r\n            let result = kernel.run.apply(kernel, arguments);\r\n            if (kernel.switchingKernels) {\r\n              const reasons = kernel.resetSwitchingKernels();\r\n              const newKernel = kernel.onRequestSwitchKernel(reasons, arguments, kernel);\r\n              shortcut.kernel = kernel = newKernel;\r\n              result = newKernel.run.apply(newKernel, arguments);\r\n            }\r\n            if (kernel.renderKernels) {\r\n              return kernel.renderKernels();\r\n            } else if (kernel.renderOutput) {\r\n              return kernel.renderOutput();\r\n            } else {\r\n              return result;\r\n            }\r\n          };\r\n          return run.apply(kernel, arguments);\r\n        };\r\n        const shortcut = function() {\r\n          return run.apply(kernel, arguments);\r\n        };\r\n        shortcut.exec = function() {\r\n          return new Promise((accept, reject) => {\r\n            try {\r\n              accept(run.apply(this, arguments));\r\n            } catch (e) {\r\n              reject(e);\r\n            }\r\n          });\r\n        };\r\n        shortcut.replaceKernel = function(replacementKernel) {\r\n          kernel = replacementKernel;\r\n          bindKernelToShortcut(kernel, shortcut);\r\n        };\r\n      \r\n        bindKernelToShortcut(kernel, shortcut);\r\n        return shortcut;\r\n      }\r\n      \r\n      function bindKernelToShortcut(kernel, shortcut) {\r\n        if (shortcut.kernel) {\r\n          shortcut.kernel = kernel;\r\n          return;\r\n        }\r\n        const properties = utils.allPropertiesOf(kernel);\r\n        for (let i = 0; i < properties.length; i++) {\r\n          const property = properties[i];\r\n          if (property[0] === '_' && property[1] === '_') continue;\r\n          if (typeof kernel[property] === 'function') {\r\n            if (property.substring(0, 3) === 'add' || property.substring(0, 3) === 'set') {\r\n              shortcut[property] = function() {\r\n                shortcut.kernel[property].apply(shortcut.kernel, arguments);\r\n                return shortcut;\r\n              };\r\n            } else {\r\n              shortcut[property] = function() {\r\n                return shortcut.kernel[property].apply(shortcut.kernel, arguments);\r\n              };\r\n            }\r\n          } else {\r\n            shortcut.__defineGetter__(property, () => shortcut.kernel[property]);\r\n            shortcut.__defineSetter__(property, (value) => {\r\n              shortcut.kernel[property] = value;\r\n            });\r\n          }\r\n        }\r\n        shortcut.kernel = kernel;\r\n      }\r\n      module.exports = {\r\n        kernelRunShortcut\r\n      };\r\n      },{\"./utils\":114}],112:[function(require,module,exports){\r\n      const source = `// https://www.shadertoy.com/view/4t2SDh\r\n      //note: uniformly distributed, normalized rand, [0,1]\r\n      highp float randomSeedShift = 1.0;\r\n      highp float slide = 1.0;\r\n      uniform highp float randomSeed1;\r\n      uniform highp float randomSeed2;\r\n      \r\n      highp float nrand(highp vec2 n) {\r\n        highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);\r\n        randomSeedShift = result;\r\n        if (randomSeedShift > 0.5) {\r\n          slide += 0.00009; \r\n        } else {\r\n          slide += 0.0009;\r\n        }\r\n        return result;\r\n      }`;\r\n      \r\n      const name = 'math-random-uniformly-distributed';\r\n      \r\n      const functionMatch = `Math.random()`;\r\n      \r\n      const functionReplace = `nrand(vTexCoord)`;\r\n      \r\n      const functionReturnType = 'Number';\r\n      const onBeforeRun = (kernel) => {\r\n        kernel.setUniform1f('randomSeed1', Math.random());\r\n        kernel.setUniform1f('randomSeed2', Math.random());\r\n      };\r\n      \r\n      const plugin = {\r\n        name,\r\n        onBeforeRun,\r\n        functionMatch,\r\n        functionReplace,\r\n        functionReturnType,\r\n        source\r\n      };\r\n      \r\n      module.exports = plugin;\r\n      },{}],113:[function(require,module,exports){\r\n      class Texture {\r\n        constructor(settings) {\r\n          const {\r\n            texture,\r\n            size,\r\n            dimensions,\r\n            output,\r\n            context,\r\n            type = 'NumberTexture',\r\n            kernel,\r\n            internalFormat,\r\n            textureFormat\r\n          } = settings;\r\n          if (!output) throw new Error('settings property \"output\" required.');\r\n          if (!context) throw new Error('settings property \"context\" required.');\r\n          if (!texture) throw new Error('settings property \"texture\" required.');\r\n          if (!kernel) throw new Error('settings property \"kernel\" required.');\r\n          this.texture = texture;\r\n          if (texture._refs) {\r\n            texture._refs++;\r\n          } else {\r\n            texture._refs = 1;\r\n          }\r\n          this.size = size;\r\n          this.dimensions = dimensions;\r\n          this.output = output;\r\n          this.context = context;\r\n          this.kernel = kernel;\r\n          this.type = type;\r\n          this._deleted = false;\r\n          this.internalFormat = internalFormat;\r\n          this.textureFormat = textureFormat;\r\n        }\r\n      \r\n        toArray() {\r\n          throw new Error(`Not implemented on ${this.constructor.name}`);\r\n        }\r\n      \r\n        clone() {\r\n          throw new Error(`Not implemented on ${this.constructor.name}`);\r\n        }\r\n      \r\n        delete() {\r\n          throw new Error(`Not implemented on ${this.constructor.name}`);\r\n        }\r\n      \r\n        clear() {\r\n          throw new Error(`Not implemented on ${this.constructor.name}`);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        Texture\r\n      };\r\n      },{}],114:[function(require,module,exports){\r\n      const acorn = require('acorn');\r\n      const { Input } = require('./input');\r\n      const { Texture } = require('./texture');\r\n      \r\n      const FUNCTION_NAME = /function ([^(]*)/;\r\n      const STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\r\n      const ARGUMENT_NAMES = /([^\\s,]+)/g;\r\n      \r\n      const utils = {\r\n        systemEndianness() {\r\n          return _systemEndianness;\r\n        },\r\n        getSystemEndianness() {\r\n          const b = new ArrayBuffer(4);\r\n          const a = new Uint32Array(b);\r\n          const c = new Uint8Array(b);\r\n          a[0] = 0xdeadbeef;\r\n          if (c[0] === 0xef) return 'LE';\r\n          if (c[0] === 0xde) return 'BE';\r\n          throw new Error('unknown endianness');\r\n        },\r\n      \r\n        isFunction(funcObj) {\r\n          return typeof(funcObj) === 'function';\r\n        },\r\n      \r\n        isFunctionString(fn) {\r\n          if (typeof fn === 'string') {\r\n            return (fn\r\n              .slice(0, 'function'.length)\r\n              .toLowerCase() === 'function');\r\n          }\r\n          return false;\r\n        },\r\n      \r\n        getFunctionNameFromString(funcStr) {\r\n          const result = FUNCTION_NAME.exec(funcStr);\r\n          if (!result || result.length === 0) return null;\r\n          return result[1].trim();\r\n        },\r\n      \r\n        getFunctionBodyFromString(funcStr) {\r\n          return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));\r\n        },\r\n      \r\n        getArgumentNamesFromString(fn) {\r\n          const fnStr = fn.replace(STRIP_COMMENTS, '');\r\n          let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\r\n          if (result === null) {\r\n            result = [];\r\n          }\r\n          return result;\r\n        },\r\n      \r\n        clone(obj) {\r\n          if (obj === null || typeof obj !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;\r\n      \r\n          const temp = obj.constructor(); \r\n      \r\n          for (let key in obj) {\r\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n              obj.isActiveClone = null;\r\n              temp[key] = utils.clone(obj[key]);\r\n              delete obj.isActiveClone;\r\n            }\r\n          }\r\n      \r\n          return temp;\r\n        },\r\n      \r\n        isArray(array) {\r\n          return !isNaN(array.length);\r\n        },\r\n      \r\n        getVariableType(value, strictIntegers) {\r\n          if (utils.isArray(value)) {\r\n            if (value.length > 0 && value[0].nodeName === 'IMG') {\r\n              return 'HTMLImageArray';\r\n            }\r\n            return 'Array';\r\n          }\r\n      \r\n          switch (value.constructor) {\r\n            case Boolean:\r\n              return 'Boolean';\r\n            case Number:\r\n              if (strictIntegers && Number.isInteger(value)) {\r\n                return 'Integer';\r\n              }\r\n              return 'Float';\r\n            case Texture:\r\n              return value.type;\r\n            case Input:\r\n              return 'Input';\r\n          }\r\n          switch (value.nodeName) {\r\n            case 'IMG':\r\n              return 'HTMLImage';\r\n            case 'CANVAS':\r\n              return 'HTMLImage';\r\n            case 'VIDEO':\r\n              return 'HTMLVideo';\r\n          }\r\n          if (value.hasOwnProperty('type')) {\r\n            return value.type;\r\n          }\r\n          return 'Unknown';\r\n        },\r\n      \r\n        getKernelTextureSize(settings, dimensions) {\r\n          let [w, h, d] = dimensions;\r\n          let texelCount = (w || 1) * (h || 1) * (d || 1);\r\n      \r\n          if (settings.optimizeFloatMemory && settings.precision === 'single') {\r\n            w = texelCount = Math.ceil(texelCount / 4);\r\n          }\r\n          if (h > 1 && w * h === texelCount) {\r\n            return new Int32Array([w, h]);\r\n          }\r\n          return utils.closestSquareDimensions(texelCount);\r\n        },\r\n      \r\n        closestSquareDimensions(length) {\r\n          const sqrt = Math.sqrt(length);\r\n          let high = Math.ceil(sqrt);\r\n          let low = Math.floor(sqrt);\r\n          while (high * low < length) {\r\n            high--;\r\n            low = Math.ceil(length / high);\r\n          }\r\n          return new Int32Array([low, Math.ceil(length / low)]);\r\n        },\r\n      \r\n        getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {\r\n          const totalArea = utils.roundTo((dimensions[0] || 1) * (dimensions[1] || 1) * (dimensions[2] || 1) * (dimensions[3] || 1), 4);\r\n          const texelCount = totalArea / bitRatio;\r\n          return utils.closestSquareDimensions(texelCount);\r\n        },\r\n      \r\n        getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {\r\n          const [w, h, d] = dimensions;\r\n          const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);\r\n          const texelCount = totalArea / (4 / bitRatio);\r\n          return utils.closestSquareDimensions(texelCount);\r\n        },\r\n      \r\n        roundTo(n, d) {\r\n          return Math.floor((n + d - 1) / d) * d;\r\n        },\r\n        getDimensions(x, pad) {\r\n          let ret;\r\n          if (utils.isArray(x)) {\r\n            const dim = [];\r\n            let temp = x;\r\n            while (utils.isArray(temp)) {\r\n              dim.push(temp.length);\r\n              temp = temp[0];\r\n            }\r\n            ret = dim.reverse();\r\n          } else if (x instanceof Texture) {\r\n            ret = x.output;\r\n          } else if (x instanceof Input) {\r\n            ret = x.size;\r\n          } else {\r\n            throw new Error(`Unknown dimensions of ${x}`);\r\n          }\r\n      \r\n          if (pad) {\r\n            ret = Array.from(ret);\r\n            while (ret.length < 3) {\r\n              ret.push(1);\r\n            }\r\n          }\r\n      \r\n          return new Int32Array(ret);\r\n        },\r\n      \r\n        flatten2dArrayTo(array, target) {\r\n          let offset = 0;\r\n          for (let y = 0; y < array.length; y++) {\r\n            target.set(array[y], offset);\r\n            offset += array[y].length;\r\n          }\r\n        },\r\n      \r\n        flatten3dArrayTo(array, target) {\r\n          let offset = 0;\r\n          for (let z = 0; z < array.length; z++) {\r\n            for (let y = 0; y < array[z].length; y++) {\r\n              target.set(array[z][y], offset);\r\n              offset += array[z][y].length;\r\n            }\r\n          }\r\n        },\r\n      \r\n        flatten4dArrayTo(array, target) {\r\n          let offset = 0;\r\n          for (let l = 0; l < array.length; l++) {\r\n            for (let z = 0; z < array[l].length; z++) {\r\n              for (let y = 0; y < array[l][z].length; y++) {\r\n                target.set(array[l][z][y], offset);\r\n                offset += array[l][z][y].length;\r\n              }\r\n            }\r\n          }\r\n        },\r\n      \r\n        flattenTo(array, target) {\r\n          if (utils.isArray(array[0])) {\r\n            if (utils.isArray(array[0][0])) {\r\n              if (utils.isArray(array[0][0][0])) {\r\n                utils.flatten4dArrayTo(array, target);\r\n              } else {\r\n                utils.flatten3dArrayTo(array, target);\r\n              }\r\n            } else {\r\n              utils.flatten2dArrayTo(array, target);\r\n            }\r\n          } else {\r\n            target.set(array);\r\n          }\r\n        },\r\n      \r\n        splitArray(array, part) {\r\n          const result = [];\r\n          for (let i = 0; i < array.length; i += part) {\r\n            result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));\r\n          }\r\n          return result;\r\n        },\r\n      \r\n        getAstString(source, ast) {\r\n          const lines = Array.isArray(source) ? source : source.split(/\\r?\\n/g);\r\n          const start = ast.loc.start;\r\n          const end = ast.loc.end;\r\n          const result = [];\r\n          if (start.line === end.line) {\r\n            result.push(lines[start.line - 1].substring(start.column, end.column));\r\n          } else {\r\n            result.push(lines[start.line - 1].slice(start.column));\r\n            for (let i = start.line; i < end.line; i++) {\r\n              result.push(lines[i]);\r\n            }\r\n            result.push(lines[end.line - 1].slice(0, end.column));\r\n          }\r\n          return result.join('\\n');\r\n        },\r\n      \r\n        allPropertiesOf(obj) {\r\n          const props = [];\r\n      \r\n          do {\r\n            props.push.apply(props, Object.getOwnPropertyNames(obj));\r\n          } while (obj = Object.getPrototypeOf(obj));\r\n      \r\n          return props;\r\n        },\r\n      \r\n        linesToString(lines) {\r\n          if (lines.length > 0) {\r\n            return lines.join(';\\n') + ';\\n';\r\n          } else {\r\n            return '\\n';\r\n          }\r\n        },\r\n        warnDeprecated(type, oldName, newName) {\r\n          if (newName) {\r\n            console.warn(`You are using a deprecated ${ type } \"${ oldName }\". It has been replaced with \"${ newName }\". Fixing, but please upgrade as it will soon be removed.`);\r\n          } else {\r\n            console.warn(`You are using a deprecated ${ type } \"${ oldName }\". It has been removed. Fixing, but please upgrade as it will soon be removed.`);\r\n          }\r\n        },\r\n        flipPixels: (pixels, width, height) => {\r\n          const halfHeight = height / 2 | 0; \r\n          const bytesPerRow = width * 4;\r\n          const temp = new Uint8ClampedArray(width * 4);\r\n          const result = pixels.slice(0);\r\n          for (let y = 0; y < halfHeight; ++y) {\r\n            const topOffset = y * bytesPerRow;\r\n            const bottomOffset = (height - y - 1) * bytesPerRow;\r\n      \r\n            temp.set(result.subarray(topOffset, topOffset + bytesPerRow));\r\n      \r\n            result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);\r\n      \r\n            result.set(temp, bottomOffset);\r\n          }\r\n          return result;\r\n        },\r\n        erectPackedFloat: (array, width) => {\r\n          return array.subarray(0, width);\r\n        },\r\n        erect2DPackedFloat: (array, width, height) => {\r\n          const yResults = new Array(height);\r\n          for (let y = 0; y < height; y++) {\r\n            const xStart = y * width;\r\n            const xEnd = xStart + width;\r\n            yResults[y] = array.subarray(xStart, xEnd);\r\n          }\r\n          return yResults;\r\n        },\r\n        erect3DPackedFloat: (array, width, height, depth) => {\r\n          const zResults = new Array(depth);\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const xStart = (z * height * width) + y * width;\r\n              const xEnd = xStart + width;\r\n              yResults[y] = array.subarray(xStart, xEnd);\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n        erectMemoryOptimizedFloat: (array, width) => {\r\n          return array.subarray(0, width);\r\n        },\r\n        erectMemoryOptimized2DFloat: (array, width, height) => {\r\n          const yResults = new Array(height);\r\n          for (let y = 0; y < height; y++) {\r\n            const offset = y * width;\r\n            yResults[y] = array.subarray(offset, offset + width);\r\n          }\r\n          return yResults;\r\n        },\r\n        erectMemoryOptimized3DFloat: (array, width, height, depth) => {\r\n          const zResults = new Array(depth);\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const offset = (z * height * width) + (y * width);\r\n              yResults[y] = array.subarray(offset, offset + width);\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n        erectFloat: (array, width) => {\r\n          const xResults = new Float32Array(width);\r\n          let i = 0;\r\n          for (let x = 0; x < width; x++) {\r\n            xResults[x] = array[i];\r\n            i += 4;\r\n          }\r\n          return xResults;\r\n        },\r\n        erect2DFloat: (array, width, height) => {\r\n          const yResults = new Array(height);\r\n          let i = 0;\r\n          for (let y = 0; y < height; y++) {\r\n            const xResults = new Float32Array(width);\r\n            for (let x = 0; x < width; x++) {\r\n              xResults[x] = array[i];\r\n              i += 4;\r\n            }\r\n            yResults[y] = xResults;\r\n          }\r\n          return yResults;\r\n        },\r\n        erect3DFloat: (array, width, height, depth) => {\r\n          const zResults = new Array(depth);\r\n          let i = 0;\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const xResults = new Float32Array(width);\r\n              for (let x = 0; x < width; x++) {\r\n                xResults[x] = array[i];\r\n                i += 4;\r\n              }\r\n              yResults[y] = xResults;\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n        erectArray2: (array, width) => {\r\n          const xResults = new Array(width);\r\n          const xResultsMax = width * 4;\r\n          let i = 0;\r\n          for (let x = 0; x < xResultsMax; x += 4) {\r\n            xResults[i++] = array.subarray(x, x + 2);\r\n          }\r\n          return xResults;\r\n        },\r\n        erect2DArray2: (array, width, height) => {\r\n          const yResults = new Array(height);\r\n          const XResultsMax = width * 4;\r\n          for (let y = 0; y < height; y++) {\r\n            const xResults = new Array(width);\r\n            const offset = y * XResultsMax;\r\n            let i = 0;\r\n            for (let x = 0; x < XResultsMax; x += 4) {\r\n              xResults[i++] = array.subarray(x + offset, x + offset + 2);\r\n            }\r\n            yResults[y] = xResults;\r\n          }\r\n          return yResults;\r\n        },\r\n        erect3DArray2: (array, width, height, depth) => {\r\n          const xResultsMax = width * 4;\r\n          const zResults = new Array(depth);\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const xResults = new Array(width);\r\n              const offset = (z * xResultsMax * height) + (y * xResultsMax);\r\n              let i = 0;\r\n              for (let x = 0; x < xResultsMax; x += 4) {\r\n                xResults[i++] = array.subarray(x + offset, x + offset + 2);\r\n              }\r\n              yResults[y] = xResults;\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n        erectArray3: (array, width) => {\r\n          const xResults = new Array(width);\r\n          const xResultsMax = width * 4;\r\n          let i = 0;\r\n          for (let x = 0; x < xResultsMax; x += 4) {\r\n            xResults[i++] = array.subarray(x, x + 3);\r\n          }\r\n          return xResults;\r\n        },\r\n        erect2DArray3: (array, width, height) => {\r\n          const xResultsMax = width * 4;\r\n          const yResults = new Array(height);\r\n          for (let y = 0; y < height; y++) {\r\n            const xResults = new Array(width);\r\n            const offset = y * xResultsMax;\r\n            let i = 0;\r\n            for (let x = 0; x < xResultsMax; x += 4) {\r\n              xResults[i++] = array.subarray(x + offset, x + offset + 3);\r\n            }\r\n            yResults[y] = xResults;\r\n          }\r\n          return yResults;\r\n        },\r\n        erect3DArray3: (array, width, height, depth) => {\r\n          const xResultsMax = width * 4;\r\n          const zResults = new Array(depth);\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const xResults = new Array(width);\r\n              const offset = (z * xResultsMax * height) + (y * xResultsMax);\r\n              let i = 0;\r\n              for (let x = 0; x < xResultsMax; x += 4) {\r\n                xResults[i++] = array.subarray(x + offset, x + offset + 3);\r\n              }\r\n              yResults[y] = xResults;\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n        erectArray4: (array, width) => {\r\n          const xResults = new Array(array);\r\n          const xResultsMax = width * 4;\r\n          let i = 0;\r\n          for (let x = 0; x < xResultsMax; x += 4) {\r\n            xResults[i++] = array.subarray(x, x + 4);\r\n          }\r\n          return xResults;\r\n        },\r\n        erect2DArray4: (array, width, height) => {\r\n          const xResultsMax = width * 4;\r\n          const yResults = new Array(height);\r\n          for (let y = 0; y < height; y++) {\r\n            const xResults = new Array(width);\r\n            const offset = y * xResultsMax;\r\n            let i = 0;\r\n            for (let x = 0; x < xResultsMax; x += 4) {\r\n              xResults[i++] = array.subarray(x + offset, x + offset + 4);\r\n            }\r\n            yResults[y] = xResults;\r\n          }\r\n          return yResults;\r\n        },\r\n        erect3DArray4: (array, width, height, depth) => {\r\n          const xResultsMax = width * 4;\r\n          const zResults = new Array(depth);\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const xResults = new Array(width);\r\n              const offset = (z * xResultsMax * height) + (y * xResultsMax);\r\n              let i = 0;\r\n              for (let x = 0; x < xResultsMax; x += 4) {\r\n                xResults[i++] = array.subarray(x + offset, x + offset + 4);\r\n              }\r\n              yResults[y] = xResults;\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n      \r\n        flattenFunctionToString: (source, settings) => {\r\n          const { findDependency, thisLookup, doNotDefine } = settings;\r\n          let flattened = settings.flattened;\r\n          if (!flattened) {\r\n            flattened = settings.flattened = {};\r\n          }\r\n          const ast = acorn.parse(source);\r\n          const functionDependencies = [];\r\n          let indent = 0;\r\n      \r\n          function flatten(ast) {\r\n            if (Array.isArray(ast)) {\r\n              const results = [];\r\n              for (let i = 0; i < ast.length; i++) {\r\n                results.push(flatten(ast[i]));\r\n              }\r\n              return results.join('');\r\n            }\r\n            switch (ast.type) {\r\n              case 'Program':\r\n                return flatten(ast.body) + (ast.body[0].type === 'VariableDeclaration' ? ';' : '');\r\n              case 'FunctionDeclaration':\r\n                return `function ${ast.id.name}(${ast.params.map(flatten).join(', ')}) ${ flatten(ast.body) }`;\r\n              case 'BlockStatement': {\r\n                const result = [];\r\n                indent += 2;\r\n                for (let i = 0; i < ast.body.length; i++) {\r\n                  const flat = flatten(ast.body[i]);\r\n                  if (flat) {\r\n                    result.push(' '.repeat(indent) + flat, ';\\n');\r\n                  }\r\n                }\r\n                indent -= 2;\r\n                return `{\\n${result.join('')}}`;\r\n              }\r\n              case 'VariableDeclaration':\r\n                const declarations = utils.normalizeDeclarations(ast)\r\n                  .map(flatten)\r\n                  .filter(r => r !== null);\r\n                if (declarations.length < 1) {\r\n                  return '';\r\n                } else {\r\n                  return `${ast.kind} ${declarations.join(',')}`;\r\n                }\r\n                case 'VariableDeclarator':\r\n                  if (ast.init.object && ast.init.object.type === 'ThisExpression') {\r\n                    const lookup = thisLookup(ast.init.property.name, true);\r\n                    if (lookup) {\r\n                      return `${ast.id.name} = ${flatten(ast.init)}`;\r\n                    } else {\r\n                      return null;\r\n                    }\r\n                  } else {\r\n                    return `${ast.id.name} = ${flatten(ast.init)}`;\r\n                  }\r\n                  case 'CallExpression': {\r\n                    if (ast.callee.property.name === 'subarray') {\r\n                      return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                    }\r\n                    if (ast.callee.object.name === 'gl' || ast.callee.object.name === 'context') {\r\n                      return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                    }\r\n                    if (ast.callee.object.type === 'ThisExpression') {\r\n                      functionDependencies.push(findDependency('this', ast.callee.property.name));\r\n                      return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                    } else if (ast.callee.object.name) {\r\n                      const foundSource = findDependency(ast.callee.object.name, ast.callee.property.name);\r\n                      if (foundSource === null) {\r\n                        return `${ast.callee.object.name}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                      } else {\r\n                        functionDependencies.push(foundSource);\r\n                        return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                      }\r\n                    } else if (ast.callee.object.type === 'MemberExpression') {\r\n                      return `${flatten(ast.callee.object)}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                    } else {\r\n                      throw new Error('unknown ast.callee');\r\n                    }\r\n                  }\r\n                  case 'ReturnStatement':\r\n                    return `return ${flatten(ast.argument)}`;\r\n                  case 'BinaryExpression':\r\n                    return `(${flatten(ast.left)}${ast.operator}${flatten(ast.right)})`;\r\n                  case 'UnaryExpression':\r\n                    if (ast.prefix) {\r\n                      return `${ast.operator} ${flatten(ast.argument)}`;\r\n                    } else {\r\n                      return `${flatten(ast.argument)} ${ast.operator}`;\r\n                    }\r\n                    case 'ExpressionStatement':\r\n                      return `${flatten(ast.expression)}`;\r\n                    case 'SequenceExpression':\r\n                      return `(${flatten(ast.expressions)})`;\r\n                    case 'ArrowFunctionExpression':\r\n                      return `(${ast.params.map(flatten).join(', ')}) => ${flatten(ast.body)}`;\r\n                    case 'Literal':\r\n                      return ast.raw;\r\n                    case 'Identifier':\r\n                      return ast.name;\r\n                    case 'MemberExpression':\r\n                      if (ast.object.type === 'ThisExpression') {\r\n                        return thisLookup(ast.property.name);\r\n                      }\r\n                      if (ast.computed) {\r\n                        return `${flatten(ast.object)}[${flatten(ast.property)}]`;\r\n                      }\r\n                      return flatten(ast.object) + '.' + flatten(ast.property);\r\n                    case 'ThisExpression':\r\n                      return 'this';\r\n                    case 'NewExpression':\r\n                      return `new ${flatten(ast.callee)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                    case 'ForStatement':\r\n                      return `for (${flatten(ast.init)};${flatten(ast.test)};${flatten(ast.update)}) ${flatten(ast.body)}`;\r\n                    case 'AssignmentExpression':\r\n                      return `${flatten(ast.left)}${ast.operator}${flatten(ast.right)}`;\r\n                    case 'UpdateExpression':\r\n                      return `${flatten(ast.argument)}${ast.operator}`;\r\n                    case 'IfStatement':\r\n                      return `if (${flatten(ast.test)}) ${flatten(ast.consequent)}`;\r\n                    case 'ThrowStatement':\r\n                      return `throw ${flatten(ast.argument)}`;\r\n                    case 'ObjectPattern':\r\n                      return ast.properties.map(flatten).join(', ');\r\n                    case 'ArrayPattern':\r\n                      return ast.elements.map(flatten).join(', ');\r\n                    case 'DebuggerStatement':\r\n                      return 'debugger;';\r\n                    case 'ConditionalExpression':\r\n                      return `${flatten(ast.test)}?${flatten(ast.consequent)}:${flatten(ast.alternate)}`;\r\n                    case 'Property':\r\n                      if (ast.kind === 'init') {\r\n                        return flatten(ast.key);\r\n                      }\r\n            }\r\n            throw new Error(`unhandled ast.type of ${ ast.type }`);\r\n          }\r\n          const result = flatten(ast);\r\n          if (functionDependencies.length > 0) {\r\n            const flattenedFunctionDependencies = [];\r\n            for (let i = 0; i < functionDependencies.length; i++) {\r\n              const functionDependency = functionDependencies[i];\r\n              if (!flattened[functionDependency]) {\r\n                flattened[functionDependency] = true;\r\n              }\r\n              functionDependency ? flattenedFunctionDependencies.push(utils.flattenFunctionToString(functionDependency, settings) + '\\n') : '';\r\n            }\r\n            return flattenedFunctionDependencies.join('') + result;\r\n          }\r\n          return result;\r\n        },\r\n      \r\n        normalizeDeclarations: (ast) => {\r\n          if (ast.type !== 'VariableDeclaration') throw new Error('Ast is not of type \"VariableDeclaration\"');\r\n          const normalizedDeclarations = [];\r\n          for (let declarationIndex = 0; declarationIndex < ast.declarations.length; declarationIndex++) {\r\n            const declaration = ast.declarations[declarationIndex];\r\n            if (declaration.id && declaration.id.type === 'ObjectPattern' && declaration.id.properties) {\r\n              const { properties } = declaration.id;\r\n              for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {\r\n                const property = properties[propertyIndex];\r\n                if (property.value.type === 'ObjectPattern' && property.value.properties) {\r\n                  for (let subPropertyIndex = 0; subPropertyIndex < property.value.properties.length; subPropertyIndex++) {\r\n                    const subProperty = property.value.properties[subPropertyIndex];\r\n                    if (subProperty.type === 'Property') {\r\n                      normalizedDeclarations.push({\r\n                        type: 'VariableDeclarator',\r\n                        id: {\r\n                          type: 'Identifier',\r\n                          name: subProperty.key.name\r\n                        },\r\n                        init: {\r\n                          type: 'MemberExpression',\r\n                          object: {\r\n                            type: 'MemberExpression',\r\n                            object: declaration.init,\r\n                            property: {\r\n                              type: 'Identifier',\r\n                              name: property.key.name\r\n                            },\r\n                            computed: false\r\n                          },\r\n                          property: {\r\n                            type: 'Identifier',\r\n                            name: subProperty.key.name\r\n                          },\r\n                          computed: false\r\n                        }\r\n                      });\r\n                    } else {\r\n                      throw new Error('unexpected state');\r\n                    }\r\n                  }\r\n                } else if (property.value.type === 'Identifier') {\r\n                  normalizedDeclarations.push({\r\n                    type: 'VariableDeclarator',\r\n                    id: {\r\n                      type: 'Identifier',\r\n                      name: property.value && property.value.name ? property.value.name : property.key.name\r\n                    },\r\n                    init: {\r\n                      type: 'MemberExpression',\r\n                      object: declaration.init,\r\n                      property: {\r\n                        type: 'Identifier',\r\n                        name: property.key.name\r\n                      },\r\n                      computed: false\r\n                    }\r\n                  });\r\n                } else {\r\n                  throw new Error('unexpected state');\r\n                }\r\n              }\r\n            } else if (declaration.id && declaration.id.type === 'ArrayPattern' && declaration.id.elements) {\r\n              const { elements } = declaration.id;\r\n              for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {\r\n                const element = elements[elementIndex];\r\n                if (element.type === 'Identifier') {\r\n                  normalizedDeclarations.push({\r\n                    type: 'VariableDeclarator',\r\n                    id: {\r\n                      type: 'Identifier',\r\n                      name: element.name\r\n                    },\r\n                    init: {\r\n                      type: 'MemberExpression',\r\n                      object: declaration.init,\r\n                      property: {\r\n                        type: 'Literal',\r\n                        value: elementIndex,\r\n                        raw: elementIndex.toString(),\r\n                        start: element.start,\r\n                        end: element.end\r\n                      },\r\n                      computed: true\r\n                    }\r\n                  });\r\n                } else {\r\n                  throw new Error('unexpected state');\r\n                }\r\n              }\r\n            } else {\r\n              normalizedDeclarations.push(declaration);\r\n            }\r\n          }\r\n          return normalizedDeclarations;\r\n        },\r\n      \r\n        splitHTMLImageToRGB: (gpu, image) => {\r\n          const rKernel = gpu.createKernel(function(a) {\r\n            const pixel = a[this.thread.y][this.thread.x];\r\n            return pixel.r * 255;\r\n          }, {\r\n            output: [image.width, image.height],\r\n            precision: 'unsigned',\r\n            argumentTypes: { a: 'HTMLImage' },\r\n          });\r\n          const gKernel = gpu.createKernel(function(a) {\r\n            const pixel = a[this.thread.y][this.thread.x];\r\n            return pixel.g * 255;\r\n          }, {\r\n            output: [image.width, image.height],\r\n            precision: 'unsigned',\r\n            argumentTypes: { a: 'HTMLImage' },\r\n          });\r\n          const bKernel = gpu.createKernel(function(a) {\r\n            const pixel = a[this.thread.y][this.thread.x];\r\n            return pixel.b * 255;\r\n          }, {\r\n            output: [image.width, image.height],\r\n            precision: 'unsigned',\r\n            argumentTypes: { a: 'HTMLImage' },\r\n          });\r\n          const aKernel = gpu.createKernel(function(a) {\r\n            const pixel = a[this.thread.y][this.thread.x];\r\n            return pixel.a * 255;\r\n          }, {\r\n            output: [image.width, image.height],\r\n            precision: 'unsigned',\r\n            argumentTypes: { a: 'HTMLImage' },\r\n          });\r\n          const result = [\r\n            rKernel(image),\r\n            gKernel(image),\r\n            bKernel(image),\r\n            aKernel(image),\r\n          ];\r\n          result.rKernel = rKernel;\r\n          result.gKernel = gKernel;\r\n          result.bKernel = bKernel;\r\n          result.aKernel = aKernel;\r\n          result.gpu = gpu;\r\n          return result;\r\n        },\r\n      \r\n        splitRGBAToCanvases: (gpu, rgba, width, height) => {\r\n          const visualKernelR = gpu.createKernel(function(v) {\r\n            const pixel = v[this.thread.y][this.thread.x];\r\n            this.color(pixel.r / 255, 0, 0, 255);\r\n          }, {\r\n            output: [width, height],\r\n            graphical: true,\r\n            argumentTypes: { v: 'Array2D(4)' }\r\n          });\r\n          visualKernelR(rgba);\r\n      \r\n          const visualKernelG = gpu.createKernel(function(v) {\r\n            const pixel = v[this.thread.y][this.thread.x];\r\n            this.color(0, pixel.g / 255, 0, 255);\r\n          }, {\r\n            output: [width, height],\r\n            graphical: true,\r\n            argumentTypes: { v: 'Array2D(4)' }\r\n          });\r\n          visualKernelG(rgba);\r\n      \r\n          const visualKernelB = gpu.createKernel(function(v) {\r\n            const pixel = v[this.thread.y][this.thread.x];\r\n            this.color(0, 0, pixel.b / 255, 255);\r\n          }, {\r\n            output: [width, height],\r\n            graphical: true,\r\n            argumentTypes: { v: 'Array2D(4)' }\r\n          });\r\n          visualKernelB(rgba);\r\n      \r\n          const visualKernelA = gpu.createKernel(function(v) {\r\n            const pixel = v[this.thread.y][this.thread.x];\r\n            this.color(255, 255, 255, pixel.a / 255);\r\n          }, {\r\n            output: [width, height],\r\n            graphical: true,\r\n            argumentTypes: { v: 'Array2D(4)' }\r\n          });\r\n          visualKernelA(rgba);\r\n          return [\r\n            visualKernelR.canvas,\r\n            visualKernelG.canvas,\r\n            visualKernelB.canvas,\r\n            visualKernelA.canvas,\r\n          ];\r\n        },\r\n      \r\n        getMinifySafeName: (fn) => {\r\n          try {\r\n            const ast = acorn.parse(`const value = ${fn.toString()}`);\r\n            const { init } = ast.body[0].declarations[0];\r\n            return init.body.name || init.body.body[0].argument.name;\r\n          } catch (e) {\r\n            throw new Error('Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }');\r\n          }\r\n        },\r\n        sanitizeName: function(name) {\r\n          if (dollarSign.test(name)) {\r\n            name = name.replace(dollarSign, 'S_S');\r\n          }\r\n          if (doubleUnderscore.test(name)) {\r\n            name = name.replace(doubleUnderscore, 'U_U');\r\n          } else if (singleUnderscore.test(name)) {\r\n            name = name.replace(singleUnderscore, 'u_u');\r\n          }\r\n          return name;\r\n        }\r\n      };\r\n      \r\n      const dollarSign = /\\$/;\r\n      const doubleUnderscore = /__/;\r\n      const singleUnderscore = /_/;\r\n      \r\n      const _systemEndianness = utils.getSystemEndianness();\r\n      \r\n      module.exports = {\r\n        utils\r\n      };\r\n      },{\"./input\":110,\"./texture\":113,\"acorn\":1}]},{},[107])(107)\r\n      });","function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(() => {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = () => ([]);\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = 377;\nmodule.exports = webpackEmptyAsyncContext;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","\r\nimport {CallbackManager} from './lib/workerCallbacks.js'\r\n\r\nlet manager = new CallbackManager();\r\nlet id = `worker_${Math.floor(Math.random()*10000000000)}`;\r\nlet counter = 0;\r\n\r\nself.onmessage = async (event) => {\r\n  let input;\r\n  if(event.data.output) input = event.data.output; //from events\r\n  else input = event.data;\r\n  //console.log(input)\r\n\r\n  let dict;\r\n  let output = undefined;\r\n  if(event.data?.eventName) { //pipe events to the event manager system\r\n    manager.EVENTS.callback(event.data);\r\n  }\r\n  else if(typeof input === 'object'){\r\n    if(input.canvas !== undefined) { //if a new canvas is sent (event.data.canvas = htmlCanvasElement.transferControlToOffscreen()).\r\n      manager.canvas = input.canvas; \r\n    }\r\n    if(input.context !== undefined ) { //set the context\r\n      manager.ctx = manager.canvas.getContext(input.context);\r\n      manager.context = manager.ctx; //alt name\r\n    } \r\n\r\n    let eventSetting = manager.checkEvents(input.foo,input.origin);\r\n    //console.log(event)\r\n\r\n    output = await manager.checkCallbacks(event);  // output some results!\r\n    counter++; //just tracks the number of calls made to the worker\r\n\r\n    //we are gonna assume typedarrays are to be transferred for speed so throw those all into the transfer array\r\n    let transfer = undefined;\r\n    if(output) {\r\n      if(output.__proto__?.__proto__?.constructor.name === 'TypedArray') { \r\n        transfer = [output.buffer];\r\n      } else if (output.constructor?.name === 'Object') {\r\n          for(const key in output) {\r\n              if(output[key].__proto__?.__proto__?.constructor.name === 'TypedArray') {\r\n                  if(!transfer) transfer = output[key].buffer;\r\n                  else transfer.push(output[key].buffer);\r\n              }\r\n          }\r\n      }\r\n    }\r\n    //if(input.foo === 'particleStep') console.log(eventSetting);\r\n\r\n    dict = {output: output, foo: input.foo, origin: input.origin, callbackId: input.callbackId, counter:counter};\r\n    if(eventSetting) {manager.EVENTS.emit(eventSetting.eventName,dict,undefined,transfer,eventSetting.port);} //if the origin and foo match an event setting on the thread, this emits output as an event\r\n    else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\r\n        self.postMessage(dict,transfer); // TODO: Correct proper transfer syntax\r\n    } \r\n  }\r\n  /*\r\n    now run \"addfunc\" to render something in the linked canvas from the worker thread\r\n    e.g. workers.postToWorker('addfunc',['offscreenrender',`(args)=>{\r\n      ctx.clearRect(0,0,canvas.width,canvas.height); //or this.offscreenctx\r\n      ctx.fillRect(25, 25, 100, 100);\r\n      ctx.clearRect(45, 45, 60, 60);\r\n      ctx.strokeRect(50, 50, 50, 50);\r\n    }`]);\r\n  */\r\n\r\n  // console.timeEnd(\"worker\");\r\n  return dict;\r\n}\r\n\r\nmanager.EVENTS.emit('newWorker',id);\r\n\r\nexport default self"],"names":["StateManager","Events","constructor","manager","undefined","state","found","responses","find","foo","name","addCallback","callback","subEvent","eventName","response","output","console","log","subscribeTrigger","unsubEvent","sub","unsubscribeTrigger","addEvent","workerId","functionName","origin","setState","post","input","workers","forEach","w","id","removeEmitter","unsubscribeAllTriggers","emit","transfer","port","WorkerGlobalScope","self","postMessage","globalThis","msg","export","dynamicImport","url","module","getFunctionBody","methodString","toString","replace","getFunctionHead","fnstring","slice","indexOf","buildNewFunction","head","body","newFunc","eval","isFunction","string","regex","RegExp","func","substring","includes","arrow","test","parseFunctionFromText","method","startindex","newFuncHead","newFuncBody","varName","split","Function","length","Math2","workerCPU","callbackManager","callbacks","case","args","crosscorrelation","autocorrelation","cov1d","cov2d","sma","addCallbacks","fn","aliases","c","workerGPU","workerRenderer","CallbackManager","canvas","ctx","context","options","cpu","gpu","renderer","EVENTS","EVENTSETTINGS","ID","Math","floor","random","defaultFunctions","list","push","safeFunc","result","err","error","set","removeCallback","Object","keys","key","threeUtil","Array","isArray","__proto__","from","obj","onmessage","eventSetting","checkEvents","Map","o","alias","get","delete","runCallback","checkCallbacks","event","data","command","cmd","gpuUtils","addFunction","addKernel","callKernel","gpuDFT","MultiChannelDFT","MultiChannelDFT_Bandpass","gpuFFT","MultiChannelFFT","MultiChannelFFT_Bandpass","gpuCoherence","correlograms","buffer","dfts","scalar","cordfts","splice","coherenceResults","nChannels","k","l","row","i","temp","autoFFTproducts","dft","newdft","fill","amp","j","noop","EventDispatcher","addEventListener","type","listener","_listeners","listeners","hasEventListener","removeEventListener","listenerArray","index","dispatchEvent","target","array","call","ElementProxyReceiver","style","clientWidth","width","clientHeight","height","setPointerCapture","releasePointerCapture","getBoundingClientRect","left","top","right","bottom","handleEvent","preventDefault","stopPropagation","focus","ProxyManager","targets","bind","makeProxy","proxy","getProxy","OffscreenCanvas","ANIMATION","ANIMATIONFUNC","ANIMATING","ANIMFRAMETIME","performance","now","PROXYMANAGER","window","document","ownerDocument","cancelAnimationFrame","THREE","setup","draw","clear","animationFunc","anim","emitevent","dict","requestAnimationFrame","setTimeout","time","tselfhis","counter","getContext","callbackId"],"sourceRoot":""}