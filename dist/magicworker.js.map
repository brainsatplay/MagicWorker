{"version":3,"file":"magicworker.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,uCAAuC;AACvC,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,kCAAkC;AAClC,iCAAiC;AACjC;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kCAAkC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,iBAAiB,KAAK,cAAc;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,0CAA0C;AAC1C;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,oCAAoC,cAAc;AAClD,kBAAkB;AAClB;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,qCAAqC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,wCAAwC;AACxC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,sGAAsG;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,kFAAkF;AAClF,+CAA+C;AAC/C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qEAAe;;AC9pB6B;AAC5C;AACA;AACA;AACA;AACA;AACO;AACP,yBAAyB,oDAAoD;AAC7E;AACA;AACA;AACA,yBAAyB,YAAY;AACrC;AACA;AACA;AACA,4BAA4B,8BAAc;AAC1C;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yBAAyB;AAC9D;AACA,UAAU;AACV;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,2BAA2B;AACzE,yDAAyD;AACzD;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,cAAc;AACd;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,wCAAwC;AACxC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,sGAAsG;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,kFAAkF;AAClF,+CAA+C;AAC/C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;A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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA,8BAA8B;AAC9B;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B;AAC5B,gCAAgC;AAChC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B;AAC5B,gCAAgC;AAChC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8BAA8B;AACpE;AACA,0BAA0B,iBAAiB,gBAAgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mCAAmC;AAC3E;AACA,kCAAkC,IAAI,mCAAmC;AACzE,kCAAkC;AAClC,sCAAsC,mCAAmC;AACzE;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,IAAI,mCAAmC;AAChF;AACA;AACA,kCAAkC,iCAAiC;AACnE,uCAAuC,iCAAiC;AACxE,0CAA0C,8CAA8C;AACxF,wCAAwC,iDAAiD;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,2DAA2D;AACpG;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+BAA+B;AACxD;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA,2BAA2B,mCAAmC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2BAA2B;AACpD,yCAAyC,2BAA2B;AACpE,iCAAiC,iDAAiD;AAClF,6BAA6B,iDAAiD;AAC9E,iCAAiC,iDAAiD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,gBAAgB,mCAAmC;AACnD,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc,oBAAoB,gBAAgB,oBAAoB,YAAY,oBAAoB,eAAe,oBAAoB,qBAAqB,oBAAoB,wBAAwB;AAC7O;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D,2DAA2D;AAC3D,uDAAuD;AACvD,0DAA0D;AAC1D,gEAAgE;AAChE,mEAAmE;AACnE;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,0BAA0B;AAC1B,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,wCAAwC;AACxC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,cAAc;AACd;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,2BAA2B;AAC3B;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,cAAc,2DAA2D,iBAAiB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa,iBAAiB;AACvD;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA,+BAA+B;AAC/B,yBAAyB;AACzB;AACA,gCAAgC;AAChC;AACA;AACA,yEAAyE;AACzE;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0HAA0H;AAC1H;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA,0EAA0E;AAC1E,2CAA2C;AAC3C;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,gEAAgE;AAChE,iBAAiB,wCAAwC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,kCAAkC;AAClC;AACA;AACA;AACA;AACA,cAAc;AACd,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mBAAmB;AACnE;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA,4BAA4B,wDAAwD;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,kGAAkG;AAClG,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,+BAA+B;AAC/B,2BAA2B;AAC3B;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,YAAY;AACZ;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,gDAAgD;AAChD;AACA,cAAc;AACd,sDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc,uCAAuC,iBAAiB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yCAAyC,qBAAqB;AAC5E;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,0BAA0B;AAC1B,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mEAAmE;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,sDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,mBAAmB;AACnB;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,oDAAoD,iBAAiB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,qBAAqB;AAC3E;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,8CAA8C;AAC9C,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,gBAAgB;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,YAAY;AACZ,0CAA0C;AAC1C;AACA,qCAAqC;AACrC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,gBAAgB;AAChB,mBAAmB;AACnB;AACA,YAAY;AACZ;AACA,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,8EAA8E;AAC9E,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,+CAA+C,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,iDAAiD;AACjD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,iEAAiE,mBAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F;AAC5F,cAAc,OAAO;AACrB;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,YAAY;AACZ,6BAA6B;AAC7B;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA,kBAAkB;AAClB,cAAc;AACd;AACA,kBAAkB;AAClB;AACA,YAAY;AACZ,0CAA0C;AAC1C;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,cAAc;AACd;AACA,kBAAkB;AAClB;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB;AAC1D;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E,cAAc,OAAO;AACrB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,kBAAkB;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,iEAAiE;AACjE;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,YAAY;AACZ,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,+CAA+C;AAC/C;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,oCAAoC;AACpC;AACA;AACA,iEAAiE,kCAAkC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,iBAAiB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA,wCAAwC;AACxC,+CAA+C;AAC/C;AACA,qCAAqC;AACrC,iBAAiB;AACjB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,+BAA+B;AAC/B,gCAAgC;AAChC,gCAAgC;AAChC,+BAA+B;AAC/B,+BAA+B;AAC/B;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA,iDAAiD;AACjD,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iDAAiD;AACjD;AACA,sCAAsC;AACtC;AACA,gCAAgC;AAChC,gDAAgD;AAChD,iDAAiD;AACjD;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,iDAAiD,6CAA6C;AAC9F;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA,8BAA8B;AAC9B,mCAAmC;AACnC,iDAAiD;AACjD,mBAAmB;AACnB,gCAAgC;AAChC;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,YAAY,wDAAwD;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,6CAA6C;AAC7C;AACA,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA,yDAAyD;AACzD;AACA,mCAAmC;AACnC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iDAAiD;AACjD;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,cAAc;AACd,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA,0CAA0C,2BAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,aAAa;AACpE;AACA,OAAO;AACP;AACA,OAAO,GAAG;AACV;AACA,OAAO,GAAG;AACV,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,UAAU;AACV,sCAAsC,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO,MAAM,YAAY,kBAAkB,YAAY,gCAAgC;AAC7H,oBAAoB;AACpB,sCAAsC,OAAO,EAAE,YAAY,YAAY;AACvE;AACA;AACA;AACA,0CAA0C,YAAY,WAAW,wBAAwB;AACzF,oCAAoC,OAAO,QAAQ,cAAc,IAAI,YAAY,iBAAiB,aAAa,GAAG;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO,EAAE,aAAa;AAC9D,sBAAsB;AACtB,8CAA8C,YAAY,UAAU,wBAAwB;AAC5F;AACA,wCAAwC,OAAO,QAAQ,oBAAoB,QAAQ,8BAA8B,GAAG,oBAAoB,EAAE;AAC1I;AACA,oBAAoB;AACpB,4CAA4C,YAAY,UAAU,EAAE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,EAAE,YAAY,cAAc,6BAA6B,EAAE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,EAAE,YAAY,gBAAgB,kCAAkC,iGAAiG,EAAE,GAAG;AACjN;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,EAAE,yCAAyC;AACtF;AACA;AACA;AACA;AACA,sCAAsC,OAAO,QAAQ,YAAY,UAAU,yBAAyB,IAAI,yCAAyC;AACjJ;AACA;AACA;AACA;AACA;AACA,sCAAsC,yCAAyC;AAC/E,oBAAoB;AACpB,sCAAsC,OAAO,QAAQ,YAAY,UAAU,yBAAyB,IAAI,yCAAyC;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY,UAAU,wBAAwB;AAChF,4BAA4B,OAAO,QAAQ,cAAc,IAAI,QAAQ;AACrE;AACA;AACA;AACA;AACA,oCAAoC,YAAY,UAAU,wBAAwB;AAClF,6CAA6C,WAAW;AACxD,4BAA4B,OAAO,MAAM,eAAe,aAAa,eAAe,YAAY,MAAM,SAAS,OAAO,wBAAwB;AAC9I,4BAA4B,OAAO,gBAAgB,MAAM,cAAc,SAAS,SAAS;AACzF,4BAA4B,SAAS,EAAE,eAAe,KAAK,eAAe,cAAc,eAAe,kBAAkB,eAAe,cAAc;AACtJ,4BAA4B,QAAQ;AACpC,4BAA4B,OAAO,qCAAqC;AACxE,4BAA4B,SAAS,iCAAiC,eAAe,SAAS,cAAc,EAAE;AAC9G,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA,4BAA4B,OAAO,KAAK,MAAM;AAC9C;AACA;AACA,4BAA4B,OAAO;AACnC,QAAQ,OAAO,gBAAgB,YAAY;AAC3C,QAAQ,OAAO,gBAAgB,YAAY;AAC3C,QAAQ,SAAS;AACjB,QAAQ,SAAS,gBAAgB,kBAAkB;AACnD,QAAQ,WAAW;AACnB,QAAQ,WAAW,MAAM,YAAY;AACrC,QAAQ,aAAa,mBAAmB,aAAa;AACrD,QAAQ;AACR,QAAQ;AACR,QAAQ;AACR,QAAQ,QAAQ,IAAI;AACpB;AACA;AACA,oBAAoB,YAAY,GAAG,OAAO,GAAG,0BAA0B,gGAAgG,EAAE;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,UAAU,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,EAAE,YAAY,qBAAqB,kCAAkC,oHAAoH,EAAE,GAAG;AACzO;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO,EAAE,yCAAyC;AACtF;AACA;AACA;AACA;AACA,sCAAsC,OAAO,QAAQ,YAAY,UAAU,yBAAyB,IAAI,yCAAyC;AACjJ;AACA,oBAAoB;AACpB,sCAAsC,OAAO,QAAQ,YAAY,UAAU,yBAAyB,IAAI,yCAAyC;AACjJ;AACA;AACA;AACA;AACA;AACA,sCAAsC,yCAAyC;AAC/E,oBAAoB;AACpB,sCAAsC,OAAO,QAAQ,YAAY,UAAU,yBAAyB,IAAI,yCAAyC;AACjJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY,GAAG,4BAA4B;AACjE;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,GAAG,OAAO,GAAG,0BAA0B,oHAAoH,EAAE;AAC7L;AACA;AACA;AACA,kCAAkC,YAAY,UAAU,wBAAwB;AAChF;AACA,4BAA4B,OAAO,QAAQ,cAAc,IAAI,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA,gBAAgB,0CAA0C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sFAAsF;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,UAAU,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,2CAA2C,qBAAqB,IAAI,0BAA0B;AAC9F;AACA;AACA;AACA;AACA,2CAA2C,qBAAqB,GAAG,gCAAgC;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,qBAAqB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,0BAA0B,mBAAmB;AAC7C;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA;AACA,iBAAiB,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,YAAY;AACZ;AACA,uBAAuB;AACvB,YAAY;AACZ;AACA,uBAAuB;AACvB;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV,cAAc,QAAQ;AACtB;AACA;AACA;AACA,gDAAgD,OAAO,IAAI,uDAAuD;AAClH,WAAW;AACX,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,cAAc;AACvB,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,kCAAkC;AAClC,YAAY;AACZ,4CAA4C,YAAY;AACxD;AACA,0BAA0B;AAC1B,mDAAmD,YAAY;AAC/D,YAAY;AACZ;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE;AAC7F;AACA,0BAA0B;AAC1B,YAAY;AACZ;AACA;AACA,8CAA8C;AAC9C;AACA,oCAAoC,cAAc,GAAG,EAAE,cAAc,UAAU,EAAE,cAAc,IAAI;AACnG;AACA,kCAAkC,iBAAiB,QAAQ;AAC3D;AACA;AACA,6BAA6B,oBAAoB;AACjD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc,MAAM;AAC3D;AACA;AACA,0BAA0B;AAC1B;AACA,yBAAyB,MAAM;AAC/B,6BAA6B;AAC7B,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,cAAc,MAAM;AAC3D;AACA;AACA;AACA,0BAA0B;AAC1B,6BAA6B;AAC7B,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA,YAAY;AACZ,0BAA0B;AAC1B,4BAA4B,uBAAuB;AACnD;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C,kBAAkB,eAAe;AACjC,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,2BAA2B;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,6BAA6B;AAC7B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA,0BAA0B;AAC1B,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,GAAG,KAAK;AAC9C;AACA;AACA;AACA;AACA,gCAAgC,OAAO,GAAG,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA,mCAAmC,mEAAmE;AACtG;AACA,mCAAmC,6CAA6C;AAChF;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mCAAmC,6CAA6C;AAChF;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA,+CAA+C,oBAAoB;AACnE;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,sBAAsB;AAC/B,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,GAAG,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,OAAO,0BAA0B,GAAG,qCAAqC;AAC5G;AACA;AACA;AACA,kBAAkB,GAAG,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gDAAgD,WAAW;AAChF,6CAA6C,6CAA6C,EAAE;AAC5F,sCAAsC,yCAAyC;AAC/E,kCAAkC,iEAAiE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,sEAAsE,oBAAoB,IAAI,oBAAoB,EAAE;AACpH,oEAAoE,qBAAqB,IAAI,qBAAqB,KAAK;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,SAAS;AACT,mBAAmB,EAAE,4BAA4B;AACjD,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kBAAkB;AAC3B,cAAc,SAAS;AACvB,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,cAAc,QAAQ;AACtB,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,UAAU;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA,gBAAgB;AAChB,iFAAiF,MAAM,yBAAyB,OAAO,iBAAiB,MAAM,yBAAyB,OAAO;AAC9K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA,6DAA6D;AAC7D,WAAW;AACX;AACA,WAAW;AACX,WAAW;AACX,mBAAmB,2EAA2E;AAC9F,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,aAAa;AACb,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mCAAmC;AACpD,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,GAAG,wCAAwC,EAAE,EAAE;AAClG;AACA;AACA,mDAAmD,GAAG,wCAAwC,EAAE,EAAE;AAClG;AACA;AACA,mDAAmD,GAAG,mBAAmB,EAAE,OAAO;AAClF;AACA;AACA,mDAAmD,GAAG,mBAAmB,GAAG;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2BAA2B;AACrD;AACA,6EAA6E,cAAc,aAAa,eAAe;AACvH,gCAAgC,cAAc,YAAY,yBAAyB,gBAAgB,OAAO;AAC1G;AACA,wBAAwB,oBAAoB,uFAAuF;AACnI;AACA;AACA;AACA;AACA,0BAA0B,+BAA+B;AACzD,yCAAyC,sBAAsB;AAC/D;AACA;AACA;AACA;AACA,mCAAmC,cAAc,yBAAyB,aAAa,EAAE;AACzF;AACA;AACA,mCAAmC,cAAc,yBAAyB,aAAa,EAAE;AACzF;AACA;AACA,mCAAmC,cAAc,IAAI,aAAa,OAAO;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA,8DAA8D,aAAa;AAC3E;AACA,gBAAgB,cAAc;AAC9B,cAAc;AACd,wCAAwC,aAAa;AACrD,gBAAgB,cAAc,IAAI,aAAa;AAC/C,sCAAsC,aAAa;AACnD;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,QAAQ;AAC3C;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iBAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD,aAAa,kDAAkD,iBAAiB,QAAQ,kBAAkB,UAAU;AACpH,aAAa,yDAAyD,iBAAiB;AACvF,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD,aAAa,kDAAkD,iBAAiB,QAAQ,kBAAkB,UAAU;AACpH,aAAa,yDAAyD,iBAAiB,mBAAmB;AAC1G;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,eAAe;AACf,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAkD,iBAAiB,qBAAqB;AACrG,aAAa,yDAAyD,iBAAiB;AACvF,0BAA0B,aAAa;AACvC;AACA;AACA,8CAA8C,kBAAkB;AAChE,eAAe,mDAAmD,iBAAiB,WAAW,eAAe,YAAY,kBAAkB,UAAU;AACrJ,4BAA4B,aAAa;AACzC;AACA,iBAAiB;AACjB;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAkD,iBAAiB,qBAAqB;AACrG,aAAa,yDAAyD,iBAAiB;AACvF,0BAA0B,aAAa;AACvC,8CAA8C,kBAAkB;AAChE,eAAe,mDAAmD,iBAAiB,WAAW,eAAe,YAAY,kBAAkB,UAAU;AACrJ,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,eAAe,mDAAmD,iBAAiB,WAAW,eAAe,YAAY,kBAAkB,UAAU;AACrJ,4BAA4B,aAAa;AACzC;AACA,iBAAiB;AACjB;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA,4BAA4B,aAAa;AACzC;AACA,iBAAiB;AACjB;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAkD,iBAAiB,qBAAqB;AACrG,aAAa,yDAAyD,iBAAiB;AACvF,0BAA0B,aAAa;AACvC;AACA;AACA,eAAe,mDAAmD,iBAAiB,WAAW,eAAe,yBAAyB;AACtI,4BAA4B,aAAa;AACzC;AACA,iDAAiD,kBAAkB;AACnE,iBAAiB,mDAAmD,iBAAiB,YAAY,eAAe,YAAY,kBAAkB,UAAU;AACxJ,8BAA8B,aAAa;AAC3C;AACA,mBAAmB;AACnB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAkD,iBAAiB,qBAAqB;AACrG,aAAa,yDAAyD,iBAAiB;AACvF,0BAA0B,aAAa;AACvC;AACA,eAAe,mDAAmD,iBAAiB,WAAW,eAAe,yBAAyB;AACtI,4BAA4B,aAAa;AACzC,iDAAiD,kBAAkB;AACnE,iBAAiB,mDAAmD,iBAAiB,YAAY,eAAe,YAAY,kBAAkB,UAAU;AACxJ;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA,mBAAmB;AACnB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA,eAAe,qCAAqC,oBAAoB,YAAY,gBAAgB;AACpG,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,iGAAiG;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC,8DAA8D;AAC9D;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yCAAyC;AACvE;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd,2CAA2C,OAAO;AAClD;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,0BAA0B,8BAA8B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,UAAU;AACxF;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd,8BAA8B,6BAA6B;AAC3D;AACA;AACA;AACA,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iCAAiC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc,uCAAuC,aAAa;AAC1G;AACA;AACA;AACA,sDAAsD,cAAc,wBAAwB,aAAa;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,cAAc,cAAc,aAAa;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,wDAAwD;AAClG;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,qBAAqB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,4BAA4B,WAAW,2BAA2B;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ,WAAW,YAAY;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,YAAY,KAAK,cAAc;AACnG;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gEAAgE;AAClF;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA,oBAAoB,oCAAoC;AACxD,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA,0BAA0B,6BAA6B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,MAAM;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,UAAU;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,UAAU;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA,oEAAoE,EAAE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB,kEAAkE,SAAS;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,WAAW;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO,WAAW,mBAAmB,cAAc,mBAAmB,OAAO,aAAa;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA,0BAA0B,wBAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd,8BAA8B,mBAAmB;AACjD;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU,EAAE,UAAU,EAAE,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,gDAAgD;AACzD,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,gEAAgE,MAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,6CAA6C,6BAA6B;AAC1E;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAA0D;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,eAAe;AACxB,cAAc,YAAY;AAC1B,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU,uCAAuC;AACvG;AACA,gBAAgB;AAChB;AACA,6CAA6C,uCAAuC,SAAS,IAAI,IAAI,qCAAqC;AAC1I;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,4CAA4C,qCAAqC;AACjF,cAAc;AACd,+CAA+C;AAC/C;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oBAAoB;AACxE;AACA;AACA,uCAAuC,6BAA6B;AACpE;AACA,sDAAsD,oBAAoB,GAAG,WAAW;AACxF;AACA;AACA;AACA,oDAAoD,oBAAoB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oBAAoB;AACxE;AACA;AACA,8FAA8F,oBAAoB;AAClH;AACA,SAAS;AACT;AACA,gCAAgC,sCAAsC;AACtE,gCAAgC,6CAA6C;AAC7E,gCAAgC,6CAA6C;AAC7E,gCAAgC,6CAA6C;AAC7E,gCAAgC,oCAAoC;AACpE;AACA;AACA,+CAA+C,2CAA2C;AAC1F;AACA;AACA;AACA,uDAAuD,gFAAgF,GAAG;AAC1I;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,aAAa;AACvC,wBAAwB,qBAAqB;AAC7C,0BAA0B;AAC1B,aAAa;AACb,oBAAoB,6BAA6B;AACjD,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC,0BAA0B,sBAAsB;AAChD,wBAAwB,sBAAsB;AAC9C,0BAA0B;AAC1B,aAAa;AACb;AACA,+BAA+B;AAC/B,YAAY;AACZ;AACA;AACA;AACA,0BAA0B,aAAa;AACvC,wBAAwB,eAAe;AACvC,0BAA0B;AAC1B,cAAc;AACd;AACA;AACA,2BAA2B,gEAAgE;AAC3F;AACA,yBAAyB;AACzB;AACA;AACA,2DAA2D;AAC3D;AACA,0CAA0C;AAC1C;AACA;AACA;AACA,kCAAkC,uCAAuC;AACzE,SAAS;AACT;AACA,gBAAgB,qBAAqB;AACrC,UAAU;AACV,UAAU;AACV,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA,+FAA+F,WAAW;AAC1G;AACA,iCAAiC,cAAc,IAAI,iBAAiB,IAAI,iBAAiB,IAAI,iBAAiB;AAC9G;AACA;AACA,iCAAiC,cAAc,IAAI,iBAAiB,IAAI,iBAAiB;AACzF;AACA;AACA,+BAA+B,cAAc,IAAI,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA,gDAAgD,sCAAsC,GAAG,WAAW;AACpG;AACA;AACA,8BAA8B,MAAM,IAAI,wBAAwB;AAChE;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oEAAoE,sCAAsC,GAAG,SAAS;AACtH;AACA;AACA,8BAA8B,MAAM,IAAI,wBAAwB;AAChE,cAAc;AACd;AACA;AACA;AACA,wBAAwB,sCAAsC,EAAE,8BAA8B;AAC9F,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA,SAAS;AACT;AACA,iCAAiC,SAAS;AAC1C,UAAU;AACV;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA,gDAAgD,iBAAiB,GAAG,cAAc;AAClF;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA,0CAA0C,iBAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,iCAAiC;AAC1C,cAAc,SAAS;AACvB,cAAc,QAAQ;AACtB,cAAc,uBAAuB;AACrC,cAAc,yBAAyB;AACvC,cAAc,yBAAyB;AACvC,cAAc,uBAAuB;AACrC,cAAc,yBAAyB;AACvC,cAAc,yBAAyB;AACvC,cAAc,uBAAuB;AACrC,cAAc,yBAAyB;AACvC,cAAc,yBAAyB;AACvC,cAAc,iBAAiB;AAC/B,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,2BAA2B;AACzC,cAAc,6BAA6B;AAC3C,cAAc,6BAA6B;AAC3C,cAAc,oBAAoB;AAClC,cAAc,sBAAsB;AACpC,cAAc,sBAAsB;AACpC,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA,2DAA2D,WAAW;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA,6CAA6C,gBAAgB,GAAG,gBAAgB,uDAAuD,wBAAwB,GAAG,wBAAwB;AAC1L;AACA;AACA;AACA;AACA,8DAA8D,sBAAsB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,uDAAuD,eAAe;AACtE;AACA;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB,MAAM;AACvD;AACA;AACA;AACA,8BAA8B,kEAAkE,IAAI;AACpG;AACA;AACA;AACA,8BAA8B,4DAA4D,UAAU;AACpG;AACA;AACA;AACA,8BAA8B,4DAA4D,eAAe;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA,YAAY;AACZ,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,OAAO;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,oBAAoB,iBAAiB;AACrC,4BAA4B,2BAA2B;AACvD;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,0kBAA0kB;AACnlB,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,gBAAgB;AACzB,cAAc,UAAU;AACxB;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,OAAO,EAAE,uBAAuB;AAChC,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,qCAAqC;AAC9C,cAAc,QAAQ;AACtB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,qCAAqC;AAC9C,cAAc,QAAQ;AACtB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C;AACA,cAAc,cAAc;AAC5B,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF,4DAA4D,uDAAuD;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,sDAAsD;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,QAAQ;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,KAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,GAAG,KAAK;AACxC;AACA;AACA;AACA,yDAAyD,uBAAuB;AAChF;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA,kEAAkE,WAAW;AAC7E;AACA;AACA;AACA,mEAAmE,WAAW;AAC9E;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+BAA+B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qCAAqC;AACrE;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,uBAAuB;AAC5E;AACA;AACA;AACA,mDAAmD,uBAAuB;AAC1E;AACA;AACA;AACA,0DAA0D,uBAAuB;AACjF;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA,yCAAyC;AACzC;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,YAAY;AACZ,4BAA4B,+BAA+B;AAC3D;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gBAAgB;AAChB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,oFAAoF,GAAG;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,uBAAuB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uBAAuB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uBAAuB;AACzE;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,uBAAuB;AAC3E;AACA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA,kCAAkC,uBAAuB,WAAW,GAAG,8BAA8B,gBAAgB;AACrH;AACA;AACA;AACA;AACA;AACA,wDAAwD,uBAAuB;AAC/E;AACA;AACA;AACA,2DAA2D,uBAAuB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,WAAW;AAC3E;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,8BAA8B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,aAAa,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,aAAa,OAAO;AACjD;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV,cAAc,QAAQ;AACtB,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,0BAA0B;AAC1B,2BAA2B,MAAM;AACjC;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA,cAAc;AACd;AACA;AACA,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM,OAAO,KAAK,cAAc,KAAK,kBAAkB,KAAK;AAC3F,gBAAgB;AAChB,+BAA+B,MAAM,OAAO,KAAK;AACjD;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB;AACjF;AACA;AACA;AACA,2CAA2C,kBAAkB;AAC7D,gCAAgC;AAChC,YAAY;AACZ,4CAA4C,YAAY,KAAK,kBAAkB;AAC/E,mDAAmD,YAAY;AAC/D,YAAY;AACZ,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC,cAAc;AACd;AACA,6BAA6B,UAAU;AACvC,cAAc;AACd;AACA,6BAA6B,UAAU;AACvC;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E,IAAI;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,uCAAuC,KAAK;AAC5C,cAAc;AACd,kCAAkC,KAAK;AACvC;AACA,YAAY;AACZ,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E,gCAAgC,WAAW,EAAE,uBAAuB,OAAO,EAAE,kBAAkB,EAAE,mBAAmB,EAAE;AACtH;AACA,0BAA0B;AAC1B,YAAY;AACZ;AACA;AACA;AACA;AACA,oCAAoC,cAAc,GAAG,EAAE,cAAc,UAAU,EAAE,cAAc,IAAI;AACnG;AACA,kCAAkC,iBAAiB,QAAQ;AAC3D;AACA;AACA,6BAA6B,oBAAoB;AACjD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc,GAAG,EAAE,cAAc,UAAU,EAAE,cAAc,IAAI;AACjG;AACA;AACA,+BAA+B;AAC/B;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc,GAAG,EAAE,cAAc,UAAU,EAAE,cAAc,IAAI;AACjG;AACA;AACA;AACA,+BAA+B;AAC/B,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA,YAAY;AACZ,0BAA0B;AAC1B,4BAA4B,uBAAuB;AACnD;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,6CAA6C,wCAAwC;AACrF;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,0CAA0C,YAAY;AACtD,gBAAgB;AAChB;AACA;AACA,0CAA0C,YAAY;AACtD;AACA;AACA,6CAA6C,wCAAwC;AACrF;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,2BAA2B;AAC3B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,6BAA6B;AAC7B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA,+CAA+C,sBAAsB;AACrE;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA,4BAA4B;AAC5B;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,oCAAoC;AACpC;AACA,cAAc;AACd;AACA;AACA,mCAAmC,SAAS;AAC5C,gBAAgB;AAChB;AACA,iCAAiC,SAAS;AAC1C;AACA,kBAAkB;AAClB,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,gCAAgC;AAChC;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,0BAA0B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,GAAG,yBAAyB;AAClE;AACA;AACA;AACA;AACA,gCAAgC,OAAO,GAAG,yBAAyB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,YAAY,KAAK,YAAY,SAAS,YAAY;AAC3F;AACA;AACA;AACA;AACA,oDAAoD,YAAY,KAAK,YAAY,SAAS,YAAY;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY,KAAK,YAAY,SAAS,YAAY;AACvG;AACA;AACA;AACA;AACA,mDAAmD,YAAY,KAAK,YAAY,SAAS,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY,KAAK,YAAY,SAAS,YAAY;AACvG;AACA;AACA;AACA;AACA,mDAAmD,YAAY,KAAK,YAAY,SAAS,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY,KAAK,YAAY,SAAS,YAAY;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY,KAAK,YAAY,SAAS,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,WAAW,IAAI,WAAW,QAAQ,WAAW;AACjG;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW,IAAI,WAAW,QAAQ,WAAW;AACrF;AACA;AACA,yCAAyC,WAAW,IAAI,WAAW,QAAQ,WAAW;AACtF;AACA;AACA;AACA,yCAAyC,WAAW,IAAI,WAAW,QAAQ,WAAW;AACtF;AACA;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY,KAAK,YAAY,SAAS,YAAY;AACrG;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,GAAG,+CAA+C;AAC1F;AACA,gCAAgC,+CAA+C;AAC/E;AACA;AACA;AACA,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,kCAAkC;AAC5E,sBAAsB;AACtB;AACA,sBAAsB;AACtB,4EAA4E,eAAe;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8GAA8G,eAAe;AAC7H;AACA;AACA,wCAAwC,KAAK,QAAQ,KAAK,YAAY,KAAK;AAC3E;AACA;AACA;AACA;AACA,8EAA8E,eAAe,OAAO,aAAa,uBAAuB,eAAe;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA,gCAAgC,OAAO;AACvC;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,wCAAwC;AACjD,cAAc,0BAA0B;AACxC,cAAc,wBAAwB;AACtC,cAAc,0BAA0B;AACxC;AACA,cAAc,4BAA4B;AAC1C,cAAc,mCAAmC;AACjD;AACA,cAAc,4BAA4B;AAC1C,cAAc,mCAAmC;AACjD;AACA,cAAc,8BAA8B;AAC5C,cAAc,qCAAqC;AACnD;AACA,cAAc,gCAAgC;AAC9C,cAAc,uCAAuC;AACrD;AACA,cAAc,+CAA+C;AAC7D,cAAc,sDAAsD;AACpE;AACA,cAAc,gCAAgC;AAC9C,cAAc,uCAAuC;AACrD;AACA,cAAc,8BAA8B;AAC5C,cAAc,qCAAqC;AACnD;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA,cAAc,+BAA+B;AAC7C,cAAc,+BAA+B;AAC7C,cAAc,+BAA+B;AAC7C;AACA,cAAc,gCAAgC;AAC9C,cAAc,uCAAuC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,wiCAAwiC;AACjjC,cAAc,mBAAmB;AACjC,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA,2DAA2D,OAAO,8BAA8B,gBAAgB;AAChH,cAAc;AACd,4DAA4D,QAAQ,8BAA8B,gBAAgB;AAClH,cAAc;AACd,sEAAsE,QAAQ,8BAA8B,gBAAgB;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,IAAI,OAAO;AACrD;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,uCAAuC;AAChD,cAAc,mCAAmC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,0BAA0B;AACnC,cAAc,QAAQ;AACtB,cAAc,+CAA+C;AAC7D;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,4DAA4D;AACrE,cAAc,QAAQ;AACtB,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,2CAA2C;AACpD,cAAc,QAAQ;AACtB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,yCAAyC;AAClD,cAAc,QAAQ;AACtB,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,iCAAiC;AAC/C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,yCAAyC;AAClD,cAAc,QAAQ;AACtB,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,2CAA2C;AACpD,cAAc,QAAQ;AACtB,cAAc,gCAAgC;AAC9C;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,6BAA6B,YAAY;AACzC,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,2CAA2C;AACpD,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA,oCAAoC,SAAS,IAAI,MAAM,GAAG;AAC1D;AACA,kCAAkC,SAAS,IAAI,OAAO;AACtD;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kBAAkB;AAC3B,cAAc,QAAQ;AACtB,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY,GAAG,8BAA8B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,sBAAsB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA,gCAAgC,SAAS,KAAK,kBAAkB;AAChE;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,aAAa,SAAS;AAC3E;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW,GAAG,UAAU;AAC7D;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB;AAChB,wBAAwB,iBAAiB;AACzC,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,aAAa,SAAS;AAC3E;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,WAAW,GAAG,UAAU;AAC7D;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,gBAAgB;AAChB,wBAAwB,iBAAiB;AACzC,gCAAgC,2BAA2B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,yEAAyE;AAClF,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,qBAAqB,uBAAuB;AACxF,yBAAyB,aAAa,gBAAgB,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,qBAAqB,uBAAuB;AACxF,yBAAyB,aAAa,gBAAgB,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,SAAS,SAAS,GAAG,SAAS,EAAE;AAC1E;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,qBAAqB,uBAAuB;AACxF,yBAAyB,aAAa,gBAAgB,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,SAAS,SAAS,GAAG,SAAS,GAAG,SAAS,EAAE;AACtF;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,qBAAqB,uBAAuB;AACxF,yBAAyB,aAAa,gBAAgB,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,SAAS,SAAS,GAAG,SAAS,GAAG,SAAS,GAAG,SAAS,EAAE;AAClG;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA,sCAAsC,WAAW,IAAI,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,qBAAqB,uBAAuB;AACxF,yBAAyB,aAAa,sBAAsB,UAAU;AACtE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW,QAAQ,2BAA2B,GAAG,uBAAuB;AAC5G,iCAAiC,WAAW,kCAAkC,UAAU;AACxF,yBAAyB,aAAa,mBAAmB,UAAU;AACnE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,QAAQ;AACtB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW,QAAQ,2BAA2B,GAAG,uBAAuB;AAC5G,iCAAiC,WAAW,kCAAkC,UAAU;AACxF,yBAAyB,aAAa,yBAAyB,UAAU;AACzE;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC,qBAAqB,aAAa,UAAU,oBAAoB,IAAI,oBAAoB;AACxF,qBAAqB,mBAAmB,UAAU,mBAAmB,IAAI,mBAAmB,IAAI,mBAAmB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,kCAAkC;AAC3C,cAAc,WAAW;AACzB,cAAc,kBAAkB;AAChC,cAAc,oBAAoB;AAClC,cAAc,QAAQ;AACtB;AACA,cAAc,iBAAiB;AAC/B,cAAc,eAAe;AAC7B,cAAc,iBAAiB;AAC/B,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAoE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uCAAuC;AACjE;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,0BAA0B,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,0CAA0C,aAAa,IAAI,aAAa,IAAI,aAAa;AACzF,wCAAwC,WAAW,IAAI,WAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,YAAY;AACZ,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,8DAA8D,iBAAiB;AAC/E;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D,8CAA8C,iBAAiB;AAC/D;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gBAAgB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sDAAsD;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,iCAAiC,MAAM,MAAM,sDAAsD,yBAAyB,wBAAwB;AACpJ;AACA,cAAc;AACd;AACA,iCAAiC,MAAM,MAAM,sDAAsD,mBAAmB,wBAAwB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,iBAAiB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,iCAAiC,MAAM,IAAI,SAAS,0BAA0B,wBAAwB;AACtG;AACA,cAAc;AACd;AACA,iCAAiC,MAAM,IAAI,SAAS,oBAAoB,wBAAwB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,iCAAiC,MAAM,+BAA+B,eAAe;AACrF;AACA,cAAc;AACd;AACA,iCAAiC,MAAM,yBAAyB,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA,+BAA+B,MAAM,yBAAyB,wBAAwB;AACtF,+BAA+B,MAAM,yBAAyB,wBAAwB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA,+BAA+B,MAAM,yBAAyB,wBAAwB;AACtF,+BAA+B,MAAM,yBAAyB,wBAAwB;AACtF,+BAA+B,MAAM,yBAAyB,wBAAwB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA,qCAAqC,MAAM,4BAA4B,wBAAwB;AAC/F;AACA,kBAAkB;AAClB;AACA,qCAAqC,MAAM,sBAAsB,wBAAwB;AACzF;AACA;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F,mCAAmC,MAAM,yBAAyB,wBAAwB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,wCAAwC,SAAS;AACjD,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,qOAAqO;AAC9O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV,cAAc,QAAQ;AACtB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,uCAAuC,KAAK;AAC5C,cAAc;AACd,kCAAkC,KAAK;AACvC;AACA,YAAY;AACZ,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,+CAA+C;AACxD,cAAc,2BAA2B;AACzC,cAAc,yBAAyB;AACvC,cAAc,2BAA2B;AACzC;AACA,cAAc,6BAA6B;AAC3C,cAAc,oCAAoC;AAClD;AACA,cAAc,kCAAkC;AAChD,cAAc,yCAAyC;AACvD;AACA,cAAc,6BAA6B;AAC3C,cAAc,oCAAoC;AAClD;AACA,cAAc,+BAA+B;AAC7C,cAAc,sCAAsC;AACpD;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA,cAAc,gDAAgD;AAC9D,cAAc,uDAAuD;AACrE;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA,cAAc,+BAA+B;AAC7C,cAAc,sCAAsC;AACpD;AACA,cAAc,kCAAkC;AAChD,cAAc,yCAAyC;AACvD;AACA,cAAc,kCAAkC;AAChD,cAAc,yCAAyC;AACvD;AACA,cAAc,kCAAkC;AAChD,cAAc,yCAAyC;AACvD;AACA,cAAc,gCAAgC;AAC9C,cAAc,gCAAgC;AAC9C,cAAc,gCAAgC;AAC9C;AACA,cAAc,iCAAiC;AAC/C,cAAc,wCAAwC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,+DAA+D,MAAM;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,+nCAA+nC;AACxoC,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,uCAAuC;AAChD,cAAc,QAAQ;AACtB,cAAc,kCAAkC;AAChD;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,iBAAiB,QAAQ;AACrE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAAwB,oBAAoB,QAAQ,kBAAkB;AACtE;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,6CAA6C;AACtD,cAAc,QAAQ;AACtB,cAAc,mCAAmC;AACjD;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB,YAAY,QAAQ;AAChE,wBAAwB,oBAAoB,QAAQ,YAAY;AAChE,wBAA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ACnC,cAAc,kBAAkB;AAChC,cAAc,QAAQ;AACtB,cAAc,iBAAiB;AAC/B,cAAc,eAAe;AAC7B,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB,eAAe;AAC7D,YAAY;AACZ,2BAA2B,oBAAoB,eAAe;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D,8CAA8C,iBAAiB;AAC/D,0CAA0C,OAAO,kBAAkB,OAAO;AAC1E;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE,0CAA0C,OAAO,kBAAkB,OAAO;AAC1E;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE,0CAA0C,OAAO,kBAAkB,OAAO;AAC1E;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA,6CAA6C,oBAAoB;AACjE,0CAA0C,OAAO,kBAAkB,OAAO;AAC1E;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,gBAAgB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAsD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,yBAAyB,OAAO,IAAI,sDAAsD,yBAAyB,wBAAwB;AAC3I;AACA,cAAc;AACd;AACA,yBAAyB,OAAO,IAAI,sDAAsD,mBAAmB,wBAAwB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,yBAAyB,MAAM,GAAG,SAAS,0BAA0B,eAAe;AACpF;AACA,cAAc;AACd;AACA,yBAAyB,MAAM,GAAG,SAAS,oBAAoB,eAAe;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA;AACA,yBAAyB,MAAM,8BAA8B,eAAe;AAC5E;AACA,cAAc;AACd;AACA,yBAAyB,MAAM,wBAAwB,eAAe;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA,uBAAuB,MAAM,wBAAwB,eAAe;AACpE,uBAAuB,MAAM,wBAAwB,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA;AACA,uBAAuB,MAAM,wBAAwB,eAAe;AACpE,uBAAuB,MAAM,wBAAwB,eAAe;AACpE,uBAAuB,MAAM,wBAAwB,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4BAA4B;AACtD;AACA,uBAAuB,OAAO,oBAAoB,wBAAwB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,2JAA2J;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO,EAAE,cAAc;AACvB,cAAc,UAAU;AACxB,cAAc,QAAQ;AACtB,cAAc,SAAS;AACvB,cAAc,YAAY;AAC1B,cAAc,mBAAmB;AACjC,cAAc,eAAe;AAC7B,cAAc,cAAc;AAC5B,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA,iDAAiD,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,cAAc;AACd,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA,YAAY;AACZ,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iBAAiB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,uMAAuM;AAChN,cAAc,MAAM;AACpB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB,cAAc,eAAe;AAC7B,cAAc,UAAU;AACxB,cAAc,kBAAkB;AAChC,cAAc,eAAe;AAC7B,cAAc,kBAAkB;AAChC,cAAc,YAAY;AAC1B;AACA,cAAc,mBAAmB;AACjC;AACA,cAAc,oBAAoB;AAClC,cAAc,cAAc;AAC5B,cAAc,wCAAwC;AACtD;AACA,cAAc,qBAAqB;AACnC,cAAc,eAAe;AAC7B,cAAc,yCAAyC;AACvD;AACA,cAAc,WAAW;AACzB;AACA,cAAc,SAAS;AACvB;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,ijBAAijB;AAC1jB;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB,iBAAiB,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,YAAY;AACjH;AACA,YAAY;AACZ;AACA,4CAA4C,mBAAmB,iBAAiB,GAAG,IAAI,GAAG,IAAI,QAAQ;AACtG;AACA,YAAY;AACZ;AACA,4CAA4C,mBAAmB,iBAAiB,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,cAAc;AACvB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,cAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAG;AACV;AACA,cAAc,QAAQ;AACtB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qDAAqD,8BAA8B;AACnF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA,YAAY;AACZ,qDAAqD,EAAE;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C,4BAA4B,qBAAqB;AACjD,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,SAAS;AACzC,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA,wDAAwD,OAAO,IAAI,SAAS,iCAAiC,SAAS;AACtH,YAAY;AACZ,wDAAwD,OAAO,IAAI,SAAS;AAC5E;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B,gBAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,4BAA4B,YAAY;AACxC;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,0CAA0C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA,mCAAmC,YAAY,GAAG,mCAAmC,KAAK,mBAAmB;AAC7G;AACA;AACA;AACA,gCAAgC,qBAAqB;AACrD;AACA;AACA,6DAA6D;AAC7D;AACA;AACA;AACA,yBAAyB,IAAI,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,4BAA4B,UAAU,EAAE,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa,IAAI,kBAAkB;AACnE,sBAAsB;AACtB;AACA;AACA,oBAAoB;AACpB,8BAA8B,aAAa,IAAI,kBAAkB;AACjE;AACA;AACA;AACA,gCAAgC,2BAA2B,GAAG,6BAA6B,GAAG,sDAAsD;AACpJ;AACA;AACA,gCAAgC,2BAA2B,GAAG,6BAA6B,GAAG,sDAAsD;AACpJ;AACA;AACA;AACA,gCAAgC,yBAAyB,GAAG,sDAAsD;AAClH,sBAAsB;AACtB;AACA;AACA,kCAAkC,uBAAuB,GAAG,yBAAyB,GAAG,sDAAsD;AAC9I,wBAAwB;AACxB;AACA,kCAAkC,yBAAyB,GAAG,sDAAsD;AACpH;AACA,sBAAsB;AACtB,gCAAgC,2BAA2B,GAAG,yBAAyB,GAAG,sDAAsD;AAChJ,sBAAsB;AACtB;AACA;AACA;AACA;AACA,qCAAqC,sBAAsB;AAC3D;AACA,+BAA+B,kBAAkB,EAAE,aAAa,EAAE,mBAAmB;AACrF;AACA;AACA,gCAAgC,cAAc,EAAE,sBAAsB;AACtE,sBAAsB;AACtB,gCAAgC,uBAAuB,EAAE,aAAa;AACtE;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA,iCAAiC,yBAAyB;AAC1D;AACA,iCAAiC,mCAAmC,OAAO,kBAAkB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oBAAoB,GAAG,sBAAsB;AAC/E;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB,GAAG,sDAAsD;AACjH;AACA,qCAAqC,mBAAmB,EAAE,mBAAmB,EAAE,oBAAoB,IAAI,kBAAkB;AACzH;AACA,gCAAgC,kBAAkB,EAAE,aAAa,EAAE,mBAAmB;AACtF;AACA,gCAAgC,sBAAsB,EAAE,aAAa;AACrE;AACA,oCAAoC,kBAAkB,IAAI,wBAAwB;AAClF;AACA,sCAAsC,sBAAsB;AAC5D;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,gCAAgC,kBAAkB,GAAG,wBAAwB,GAAG,uBAAuB;AACvG;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU;AAChE;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yCAAyC,4CAA4C;AACrF;AACA;AACA,sBAAsB,aAAa;AACnC,0CAA0C,mCAAmC;AAC7E;AACA;AACA,iDAAiD,qDAAqD;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,uBAAuB;AACvB,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd,sBAAsB,WAAW;AACjC,yCAAyC,gCAAgC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,mBAAmB;AACnB,kBAAkB;AAClB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B,gBAAgB;AAC7C,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B,gBAAgB;AAC7C,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B,gBAAgB;AAC7C,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B,gBAAgB;AAC7C,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B;AAC7B,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B;AAC7B,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B;AAC7B,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,6BAA6B;AAC7B,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,qDAAqD,cAAc;AACnE,oBAAoB,OAAO;AAC3B;AACA,YAAY;AACZ,sHAAsH,kCAAkC;AACxJ;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,EAAE,wCAAwC,EAAE,GAAG;AACtD,OAAO;;;;;;;;;;;;;;;;;;;AC1hmBP;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM;AACxB;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,oBAAoB;AACpB,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;AC9kB6B;AACiD;AAC9E;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACO;AACP;AACA;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yBAAyB,wCAAwC;AACjE;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,yBAAyB,UAAU;AACnC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP,yBAAyB,qDAAqD;AAC9E;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI,uBAAuB;AAC3B;AACA,2CAA2C,iCAAqB;AAChE,6CAA6C,iCAAqB;AAClE,kCAAkC,wBAAY;AAC9C,mCAAmC,yBAAa;AAChD,2CAA2C,iCAAqB;AAChE,4CAA4C,kCAAsB;AAClE,kCAAkC,wBAAY;AAC9C,mCAAmC,yBAAa;AAChD,2CAA2C,iCAAqB;AAChE,4CAA4C,kCAAsB;AAClE,wCAAwC,8BAAkB;AAC1D,wCAAwC,8BAAkB;AAC1D,iDAAiD,uCAA2B;AAC5E,wCAAwC,8BAAkB;AAC1D,iDAAiD,uCAA2B;AAC5E,kDAAkD,wCAA4B;AAC9E,kDAAkD,wCAA4B;AAC9E,2CAA2C,iCAAqB;AAChE;AACA;AACA,OAAO,4CAA4C;AACnD,OAAO,iDAAiD;AACxD,OAAO,0BAA0B;AACjC,OAAO,4BAA4B;AACnC,OAAO,6CAA6C;AACpD,OAAO,0BAA0B;AACjC,OAAO,4BAA4B;AACnC,OAAO,4CAA4C;AACnD,OAAO,8CAA8C;AACrD,OAAO,sCAAsC;AAC7C,OAAO,sCAAsC;AAC7C,OAAO,wDAAwD;AAC/D,OAAO,sCAAsC;AAC7C,OAAO,wDAAwD;AAC/D,OAAO,0DAA0D;AACjE,OAAO,0DAA0D;AACjE,OAAO;AACP;AACA;AACA;AACA,qFAAqF,gBAAgB;AACrG;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kCAAkC;AACvD;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,sEAAsE;AACtE;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kCAAkC;AACvD;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,sEAAsE;AACtE;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,2BAA2B;AAC3B;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kCAAkC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA,uCAAuC;AACvC,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA,2CAA2C,2BAA2B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;;;AChrBY;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AAC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","sources":["webpack://magic/webpack/universalModuleDefinition","webpack://magic/./node_modules/objectlisteners/ObjectListener.js","webpack://magic/./node_modules/anotherstatemanager/StateManager.js","webpack://magic/./src/lib/Event.js","webpack://magic/./src/lib/Math2.js","webpack://magic/./src/lib/ProxyListener.js","webpack://magic/./src/lib/workerCallbacks.js","webpack://magic/./node_modules/gpujsutils/src/gpu-browser.min.js","webpack://magic/./node_modules/gpujsutils/src/gpuUtils-functs.js","webpack://magic/./node_modules/gpujsutils/src/gpuUtils.js","webpack://magic/./node_modules/worker-loader/dist/runtime/inline.js","webpack://magic/./src/lib|lazy|groupOptions: {}|namespace object","webpack://magic/webpack/bootstrap","webpack://magic/webpack/runtime/compat get default export","webpack://magic/webpack/runtime/define property getters","webpack://magic/webpack/runtime/hasOwnProperty shorthand","webpack://magic/webpack/runtime/publicPath","webpack://magic/./src/magic.worker.js","webpack://magic/./src/lib/ProxyElement.js","webpack://magic/./src/lib/ThreadedCanvas.js","webpack://magic/./src/WorkerManager.js","webpack://magic/./src/package.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"magic\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"magic\"] = factory();\n\telse\n\t\troot[\"magic\"] = factory();\n})(this, function() {\nreturn ","\r\n/*\r\n//Example:\r\nlet events = new ObjectListener();\r\nlet x = { y: 1, z: { w: 2 }}\r\n\r\n\r\nevents.addListener(\"y\",x,\"y\");\r\nevents.addListener(\"z\",x,\"z\");\r\n\r\nx.z.w = 3;\r\nx.y = 2;\r\n//See console\r\n\r\n*/\r\n\r\n//By Joshua Brewster (AGPL v3.0 License)\r\n\r\n//Create instance and then call instance.addListener(listenerName,objectToListenTo,propToListenTo,onchange,interval).\r\n//name, propToListenTo, onchange, and interval are optional (leave or set as undefined). Onchange is a custom callback just like for other event listeners. Set a name to make it easier to start and stop or edit each listener.\r\nexport class ObjectListener {\r\n    constructor(debug=false, synchronous=false) {\r\n        this.debug = debug;\r\n        this.listeners = [];\r\n        this.synchronous = synchronous;//check all listeners simulatenously instead of on individual loops. use startSync() to trigger\r\n        this.syncInterval = 'FRAMERATE'; //interval\r\n        this.syncAnim = undefined;\r\n        if(synchronous === true) this.startSync();\r\n    }\r\n\r\n    //add a new object listener with specified props (or none to watch the whole object), and onchange functions, with optional interval\r\n    addListener(listenerKey=null,objectToListenTo,propToListenTo=undefined,onchange=undefined,interval=undefined,debug=this.debug,startRunning=true) {\r\n        if(objectToListenTo === undefined) {\r\n            console.error(\"You must assign an object\");\r\n            return;\r\n        }\r\n\r\n        var key = listenerKey;\r\n        if(key == null) {\r\n            key = Math.floor(Math.random()*100000);\r\n        }\r\n        if(this.synchronous === true) startRunning = false; //negate this in case of synchronous runtime\r\n        var listener = {key:key, listener: new ObjectListenerInstance(objectToListenTo,propToListenTo,onchange,interval,debug,startRunning)};\r\n        this.listeners.push(listener);\r\n    }\r\n\r\n    getListener(key) {\r\n        let found = this.listeners.find((item,i) =>{\r\n            if(item.key === key) return true;\r\n        });\r\n        return found;\r\n    }\r\n\r\n    hasKey(key) {\r\n        var found = false;\r\n        this.listeners.forEach((item,i) =>{\r\n            if(item.key === key) {found = true; return true;}\r\n        });\r\n        return found;\r\n    }\r\n\r\n    getKeyIndices(key) {\r\n        var indices = [];\r\n        this.listeners.find((o,i) => {\r\n            if(o.key === key) {\r\n                indices.push(i);\r\n            }\r\n        });\r\n        return indices;\r\n    }\r\n\r\n    onchange(key=null,newCallback=null){\r\n        if(key == null) {\r\n            this.listeners.forEach((obj,i) => {\r\n                obj.listener.onchange = newCallback;\r\n            });\r\n        }\r\n        else {\r\n            var found = this.listeners.find((o,i) => {\r\n                if(o.name === key) {\r\n                    o.listener.onchange = newCallback;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    //Add extra onchange functions\r\n    addFunc = (key=null,newCallback=null, start=true) => {\r\n        var callbackIdx = null;\r\n        if(newCallback !== null){\r\n            if(key == null) {\r\n                this.listeners.forEach((obj,i) => {\r\n                    callbackIdx = obj.listener.addFunc(newCallback);\r\n                    if(obj.listener.running == false && start == true)\r\n                        obj.listener.start();\r\n                });\r\n            }\r\n            else {\r\n                var found = this.listeners.find((obj,i) => {\r\n                    if(obj.key === key) {\r\n                        callbackIdx = obj.listener.addFunc(newCallback);\r\n                        if(obj.listener.running == false && start == true)\r\n                            obj.listener.start();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return callbackIdx;\r\n    }\r\n\r\n    //get the array of secondary onchange functions\r\n    getFuncs = (key=undefined) => {\r\n        if(key) {\r\n            var found = this.listeners.find((o,i) => {\r\n                if(o.key === key) {\r\n                    return true;\r\n                }\r\n            });\r\n            return found.onchangeFuncs;\r\n        } else return undefined;\r\n    }\r\n\r\n    //Remove extra onchange functions\r\n    removeFuncs = (key = null, idx = null, stop=false) => {\r\n        if(key == null) {\r\n            this.listeners.forEach((obj,i) => {\r\n                obj.listener.removeFuncs(idx);\r\n            });\r\n        }\r\n        else {\r\n            var found = this.listeners.find((o,i) => {\r\n                if(o.key === key) {\r\n                    o.listener.removeFuncs(idx);\r\n                    if(o.listener.onchangeFuncs.length === 0 || stop === true) {\r\n                        o.listener.stop()\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    //Stop all or named listeners\r\n    stop(key=null) {\r\n        if(this.synchronous) this.stopSync();\r\n        if(key == null) {\r\n            this.listeners.forEach((obj,i) => {\r\n                obj.listener.stop();\r\n            });\r\n        }\r\n        else {\r\n            var found = this.listeners.find((o,i) => {\r\n                if(o.name === key) {\r\n                    o.listener.stop();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    //Restart all or named listeners\r\n    start(key=null) {\r\n        if(this.synchronous) this.stopSync();\r\n        if(key == null) {\r\n            this.listeners.forEach((obj,i) => {\r\n                obj.listener.start();\r\n            });\r\n        }\r\n        else {\r\n            var found = this.listeners.find((o,i) => {\r\n                if(o.name === key) {\r\n                    o.listener.start();\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    //run listeners synchronously instead of on their own individual loops\r\n    startSync() {\r\n        if(this.synchronous === false) {\r\n            this.synchronous = true;\r\n            this.stop(); //stop the async calls\r\n            let runChecks = () => {\r\n                if(this.synchronous === true) {\r\n                    this.listeners.forEach((l)=>{\r\n                        l.listener.check();\r\n                    });\r\n                    if(this.syncInterval === 'FRAMERATE') {\r\n                        this.syncAnim = requestAnimationFrame(runChecks);\r\n                    } else if (typeof this.syncInterval === 'number') {\r\n                        setTimeout(runChecks, this.syncInterval);\r\n                    }\r\n                }\r\n            }\r\n            runChecks();\r\n        }\r\n    }\r\n\r\n    //stop the synchronous checking\r\n    stopSync() {\r\n        this.synchronous = false;\r\n        if(this.syncAnim) cancelAnimationFrame(this.syncAnim);\r\n    }   \r\n\r\n    remove(key=null){\r\n        if(key == null) {\r\n            this.listeners.forEach((o) => {\r\n                o.listener.stop();\r\n            });\r\n            this.listeners.splice(0,this.listeners.length);\r\n        }\r\n        else {\r\n            var indices = [];\r\n            var found = this.listeners.forEach((o,i) => {\r\n                if(o.key === key) {\r\n                    indices.push(i);\r\n                }\r\n            });\r\n            indices.reverse().forEach((idx) => {\r\n                this.listeners[idx].listener.stop();\r\n                this.listeners.splice(idx,1);\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\n//Instance of an object listener. This will subscribe to object properties (or whole objects) and run attached functions when a change is detected.\r\nexport class ObjectListenerInstance {\r\n    constructor(object,propName=\"__ANY__\",onchange=this.onchange,interval=\"FRAMERATE\",debug=false,startRunning=true) {\r\n        this.debug=debug;\r\n\r\n        this.onchange = onchange; //Main onchange function\r\n        this.onchangeFuncs = []; //Execute extra functions pushed to this array\r\n\r\n        this.object = object; //Objects are always passed by reference\r\n        this.propName = propName;\r\n        this.propOld = undefined;\r\n        this.setListenerRef(propName);\r\n\r\n        this.running = startRunning;\r\n        this.funcs = 0;\r\n\r\n        this.interval;\r\n        if(interval < 10) {\r\n            this.interval = 10; console.log(\"Min recommended interval set: 10ms\");}\r\n        else {\r\n            this.interval = interval;\r\n        }\r\n\r\n        if(startRunning === true) {\r\n            if (typeof window === 'undefined') {\r\n                setTimeout(()=>{this.check();}, 60)\r\n            } else {\r\n                this.checker = requestAnimationFrame(this.check);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Main onchange execution\r\n    onchange = (newData) => {\r\n        console.log(this.propName,\" changed from: \", this.propOld,\" to: \", this.object[this.propName]);\r\n    }\r\n\r\n    //Add extra onchange functions for execution\r\n    addFunc = (onchange=null) => {\r\n        let sub = 0;\r\n        if(onchange !== null){\r\n            this.onchangeFuncs.push({idx:this.funcs, onchange:onchange});\r\n            sub=this.funcs;\r\n            this.funcs++;\r\n        }\r\n        return sub;\r\n    }\r\n\r\n    //Remove extra onchange functions\r\n    removeFuncs(idx = null) {\r\n        let i = 0;\r\n        if(idx === null) {\r\n            this.onchangeFuncs = [];\r\n        }\r\n        else if(this.onchangeFuncs.find((o,j)=>{if(o.idx===idx){ i=j; return true;}}) !== undefined) {\r\n            this.onchangeFuncs.splice(i,1);\r\n        }\r\n    }\r\n\r\n    //Execute extra onchange functions\r\n    onchangeMulti = (newData) => {\r\n        let onChangeCache = [...this.onchangeFuncs]\r\n        onChangeCache.forEach((func,i) => {\r\n            if(this.debug === true) { console.log(func.onchange); }\r\n            func.onchange(newData);\r\n        });\r\n    }\r\n\r\n    //Update listener reference copy.\r\n    setListenerRef = (propName) => {\r\n        if(propName === \"__ANY__\" || propName === null || propName === undefined) {\r\n            this.propOld = JSON.stringifyFast(this.object);\r\n        }\r\n        else if(Array.isArray(this.object[propName])) {\r\n            this.propOld = JSON.stringifyFast(this.object[propName].slice(this.object[propName].length-20));\r\n        }\r\n        else if(typeof this.object[propName] === \"object\"){\r\n            this.propOld = JSON.stringifyFast(this.object[propName]);\r\n        }\r\n        else if(typeof this.object[propName] === \"function\"){\r\n            this.propOld = this.object[propName].toString();\r\n        }\r\n        else{\r\n            this.propOld = this.object[propName]; //usually a number, bool, or string;\r\n        }\r\n        \r\n        if(this.debug === true) { console.log(\"propname\", propName, \", new assignment: \", this.propOld); }\r\n    }\r\n\r\n    check = () => {\r\n        let changed = false;\r\n        if(this.propName === \"__ANY__\" || this.propName === null || this.propName === undefined){\r\n            if(this.propOld !== JSON.stringifyFast(this.object)){\r\n                if(this.debug === true) { console.log(\"onchange: \", this.onchange); }\r\n                this.onchange(this.object);\r\n                if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object); }\r\n                this.setListenerRef(this.propName);\r\n                changed = true;\r\n            }\r\n        }\r\n        else if(Array.isArray(this.object[this.propName])) { //cut arrays down for speed\r\n            if(this.propOld !== JSON.stringifyFast(this.object[this.propName].slice(this.object[this.propName].length-20))){\r\n                if(this.debug === true) { console.log(\"onchange: \", this.onchange); }\r\n                this.onchange(this.object[this.propName]);\r\n                if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object[this.propName]); }\r\n                this.setListenerRef(this.propName);\r\n                changed = true;\r\n            }\r\n        }\r\n        else if(typeof this.object[this.propName] === \"object\") {\r\n            let string = JSON.stringifyFast(this.object[this.propName]);\r\n            if(this.propOld !== string){\r\n                if(this.debug === true) { console.log(\"onchange: \", this.onchange); }\r\n                this.onchange(this.object[this.propName]);\r\n                if(this.onchangeFuncs.length > 0) { \r\n                    this.onchangeMulti(this.object[this.propName]); \r\n                }\r\n                this.setListenerRef(this.propName);\r\n                changed = true;\r\n            }\r\n        }\r\n        else if(typeof this.object[this.propName] === \"function\") {\r\n            if(this.propOld !== this.object[this.propName].toString()){\r\n                if(this.debug === true) { console.log(\"onchange: \", this.onchange); }\r\n                this.onchange(this.object[this.propName].toString());\r\n                if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object[this.propName].toString()); }\r\n                this.setListenerRef(this.propName);\r\n                changed = true;\r\n            }\r\n        }\r\n        else if(this.object[this.propName] !== this.propOld) {\r\n            if(this.debug === true) { console.log(\"onchange: \", this.onchange); }\r\n            this.onchange(this.object[this.propName]);\r\n            if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object[this.propName]); }\r\n            this.setListenerRef(this.propName);\r\n            changed = true;\r\n        }\r\n        \r\n        if(this.running === true) {\r\n            if(this.debug === true) {console.log(\"checking\", this.object, this.propName);}\r\n            if(this.interval === \"FRAMERATE\"){\r\n                if (typeof window === 'undefined') {\r\n                    setTimeout(()=>{this.check();}, 16)\r\n                } else {\r\n                    this.checker = requestAnimationFrame(this.check);\r\n                }\r\n            }\r\n            else {\r\n                setTimeout(()=>{this.check();},this.interval);\r\n            }\r\n        };\r\n\r\n        return changed;\r\n    }\r\n\r\n    start() {\r\n        this.running = true;\r\n        if (typeof window === 'undefined') {\r\n            setTimeout(()=>{this.check();}, 16);\r\n        } else {\r\n            this.checker = requestAnimationFrame(this.check);\r\n        }\r\n    }\r\n\r\n    stop() {\r\n        this.running = false;\r\n        cancelAnimationFrame(this.checker);\r\n    }\r\n\r\n}\r\n\r\n\r\n//This only really matters in Chrome and one other browser\r\nexport function sortObjectByValue(object) { //Sorts number and string objects by numeric value. Strings have charcodes summed for comparison. Objects and functions are stringified.\r\n    var sortable = [];\r\n    for(var prop in object) {\r\n        sortable.push([prop, object[prop]]);\r\n    }\r\n\r\n    sortable.sort(function(a,b) {\r\n        var prop1 = a;\r\n        var prop2 = b;\r\n        if(typeof prop1[1] === \"function\"){\r\n            prop1[1] = prop1[1].toString();\r\n        }\r\n        else if(typeof prop1[1] === \"object\"){\r\n            prop1[1] = JSON.stringifyFast(prop1[1]);\r\n        }\r\n        if(typeof prop2[1] === \"function\"){\r\n            prop2[1] = prop2[1].toString();\r\n        }\r\n        else if(typeof prop2[1] === \"object\"){\r\n            prop2[1] = JSON.stringifyFast(prop2[1]);\r\n        }\r\n        \r\n        if(typeof prop1[1] === \"string\") {\r\n            var temp = 0;\r\n            prop1.forEach((char,i) => {\r\n                temp += prop1.charCodeAt(i);\r\n            });\r\n            prop1 = temp;\r\n        }\r\n        if(typeof prop2[1] === \"string\") {\r\n            var temp = 0;\r\n            prop2.forEach((char,i) => {\r\n                temp += prop2.charCodeAt(i);\r\n            });\r\n            prop2 = temp;\r\n        }\r\n        return prop1[1]-prop2[1];\r\n    });\r\n\r\n    var sorted = {};\r\n\r\n    sortable.forEach((item) => {\r\n       sorted[item[0]]=item[1];\r\n    });\r\n\r\n    return sorted;\r\n\r\n}\r\n\r\nexport function sortObjectByPropName(object) {\r\n\r\n    var sortable = [];\r\n\r\n    for(var prop in object) {\r\n        sortable.push([prop, object[prop]]);\r\n    }\r\n\r\n    sortable.sort(function(a,b) {\r\n        return a[0] > b[0];\r\n    });\r\n\r\n    var sorted = {};\r\n\r\n    sortable.forEach((item) => {\r\n        sorted[item[0]]=item[1];\r\n    });\r\n\r\n    return sorted;\r\n\r\n}\r\n\r\n//modified to also cut down the size arrays for faster looping\r\nif(JSON.stringifyFast === undefined) {\r\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\r\n    JSON.stringifyFast = (function() {\r\n        const refs = new Map();\r\n        const parents = [];\r\n        const path = [\"this\"];\r\n\r\n        function clear() {\r\n            refs.clear();\r\n            parents.length = 0;\r\n            path.length = 1;\r\n        }\r\n\r\n        function updateParents(key, value) {\r\n            var idx = parents.length - 1;\r\n            if(parents[idx]){\r\n                var prev = parents[idx];\r\n                if (prev[key] === value || idx === 0) {\r\n                    path.push(key);\r\n                    parents.push(value.pushed);\r\n                } else {\r\n                    while (idx-- >= 0) {\r\n                    prev = parents[idx];\r\n                    if (prev[key] === value) {\r\n                        idx += 2;\r\n                        parents.length = idx;\r\n                        path.length = idx;\r\n                        --idx;\r\n                        parents[idx] = value;\r\n                        path[idx] = key;\r\n                        break;\r\n                    }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkValues(key, value) {\r\n            let val;\r\n            if (value != null) {\r\n                if (typeof value === \"object\") {\r\n                    //if (key) { updateParents(key, value); }\r\n                    let c = value.constructor.name;\r\n                    if (key && c === 'Object') {updateParents(key, value); }\r\n\r\n                    let other = refs.get(value);\r\n                    if (other) {\r\n                        return '[Circular Reference]' + other;\r\n                    } else {\r\n                        refs.set(value, path.join('.'));\r\n                    }\r\n                    if(c === \"Array\") { //Cut arrays down to 100 samples for referencing\r\n                        if(value.length > 20) {\r\n                            val = value.slice(value.length-20);\r\n                        } else val = value;\r\n                       // refs.set(val, path.join('.'));\r\n                    }  \r\n                    else if (c.includes(\"Set\")) {\r\n                        val = Array.from(value)\r\n                    }  \r\n                    else if (c !== \"Object\" && c !== \"Number\" && c !== \"String\" && c !== \"Boolean\") { //simplify classes, objects, and functions, point to nested objects for the state manager to monitor those properly\r\n                        val = \"instanceof_\"+c;\r\n                    }\r\n                    else if (c === 'Object') {\r\n                        let obj = {};\r\n                        for(const prop in value) {\r\n                            if (value[prop] == null){\r\n                                obj[prop] = value[prop]; \r\n                            }\r\n                            else if(Array.isArray(value[prop])) { \r\n                                if(value[prop].length>20)\r\n                                    obj[prop] = value[prop].slice(value[prop].length-20); \r\n                                else obj[prop] = value[prop];\r\n                            } //deal with arrays in nested objects (e.g. means, slices)\r\n                            else if (value[prop].constructor.name === 'Object') { //additional layer of recursion for 3 object-deep array checks\r\n                                obj[prop] = {};\r\n                                for(const p in value[prop]) {\r\n                                    if(Array.isArray(value[prop][p])) {\r\n                                        if(value[prop][p].length>20)\r\n                                            obj[prop][p] = value[prop][p].slice(value[prop][p].length-20); \r\n                                        else obj[prop][p] = value[prop][p];\r\n                                    }\r\n                                    else { \r\n                                        if (value[prop][p] != null){\r\n                                            let con = value[prop][p].constructor.name;\r\n                                            if (con.includes(\"Set\")) {\r\n                                                obj[prop][p] = Array.from(value[prop][p])\r\n                                            } else if(con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\r\n                                                obj[prop][p] = \"instanceof_\"+con; //3-deep nested objects are cut off\r\n                                            }  else {\r\n                                                obj[prop][p] = value[prop][p]; \r\n                                            }\r\n                                        } else {\r\n                                            obj[prop][p] = value[prop][p]; \r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else { \r\n                                let con = value[prop].constructor.name;\r\n                                if (con.includes(\"Set\")) {\r\n                                    obj[prop] = Array.from(value[prop])\r\n                                } else if(con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\r\n                                    obj[prop] = \"instanceof_\"+con;\r\n                                } else {\r\n                                    obj[prop] = value[prop]; \r\n                                }\r\n                            }\r\n                        }\r\n                        //console.log(obj, value)\r\n                        val = obj;\r\n                        //refs.set(val, path.join('.'));\r\n                    }\r\n                    else {\r\n                        val = value;\r\n                    }\r\n                } else {\r\n                    val = value;\r\n                }\r\n            }\r\n            //console.log(value, val)\r\n            return val;\r\n        }\r\n\r\n        return function stringifyFast(obj, space) {\r\n            try {\r\n                parents.push(obj);\r\n                return JSON.stringify(obj, checkValues, space);\r\n            } catch(er) {\r\n                console.error(obj, er);\r\n            } finally {\r\n                clear();\r\n            } \r\n        }\r\n    })();\r\n}\r\n\r\n\r\n\r\nif(JSON.stringifyWithCircularRefs === undefined) {\r\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\r\n    JSON.stringifyWithCircularRefs = (function() {\r\n        const refs = new Map();\r\n        const parents = [];\r\n        const path = [\"this\"];\r\n\r\n        function clear() {\r\n        refs.clear();\r\n        parents.length = 0;\r\n        path.length = 1;\r\n        }\r\n\r\n        function updateParents(key, value) {\r\n        var idx = parents.length - 1;\r\n        var prev = parents[idx];\r\n        if (prev[key] === value || idx === 0) {\r\n            path.push(key);\r\n            parents.push(value);\r\n        } else {\r\n            while (idx-- >= 0) {\r\n            prev = parents[idx];\r\n            if (prev[key] === value) {\r\n                idx += 2;\r\n                parents.length = idx;\r\n                path.length = idx;\r\n                --idx;\r\n                parents[idx] = value;\r\n                path[idx] = key;\r\n                break;\r\n            }\r\n            }\r\n        }\r\n        }\r\n\r\n        function checkCircular(key, value) {\r\n        if (value != null) {\r\n            if (typeof value === \"object\") {\r\n            if (key) { updateParents(key, value); }\r\n\r\n            let other = refs.get(value);\r\n            if (other) {\r\n                return '[Circular Reference]' + other;\r\n            } else {\r\n                refs.set(value, path.join('.'));\r\n            }\r\n            }\r\n        }\r\n        return value;\r\n        }\r\n\r\n        return function stringifyWithCircularRefs(obj, space) {\r\n        try {\r\n            parents.push(obj);\r\n            return JSON.stringify(obj, checkCircular, space);\r\n        } finally {\r\n            clear();\r\n        }\r\n        }\r\n    })();\r\n}\r\n\r\nexport default ObjectListener","import ObjectListener from 'objectlisteners'\r\n\r\n//By Joshua Brewster (MIT License)\r\n//Simple state manager.\r\n//Set key responses to have functions fire when keyed values change\r\n//add variables to state with addToState(key, value, keyonchange (optional))\r\nexport class StateManager {\r\n    constructor(init = {}, interval=\"FRAMERATE\", defaultKeyEventLoop=true) { //Default interval is at the browser framerate\r\n        this.data = init;\r\n        this.interval = interval;\r\n        this.pushToState={};\r\n        this.pushRecord={pushed:[]}; //all setStates between frames\r\n        this.pushCallbacks = {};\r\n        this.triggers = {};\r\n\r\n        this.listener = new ObjectListener();\r\n        this.defaultStartListenerEventLoop = defaultKeyEventLoop;\r\n\r\n        /*\r\n        this.prev = Object.assign({},this.data);\r\n         \r\n        const onStateChanged = () => {\r\n            this.prev = Object.assign({},this.data);\r\n            //this.prev=JSON.parse(JSON.stringifyFast(this.data));\r\n        }\r\n\r\n        //Causes app to be stuck on startup\r\n        this.listener.addListener(\r\n            \"state\",\r\n            this.data,\r\n            \"__ANY__\",\r\n            onStateChanged,\r\n            interval,\r\n        );\r\n        */\r\n    }\r\n\r\n    setInterval(interval=\"FRAMERATE\") {\r\n        this.interval = interval;\r\n        this.listener.listeners.forEach((obj,i) => {\r\n            obj.interval = this.interval;\r\n        });\r\n    }\r\n\r\n\r\n    // Managed State Updates. Must Still Clean Event Listeners\r\n    updateState(key, value){\r\n        if (this.data[key] == null){\r\n            this.addToState(key,value)\r\n        } else {\r\n            this.data[key] = value\r\n        }    \r\n    }\r\n\r\n    //Removes all references to a state key i.e. subscriptions and data\r\n    removeState(key, sequential=false){\r\n            if (sequential) this.unsubscribeAllSequential(key);\r\n            else this.unsubscribeAll(key);\r\n            delete this.data[key]\r\n\r\n            // Log Update\r\n            this.setSequentialState({stateRemoved: key})\r\n    }\r\n\r\n    setupSynchronousUpdates = () => {\r\n        if(!this.listener.hasKey('pushToState')) {\r\n            //we won't add this listener unless we use this function\r\n            const pushToStateResponse = () => {\r\n                if(Object.keys(this.pushToState).length > 0) {\r\n                    //Object.assign(this.prev,this.data);//Temp fix until the global state listener function works as expected\r\n                    Object.assign(this.data,this.pushToState);\r\n\r\n                    //console.log(\"new state: \", this.data); console.log(\"props set: \", this.pushToState);\r\n                    for (const prop of Object.getOwnPropertyNames(this.pushToState)) {\r\n                        delete this.pushToState[prop];\r\n                    }\r\n                }\r\n            }\r\n    \r\n            this.listener.addListener(\r\n                \"pushToState\",\r\n                this.pushToState,\r\n                \"__ANY__\",\r\n                pushToStateResponse,\r\n                this.interval\r\n            );\r\n\r\n            this.addToState('pushRecord',this.pushRecord,(record)=>{\r\n\r\n                let l = record.pushed.length;\r\n                for (let i = 0; i < l; i++){\r\n                    let updateObj = record.pushed[i];\r\n                    for(const prop in updateObj) {\r\n                        if(this.pushCallbacks[prop]) {\r\n                            this.pushCallbacks[prop].forEach((o) =>{\r\n                                o.onchange(updateObj[prop]);\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                this.pushRecord.pushed.splice(0,l);\r\n            });\r\n\r\n            this.data.pushCallbacks = this.pushCallbacks;\r\n\r\n        }\r\n    }\r\n\r\n    //Alternatively just add to the state by doing this.state[key] = value with the state manager instance\r\n    addToState(key, value, onchange=null, startRunning=this.defaultStartListenerEventLoop, debug=false) {\r\n        if(!this.listener.hasKey('pushToState') && this.defaultStartListenerEventLoop) {\r\n            this.setupSynchronousUpdates();\r\n        }\r\n\r\n        this.data[key] = value;\r\n\r\n        // Log Update\r\n        this.setSequentialState({stateAdded: key})\r\n\r\n        if(onchange !== null){\r\n            return this.addSecondaryKeyResponse(key,onchange,debug,startRunning);\r\n        }\r\n    }\r\n\r\n    getState() { //Return a hard copy of the latest state with reduced values. Otherwise just use this.state.data\r\n        return JSON.parse(JSON.stringifyFast(this.data));\r\n    }\r\n\r\n    //Synchronous set-state, only updates main state on interval. Can set to trigger now instead of waiting on interval. Also can append arrays in state instead of replacing them\r\n    setState(updateObj={}, appendArrs=false){ //Pass object with keys in. Undefined keys in state will be added automatically. State only notifies of change based on update interval\r\n        //console.log(\"setting state\");\r\n        if(!this.listener.hasKey('pushToState') && this.defaultStartListenerEventLoop) {\r\n            this.setupSynchronousUpdates();\r\n            this.pushRecord.pushed.push(JSON.parse(JSON.stringifyWithCircularRefs(updateObj)));\r\n        }\r\n\r\n        updateObj.stateUpdateTimeStamp = Date.now();\r\n        \r\n        if(appendArrs) {\r\n            for(const prop in updateObj) { //3 object-deep array checks to buffer values instead of overwriting\r\n                if(this.pushToState[prop]) {\r\n                    if(Array.isArray(this.pushToState[prop]) && Array.isArray(updateObj[prop])) {\r\n                        updateObj[prop] = this.pushToState[prop].push(...updateObj[prop]);\r\n                    } else if (typeof this.pushToState[prop] === 'object' && typeof updateObj[prop] === 'object') {\r\n                        for(const p in updateObj[prop]) {\r\n                            if(this.pushToState[prop][p]) {\r\n                                if(Array.isArray(this.pushToState[prop][p]) && Array.isArray(updateObj[prop][p])) {\r\n                                    updateObj[prop][p] = this.pushToState[prop][p].push(...updateObj[prop][p]);\r\n                                }\r\n                                else if (typeof this.pushToState[prop][p] === 'object' && typeof updateObj[prop][p] === 'object') {\r\n                                    for(const p2 in updateObj[prop][p]) {\r\n                                        if(this.pushToState[prop][p][p2]) {\r\n                                            if(Array.isArray(this.pushToState[prop][p][p2]) && Array.isArray(updateObj[prop][p][p2])) {\r\n                                                updateObj[prop][p][p2] = this.pushToState[prop][p][p2].push(...updateObj[prop][p][p2]);\r\n                                            }\r\n                                        }\r\n                                        else if (typeof this.pushToState[prop][p][p2] === 'object' && typeof updateObj[prop][p][p2] === 'object') {\r\n                                            for(const p3 in updateObj[prop][p][p2]) {\r\n                                                if(this.pushToState[prop][p][p2][p3]) {\r\n                                                    if(Array.isArray(this.pushToState[prop][p][p2][p3]) && Array.isArray(updateObj[prop][p][p2][p3])) {\r\n                                                        updateObj[prop][p][p2][p3] = this.pushToState[prop][p][p2][p3].push(...updateObj[prop][p][p2][p3]);\r\n                                                    }\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        Object.assign(this.pushToState,updateObj);\r\n        \r\n        if(Object.keys(this.triggers).length > 0) {\r\n            // Object.assign(this.data,this.pushToState);\r\n            for (const prop of Object.getOwnPropertyNames(this.triggers)) {\r\n                if(this.pushToState[prop]) {\r\n                    this.data[prop] = this.pushToState[prop]\r\n                    delete this.pushToState[prop];\r\n                    this.triggers[prop].forEach((obj)=>{\r\n                        obj.onchange(this.data[prop]);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return this.pushToState;\r\n    }\r\n\r\n    //Trigger-only functions on otherwise looping listeners\r\n    subscribeTrigger(key=undefined,onchange=(value)=>{}) {\r\n\r\n        // console.error('SUBSCRIBING')\r\n        if(key) {\r\n            if(!this.triggers[key]) {\r\n                this.triggers[key] = [];\r\n            }\r\n            let l = this.triggers[key].length;\r\n            this.triggers[key].push({idx:l, onchange:onchange});\r\n            return this.triggers[key].length-1;\r\n        } else return undefined;\r\n    }\r\n\r\n    //will remove the trigger after firing once\r\n    subscribeTriggerOnce(key=undefined,onchange=(value)=>{}) {\r\n        let sub;\r\n        let changed = (value) => {\r\n            onchange(value);\r\n            this.unsubscribeTrigger(key,sub);\r\n        }\r\n\r\n        sub = this.subscribeTrigger(key,changed);\r\n    }\r\n\r\n    //Delete specific trigger functions for a key\r\n    unsubscribeTrigger(key=undefined,sub=0) {\r\n        let idx = undefined;\r\n        let triggers = this.triggers[key]\r\n        if (triggers){\r\n            let obj = triggers.find((o)=>{\r\n                if(o.idx===sub) {return true;}\r\n            });\r\n            if(obj) triggers.splice(idx,1);\r\n        }\r\n    }\r\n\r\n    //Remove all triggers for a key\r\n    unsubscribeAllTriggers(key) {\r\n        if(key && this.triggers[key]) {\r\n            delete this.triggers[key];\r\n        }\r\n    }\r\n\r\n    //only push to an object that keeps the sequences of updates instead of synchronously updating the whole state.\r\n    setSequentialState(updateObj={}) {\r\n        //console.log(\"setting state\");\r\n        if(!this.listener.hasKey('pushToState')) {\r\n            this.setupSynchronousUpdates();\r\n        }\r\n        updateObj.stateUpdateTimeStamp = Date.now();\r\n        this.pushRecord.pushed.push(JSON.parse(JSON.stringify(updateObj)));\r\n    }\r\n\r\n    subscribeSequential(key=undefined,onchange=undefined) {\r\n        // console.error('SUBSCRIBING')\r\n\r\n        if(key) {\r\n            \r\n            if(this.data[key] === undefined) {this.addToState(key,null,undefined);}\r\n\r\n            if(!this.pushCallbacks[key])\r\n                this.pushCallbacks[key] = [];\r\n\r\n            if(onchange) {\r\n                let idx = this.pushCallbacks[key].length;\r\n                this.pushCallbacks[key].push({idx:idx, onchange:onchange});\r\n                return this.pushCallbacks[key].length-1; //get key sub index for unsubscribing\r\n            } \r\n            else return undefined;\r\n        } else return undefined;\r\n    }\r\n    \r\n    //will remove the sequence after firing once (e.g. between frames)\r\n    subscribeSequentialOnce(key=undefined,onchange=(value)=>{}) {\r\n        let sub;\r\n        let changed = (value) => {\r\n            onchange(value);\r\n            this.unsubscribeSequential(key,sub);\r\n        }\r\n\r\n        sub = this.subscribeSequential(key,changed);\r\n    }\r\n\r\n    unsubscribeSequential(key=undefined,sub=0) {\r\n        if(key){\r\n            if(this.pushCallbacks[key]) {\r\n                if(this.pushCallbacks[key].find((o,j)=>{\r\n                    if(o.idx === sub) {\r\n                        this.pushCallbacks[key].splice(j,1);\r\n                        return true;\r\n                    }\r\n                })) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    unsubscribeAllSequential(key) {\r\n        if(key) {\r\n            if(this.pushCallbacks[key]) {\r\n                if(this.pushCallbacks[key]) {\r\n                    delete this.pushCallbacks[key];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //Set main onchange response for the property-specific object listener. Don't touch the state\r\n    setPrimaryKeyResponse(key=null, onchange=null, debug=false, startRunning=this.defaultStartListenerEventLoop) {\r\n        if(onchange !== null){\r\n            if(this.listener.hasKey(key)){\r\n                this.listener.onchange(key, onchange);\r\n            }\r\n            else if(key !== null){\r\n                this.listener.addListener(key, this.data, key, onchange, this.data[\"stateUpdateInterval\"], debug, startRunning);\r\n            }\r\n        }\r\n    }\r\n\r\n    //Add extra onchange responses to the object listener for a set property. Use state key for state-wide change responses\r\n    addSecondaryKeyResponse(key=null, onchange=null, debug=false, startRunning=this.defaultStartListenerEventLoop) {\r\n        if(onchange !== null){\r\n            if(this.listener.hasKey(key)){\r\n                return this.listener.addFunc(key, onchange);\r\n            }\r\n            else if(key !== null){\r\n                this.listener.addListener(key, this.data,key,()=>{},this.data[\"stateUpdateInterval\"], debug, startRunning);\r\n                return this.listener.addFunc(key, onchange);\r\n            }\r\n            else { return this.listener.addFunc(\"state\", onchange);}\r\n        }\r\n    }\r\n\r\n    //removes all secondary responses if idx left null. use \"state\" key for state-wide change responses\r\n    removeSecondaryKeyResponse(key=null,responseIdx=null, stopIfEmpty=true) {\r\n        if(key !== null) {\r\n            if(this.listener.hasKey(key)){\r\n                this.listener.removeFuncs(key, responseIdx, stopIfEmpty);\r\n            } else {\r\n                console.error(\"key does not exist\")\r\n            }\r\n        }\r\n        else{console.error(\"provide key\")}\r\n    }\r\n\r\n    //Remove any extra object listeners for a key. Entering \"state\" will break the state manager's primary response\r\n    clearAllKeyResponses(key=null) {\r\n        if(key === null) this.listener.remove(null);\r\n        else if(this.listener.hasKey(key)) this.listener.remove(key);\r\n    }\r\n\r\n    //Get all of the onchange functions added via subscribe/addSecondaryKeyResponse\r\n    getKeySubCallbacks(key) {\r\n        let callbacks = this.listener.getFuncs(key);\r\n        return callbacks;\r\n    }\r\n\r\n    //Save the return value to provide as the responseIdx in unsubscribe\r\n    subscribe(key, onchange, startRunning=true) {\r\n        // console.error('SUBSCRIBING')\r\n\r\n        if(this.data[key] === undefined) {this.addToState(key,null,onchange,startRunning);}\r\n        else {return this.addSecondaryKeyResponse(key,onchange);}\r\n    }\r\n \r\n    //will remove the subscription after firing once\r\n    subscribeOnce(key=undefined,onchange=(value)=>{}) {\r\n        let sub;\r\n        let changed = (value) => {\r\n            onchange(value);\r\n            this.unsubscribe(key,sub);\r\n        }\r\n\r\n        sub = this.subscribe(key,changed);\r\n    }\r\n    \r\n    //Unsubscribe from the given key using the index of the response saved from the subscribe() function\r\n    unsubscribe(key, responseIdx=null) {\r\n        if(responseIdx !== null) this.removeSecondaryKeyResponse(key, responseIdx, true);\r\n        else console.error(\"Specify a subcription function index\");\r\n    }\r\n\r\n    unsubscribeAll(key) { // Removes the listener for the key (including the animation loop)\r\n        this.clearAllKeyResponses(key);\r\n        if(this.data[key]) delete this.data[key];\r\n    }\r\n\r\n    //runs only one animation frame to check all state keys\r\n    runSynchronousListeners() {\r\n        this.defaultStartListenerEventLoop = false;\r\n        this.listener.startSync();\r\n    }\r\n\r\n    //stops the listener event loops without clearing the keys.\r\n    stop(key=null) {\r\n        this.listener.stop(key);\r\n    }\r\n\r\n}\r\n\r\n\r\n//modified to also cut down the size arrays for faster looping\r\nif(JSON.stringifyFast === undefined) {\r\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\r\n    JSON.stringifyFast = (function() {\r\n        const refs = new Map();\r\n        const parents = [];\r\n        const path = [\"this\"];\r\n\r\n        function clear() {\r\n            refs.clear();\r\n            parents.length = 0;\r\n            path.length = 1;\r\n        }\r\n\r\n        function updateParents(key, value) {\r\n            var idx = parents.length - 1;\r\n            //console.log(idx, parents[idx])\r\n            if(parents[idx]){\r\n                var prev = parents[idx];\r\n                //console.log(value); \r\n                if (prev[key] === value || idx === 0) {\r\n                    path.push(key);\r\n                    parents.push(value.pushed);\r\n                } else {\r\n                    while (idx-- >= 0) {\r\n                    prev = parents[idx];\r\n                    if (prev[key] === value) {\r\n                        idx += 2;\r\n                        parents.length = idx;\r\n                        path.length = idx;\r\n                        --idx;\r\n                        parents[idx] = value;\r\n                        path[idx] = key;\r\n                        break;\r\n                    }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        function checkValues(key, value) {\r\n            let val;\r\n            if (value != null) {\r\n                if (typeof value === \"object\") {\r\n                    //if (key) { updateParents(key, value); }\r\n                    let c = value.constructor.name;\r\n                    if (key && c === 'Object') {updateParents(key, value); }\r\n\r\n                    let other = refs.get(value);\r\n                    if (other) {\r\n                        return '[Circular Reference]' + other;\r\n                    } else {\r\n                        refs.set(value, path.join('.'));\r\n                    }\r\n                    if(c === \"Array\") { //Cut arrays down to 100 samples for referencing\r\n                        if(value.length > 20) {\r\n                            val = value.slice(value.length-20);\r\n                        } else val = value;\r\n                       // refs.set(val, path.join('.'));\r\n                    }  \r\n                    else if (c.includes(\"Set\")) {\r\n                        val = Array.from(value)\r\n                    }  \r\n                    else if (c !== \"Object\" && c !== \"Number\" && c !== \"String\" && c !== \"Boolean\") { //simplify classes, objects, and functions, point to nested objects for the state manager to monitor those properly\r\n                        val = \"instanceof_\"+c;\r\n                    }\r\n                    else if (c === 'Object') {\r\n                        let obj = {};\r\n                        for(const prop in value) {\r\n                            if (value[prop] == null){\r\n                                obj[prop] = value[prop]; \r\n                            }\r\n                            else if(Array.isArray(value[prop])) { \r\n                                if(value[prop].length>20)\r\n                                    obj[prop] = value[prop].slice(value[prop].length-20); \r\n                                else obj[prop] = value[prop];\r\n                            } //deal with arrays in nested objects (e.g. means, slices)\r\n                            else if (value[prop].constructor.name === 'Object') { //additional layer of recursion for 3 object-deep array checks\r\n                                obj[prop] = {};\r\n                                for(const p in value[prop]) {\r\n                                    if(Array.isArray(value[prop][p])) {\r\n                                        if(value[prop][p].length>20)\r\n                                            obj[prop][p] = value[prop][p].slice(value[prop][p].length-20); \r\n                                        else obj[prop][p] = value[prop][p];\r\n                                    }\r\n                                    else { \r\n                                        if (value[prop][p] != null){\r\n                                            let con = value[prop][p].constructor.name;\r\n                                            if (con.includes(\"Set\")) {\r\n                                                obj[prop][p] = Array.from(value[prop][p])\r\n                                            } else if(con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\r\n                                                obj[prop][p] = \"instanceof_\"+con; //3-deep nested objects are cut off\r\n                                            }  else {\r\n                                                obj[prop][p] = value[prop][p]; \r\n                                            }\r\n                                        } else {\r\n                                            obj[prop][p] = value[prop][p]; \r\n                                        }\r\n                                    }\r\n                                }\r\n                            }\r\n                            else { \r\n                                let con = value[prop].constructor.name;\r\n                                if (con.includes(\"Set\")) {\r\n                                    obj[prop] = Array.from(value[prop])\r\n                                } else if(con !== \"Number\" && con !== \"String\" && con !== \"Boolean\") {\r\n                                    obj[prop] = \"instanceof_\"+con;\r\n                                } else {\r\n                                    obj[prop] = value[prop]; \r\n                                }\r\n                            }\r\n                        }\r\n                        //console.log(obj, value)\r\n                        val = obj;\r\n                        //refs.set(val, path.join('.'));\r\n                    }\r\n                    else {\r\n                        val = value;\r\n                    }\r\n                } else {\r\n                    val = value;\r\n                }\r\n            }\r\n            //console.log(value, val)\r\n            return val;\r\n        }\r\n\r\n        return function stringifyFast(obj, space) {\r\n            try {\r\n                parents.push(obj);\r\n                return JSON.stringify(obj, checkValues, space);\r\n            } catch(er) {\r\n                console.error(obj, er);\r\n            } finally {\r\n                clear();\r\n            } \r\n        }\r\n    })();\r\n}\r\n\r\n\r\n\r\nif(JSON.stringifyWithCircularRefs === undefined) {\r\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\r\n    JSON.stringifyWithCircularRefs = (function() {\r\n        const refs = new Map();\r\n        const parents = [];\r\n        const path = [\"this\"];\r\n\r\n        function clear() {\r\n        refs.clear();\r\n        parents.length = 0;\r\n        path.length = 1;\r\n        }\r\n\r\n        function updateParents(key, value) {\r\n        var idx = parents.length - 1;\r\n        var prev = parents[idx];\r\n        if (prev[key] === value || idx === 0) {\r\n            path.push(key);\r\n            parents.push(value);\r\n        } else {\r\n            while (idx-- >= 0) {\r\n            prev = parents[idx];\r\n            if (prev[key] === value) {\r\n                idx += 2;\r\n                parents.length = idx;\r\n                path.length = idx;\r\n                --idx;\r\n                parents[idx] = value;\r\n                path[idx] = key;\r\n                break;\r\n            }\r\n            }\r\n        }\r\n        }\r\n\r\n        function checkCircular(key, value) {\r\n        if (value != null) {\r\n            if (typeof value === \"object\") {\r\n            if (key) { updateParents(key, value); }\r\n\r\n            let other = refs.get(value);\r\n            if (other) {\r\n                return '[Circular Reference]' + other;\r\n            } else {\r\n                refs.set(value, path.join('.'));\r\n            }\r\n            }\r\n        }\r\n        return value;\r\n        }\r\n\r\n        return function stringifyWithCircularRefs(obj, space) {\r\n        try {\r\n            parents.push(obj);\r\n            return JSON.stringify(obj, checkCircular, space);\r\n        } finally {\r\n            clear();\r\n        }\r\n        }\r\n    })();\r\n}\r\n\r\nexport default StateManager","\r\n//multithreaded event manager, spawn one per thread and import a single instance elsewhere.\r\n\r\n/**\r\n * This is both a simple wrapper for a trigger-only state manager as well \r\n * as an interface for multithreaded events for simpler, more dynamic threading pipelines\r\n * \r\n * From any thread:\r\n * emit -> tx\r\n * rx -> run trigger \r\n * \r\n */\r\n\r\n import {StateManager} from 'anotherstatemanager'\r\n\r\n export class Events {\r\n     constructor(manager=undefined) {\r\n \r\n         this.state = new StateManager({},undefined,false); //trigger only state (no overhead)\r\n         this.manager = manager;\r\n \r\n         if(manager !== undefined) { //only in window\r\n            let found = manager.responses.find((foo) => {\r\n                if(foo.name === 'eventmanager') return true;\r\n            });\r\n            if(!found) {\r\n                manager.addCallback('eventmanager',this.callback);\r\n            }\r\n         } \r\n \r\n     }\r\n \r\n     //subscribe a to an event, default is the port reponse \r\n     subEvent(eventName, response=(output)=>{console.log(eventName,output);}) {\r\n         return this.state.subscribeTrigger(eventName,response);\r\n     }\r\n \r\n     unsubEvent(eventName, sub) {\r\n         return this.state.unsubscribeTrigger(eventName,sub);\r\n     }\r\n \r\n     //add an event name, can optionally add them to any threads too from the main thread\r\n     async addEvent(eventName,workerId=undefined,functionName=undefined,origin=undefined) {\r\n         this.state.setState({[eventName]:undefined});\r\n         if(this.manager !== undefined) {\r\n             if(origin !== undefined || functionName !== undefined) {\r\n                 if(workerId !== undefined) {\r\n                    return await this.manager.post({origin:origin,foo:'addevent',input:[eventName,functionName]},workerId);\r\n                 } else {\r\n                    this.manager.workers.forEach((w)=>{\r\n                        this.manager.post({origin:origin,foo:'addevent',input:[eventName,functionName]},w.id); //add it to all of them since we're assuming we're rotating threads\r\n                    });\r\n                    return true;\r\n                 }\r\n             }\r\n         }\r\n     }\r\n \r\n     //remove an event\r\n     removeEmitter(eventName) {\r\n         this.state.unsubscribeAllTriggers(eventName);\r\n     }\r\n \r\n     //use this to set values by event name, will post messages on threads too\r\n     emit = (eventName, input, workerId=undefined,transfer=undefined,port=undefined) => {\r\n        let output = {eventName:eventName, output:input};\r\n        \r\n        if(!input || !eventName) return;\r\n        if (this.manager !== undefined) { //when emitting values for workers, input should be an object like {input:0, foo'abc', origin:'here'} for correct worker callback usage\r\n            if(workerId !== undefined) this.manager.post(output,workerId,transfer);\r\n            else {this.manager.workers.forEach((w)=>{this.manager.post(output,w.id,transfer);});}\r\n        } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\r\n            // run this in global scope of window or worker. since window.self = window, we're ok\r\n            //if(port) console.log(port,output);\r\n            if(port) port.postMessage(output,undefined,transfer);\r\n            else self.postMessage(output,undefined,transfer); //thread event \r\n        }\r\n        this.state.setState({[eventName]:input}); //local event \r\n     }\r\n \r\n    callback = (msg) => {\r\n        if(typeof msg === 'object') {\r\n            if(msg.eventName !== undefined && msg.output !== undefined) {\r\n                this.state.setState({[msg.eventName]:msg.output});\r\n            }\r\n        }\r\n    }\r\n\r\n    export = () => {\r\n        return this;\r\n    }\r\n\r\n }","//By Joshua Brewster (AGPL)\r\n\r\n\r\n/**\r\n * Math2 Contains All Static Methods\r\n * We'll add more useful static things like filter kernels etc. as we get to making them.\r\n * \r\n * //Just type these and the variable inputs that pop up should be easy to follow. Everything is commented otherwise till we document it\r\n * genSineWave() //generate a sine wave\r\n * getSineAmplitude() //get amplitude of a sine at time t\r\n * mean() //array mean\r\n * mode() //array mode\r\n * std() //standard dev\r\n * relError() //relative error\r\n * informationEntropy() //trying to build a maxent distribution off of this stuff\r\n * zscore() //array z score\r\n * variance() //variance\r\n * dot() //dot product\r\n * cross3D() //3d cross product\r\n * magnitude() //vector magnitude\r\n * distance() //distance function p1-p2\r\n * normalize() //array normalization\r\n * newtonsMethod() //root approximation\r\n * integral() //1d integral\r\n * dintegral() //2d integral\r\n * tintegral() //3d integral\r\n * pintegral() //2d path integral\r\n * makeVec() \r\n * transpose(mat) //2d mat transpose\r\n * matmul(a,b) \r\n * matscale(mat,scalar)\r\n * matadd(a,b)\r\n * matsub(a,b)\r\n * normalDistribution(samples=[], normalize=true) //create a norall (gaussian) distribution\r\n * expectedValue(samples=[],probabilities=this.normalDistribution(samples)) //get expected value of an array\r\n * originMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) //statistical moment about origin\r\n * centralMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) //statistical moment about mean\r\n * linearDiscriminantAnalysis(samples=[], classifier=[]) //LDA\r\n * conv1D(arr=[],kern=[],pad=0) //1d convolution //1d convolution\r\n * conv2D(mat=[[],[],[]],kern=[[],[],[]],pad=0) //2d convolution\r\n * cov2d(mat) //2d covariance\r\n * cov1d(arr1=[],arr2=[]) //1d covariance\r\n * cov3d(x=[],y=[],z=[]) //3d covariance\r\n * covNd(dimensionalData=[]) //nd covariance\r\n * eigens2x2(mat=[[1,2],[3,4]]) //fast 2x2 eigenvalue \r\n * eigenvectors2x2(mat=[[1,2],[3,4]], eigens=[1,2]) //fast 2x2 eigenvector \r\n * fastpca2d(xarr,yarr) //fast 2d pca\r\n * crosscorrelation(arr1,arr2) //crosscor\r\n * autocorrelation(arr1) //autocor\r\n * correlograms(dat=[[],[]]) //return cross correlations of many signals\r\n * sma(arr=[], window) //simple moving average \r\n * sum(arr=[]) //array sum\r\n * reduceArrByFactor(arr,factor=2) //reduce array sizes\r\n * makeArr(startValue, stopValue, nSteps) //linspace\r\n * interpolateArray(data, fitCount, scalar=1) \r\n * isExtrema(arr,critical='peak') //peak or valley\r\n * isCriticalPoint(arr,critical='peak') //peak, valley\r\n * peakDetect = (smoothedArray,type='peak',window=49) //wider window to find less peaks\r\n * getPeakThreshold(arr, peakIndices, thresholdVar)\r\n * \r\n * eigens(M=[[],[]], tolerance=0.0001, max_iterations=1000)\r\n * pca(mat=[[],[]],tolerance = 0.00001) //power iteration method PCA\r\n * eigenvalue_of_vector(mat, eigenvector)\r\n * power_iteration(mat, tolerance=0.00001, max_iterations=1000)\r\n * squared_difference(v1, v2)\r\n * flatten_vector(v) //column to row\r\n * column(mat, x) //row to column\r\n * \r\n */\r\n\r\n\r\n\r\nexport class Math2 {\r\n\tconstructor() {\r\n\r\n\t}\r\n\r\n\t//----------------------------------------------------------------\r\n\t//-------------------- Static Variables---------------------------\r\n\t//----------------------------------------------------------------\r\n\r\n\t//Throwing a bunch in here for the hell of it\r\n\tstatic TWO_PI = Math.PI*2; \t\t\t//2PI\r\n\tstatic C = 299792458; \t\t\t\t//speed of light m/s\r\n\tstatic G = 6.67430e-11; \t\t\t//Newton's gravitation constant N*m^2 / kg^2\r\n\tstatic h = 6.62607015e-34; \t\t\t//Planck constant J*s\r\n\tstatic R = 8.31432e3; \t\t\t\t//Universal gas constant J / kg*mol*K\r\n\tstatic Ra = 287; \t\t\t\t\t//Air gas constant J / kg*K\r\n\tstatic H = 69.3; \t\t\t\t\t//Hubble constant km/s/Mpc \r\n\tstatic kbar = 1.054571817e-34; \t\t//Dirac constant J*s\r\n\tstatic kB = 1.380649e-23; \t\t\t//Boltzmann constant J/K\r\n\tstatic ke = 8.9875517923e9; \t\t//Coulomb constant kg * m^3 * s^-2 * C^-2\r\n\tstatic me = 9.1093837015e-31; \t\t//electron mass kg\r\n\tstatic mp = 1.67262192369e-27; \t\t//proton mass kg\r\n\tstatic mn =\t1.67492749804e-27; \t\t//neutron mass kg\r\n\tstatic P0 = 1.01325e5; \t\t\t\t//Sea level pressure N/m^2\r\n\tstatic T0 = 288.15; \t\t\t\t//Sea level room temperature K\r\n\tstatic p0 = 1.225; \t\t\t\t\t//Sea level air density kg/m^3\r\n\tstatic Na = 6.0220978e23; \t\t\t//Avogadro's number 1 / kg*mol\r\n\tstatic y = 1.405; \t\t\t\t\t//Adiabatic constant\r\n\tstatic M0 = 28.96643; \t\t\t\t//Sea level molecular weight\r\n\tstatic g0 = 9.80665; \t\t\t\t//Sea level gravity m/s^2\r\n\tstatic Re = 6.3781e6; \t\t\t\t//Earth radius m\r\n\tstatic B = 1.458e-6; \t\t\t\t//Thermal constant Kg / m*s*sqrt(kg)\r\n\tstatic S = 110.4; \t\t\t\t\t//Sutherland's constant K\r\n\tstatic Sigma = 3.65e-10; \t\t\t//Collision diameter of air m\r\n\r\n\tstatic imgkernels = {\r\n\t\tedgeDetection: [\r\n\t\t  [-1, -1, -1],\r\n\t\t  [-1,  8, -1],\r\n\t\t  [-1, -1, -1]\r\n\t\t], boxBlur: [\r\n\t\t  [1/9, 1/9, 1/9],\r\n\t\t  [1/9, 1/9, 1/9],\r\n\t\t  [1/9, 1/9, 1/9]\r\n\t\t], sobelLeft: [\r\n\t\t  [1,  0, -1],\r\n\t\t  [2,  0, -2],\r\n\t\t  [1,  0, -1]\r\n\t\t], sobelRight: [\r\n\t\t  [-1, 0, 1],\r\n\t\t  [-2, 0, 2],\r\n\t\t  [-1, 0, 1]\r\n\t\t], sobelTop: [\r\n\t\t  [1,  2,   1],\r\n\t\t  [0,  0,   0],\r\n\t\t  [-1, -2, -1] \r\n\t\t], sobelBottom: [\r\n\t\t  [-1, 2, 1],\r\n\t\t  [0,  0, 0],\r\n\t\t  [1,  2, 1]\r\n\t\t], identity: [\r\n\t\t  [0, 0, 0],\r\n\t\t  [0, 1, 0], \r\n\t\t  [0, 0, 0]\r\n\t\t], gaussian3x3: [\r\n\t\t  [1,  2,  1],\r\n\t\t  [2,  4,  2], \r\n\t\t  [1,  2,  1]\r\n\t\t], guassian7x7: [\r\n\t\t  [0, 0,  0,   5,   0,   0,  0],\r\n\t\t  [0, 5,  18,  32,  18,  5,  0],\r\n\t\t  [0, 18, 64,  100, 64,  18, 0],\r\n\t\t  [5, 32, 100, 100, 100, 32, 5],\r\n\t\t  [0, 18, 64,  100, 64,  18, 0],\r\n\t\t  [0, 5,  18,  32,  18,  5,  0],\r\n\t\t  [0, 0,  0,   5,   0,   0,  0],\r\n\t\t], emboss: [\r\n\t\t  [-2, -1,  0],\r\n\t\t  [-1,  1,  1], \r\n\t\t  [ 0,  1,  2]\r\n\t\t], sharpen: [\r\n\t\t  [0, -1,   0],\r\n\t\t  [-1,  5, -1],\r\n\t\t  [0, -1,   0]\r\n\t\t]\r\n\t  };\r\n\r\n\t//----------------------------------------------------------------\r\n\t//-------------------- Static Functions --------------------------\r\n\t//----------------------------------------------------------------\r\n\r\n\t//Generate sinewave, you can add a noise frequency in too. Array length will be Math.ceil(fs*nSec)\r\n\tstatic genSineWave(freq=20,peakAmp=1,nSec=1,fs=512,freq2=0,peakAmp2=1){\r\n\t\tvar sineWave = [];\r\n\t\tvar t = [];\r\n\t\tvar increment = 1/fs; //x-axis time increment based on sample rate\r\n\t\tfor (var ti = 0; ti < nSec; ti+=increment){\r\n\t\t\tvar amplitude = Math.sin(2*Math.PI*freq*ti)*peakAmp;\r\n\t\t\tamplitude += Math.sin(2*Math.PI*freq2*ti)*peakAmp2; //Add interference\r\n\t\t\tsineWave.push(amplitude);\r\n\t\t\tt.push(ti);\r\n\t\t}\r\n\t\treturn [t,sineWave]; // [[times],[amplitudes]]\r\n\t}\r\n\r\n\t//get the sine amplitude at a particular time (seconds)\r\n\tstatic getSineAmplitude(frequency=20,peakAmplitude=1,ti=0, tOffset=0) {\r\n\t\treturn Math.sin(this.TWO_PI*frequency*ti+tOffset)*peakAmplitude;\r\n\t}\r\n\r\n\t//average value of array\r\n\tstatic mean(arr){\r\n\t\tvar sum = arr.reduce((prev,curr)=> curr += prev);\r\n\t\treturn sum / arr.length;\r\n\t}\r\n\r\n\t//array mode (most commonly occurring number)\r\n\tstatic mode(arr){\r\n\t\treturn arr.sort((a,b) =>\r\n\t\t\t  arr.filter(v => v===a).length\r\n\t\t\t- arr.filter(v => v===b).length\r\n\t\t).pop();\r\n\t}\r\n\r\n\t//standard deviation\r\n\tstatic std(arr,mean=undefined){\r\n\t\tlet avg = mean; \r\n\t\tif(!mean) avg = this.mean(arr);\r\n\t\tlet summed = 0;\r\n\t\tfor(let i = 0; i<arr.length; i++) {\r\n\t\t\tlet subbed = arr[i] - avg;\r\n\t\t\tsummed += subbed*subbed;\r\n\t\t}\r\n\t\t\r\n\t\treturn Math.sqrt(summed/arr.length);\r\n\t}\r\n\r\n\t//find the relative error of predicted results\r\n\tstatic relError(actual=[],forecast=[],abs=true) {\r\n\t\tif(actual.length !== forecast.length) throw new Error('Input arrays of same length!');\r\n\t\tlet i = actual.length;\r\n\t\tlet d = []; //relative errors\r\n\t\tfor(let j = 0; j<i; j++) {\r\n\t\t\tlet dd = (actual[j] - forecast[j])/actual[j];\r\n\t\t\tif(abs) dd = Math.abs(dd);\r\n\t\t\td.push(dd);\r\n\t\t}\r\n\t\treturn d;\r\n\t}\r\n\r\n\t//returns information entropy in natural units (base e)\r\n\tstatic informationEntropy(probabilities=[]) {\r\n\t\tlet entropy = [];\r\n\t\tlet len = probabilities.length;\r\n\t\tfor(let i = 0; i < len; i++) {\r\n\t\t\tlet ent = probabilities[i]*Math.log(probabilities[i]);\r\n\t\t\tif(isNaN(ent)) ent = 0;\r\n\t\t\tentropy.push(ent);\r\n\t\t}\r\n\r\n\t\treturn entropy;\r\n\t}\r\n\r\n\t//array zscore (probabilities)\r\n\tstatic zscore(arr){\r\n\t\tlet mean = this.mean(arr);\r\n\t\tlet std = this.std(arr,mean);\r\n\t\tlet z = [];\r\n\t\tfor (let i = 0; i<arr.length; i++) {\r\n\t\t\tz.push((arr[i]-mean) / std);\r\n\t\t}\r\n\r\n\t\treturn z;\r\n\t}\r\n\r\n\tstatic variance(arr) { //Variance of 1D input arrays of length n\r\n\t\tvar mean = this.mean(arr);\r\n\t\treturn arr.reduce((a,b) => a + ((b - mean)**2), 0)/arr.length;\r\n\t}\r\n\r\n\tstatic dot(vec1,vec2) { //nDimensional vector dot product\r\n        var dot=0;\r\n        for(var i=0; i<vec1.length; i++) {\r\n            dot += vec1[i]*vec2[i];\r\n        }\r\n\t\treturn dot;\r\n    }\r\n\r\n    static cross3D(vec1,vec2) { //3D vector cross product\r\n        return [\r\n            vec1[1]*vec2[2]-vec1[2]*vec2[1], //x\r\n            vec1[2]*vec2[0]-vec1[0]*vec2[2], //y\r\n            vec1[0]*vec2[1]-vec1[1]*vec2[0]  //z\r\n\t\t];\r\n    }\r\n\r\n    static magnitude(vec) { //nDimensional magnitude\r\n        var sqrd = 0;\r\n        vec.forEach((c) => {\r\n            sqrd+=c*c;\r\n        })\r\n        return Math.sqrt(sqrd)\r\n    }\r\n\r\n    static distance(point1, point2) { //nDimensional vector distance function\r\n        var dsqrd = 0;\r\n        point1.forEach((c,i) => {\r\n            dsqrd += (point2[i] - c)*(point2[i] - c);\r\n        })\r\n        return Math.sqrt(dsqrd);\r\n    }\r\n\tstatic normalize(vec) { //nDimensional vector normalization\r\n        var norm = 0;\r\n        norm = this.magnitude(vec);\r\n        var vecn = [];\r\n        vec.forEach((c,i) => {\r\n            vecn.push(c*norm);\r\n        })\r\n        return vecn;\r\n    }\r\n\r\n\t//return the quadratic roots based on your input ax^2 + bx + c = 0\r\n\tstatic quadraticFormula(a,b,c) {\r\n\t\tlet bbmac4 = Math.sqrt(b*b-4*a*c);\r\n\t\tif(!isNaN(bbmac4)) return ['complex','complex'];\r\n\t\tlet _a2 = 1/(2*a);\r\n\t\tif(bbmac4 === 0) return [b*_a2];\r\n\t\tlet nb = -b;\r\n\t\treturn [(nb + bbmac4)*_a2,((nb - bbmac4)*_a2)];\r\n\t}\r\n\r\n\t//approximation of function roots. Provide a function (1d), window, and precision and it will return approximate roots along that window\r\n\tstatic newtonsMethod(foo=(x)=>{return Math.pow(x,5) + x*x - x - 0.2}, start=0,end=1, precision=0.01, attempts=10) {\r\n\t\tlet roots = [];\r\n\r\n\t\tfor(let i = 0; i < attempts; i++) {\r\n\t\t\tlet seedx = Math.random()*(end-start);\t\r\n\t\t\tlet guess = foo(seedx);\r\n\t\t\tlet guess2 = foo(seedx + precision);\r\n\t\t\tlet slope = (guess2 - guess)/precision;\r\n\r\n\t\t\tlet xn = seedx+precision;\r\n\t\t\twhile((Math.abs(slope) > precision)) {\r\n\t\t\t\tlet step = -guess/slope;\r\n\t\t\t\tlet xn1 = xn+step;\r\n\t\t\t\tguess = guess2;\r\n\t\t\t\tguess2 = foo(xn1);\r\n\t\t\t\tlet slope = (guess2 - guess)/(xn1-xn);\r\n\t\t\t}\r\n\r\n\t\t\tlet idx;\r\n\t\t\tlet f = roots.find((root,i) => {\r\n\t\t\t\tif(Math.abs(xn1 - root) < precision) {\r\n\t\t\t\t\tidx = i;\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t\tif(f) roots[idx] = (xn1 + f)*0.5;\r\n\t\t\telse roots.push(xn1);\r\n\t\t}\r\n\t\treturn roots;\r\n\t}\r\n\r\n\t//2D integral approximation using rectangular area under the curve. If you need absolute values be sure to return that.\r\n    static integral = (func=(x)=>{ let y=x; return y;}, range=[], stepx=0.01) => {\r\n        let area = 0;\r\n        for(let i = range[0]; i<range[1]; i+=stepx) {\r\n            let y=func(i);\r\n            area += y*stepx;\r\n        }\r\n        return area;\r\n    }\r\n\r\n    //3D double integral approximation\r\n    static dintegral = (func=(x,y)=>{ let z = x+y; return z;}, range=[[],[]], stepx=0.01,stepy=stepx) => {\r\n        let volume = 0;\r\n        for(let i = range[0][0]+stepx; i<range[0][1]; i+=stepx) {\r\n            for(let j = range[1][0]+stepy; j<range[1][1]; j+=stepy) {\r\n                let z=func(i,j);\r\n                volume += z*stepx*stepy;\r\n            }\r\n        }\r\n        return volume;\r\n    }\r\n\r\n    //4D triple integral approximation\r\n    static tintegral = (func=(x,y,z)=>{ let w=x+y+z; return w;}, range=[[],[],[]], stepx=0.01, stepy=stepx, stepz=stepx) => {\r\n        let volume = 0;\r\n        for(let i = range[0][0]+stepx; i<range[0][1]; i+=stepx) {\r\n            for(let j = range[1][0]+stepy; j<range[1][1]; j+=stepy) {\r\n                for(let k = range[2][0]+stepz; k<range[2][1]; k+=stepz) {\r\n                    let w=func(i,j,k);\r\n                    volume += w*stepx*stepy*stepz;\r\n                }\r\n            }\r\n        }\r\n        return volume;\r\n    }\r\n\r\n    //2D path integral approximation (the length of a curve)\r\n    static pintegral = (func=(x)=>{ let y=x; return y; }, range=[], stepx=0.01) => {\r\n        let length = 0;\r\n        let y0 = undefined;\r\n        let yi = undefined;\r\n        for(let i = range[0]; i<range[1]; i+=stepx) {\r\n            y0 = yi;\r\n            yi = func(i);\r\n            if(y0)\r\n                length += this.distance([0,y0],[stepx,yi]);\r\n        }\r\n        return length;\r\n    }\r\n\r\n    static makeVec(point1,point2) {  //Make vector from two nDimensional points (arrays)\r\n        var vec = [];\r\n        point1.forEach((c,i) => {\r\n            vec.push(point2[i]-c);\r\n        })\r\n        return vec;\r\n    }\r\n\r\n\tstatic transpose(mat){\r\n\t\treturn mat[0].map((_, colIndex) => mat.map(row => row[colIndex]));\r\n\t}\r\n\r\n\t//2D Matrix multiplication from: https://stackoverflow.com/questions/27205018/multiply-2-matrices-in-javascript\r\n\tstatic matmul(a, b) {\r\n\t\tvar aNumRows = a.length, aNumCols = a[0].length,\r\n\t\t\tbNumRows = b.length, bNumCols = b[0].length,\r\n\t\t\tm = new Array(aNumRows);  // initialize array of rows\r\n\t\tfor (var r = 0; r < aNumRows; ++r) {\r\n\t\t  m[r] = new Array(bNumCols); // initialize the current row\r\n\t\t  for (var c = 0; c < bNumCols; ++c) {\r\n\t\t\tm[r][c] = 0;             // initialize the current cell\r\n\t\t\tfor (var i = 0; i < aNumCols; ++i) {\r\n\t\t\t  m[r][c] += a[r][i] * b[i][c];\r\n\t\t\t}\r\n\t\t  }\r\n\t\t}\r\n\t\treturn m;\r\n\t}\r\n\r\n\t//Apply scalar to 2D matrix \r\n\tstatic matscale(mat,scalar) {\r\n\t\tlet m = [];\r\n\t\tfor (var i = 0; i < mat.length; i++) {\r\n\t\t\tm[i] = [];\r\n\t\t\tfor (let j = 0; j < mat[0].length; j++) {\r\n\t\t\t\tm[i][j] = mat[i][j] * scalar;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn m;\r\n\t}\r\n\r\n\t//2d matrix addition\r\n\tstatic matadd(a,b) {\r\n\t\tlet m = [];\r\n\t\tfor (let i = 0; i < a.length; i++) {\r\n\t\t\tm[i] = [];\r\n\t\t\tfor (var j = 0; j < a[0].length; j++) {\r\n\t\t\t\tm[i][j] = a[i][j] + b[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn m;\r\n\t}\r\n\r\n\t//2d matrix subtraction\r\n\tstatic matsub(a,b) {\r\n\t\tlet m = [];\r\n\t\tfor (let i = 0; i < a.length; i++) {\r\n\t\t\tm[i] = [];\r\n\t\t\tfor (var j = 0; j < a[0].length; j++) {\r\n\t\t\t\tm[i][j] = a[i][j] - b[i][j];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn m;\r\n\t}\r\n\r\n\t//return a histogram of the array, use nBins to override binSize\r\n\tstatic histogram(arr=[], binSize=1, nBins=undefined) {  \r\n\t\tlet copy = [...arr]; \r\n\t\tcopy.sort(function(a, b){return a - b}); //ascending sort\r\n\t\tlet binStart = Math.min(...copy);\r\n\t\tif(typeof nBins === 'number') {\r\n\t\t\tlet binEnd = Math.max(...copy);\r\n\t\t\tbinSize = Math.abs((binEnd - binStart) / (nBins-1));\r\n\t\t} \r\n\t\tlet j = binStart;\r\n\t\tlet binx = [];\r\n\t\tlet biny = [];\r\n\t\tfor(let i = 0; i < copy.length; i++) {\r\n\t\t\tlet binidx = binSize*j;\r\n\t\t\tif(copy[i] > binStart+binidx) { \r\n\t\t\t\tj++; \r\n\t\t\t\tbinidx+=binSize; \r\n\t\t\t\tlet binmin = binStart+binidx;\r\n\t\t\t\tlet binmid = binmin + binidx*0.5;\r\n\t\t\t\tbinx.push(binmid);\r\n\t\t\t\tbiny.push(0);\r\n\t\t\t}\r\n\t\t\tbiny[biny.length-1]++;\r\n\t\t}\r\n\r\n\t\treturn [binx,biny];\r\n\t}\r\n\r\n\r\n\t//Get probability densities for the samples, set a cutoff to avoid obscenely small numbers\r\n\tstatic normalDistribution(samples=[], normalize=true, cutoff = 0.0001) {\r\n\t\tlet m = this.mean(samples);\r\n\t\tlet vari = this.variance(samples);\r\n\t\tlet nSamples = samples.length;\r\n\r\n\t\tlet probabilities = [];\r\n\r\n\t\tlet denom = 1/(this.TWO_PI*vari);\r\n\t\tlet _variance = 1/vari;\r\n\t\tlet sum = 0; //for normalization\r\n\t\tfor (let i = 0; i < nSamples; i++) {\r\n\t\t\tlet px = Math.exp(-0.5*Math.pow((samples[i]-m)*_variance,2))*denom\r\n\t\t\tif(px < cutoff) px = 0;\r\n\t\t\tprobabilities.push(px);\r\n\t\t\tsum += px;\r\n\t\t}\r\n\t\tif(normalize) {\r\n\t\t\tlet _sum = 1/sum;\r\n\t\t\tprobabilities = probabilities.map(x => x*_sum);\r\n\t\t}\r\n\t\r\n\t\treturn probabilities;\r\n\t}\r\n\r\n\tstatic expectedValue(samples=[],probabilities=this.normalDistribution(samples)) {\r\n\t\treturn samples.reduce((sum,item,idx) => sum + item*probabilities[idx]);\r\n\t}\r\n\r\n\t//moment about the origin (statistics)\r\n\tstatic originMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) {\r\n\t\treturn samples.reduce((sum,item,idx) => sum + Math.pow(item,order)*probabilities[idx]);\r\n\t}\r\n\r\n\t//moment about the population mean (statistics)\r\n\tstatic centralMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) {\r\n\t\tlet m = this.mean(samples);\r\n\t\treturn samples.reduce((sum,item,idx) => sum + Math.pow((item-m),order)*probabilities[idx]/samples.length);\r\n\t}\r\n\r\n\tstatic linearDiscriminantAnalysis(samples=[], classifier=[]) {\r\n\t\tlet mean = this.mean(samples);\r\n\t\tlet meank = this.mean(classifier);\r\n\t\tlet covariance = this.cov1d(samples,classifier);\r\n\t\tlet probs = this.normalDistribution(samples);\r\n\r\n\t\tlet dk = [];\r\n\t\tfor(let i = 0; i < samples.length; i++){ \r\n\t\t\tdk.push(x[i]*covariance*meank - .5*mean*covariance*meank + Math.log10(probs[i]));\r\n\t\t}\r\n\r\n\t\treturn dk;\r\n\t}\r\n\r\n\t//1D convolution (filtering)\r\n\tstatic conv1D(arr=[],kern=[1/3,1/3,1/3],pad=Math.floor(kern.length*0.5)) {\r\n\t\tlet result = [];\r\n\t\tlet _n = 1/kern.length;\r\n\r\n\t\tif(pad > 0) {\r\n\t\t\tlet pads = new Array(pad).fill(0);\r\n\t\t\tarr = [...pads,...arr,...pads];\r\n\t\t}\r\n\r\n\t\tlet start = Math.floor(kern.length*0.5); //offset since kernel will reduce size of array\r\n\t\tlet end = arr.length - kern.length + start; //end index\r\n\r\n\t\tfor(let i = start; i < end; i++) {\r\n\t\t\tlet acc = 0;\r\n\t\t\tfor(let j = 0; j < kern.length; j++) {\r\n\t\t\t\tacc += arr[i-start] * kern[j];\r\n\t\t\t}\r\n\t\t\tresult.push(acc* _n);\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\t\r\n\r\n\t//2D convolution (filtering), input 2d mat and 2d kernel \r\n\tstatic conv2D(mat=[[],[],[]],kern=[[],[],[]],pad=0) {\r\n\t\tlet result = new Array(mat.length - Math.ceil(kern.length*0.5)).fill([]);\r\n\t\t\r\n\t\tlet mat_t;\r\n\t\tlet kern_t = Math2.transpose(kern_t);\r\n\r\n\t\tif(pad > 0) {\r\n\t\t\tlet pads = new Array(pad).fill(0);\r\n\r\n\t\t\t//transpose to col/row\r\n\t\t\tmat_t = Math2.transpose(mat); //hard copy\r\n\t\t\tfor(let i = 0; i < mat_t.length; i++) {\r\n\t\t\t\tmat_t[i] = [...pads,...mat_t[i],...pads];\r\n\t\t\t}\r\n\r\n\t\t\t//transpose back\r\n\t\t\tmat = Math2.transpose(mat_t);\r\n\t\t\tfor(let j = 0; j < mat.length; j++) {\r\n\t\t\t\tmat[j] = [...pads,...mat[j],...pads];\r\n\t\t\t}\r\n \r\n\t\t}\r\n\r\n\t\t\r\n\t\tlet startr = Math.floor(kern[0].length*0.5); //offset since kernel will reduce size of array\r\n\t\tlet startl = Math.floor(kern_t[0].length*0.5); //offset since kernel will reduce size of array\r\n\r\n\t\tlet endr = mat[0].length - kern[0].length + startr; //row end\r\n\t\tlet endl = mat_t[0].length - kern_t[0].length + startl; //column end\r\n\r\n\t\tlet _n = 1/(kern[0].length*kern_t[0].length);\r\n\r\n\t\tlet iters = endr*endl; //number of convolutions to perform\r\n\r\n\t\tlet i = startr;\r\n\t\tlet x; let y=startl;\r\n\t\twhile(i < iters) {\r\n\t\t\tlet acc = 0;\r\n\t\t\tx = i % mat[0].length;\r\n\t\t\tif(x === 0) {\r\n\t\t\t\ty++;\r\n\t\t\t}\r\n\r\n\t\t\tfor(let j = 0; j < kern[0].length; j++) {\r\n\t\t\t\tfor(let k = 0; k < kern_t[0].length; j++) {\r\n\t\t\t\t\tacc += mat[y-startl+k][x-startr+j] * kern[k][j];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tresult[y].push(acc*_n);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\ti++;\r\n\t\t}\r\n\t\t\r\n\t\treturn result;\r\n\r\n\t}\t\r\n\r\n\t//2D matrix covariance (e.g. for lists of signals). Pretty fast!!!\r\n\tstatic cov2d(mat) { //[[x,y,z,w],[x,y,z,w],...] input list of vectors of the same length\r\n\t\t//Get variance of rows and columns\r\n\t\t//console.time(\"cov2d\");\r\n\t\tvar mattransposed = this.transpose(mat);\r\n\t\t//console.log(mattransposed)\r\n\t\tvar matproducts = [];\r\n\r\n\t\tvar rowmeans = [];\r\n\t\tvar colmeans = [];\r\n\r\n\t\tmat.forEach((row, idx) => {\r\n\t\t\trowmeans.push(this.mean(row));\r\n\t\t});\r\n\r\n\t\tmattransposed.forEach((col,idx) => {\r\n\t\t\tcolmeans.push(this.mean(col));\r\n\t\t});\r\n\r\n\t\tmat.forEach((row,idx) => {\r\n\t\t\tmatproducts.push([]);\r\n\t\t\tfor(var col = 0; col < row.length; col++){\r\n\t\t\t\tmatproducts[idx].push((mat[idx][col]-rowmeans[idx])*(mat[idx][col]-colmeans[col])/(row.length - 1));\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t/*\r\n\t\t\tmat[y][x] = (x - rowAvg)*(x - colAvg) / (mat[y].length - 1);\r\n\t\t*/\r\n\r\n\t\t//console.log(matproducts);\r\n\t\t//Transpose matrix\r\n\t\tvar matproductstransposed = this.transpose(matproducts);\r\n\r\n\t\t//Matrix multiplication, stolen from: https://stackoverflow.com/questions/27205018/multiply-2-matrices-in-javascript\r\n\t\tvar aNumRows = matproducts.length, aNumCols = matproducts[0].length,\r\n\t\t\tbNumRows = matproductstransposed.length, bNumCols = matproductstransposed[0].length,\r\n\t\t\tm = new Array(aNumRows);  // initialize array of rows\r\n\t\tfor (var r = 0; r < aNumRows; ++r) {\r\n\t\t  m[r] = new Array(bNumCols); // initialize the current row\r\n\t\t  for (var c = 0; c < bNumCols; ++c) {\r\n\t\t\tm[r][c] = 0;             // initialize the current cell\r\n\t\t\tfor (var i = 0; i < aNumCols; ++i) {\r\n\t\t\t  m[r][c] += matproducts[r][i] * matproductstransposed[i][c] / (mat[0].length - 1); //divide by row length - 1\r\n\t\t\t}\r\n\t\t  }\r\n\t\t}\r\n\t\t//console.timeEnd(\"cov2d\");\r\n\t\treturn m; //Covariance matrix\r\n\t}\r\n\r\n\r\n\t//Covariance between two 1D arrays\r\n\tstatic cov1d(arr1=[],arr2=[]) {\r\n\t\treturn this.cov2d([arr1,arr2]);\r\n\t}\r\n\r\n\t//3d covariance\r\n\tstatic cov3d(x=[],y=[],z=[]) {\r\n\t\treturn [\r\n\t\t\t[this.cov1d(x,x),this.cov1d(x,y),this.cov1d(x,z)],\r\n\t\t\t[this.cov1d(y,x),this.cov1d(y,y),this.cov1d(y,z)],\r\n\t\t\t[this.cov1d(z,x),this.cov1d(z,y),this.cov1d(z,z)]\r\n\t\t];\r\n\t}\r\n\r\n\t//n-dimensional covariance matrix\r\n\tstatic covNd(dimensionalData=[]) {\r\n\t\tlet covariance = [];\r\n\t\tdimensionalData.forEach((arr,i)=>{\r\n\t\t\tcovariance.push([]);\r\n\t\t\tdimensionalData.forEach((arr2,j)=>{\r\n\t\t\t\tcovariance[i].push(this.cov1d(arr,arr2));\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\t//fast 2x2 eigenvalue calculator: https://www.youtube.com/watch?v=e50Bj7jn9IQ\r\n\tstatic eigens2x2(mat=[[1,2],[3,4]]) {\r\n\t\tlet det = mat[0][0]*mat[1][1] - mat[0][1]*mat[1][0];\r\n\t\tlet mean = (mat[0][0]+mat[1][1])*.5;\r\n\r\n\t\tlet sqrt = Math.sqrt(mean*mean - det);\r\n\t\tlet eig1 = mean + sqrt;\r\n\t\tlet eig2 = mean - sqrt;\r\n\r\n\t\treturn [eig1, eig2];\r\n\t}\r\n\r\n\t//http://math.colgate.edu/~wweckesser/math312Spring06/handouts/IMM_2x2linalg.pdf\r\n\tstatic eigenvectors2x2(mat=[[1,2],[3,4]], eigens=[1,2]) {\r\n\t\tlet v1 = [-mat[0][1], mat[0][0]-eigens[0]];\r\n\t\tif(v1[0] === 0 && v1[1] === 0) {\r\n\t\t\tv1[0] = mat[1][1]-eigens[0];\r\n\t\t\tv1[1] = -mat[1][0];\r\n\t\t}\r\n\t\tlet v2 = [-mat[0][1], mat[0][0]-eigens[1]];\r\n\t\tif(v2[0] === 0 && v2[1] === 0) {\r\n\t\t\tv2[0] = mat[1][1]-eigens[1];\r\n\t\t\tv2[1] = -mat[1][0];\r\n\t\t}\r\n\t\treturn [v1, v2];\r\n\t}\r\n\r\n\t//Fast PCA for 2D datasets https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c\r\n\tstatic fastpca2d(xarr,yarr){\r\n\t\tlet cov1d = this.cov1d(xarr,yarr); //yields a 2x2 matrix\r\n\t\tlet eigs = this.eigens2x2(cov1d);\r\n\t\tif(eigs[1] > eigs[0]) eigs.reverse();\r\n\t\tlet evs = this.eigenvectors2x2(cov1d,eigs);\r\n\r\n\t\tconsole.log(eigs,evs)\r\n\t\treturn [eigs,evs];\r\n\t}\r\n\r\n\t//Simple cross correlation.\r\n\tstatic crosscorrelation(arr1,arr2) {\r\n\r\n\t\t//console.time(\"crosscorrelation\");\r\n\t\tvar arr2buf = [...arr2,...Array(arr2.length).fill(0)];\r\n\t\tvar mean1 = this.mean(arr1);\r\n\t\tvar mean2 = this.mean(arr2);\r\n\r\n\t\t//Estimators\r\n\t\tvar arr1Est = arr1.reduce((sum,item) => sum += Math.pow(item-mean1,2));\r\n\t\tarr1Est = Math.sqrt(arr1Est);\r\n\t\tvar arr2Est = arr2.reduce((sum,item) => sum += Math.pow(item-mean1,2));\r\n\t\tarr2Est = Math.sqrt(arr2Est);\r\n\r\n\t\tvar _arrEstsMul = 1/(arr1Est * arr2Est);\r\n\t\tvar correlations = new Array(arr1.length).fill(0);\r\n\r\n\t\tfor(var delay = 0; delay < arr1.length; delay++) {\r\n\t\t\tvar r = arr1.reduce((sum,item,i) => sum += (item - mean1)*(arr2buf[delay+i]-mean2));\r\n\t\t\tcorrelations[delay] = r*_arrEstsMul;\r\n\t\t}\r\n\r\n\t\t//console.timeEnd(\"crosscorrelation\");\r\n\t\treturn correlations;\r\n\t}\r\n\r\n\t//Simple autocorrelation. Better method for long series: FFT[x1] .* FFT[x2]\r\n\tstatic autocorrelation(arr1) {\r\n\t\tvar delaybuf = [...arr1,...Array(arr1.length).fill(0)];\r\n\t\tvar mean1 = this.mean(arr1);\r\n\r\n\t\t//Estimators\r\n\t\tvar arr1Est = arr1.reduce((sum,item) => sum += Math.pow(item-mean1,2));\r\n\t\tarr1Est = Math.sqrt(arr1Est);\r\n\r\n\t\tvar _arr1estsqrd = 1/(arr1Est * arr1Est);\r\n\t\tvar correlations = new Array(arr1.length).fill(0);\r\n\r\n\t\tfor(var delay = 0; delay < arr1.length; delay++) {\r\n\t\t\tvar r = arr1.reduce((sum,item,i) => sum += (item - mean1)*(delaybuf[delay+i]-mean1));\r\n\t\t\tcorrelations[delay] = r*_arr1estsqrd;\r\n\t\t}\r\n\r\n\t\treturn correlations;\r\n\t}\r\n\r\n\t//Compute correlograms of the given array of arrays (of equal length). Input array of equal length arrays of latest raw data (use dat = eeg32instance.getTaggedRawData())\r\n\tstatic correlograms(dat=[[],[]]) {//Coherence network math for data pushed to the atlas\r\n\t\tvar correlograms = []; //auto and cross correlations for each channel\r\n\t\tdat.forEach((row1,i) => {\r\n\t\t\tdat.forEach((row2,j) => {\r\n\t\t\t\tif(j >= i) {\r\n\t\t\t\t\tcorrelograms.push(Math2.crosscorrelation(row1,row2));\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t});\r\n\t\treturn correlograms; //Output ordered like (tag1:tag1, tag1:tag2 ... tag2:tag2, tag2:tag3 ... tagn:tagn) where autocorrelograms are also included\r\n\t}\r\n\r\n\t//Input data and averaging window, output array of moving averages (should be same size as input array, initial values not fully averaged due to window)\r\n\tstatic sma(arr=[], window) {\r\n\t\tvar smaArr = []; //console.log(arr);\r\n\t\tfor(var i = 0; i < arr.length; i++) {\r\n\t\t\tif((i == 0)) {\r\n\t\t\t\tsmaArr.push(arr[0]);\r\n\t\t\t}\r\n\t\t\telse if(i < window) { //average partial window (prevents delays on screen)\r\n\t\t\t\tvar arrslice = arr.slice(0,i+1);\r\n\t\t\t\tsmaArr.push(arrslice.reduce((previous,current) => current += previous ) / (i+1));\r\n\t\t\t}\r\n\t\t\telse { //average windows\r\n\t\t\t\tvar arrslice = arr.slice(i-window,i);\r\n\t\t\t\tsmaArr.push(arrslice.reduce((previous,current) => current += previous) / window);\r\n\t\t\t}\r\n\t\t}\r\n\t\t//console.log(temp);\r\n\t\treturn smaArr;\r\n\t}\r\n\r\n\tstatic sum(arr=[]){\r\n\t\tif (arr.length > 0){\r\n\t\t\tvar sum = arr.reduce((prev,curr)=> curr += prev);\r\n\t\treturn sum;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\tstatic reduceArrByFactor(arr,factor=2) { //faster than interpolating\r\n        let x = arr.filter((element, index) => {\r\n            return index % factor === 0;\r\n        });\r\n        return x;\r\n    }\r\n\r\n\t//Make an array of size n from a to b \r\n    static makeArr(startValue, stopValue, nSteps) {\r\n        var arr = [];\r\n        var step = (stopValue - startValue) / (nSteps - 1);\r\n        for (var i = 0; i < nSteps; i++) {\r\n          arr.push(startValue + (step * i));\r\n        }\r\n        return arr;\r\n    }\r\n\r\n\t//Linear interpolation from https://stackoverflow.com/questions/26941168/javascript-interpolate-an-array-of-numbers. Input array and number of samples to fit the data to\r\n\tstatic interpolateArray(data, fitCount, scalar=1) {\r\n\r\n\t\tvar linearInterpolate = function (before, after, atPoint) {\r\n\t\t\treturn (before + (after - before) * atPoint)*scalar;\r\n\t\t};\r\n\r\n\t\tvar newData = new Array();\r\n\t\tvar springFactor = new Number((data.length - 1) / (fitCount - 1));\r\n\t\tnewData[0] = data[0]; // for new allocation\r\n\t\tfor ( var i = 1; i < fitCount - 1; i++) {\r\n\t\t\tvar tmp = i * springFactor;\r\n\t\t\tvar before = new Number(Math.floor(tmp)).toFixed();\r\n\t\t\tvar after = new Number(Math.ceil(tmp)).toFixed();\r\n\t\t\tvar atPoint = tmp - before;\r\n\t\t\tnewData[i] = linearInterpolate(data[before], data[after], atPoint);\r\n\t\t}\r\n\t\tnewData[fitCount - 1] = data[data.length - 1]; // for new allocation\r\n\t\treturn newData;\r\n\t};\r\n\r\n\tstatic isExtrema(arr,critical='peak') { //Checks if the middle point of the (odd-numbered) array is a local extrema. options: 'peak','valley','tangent'. Even numbered arrays are popped\r\n        let ref = [...arr];\r\n\t\tif(ref.length%2 === 0) ref.pop();\r\n        if(arr.length > 1) { \r\n            let pass = true;\r\n            for(let i = 0; i < ref.length; i++) {\r\n                let val = ref[i];\r\n                if(critical === 'peak') { //search first derivative\r\n                    if(i < Math.floor(ref.length*.5) && val >= ref[Math.floor(ref.length*.5)] ) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if (i > Math.floor(ref.length*.5) && val >= ref[Math.floor(ref.length*.5)]) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                } else if (critical === 'valley') { //search first derivative\r\n                    if(i < Math.floor(ref.length*.5) && val <= ref[Math.floor(ref.length*.5)] ) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if (i > Math.floor(ref.length*.5) && val <= ref[Math.floor(ref.length*.5)]) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                } else { //look for tangents (best with 2nd derivative usually)\r\n                    if((i < Math.floor(ref.length*.5) && val <= ref[Math.floor(ref.length*.5)] )) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if ((i > Math.floor(ref.length*.5) && val <= ref[Math.floor(ref.length*.5)])) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                } //|| (i < ref.length*.5 && val <= 0 ) || (i > ref.length*.5 && val > 0)\r\n            }\r\n            if(critical !== 'peak' && critical !== 'valley' && pass === false) {\r\n                pass = true;\r\n                for(let i = 0; i < ref.length; i++) {\r\n                    let val = ref[i];\r\n                    if((i <  Math.floor(ref.length*.5) && val >= ref[Math.floor(ref.length*.5)] )) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if ((i >  Math.floor(ref.length*.5) && val >= ref[Math.floor(ref.length*.5)])) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return pass;\r\n        } else return undefined;\r\n    }\r\n\r\n    static isCriticalPoint(arr,critical='peak') { //Checks if the middle point of the (odd-numbered) array is a critical point. options: 'peak','valley','tangent'. Even numbered arrays are popped\r\n        let ref = [...arr];\r\n\t\tif(ref.length%2 === 0) ref.pop();\r\n        if(arr.length > 1) { \r\n            let pass = true;\r\n            for(let i = 0; i < ref.length; i++) {\r\n                let val = ref[i];\r\n                if(critical === 'peak') { //search first derivative\r\n                    if(i < ref.length*.5 && val <= 0 ) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if (i > ref.length*.5 && val > 0) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                } else if (critical === 'valley') { //search first derivative\r\n                    if(i < ref.length*.5 && val >= 0 ) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if (i > ref.length*.5 && val < 0) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                } else { //look for tangents (best with 2nd derivative usually)\r\n                    if((i < ref.length*.5 && val >= 0 )) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if ((i > ref.length*.5 && val < 0)) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if(critical !== 'peak' && critical !== 'valley' && pass === false) {\r\n                pass = true;\r\n                for(let i = 0; i < ref.length; i++) {\r\n                    let val = ref[i];\r\n                    if((i < ref.length*.5 && val <= 0 )) {\r\n                        pass = false;\r\n                        break;\r\n                    } else if ((i > ref.length*.5 && val > 0)) {\r\n                        pass = false;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return pass;\r\n        } else return undefined;\r\n    }\r\n\r\n\t//returns array of indices of detected peaks/valleys\r\n    static peakDetect = (smoothedArray,type='peak',window=49) => {\r\n        let mid = Math.floor(window*.5);\r\n        let peaks = [];\r\n        //console.log(smoothedArray.length-window)\r\n        for(let i = 0; i<smoothedArray.length-window; i++) {\r\n            let isPeak = this.isExtrema(smoothedArray.slice(i,i+window),type);\r\n            if(isPeak) {\r\n                peaks.push(i+mid-1);\r\n            }\r\n        }\r\n        return peaks;\r\n    }\r\n\r\n\t//gets a mean threshold based on peaks in an array\r\n    static getPeakThreshold(arr,peakIndices, thresholdVar) {\r\n        let threshold;\r\n        let filtered = arr.filter((o,i)=>{if(peakIndices.indexOf(i)>-1) return true;});\r\n        if(thresholdVar === 0) {\r\n            threshold = this.mean(filtered); \r\n        } else threshold = (thresholdVar+this.mean(filtered))*0.5;  \r\n        \r\n        return threshold;\r\n    }\r\n\r\n\t//-------------------------------------------------------------\r\n\r\n\r\n\r\n\t//The following n-dimensional Eigenvalue/PCA Math was adapted from: https://github.com/johnmihalik/eigenvector/blob/master/pca.js\r\n\tstatic column(mat, x) {\r\n\t\tlet col = new Array(mat.length).fill(0).map(() => new Array(1).fill(0));\r\n\t\tfor (let i = 0; i < mat.length; i ++) {\r\n\t\t\tcol[i][0] = mat[i][x];\r\n\t\t}\r\n\t\treturn col;\r\n\t}\r\n\r\n\t//flatten a vector of 1-value vectors\r\n\tstatic flatten_vector(v) {\r\n\t\tlet v_new = [];\r\n\t\tfor (let i = 0; i < v.length; i++) {\r\n\t\t\tv_new[i] = v[i][0];\r\n\t\t}\r\n\t\treturn v_new;\r\n\t}\r\n\r\n\tstatic squared_difference(v1, v2) {\r\n\t\tlet sum = 0.0;\r\n\t\tfor (let i = 0; i < v1.length; i ++) {\r\n\t\t\tsum = sum + Math.pow( v1[i] - v2[i], 2 );\r\n\t\t}\r\n\t\treturn sum;\r\n\t}\r\n\r\n\t// See: https://math.stackexchange.com/questions/768882/power-method-for-finding-all-eigenvectors\r\n\tstatic shift_deflate(mat, eigenvalue, eigenvector)  {\r\n\t\tlet len = Math.sqrt( this.matmul(this.transpose(eigenvector), eigenvector)  );\r\n\t\tlet U = this.matscale(eigenvector, 1.0/len);\r\n\t\tlet delta = this.matscale( this.matmul(U, this.transpose(U)) , eigenvalue);\r\n\t\tlet M_new = this.matsub(mat, delta);\r\n\t\treturn M_new;\r\n\t}\r\n\r\n\tstatic eigenvalue_of_vector(mat, eigenvector) {\r\n\t\t// Xt * M * x\r\n\t\tev = this.matmul( this.matmul(this.transpose(eigenvector), mat ), eigenvector);\r\n\t\treturn ev;\r\n\t}\r\n\r\n\t//Input square 2D matrix\r\n\tstatic power_iteration(mat, tolerance=0.00001, max_iterations=1000) {\r\n\r\n\t\tlet rank = mat.length;\r\n\t\r\n\t\t// Initialize the first guess pf the eigenvector to a row vector of the sqrt of the rank\r\n\t\tlet eigenvector = new Array(rank).fill(0).map(() => new Array(1).fill(Math.sqrt(rank)));\r\n\t\r\n\t\t// Compute the corresponding eigenvalue\r\n\t\tlet eigenvalue = this.eigenvalue_of_vector(mat, eigenvector);\r\n\t\r\n\t\tlet epsilon = 1.0;\r\n\t\tlet iter = 0;\r\n\t\twhile (epsilon > tolerance && iter < max_iterations) {\r\n\t\r\n\t\t\tlet old_eigenvalue = JSON.parse(JSON.stringify(eigenvalue));\r\n\t\r\n\t\t\t// Multiply the Matrix M by the guessed eigenveector\r\n\t\t\tlet Mv = this.matmul(mat,eigenvector);\r\n\t\r\n\t\t\t// Normalize the eigenvector to unit length\r\n\t\t\teigenvector = this.normalize(Mv);\r\n\t\r\n\t\t\t// Calculate the associated eigenvalue with the eigenvector (transpose(v) * M * v)\r\n\t\t\teigenvalue = this.eigenvalue_of_vector(mat, eigenvector);\r\n\t\r\n\t\t\t// Calculate the epsilon of the differences\r\n\t\t\tepsilon = Math.abs( eigenvalue - old_eigenvalue);\r\n\t\t\titer++;\r\n\t\r\n\t\t};\r\n\t\r\n\t\treturn [eigenvalue, eigenvector];\r\n\t}\r\n\t\r\n\t//Input square 2D matrix\r\n\tstatic eigens(mat, tolerance=0.0001, max_iterations=1000) {\r\n\r\n\t\tlet eigenvalues = [];\r\n\t\tlet eigenvectors = [];\r\n\t\r\n\t\tfor (let i = 0; i < mat.length; i++ ) {\r\n\t\r\n\t\t\t// Compute the remaining most prominent eigenvector of the matrix M\r\n\t\t\tlet result = this.power_iteration(mat, tolerance, max_iterations);\r\n\t\r\n\t\t\t// Separate the eigenvalue and vector from the return array\r\n\t\t\tlet eigenvalue = result[0];\r\n\t\t\tlet eigenvector = result[1];\r\n\t\r\n\t\t\teigenvalues[i] = eigenvalue;\r\n\t\t\teigenvectors[i] = this.flatten_vector(eigenvector);\r\n\t\r\n\t\t\t// Now remove or peel off the last eigenvector\r\n\t\t\tmat = this.shift_deflate(mat, eigenvalue, eigenvector);\r\n\t\t}\r\n\t\r\n\t\treturn [eigenvalues, eigenvectors];\r\n\t}\r\n\r\n\t//Input square 2D matrix. For eeg data you input a square covariance matrix of the signal data (or the z-scores of the signal data)\r\n\tstatic pca(mat,tolerance = 0.00001) {\r\n\t\tlet dims = mat.length;\r\n\t\t\r\n\t\tlet t = new Array(dims);\r\n\t\tlet p = new Array(dims);\r\n\r\n\t\tlet mat_t = this.transpose(mat);\r\n\t\tt[0] = this.column(mat,0);\r\n\t\tlet epsilon = 1.0;\r\n\t\tlet iter = 0;\r\n\r\n\t\twhile(espilon > tolerance) {\r\n\t\t\titer++;\r\n\t\t\tp[0] = this.matmul(mat_t,t[0]);\r\n\t\t\tlet tp = this.matmul(this.transpose(t[0]),t[0]);\r\n\t\t\tp[0] = this.matscale(p[0], 1.0 / tp);\r\n\r\n\t\t\t// Normalize p\r\n\t\t\tlet p_length = Math.sqrt(this.matmul(this.transpose(p[0]), p[0]));\r\n\t\t\tp[0] = this.matscale(p[0], 1.0 / p_length);\r\n\t\r\n\t\t\tlet t_new = this.matmul(mat, p[0]);\r\n\t\t\tlet pp = this.matmul(this.transpose(p[0]), p[0]);\r\n\t\t\tt_new = this.matscale(t_new, 1.0 / pp);\r\n\t\r\n\t\t\tepsilon = this.squared_difference(t[0], t_new);\r\n\t\r\n\t\t\tt[0] = JSON.parse(JSON.stringify(t_new));\r\n\t\t}\r\n\r\n\t\tlet components = this.matmul(this.transpose(t[0]),t[0]);\r\n\r\n\t\treturn components;\r\n\t}\t\r\n\r\n\t//-------------------------------------------------------------\r\n\r\n\t//pass in 1 second of raw data ish recommended, desired event timestamps and signals are ordered from least current to most current \r\n\tstatic p300(event_timestamps=[],raw_signal=[],signal_timestamps=[], sps=256) {\r\n\t\tlet smoothingstep = Math.floor(sps/10); //300ms width peak, 1/10th sec smoothing for filtering\r\n\t\tlet smoothed = this.sma(raw_signal,smoothingstep);\r\n\t\tlet peaks = this.peakDetect(smoothed,'peak',smoothingstep); //returns indices of peaks\r\n\t\tlet mean = this.mean(smoothed);\r\n\t\tlet std = this.std(smoothed,mean);\r\n\r\n\t\tlet p_idx = 0;\r\n\t\tlet candidates = [];\r\n\t\tif(peaks.length > 0) {\r\n\t\t\tevent_timestamps.forEach((t,j) => {\r\n\t\t\t\twhile(signal_timestamps[peaks[p_idx]] < t + 200) { //roll over peaks that are behind of the latest event + 200ms\r\n\t\t\t\t\tp_idx++;\r\n\t\t\t\t\tif(!peaks[p_idx]) break;\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tlet tempi = 0;\r\n\t\t\t\tlet tempcandidates = [];\r\n\t\t\t\twhile(signal_timestamps[peaks[p_idx+tempi]] < t + 600 ) { //get peaks that are behind the latest event + (200ms-600ms)\r\n\t\t\t\t\ttempcandidates.push(p_idx+tempi);\r\n\t\t\t\t\ttempi++;\r\n\t\t\t\t\tif(!peaks[p_idx+tempi]) break;\r\n\t\t\t\t}\r\n\t\t\t\tif(tempcandidates.length > 1) { //if multiple peaks found choose the biggest one for the main p300 peak (not worrying about p1,p2,n1,n2 yet)\r\n\t\t\t\t\tlet peakvals = [];\r\n\t\t\t\t\ttempcandidates.forEach((tc) => {\r\n\t\t\t\t\t\tpeakvals.push(smoothed[peaks[tc]]);\r\n\t\t\t\t\t});\r\n\t\t\t\t\tlet max = Math.max(...peakvals);\r\n\t\t\t\t\tlet maxi = tempcandidates[peakvals.indexOf(max)];\r\n\r\n\t\t\t\t\tcandidates.push({\r\n\t\t\t\t\t\tevent_timestamp:t, \r\n\t\t\t\t\t\tevent_index:j, \r\n\t\t\t\t\t\tpeak_timestamp:signal_timestamps[[peaks[maxi]]],\r\n\t\t\t\t\t\tsignal_index:[peaks[maxi]], \r\n\t\t\t\t\t\tsignal_amplitude:raw_signal[[peaks[maxi]]], \r\n\t\t\t\t\t\tzscore:(smoothed[peaks[maxi]]-mean)/std //significance measure\r\n\t\t\t\t\t});\r\n\t\t\t\t} else if (tempcandidates.length === 1) candidates.push({\r\n\t\t\t\t\tevent_timestamp:t, \r\n\t\t\t\t\tevent_index:j, \r\n\t\t\t\t\tpeak_timestamp:signal_timestamps[peaks[tempcandidates[0]]],\r\n\t\t\t\t\tsignal_index:peaks[tempcandidates[0]],\r\n\t\t\t\t\tsignal_amplitude:raw_signal[[peaks[tempcandidates[0]]]],\r\n\t\t\t\t\tzscore:(smoothed[peaks[tempcandidates[0]]]-mean)/std //significance measure\r\n\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t} return candidates;\r\n\t}\r\n\r\n}\r\n","//From Worker Thread\r\n\r\n\r\nfunction noop() {\r\n}\r\n\r\n/////////////https://threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html\r\n\r\nexport class EventDispatcher {\r\n\taddEventListener( type, listener ) {\r\n\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\t\tconst listeners = this._listeners;\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\t\t\tlisteners[ type ] = [];\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\t\t\tlisteners[ type ].push( listener );\r\n\t\t}\r\n\r\n\t}\r\n\r\n\thasEventListener( type, listener ) {\r\n\t\tif ( this._listeners === undefined ) return false;\r\n\t\tconst listeners = this._listeners;\r\n\t\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\r\n\t}\r\n\r\n\tremoveEventListener( type, listener ) {\r\n\t\tif ( this._listeners === undefined ) return;\r\n\t\tconst listeners = this._listeners;\r\n\t\tconst listenerArray = listeners[ type ];\r\n\t\tif ( listenerArray !== undefined ) {\r\n\t\t\tconst index = listenerArray.indexOf( listener );\r\n\t\t\tif ( index !== - 1 ) {\r\n\t\t\t\tlistenerArray.splice( index, 1 );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tdispatchEvent( event ) {\r\n\t\tif ( this._listeners === undefined ) return;\r\n\t\tconst listeners = this._listeners;\r\n\t\tconst listenerArray = listeners[ event.type ];\r\n\t\tif ( listenerArray !== undefined ) {\r\n\t\t\tevent.target = this;\r\n\t\t\t// Make a copy, in case listeners are removed while iterating.\r\n\t\t\tconst array = listenerArray.slice( 0 );\r\n\t\t\tfor ( let i = 0, l = array.length; i < l; i ++ ) {\r\n\t\t\t\tarray[ i ].call( this, event );\r\n\t\t\t}\r\n\t\t\tevent.target = null;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/////////////https://threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html\r\nexport class ElementProxyReceiver extends EventDispatcher {\r\n    constructor() {\r\n        super();\r\n        // because OrbitControls try to set style.touchAction;\r\n        this.style = {};\r\n    }\r\n    get clientWidth() {\r\n        return this.width;\r\n    }\r\n    get clientHeight() {\r\n        return this.height;\r\n    }\r\n    // OrbitControls call these as of r132. Maybe we should implement them\r\n    setPointerCapture() {}\r\n\r\n    releasePointerCapture() {}\r\n\r\n    getBoundingClientRect() {\r\n        return {\r\n            left: this.left,\r\n            top: this.top,\r\n            width: this.width,\r\n            height: this.height,\r\n            right: this.left + this.width,\r\n            bottom: this.top + this.height,\r\n        };\r\n    }\r\n\r\n    handleEvent(data) {\r\n        if (data.type === 'size') {\r\n            this.left = data.left;\r\n            this.top = data.top;\r\n            this.width = data.width;\r\n            this.height = data.height;\r\n            return;\r\n        }\r\n        data.preventDefault = noop;\r\n        data.stopPropagation = noop;\r\n        this.dispatchEvent(data);\r\n    }\r\n\r\n    focus() {}\r\n}\r\n\r\n/////////////https://threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html\r\nexport class ProxyManager {\r\n    constructor() {\r\n      this.id = 'proxy'+Math.floor(Math.random()*10000);\r\n      this.targets = {};\r\n      this.handleEvent = this.handleEvent.bind(this);\r\n    }\r\n\r\n    makeProxy(data) {        \r\n      const {id} = data;\r\n      const proxy = new ElementProxyReceiver();\r\n      this.targets[id] = proxy;\r\n    }\r\n\r\n    getProxy(id) {\r\n      return this.targets[id];\r\n    }\r\n\r\n    handleEvent(data) {\r\n      this.targets[data.id].handleEvent(data.data);\r\n    }\r\n}\r\n\r\n","import { gpuUtils } from 'gpujsutils';\r\nimport { Math2 } from './Math2';\r\nimport { Events } from './Event.js';\r\nimport { ProxyManager } from './ProxyListener.js';\r\n\r\nlet dynamicImport = async (url) => {\r\n  let module = await import(url);\r\n  return module;\r\n}\r\n\r\n//Get the text inside of a function (regular or arrow);\r\nfunction getFunctionBody(methodString) {\r\n  return methodString.toString().replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i, '$2$3$4');\r\n}\r\n\r\nfunction getFunctionHead(methodString) {\r\n  let fnstring = methodString.toString();\r\n  return fnstring.slice(0, fnstring.indexOf('{') + 1);\r\n}\r\n\r\nfunction buildNewFunction(head, body) {\r\n  let newFunc = eval(head + body + '}');\r\n  return newFunc;\r\n}\r\n\r\nfunction isFunction(string) {\r\n  let regex = new RegExp('(|[a-zA-Z]\\w*|\\([a-zA-Z]\\w*(,\\s*[a-zA-Z]\\w*)*\\))\\s*=>')\r\n  let func = (typeof string === 'string') ? string.substring(0,10).includes('function') : false;\r\n  let arrow = (typeof string === 'string') ? regex.test(string) : false;\r\n  if(func || arrow) return true;\r\n  else return false;\r\n}\r\n\r\nfunction parseFunctionFromText(method) {\r\n  //Get the text inside of a function (regular or arrow);\r\n  let getFunctionBody = (methodString) => {\r\n    return methodString.replace(/^\\W*(function[^{]+\\{([\\s\\S]*)\\}|[^=]+=>[^{]*\\{([\\s\\S]*)\\}|[^=]+=>(.+))/i, '$2$3$4');\r\n  }\r\n\r\n  let getFunctionHead = (methodString) => {\r\n    let startindex = methodString.indexOf(')');\r\n    return methodString.slice(0, methodString.indexOf('{',startindex) + 1);\r\n  }\r\n\r\n  let newFuncHead = getFunctionHead(method);\r\n  let newFuncBody = getFunctionBody(method);\r\n\r\n  let newFunc;\r\n  if (newFuncHead.includes('function ')) {\r\n    let varName = newFuncHead.split('(')[1].split(')')[0]\r\n    newFunc = new Function(varName, newFuncBody);\r\n  } else {\r\n    if(newFuncHead.substring(0,6) === newFuncBody.substring(0,6)) {\r\n      //newFuncBody = newFuncBody.substring(newFuncHead.length);\r\n      let varName = newFuncHead.split('(')[1].split(')')[0]\r\n      //console.log(varName, newFuncHead ,newFuncBody);\r\n      newFunc = new Function(varName, newFuncBody.substring(newFuncBody.indexOf('{')+1,newFuncBody.length-1));\r\n    }\r\n    else newFunc = eval(newFuncHead + newFuncBody + \"}\");\r\n  }\r\n\r\n  return newFunc;\r\n\r\n}\r\n\r\n\r\nexport class CallbackManager {\r\n  ctx;\r\n  context; \r\n\r\n  constructor() {\r\n\r\n    try {\r\n      window.gpu = new gpuUtils();\r\n      this.gpu = window.gpu;\r\n    } catch {\r\n      let gpu = new gpuUtils();\r\n      this.gpu = gpu;\r\n    }\r\n\r\n    this.EVENTS = new Events();\r\n    this.EVENTSETTINGS = [];\r\n\r\n\r\n    this.canvas = new OffscreenCanvas(512, 512); //can add fnctions and refer to this.offscreen \r\n    this.ANIMATION = undefined;\r\n    this.ANIMATIONFUNC = undefined;\r\n    this.ANIMATING = false;\r\n    this.ANIMFRAMETIME = performance.now(); //ms based on UTC stamps\r\n    this.threeUtil = undefined;\r\n    this.PROXYMANAGER = new ProxyManager();\r\n    this.ID = Math.floor(Math.random()*1000); //just a reference for discerning threads \r\n    \r\n    try{\r\n      if(window) console.log('worker in window!');\r\n    } catch(err) {\r\n      self.document = {}; //threejs hack\r\n    }\r\n\r\n    //args = array of expected arguments\r\n    //origin = optional tag on input object\r\n    //self = this. scope for variables within the callbackmanager (including values set)\r\n\r\n    this.callbacks = [\r\n      { //ping pong, just validates responsiveness\r\n        case: 'ping', callback: (self, args, origin) => {\r\n          return 'pong';\r\n        }\r\n      },\r\n      { //return a list of function calls available on the worker\r\n        case: 'list', callback: (self, args, origin) => {\r\n          let list = [];\r\n          this.callbacks.forEach((obj) => {\r\n            list.push(obj.case);\r\n          });\r\n          return list;\r\n        }\r\n      },\r\n      { //add a local function, can implement whole algorithm pipelines on-the-fly\r\n        case: 'addfunc', callback: (self, args, origin) => { //arg0 = name, arg1 = function string (arrow or normal)\r\n          let newFunc = parseFunctionFromText(args[1]);\r\n\r\n          let newCallback = { case: args[0], callback: newFunc };\r\n\r\n          let found = self.callbacks.findIndex(c => { if (c.case === newCallback.case) return c });\r\n          if (found != -1) self.callbacks[found] = newCallback;\r\n          else self.callbacks.push(newCallback);\r\n          return true;\r\n        }\r\n      },\r\n      { //set locally accessible values, just make sure not to overwrite the defaults in the callbackManager\r\n        case: 'setValues', callback: (self, args, origin) => {\r\n          if (typeof args === 'object') {\r\n            Object.keys(args).forEach((key) => {\r\n              self[key] = args[key]; //variables will be accessible in functions as this.x or this['x']\r\n              if (self.threeUtil) self.threeUtil[key] = args[key];\r\n            });\r\n            return true;\r\n          } else return false;\r\n        }\r\n      },\r\n      { //append array values\r\n        case: 'appendValues', callback: (self, args, origin) => {\r\n          if (typeof args === 'object') {\r\n            Object.keys(args).forEach((key) => {\r\n              if(!self[key]) self[key] = args[key];\r\n              else if (Array.isArray(args[key])) self[key].push(args[key]); //variables will be accessible in functions as this.x or this['x']\r\n              else self[key] = args[key];\r\n            });\r\n            return true;\r\n          } else return false;\r\n        }\r\n      },\r\n      { //for use with transfers\r\n        case: 'setValuesFromArrayBuffers', callback: (self, args, origin) => {\r\n          if (typeof args === 'object') {\r\n            Object.keys(args).forEach((key) => { \r\n              if(args[key].__proto__.__proto__.constructor.name === 'TypedArray') self[key] = Array.from(args[key]);\r\n              else self[key] = args[key];\r\n            });\r\n            return true;\r\n          } else return false;\r\n        }\r\n      },\r\n      { //for use with transfers\r\n        case: 'appendValuesFromArrayBuffers', callback: (self, args, origin) => {\r\n          if (typeof args === 'object') {\r\n            Object.keys(args).forEach((key) => {\r\n              if(!self[key] && args[key].__proto__.__proto__.constructor.name === 'TypedArray') self[key] = Array.from(args[key]);\r\n              else if(!self[key]) self[key] = args[key];\r\n              else if(args[key].__proto__.__proto__.constructor.name === 'TypedArray') self[key].push(Array.from(args[key]));\r\n              else if(Array.isArray(args[key])) self[key].push(args[key]); //variables will be accessible in functions as this.x or this['x']\r\n              else self[key] = args[key];\r\n            });\r\n            return true;\r\n          } else return false;\r\n        }\r\n      },\r\n      { //parses a stringified class prototype (class x{}.toString()) containing function methods for use on the worker\r\n        case: 'transferClassObject', callback: (self, args, origin) => {\r\n          if (typeof args === 'object') {\r\n            Object.keys(args).forEach((key) => {\r\n              if(typeof args[key] === 'string') {\r\n                let obj = args[key];\r\n                if(args[key].indexOf('class') === 0) obj = eval('('+args[key]+')');\r\n                self[key] = obj; //variables will be accessible in functions as this.x or this['x']\r\n                //console.log(self,key,obj);\r\n                if (self.threeUtil) self.threeUtil[key] = obj;\r\n              }\r\n            });\r\n            return true;\r\n          } else return false;\r\n        }\r\n      },\r\n      { //add a gpu function call usable in kernels, follow gpujs's tutorials and pass stringified functions using their format\r\n        case: 'addgpufunc', callback: (self, args, origin) => { //arg0 = gpu in-thread function string\r\n          return self.gpu.addFunction(parseFunctionFromText(args[0]));\r\n        }\r\n      },\r\n      { //add a gpu kernels, follow gpujs's tutorials and pass stringified functions using their format\r\n        case: 'addkernel', callback: (self, args, origin) => { //arg0 = kernel name, arg1 = kernel function string\r\n          return self.gpu.addKernel(args[0], parseFunctionFromText(args[1]));\r\n        }\r\n      },\r\n      { //call a custom gpu kernel\r\n        case: 'callkernel', callback: (self, args, origin) => { //arg0 = kernel name, args.slice(1) = kernel input arguments\r\n          return self.gpu.callKernel(args[0], args.slice(1)); //generalized gpu kernel calls\r\n        }\r\n      },\r\n      { //MessageChannel port, it just runs the whole callback system to keep it pain-free, while allowing messages from other workers\r\n        case: 'addport', callback: (self, args, origin) => { //args[0] = eventName, args[1] = case, only fires event if from specific same origin\r\n          let port = args[1];\r\n          port.onmessage = onmessage; //sets up a new receiver source (from other workers, perform addevent on the other worker)\r\n          this[args[0]] = port; //locally \r\n        }\r\n      },\r\n      { //add an event to the event manager, this helps building automated pipelines between threads\r\n        case: 'addevent', callback: (self, args, origin) => { //args[0] = eventName, args[1] = case, only fires event if from specific same origin\r\n          self.EVENTSETTINGS.push({ eventName: args[0], case: args[1], port:args[2], origin: origin });\r\n          //console.log(args);\r\n          if(args[2]){ \r\n            let port = args[2];\r\n            port.onmessage = onmessage; //attach the port onmessage event\r\n            this[args[0]+'port'] = port;\r\n          }\r\n          return true;\r\n        }\r\n      },\r\n      { //internal event subscription, look at Event.js for usage, its essentially a function trigger manager for creating algorithms\r\n        case: 'subevent', callback: (self, args, origin) => { //args[0] = eventName, args[1] = response function(self,args,origin) -> lets you reference self for setting variables\r\n          if(typeof args[0] !== 'string') return false;\r\n          \r\n          let response = parseFunctionFromText(args[1]);\r\n          let eventSetting = this.checkEvents(args[0]); //this will contain the port setting if there is any\r\n          //console.log(args, eventSetting)\r\n          return self.EVENTS.subEvent(args[0], (output) => {\r\n            response(self,output,origin,eventSetting?.port,eventSetting?.eventName); //function wrapper so you can access self from the event subscription\r\n          });\r\n        }\r\n      },\r\n      { //internal event unsubscribe\r\n        case: 'unsubevent', callback: (self, args, origin) => { //args[0] = eventName, args[1] = case, only fires event if from specific same origin\r\n          return self.EVENTS.unsubEvent(args[0], args[1]);\r\n        }\r\n      },\r\n      { //resize an offscreen canvas\r\n        case: 'resizecanvas', callback: (self, args, origin) => {\r\n          self.canvas.width = args[0];\r\n          self.canvas.height = args[1];\r\n          return true;\r\n        }\r\n      }, \r\n      { //args[0] = ProxyManager Id returned from startProxy, args[1] = event object\r\n        case:'proxyHandler', callback: (self, args, origin) => {\r\n\r\n          if(args.type === 'makeProxy') {\r\n            self.PROXYMANAGER.makeProxy(args);\r\n\r\n            const proxy = self.PROXYMANAGER.getProxy(args.id); \r\n            proxy.ownerDocument = proxy; // HACK!\r\n            self[args.id] = proxy;\r\n          } else if (args.type === 'event') {\r\n            self.PROXYMANAGER.handleEvent(args);\r\n          }\r\n          else return false;\r\n\r\n          return true;\r\n        }\r\n      },\r\n      {\r\n        case: 'initThree', callback: async (self, args, origin) => {\r\n          if (self.ANIMATING) {\r\n            self.ANIMATING = false;\r\n            cancelAnimationFrame(self.ANIMATION);\r\n          }\r\n          if (!self.threeUtil) {\r\n            let module = await dynamicImport('./workerThreeUtils.js');\r\n            self.threeUtil = new module.threeUtil(self.canvas,self,self.PROXYMANAGER.getProxy(args[0]));\r\n            self.THREE = self.threeUtil.THREE; //add another reference for the hell of it\r\n          }\r\n          if (typeof args[1] === 'object') { //first is the setup function\r\n            await this.runCallback('setValues',args[1]);\r\n          }\r\n          //console.log(args)\r\n          if (args[2]) { //first is the setup function\r\n            self.threeUtil.setup = parseFunctionFromText(args[2]);\r\n          }\r\n          if (args[3]) { //next is the draw function (for 1 frame)\r\n            self.threeUtil.draw = parseFunctionFromText(args[3]);\r\n          }\r\n          if (args[4]) {\r\n            self.threeUtil.clear = parseFunctionFromText(args[4]);\r\n          }\r\n          self.threeUtil.clear(self, args, origin);\r\n          self.threeUtil.setup(self, args, origin);\r\n          //console.log(self.threeUtil);\r\n          return true;\r\n        }\r\n      },\r\n      {\r\n        case: 'startThree', callback: async (self, args, origin) => { //run the setup to start the three animation\r\n          if (this.ANIMATING) {\r\n            self.ANIMATING = false;\r\n            cancelAnimationFrame(self.ANIMATION);\r\n          }\r\n          if (!this.threeUtil) {\r\n            let module = await dynamicImport('./workerThreeUtils.js');\r\n            //console.log(module);\r\n            self.threeUtil = new module.threeUtil(self.canvas,self,self.PROXYMANAGER.getProxy(args[0]));\r\n          }\r\n          if (this.threeUtil) {\r\n            self.threeUtil.clear(self, args, origin);\r\n            self.threeUtil.setup(self, args, origin);\r\n          }\r\n          return true;\r\n        }\r\n      },\r\n      {\r\n        case: 'clearThree', callback: (self, args, origin) => { //run the clear function to stop three\r\n          if (this.threeUtil) {\r\n            this.threeUtil.clear(self, args, origin);\r\n          }\r\n          return true;\r\n        }\r\n      },\r\n      {case: 'setAnimation', callback: (self, args, origin) => { //pass a draw function to be run on an animation loop. Reference this.canvas and this.context or canvas and context. Reference values with this.x etc. and use setValues to set the values from another thread\r\n          this.animationFunc = parseFunctionFromText(args[0]);\r\n          return true;\r\n        }\r\n      },\r\n      {\r\n        case: 'startAnimation', callback: (self, args, origin) => {\r\n          //console.log(this.animationFunc.toString(), this.canvas, this.angle, this.angleChange, this.bgColor)\r\n          let anim = () => {\r\n            if (self.ANIMATING) {\r\n              self.animationFunc(self, args, origin);\r\n              self.ANIMFRAMETIME = performance.now() - self.ANIMFRAMETIME;\r\n              let emitevent = self.checkEvents('render', origin);\r\n              let dict = { foo: 'render', output: self.ANIMFRAMETIME, origin: origin};\r\n              self.ANIMFRAMETIME = performance.now();\r\n              if (emitevent) {\r\n                self.EVENTS.emit('render', dict);\r\n              }\r\n              else {\r\n                postMessage(dict);\r\n              }\r\n              requestAnimationFrame(anim);\r\n            }\r\n          }\r\n\r\n          if (this.ANIMATING) {\r\n            self.ANIMATING = false;\r\n            cancelAnimationFrame(self.ANIMATION);\r\n            setTimeout(() => {\r\n              self.ANIMATING = true;\r\n              self.ANIMATION = requestAnimationFrame(anim);\r\n            }, 300);\r\n          } else {\r\n            self.ANIMATING = true;\r\n            console.log('begin animation');\r\n            self.ANIMATION = requestAnimationFrame(anim);\r\n          }\r\n          return true;\r\n        }\r\n      },\r\n      {\r\n        case: 'stopAnimation', callback: (self, args, origin) => {\r\n          if (self.ANIMATING) {\r\n            self.ANIMATING = false;\r\n            cancelAnimationFrame(self.ANIMATION);\r\n            return true;\r\n          } else return false;\r\n        }\r\n      },\r\n      {\r\n        case: 'render', callback: (self, args, origin) => { //runs the animation function\r\n          self.animationFunc(self, args, origin);\r\n          let time = performance.now() - self.ANIMFRAMETIME\r\n          tselfhis.ANIMFRAMETIME = performance.now();\r\n          return time;\r\n        }\r\n      },\r\n      { \r\n        case: 'xcor', callback: (self, args, origin) => { \r\n          return Math2.crosscorrelation(...args); \r\n        } \r\n      },\r\n      { \r\n        case: 'autocor', callback: (self, args, origin) => { \r\n          return Math2.autocorrelation(args); \r\n        } \r\n      },\r\n      { \r\n        case: 'cov1d', callback: (self, args, origin) => { \r\n          return Math2.cov1d(...args); } \r\n        },\r\n      { \r\n        case: 'cov2d', callback: (self, args, origin) => { \r\n          return Math2.cov2d(args); } \r\n        },\r\n      { \r\n        case: 'sma', callback: (self, args, origin) => { \r\n          return Math2.sma(...args); } \r\n        },\r\n      {\r\n        case: 'dft', callback: (self, args, origin) => {\r\n          if (args[2] == undefined) args[2] = 1;\r\n          return self.gpu.gpuDFT(...args);\r\n        }\r\n      },\r\n      {\r\n        case: 'multidft', callback: (self, args, origin) => {\r\n          if (args[2] == undefined) args[2] = 1;\r\n          return self.gpu.MultiChannelDFT(...args);\r\n        }\r\n      },\r\n      {\r\n        case: 'multidftbandpass', callback: (self, args, origin) => {\r\n          if (args[4] == undefined) args[4] = 1;\r\n          return self.gpu.MultiChannelDFT_Bandpass(...args);\r\n        }\r\n      },\r\n      {\r\n        case: 'fft', callback: (self, args, origin) => {\r\n          if (args[2] == undefined) args[2] = 1;\r\n          return self.gpu.gpuFFT(...args);\r\n        }\r\n      },\r\n      {\r\n        case: 'multifft', callback: (self, args, origin) => {\r\n          if (args[2] == undefined) args[2] = 1;\r\n          return self.gpu.MultiChannelFFT(...args);\r\n        }\r\n      },\r\n      {\r\n        case: 'multifftbandpass', callback: (self, args, origin) => {\r\n          if (args[4] == undefined) args[4] = 1;\r\n          return self.gpu.MultiChannelFFT_Bandpass(...args);\r\n        }\r\n      },\r\n      { \r\n        case: 'gpucoh', callback: (self, args, origin) => { \r\n          return self.gpu.gpuCoherence(...args); } \r\n        },\r\n      {\r\n        case: 'coherence', callback: (self, args, origin) => {\r\n          const correlograms = Math2.correlograms(args[0]);\r\n          const buffer = [...args[0], ...correlograms];\r\n          //console.log(buffer)\r\n          var dfts;\r\n\r\n          var scalar = 1;\r\n          //console.log(mins)\r\n          //console.log(buffer);\r\n          dfts = self.gpu.MultiChannelDFT_Bandpass(buffer, args[1], args[2], args[3], scalar);\r\n          //console.log(dfts)\r\n          const cordfts = dfts[1].splice(args[0].length, buffer.length - args[0].length);\r\n          //console.log(cordfts)\r\n\r\n          const coherenceResults = [];\r\n          const nChannels = args[0].length;\r\n\r\n          //cross-correlation dfts arranged like e.g. for 4 channels: [0:0, 0:1, 0:2, 0:3, 1:1, 1:2, 1:3, 2:2, 2:3, 3:3] etc.\r\n          var k = 0;\r\n          var l = 0;\r\n          cordfts.forEach((row, i) => { //move autocorrelation results to front to save brain power\r\n            if (l + k === nChannels) {\r\n              var temp = cordfts.splice(i, 1);\r\n              k++;\r\n              cordfts.splice(k, 0, ...temp);\r\n              l = 0;\r\n              //console.log(i);\r\n            }\r\n            l++;\r\n          });\r\n          //Now arranged like [0:0,1:1,2:2,3:3,0:1,0:2,0:3,1:2,1:3,2:3]\r\n\r\n          //Outputs FFT coherence data in order of channel data inputted e.g. for 4 channels resulting DFTs = [0:1,0:2,0:3,1:2,1:3,2:3];\r\n\r\n          var autoFFTproducts = [];\r\n          k = 0;\r\n          l = 1;\r\n          cordfts.forEach((dft, i) => {\r\n            var newdft = new Array(dft.length).fill(0);\r\n            if (i < nChannels) { //sort out autocorrelogram FFTs\r\n              dft.forEach((amp, j) => {\r\n                newdft[j] = amp//*dfts[1][i][j];\r\n              });\r\n              autoFFTproducts.push(newdft);\r\n            }\r\n            else { //now multiply cross correlogram ffts and divide by autocorrelogram ffts (magnitude squared coherence)\r\n              dft.forEach((amp, j) => {\r\n                newdft[j] = amp * amp / (autoFFTproducts[k][j] * autoFFTproducts[k + l][j]);//Magnitude squared coherence;\r\n                if (newdft[j] > 1) { newdft[j] = 1; } //caps the values at 1\r\n                //newdft[j] = Math.pow(newdft[j],.125)\r\n              });\r\n              l++;\r\n              if ((l + k) === nChannels) {\r\n                k++;\r\n                l = 1;\r\n              }\r\n              coherenceResults.push(newdft);\r\n            }\r\n          });\r\n          return [dfts[0], dfts[1], coherenceResults];\r\n        }\r\n      }\r\n    ];\r\n  }\r\n\r\n  \r\n  addCallback(functionName,callback=(self,args,origin)=>{}) {\r\n    if(!functionName || !callback) return false;\r\n    this.removeCallback(functionName); //removes existing callback if it is there\r\n    this.callbacks.push({case:functionName,callback:callback});\r\n    return true;\r\n  }\r\n\r\n  removeCallback(functionName) {\r\n      let foundidx;\r\n      let found = this.callbacks.find((o,i) => {\r\n          if(o.case === functionName) {\r\n              foundidx = i;\r\n              return true;\r\n          }\r\n      });\r\n      if(found) {\r\n          this.callbacks.splice(i,1);\r\n          return true;\r\n      }\r\n      else return false;\r\n  }\r\n\r\n  async runCallback(functionName,input=[],origin) {\r\n    let output = undefined;\r\n    await Promise.all(this.callbacks.map(async (o,i) => {\r\n      if (o.case === functionName) {\r\n        output = await o.callback(this, input, origin);\r\n        return true;\r\n      } else if (o.aliases) {\r\n        if(o.aliases.indexOf(functionName) > -1) {\r\n            output = await o.callback(this, input, origin, user);\r\n            return true;\r\n        }\r\n      } \r\n      return false;\r\n    }));\r\n    return output;\r\n  }\r\n\r\n  checkEvents(functionName, origin) {\r\n    let found = this.EVENTSETTINGS.find((o) => {\r\n      if ((o.origin && origin && o.case && functionName)) {\r\n        if (o.origin === origin && o.case === functionName) return true;\r\n        else return false;\r\n      } else if (o.case && functionName) {\r\n        if (o.case === functionName) return true;\r\n        else return false;\r\n      } else if (o.origin && origin) {\r\n        if(o.origin === origin) return true;\r\n        else return false;\r\n      }\r\n      else return false;\r\n    });\r\n    //console.log(functionName,origin,found)\r\n    return found;\r\n  }\r\n\r\n  async checkCallbacks(event) {\r\n    //console.log(event);\r\n    let output = 'function not defined';\r\n    if(!event.data) return output;\r\n    await Promise.all(this.callbacks.map(async (o,i) => {\r\n      if (o.case === event.data.foo || o.case === event.data.case) {\r\n        if (event.data.input) output = await o.callback(this, event.data.input, event.data.origin);\r\n        else if (event.data.args) output = await o.callback(this, event.data.args, event.data.origin);\r\n        else output = await o.callback(this, undefined, event.data.origin); //no inputs\r\n        return true;\r\n      } else return false;\r\n    }));\r\n    return output;\r\n  }\r\n}","/**\r\n * gpu.js\r\n * http://gpu.rocks/\r\n *\r\n * GPU Accelerated JavaScript\r\n *\r\n * @version 2.11.0\r\n * @date Tue Jan 05 2021 15:55:59 GMT-0500 (Eastern Standard Time)\r\n *\r\n * @license MIT\r\n * The MIT License\r\n *\r\n * Copyright (c) 2021 gpu.js Team\r\n */(function(f){\r\n     if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}\r\n     else if(typeof define===\"function\"&&define.amd){define([],f)}\r\n     else{var g;if(typeof window!==\"undefined\"){g=window}\r\n     else if(typeof global!==\"undefined\"){g=global}\r\n     else if(typeof self!==\"undefined\"){g=self}\r\n     else{g=this}\r\n         f()\r\n    }})\r\n     (function(){\r\n         var define,module,exports;\r\n         return (function(){\r\n             function r(e,n,t){\r\n                 function o(i,f){if(!n[i]){if(!e[i]){\r\n                     var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\r\n    (function (global, factory) {\r\n        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\r\n        typeof define === 'function' && define.amd ? define(['exports'], factory) :\r\n        (global = global || self, factory(global.acorn = {}));\r\n      }(this, function (exports) { 'use strict';\r\n      \r\n      \r\n        var reservedWords = {\r\n          3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\r\n          5: \"class enum extends super const export import\",\r\n          6: \"enum\",\r\n          strict: \"implements interface let package private protected public static yield\",\r\n          strictBind: \"eval arguments\"\r\n        };\r\n      \r\n      \r\n        var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\r\n      \r\n        var keywords = {\r\n          5: ecma5AndLessKeywords,\r\n          \"5module\": ecma5AndLessKeywords + \" export import\",\r\n          6: ecma5AndLessKeywords + \" const class extends export import super\"\r\n        };\r\n      \r\n        var keywordRelationalOperator = /^in(stanceof)?$/;\r\n      \r\n      \r\n        var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\r\n        var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\r\n      \r\n        var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\r\n        var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\r\n      \r\n        nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\r\n      \r\n      \r\n        var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\r\n      \r\n        var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];\r\n      \r\n        function isInAstralSet(code, set) {\r\n          var pos = 0x10000;\r\n          for (var i = 0; i < set.length; i += 2) {\r\n            pos += set[i];\r\n            if (pos > code) { return false }\r\n            pos += set[i + 1];\r\n            if (pos >= code) { return true }\r\n          }\r\n        }\r\n      \r\n      \r\n        function isIdentifierStart(code, astral) {\r\n          if (code < 65) { return code === 36 }\r\n          if (code < 91) { return true }\r\n          if (code < 97) { return code === 95 }\r\n          if (code < 123) { return true }\r\n          if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\r\n          if (astral === false) { return false }\r\n          return isInAstralSet(code, astralIdentifierStartCodes)\r\n        }\r\n      \r\n      \r\n        function isIdentifierChar(code, astral) {\r\n          if (code < 48) { return code === 36 }\r\n          if (code < 58) { return true }\r\n          if (code < 65) { return false }\r\n          if (code < 91) { return true }\r\n          if (code < 97) { return code === 95 }\r\n          if (code < 123) { return true }\r\n          if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\r\n          if (astral === false) { return false }\r\n          return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\r\n        }\r\n      \r\n      \r\n      \r\n      \r\n      \r\n        var TokenType = function TokenType(label, conf) {\r\n          if ( conf === void 0 ) conf = {};\r\n      \r\n          this.label = label;\r\n          this.keyword = conf.keyword;\r\n          this.beforeExpr = !!conf.beforeExpr;\r\n          this.startsExpr = !!conf.startsExpr;\r\n          this.isLoop = !!conf.isLoop;\r\n          this.isAssign = !!conf.isAssign;\r\n          this.prefix = !!conf.prefix;\r\n          this.postfix = !!conf.postfix;\r\n          this.binop = conf.binop || null;\r\n          this.updateContext = null;\r\n        };\r\n      \r\n        function binop(name, prec) {\r\n          return new TokenType(name, {beforeExpr: true, binop: prec})\r\n        }\r\n        var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\r\n      \r\n      \r\n        var keywords$1 = {};\r\n      \r\n        function kw(name, options) {\r\n          if ( options === void 0 ) options = {};\r\n      \r\n          options.keyword = name;\r\n          return keywords$1[name] = new TokenType(name, options)\r\n        }\r\n      \r\n        var types = {\r\n          num: new TokenType(\"num\", startsExpr),\r\n          regexp: new TokenType(\"regexp\", startsExpr),\r\n          string: new TokenType(\"string\", startsExpr),\r\n          name: new TokenType(\"name\", startsExpr),\r\n          eof: new TokenType(\"eof\"),\r\n      \r\n          bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\r\n          bracketR: new TokenType(\"]\"),\r\n          braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\r\n          braceR: new TokenType(\"}\"),\r\n          parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\r\n          parenR: new TokenType(\")\"),\r\n          comma: new TokenType(\",\", beforeExpr),\r\n          semi: new TokenType(\";\", beforeExpr),\r\n          colon: new TokenType(\":\", beforeExpr),\r\n          dot: new TokenType(\".\"),\r\n          question: new TokenType(\"?\", beforeExpr),\r\n          arrow: new TokenType(\"=>\", beforeExpr),\r\n          template: new TokenType(\"template\"),\r\n          invalidTemplate: new TokenType(\"invalidTemplate\"),\r\n          ellipsis: new TokenType(\"...\", beforeExpr),\r\n          backQuote: new TokenType(\"`\", startsExpr),\r\n          dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\r\n      \r\n      \r\n          eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\r\n          assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\r\n          incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\r\n          prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n          logicalOR: binop(\"||\", 1),\r\n          logicalAND: binop(\"&&\", 2),\r\n          bitwiseOR: binop(\"|\", 3),\r\n          bitwiseXOR: binop(\"^\", 4),\r\n          bitwiseAND: binop(\"&\", 5),\r\n          equality: binop(\"==/!=/===/!==\", 6),\r\n          relational: binop(\"</>/<=/>=\", 7),\r\n          bitShift: binop(\"<</>>/>>>\", 8),\r\n          plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\r\n          modulo: binop(\"%\", 10),\r\n          star: binop(\"*\", 10),\r\n          slash: binop(\"/\", 10),\r\n          starstar: new TokenType(\"**\", {beforeExpr: true}),\r\n      \r\n          _break: kw(\"break\"),\r\n          _case: kw(\"case\", beforeExpr),\r\n          _catch: kw(\"catch\"),\r\n          _continue: kw(\"continue\"),\r\n          _debugger: kw(\"debugger\"),\r\n          _default: kw(\"default\", beforeExpr),\r\n          _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\r\n          _else: kw(\"else\", beforeExpr),\r\n          _finally: kw(\"finally\"),\r\n          _for: kw(\"for\", {isLoop: true}),\r\n          _function: kw(\"function\", startsExpr),\r\n          _if: kw(\"if\"),\r\n          _return: kw(\"return\", beforeExpr),\r\n          _switch: kw(\"switch\"),\r\n          _throw: kw(\"throw\", beforeExpr),\r\n          _try: kw(\"try\"),\r\n          _var: kw(\"var\"),\r\n          _const: kw(\"const\"),\r\n          _while: kw(\"while\", {isLoop: true}),\r\n          _with: kw(\"with\"),\r\n          _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\r\n          _this: kw(\"this\", startsExpr),\r\n          _super: kw(\"super\", startsExpr),\r\n          _class: kw(\"class\", startsExpr),\r\n          _extends: kw(\"extends\", beforeExpr),\r\n          _export: kw(\"export\"),\r\n          _import: kw(\"import\", startsExpr),\r\n          _null: kw(\"null\", startsExpr),\r\n          _true: kw(\"true\", startsExpr),\r\n          _false: kw(\"false\", startsExpr),\r\n          _in: kw(\"in\", {beforeExpr: true, binop: 7}),\r\n          _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\r\n          _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n          _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\r\n          _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\r\n        };\r\n      \r\n      \r\n        var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\r\n        var lineBreakG = new RegExp(lineBreak.source, \"g\");\r\n      \r\n        function isNewLine(code, ecma2019String) {\r\n          return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\r\n        }\r\n      \r\n        var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\r\n      \r\n        var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\r\n      \r\n        var ref = Object.prototype;\r\n        var hasOwnProperty = ref.hasOwnProperty;\r\n        var toString = ref.toString;\r\n      \r\n      \r\n        function has(obj, propName) {\r\n          return hasOwnProperty.call(obj, propName)\r\n        }\r\n      \r\n        var isArray = Array.isArray || (function (obj) { return (\r\n          toString.call(obj) === \"[object Array]\"\r\n        ); });\r\n      \r\n        function wordsRegexp(words) {\r\n          return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\r\n        }\r\n      \r\n      \r\n        var Position = function Position(line, col) {\r\n          this.line = line;\r\n          this.column = col;\r\n        };\r\n      \r\n        Position.prototype.offset = function offset (n) {\r\n          return new Position(this.line, this.column + n)\r\n        };\r\n      \r\n        var SourceLocation = function SourceLocation(p, start, end) {\r\n          this.start = start;\r\n          this.end = end;\r\n          if (p.sourceFile !== null) { this.source = p.sourceFile; }\r\n        };\r\n      \r\n      \r\n        function getLineInfo(input, offset) {\r\n          for (var line = 1, cur = 0;;) {\r\n            lineBreakG.lastIndex = cur;\r\n            var match = lineBreakG.exec(input);\r\n            if (match && match.index < offset) {\r\n              ++line;\r\n              cur = match.index + match[0].length;\r\n            } else {\r\n              return new Position(line, offset - cur)\r\n            }\r\n          }\r\n        }\r\n      \r\n      \r\n        var defaultOptions = {\r\n          ecmaVersion: 10,\r\n          sourceType: \"script\",\r\n          onInsertedSemicolon: null,\r\n          onTrailingComma: null,\r\n          allowReserved: null,\r\n          allowReturnOutsideFunction: false,\r\n          allowImportExportEverywhere: false,\r\n          allowAwaitOutsideFunction: false,\r\n          allowHashBang: false,\r\n          locations: false,\r\n          onToken: null,\r\n          onComment: null,\r\n          ranges: false,\r\n          program: null,\r\n          sourceFile: null,\r\n          directSourceFile: null,\r\n          preserveParens: false\r\n        };\r\n      \r\n      \r\n        function getOptions(opts) {\r\n          var options = {};\r\n      \r\n          for (var opt in defaultOptions)\r\n            { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\r\n      \r\n          if (options.ecmaVersion >= 2015)\r\n            { options.ecmaVersion -= 2009; }\r\n      \r\n          if (options.allowReserved == null)\r\n            { options.allowReserved = options.ecmaVersion < 5; }\r\n      \r\n          if (isArray(options.onToken)) {\r\n            var tokens = options.onToken;\r\n            options.onToken = function (token) { return tokens.push(token); };\r\n          }\r\n          if (isArray(options.onComment))\r\n            { options.onComment = pushComment(options, options.onComment); }\r\n      \r\n          return options\r\n        }\r\n      \r\n        function pushComment(options, array) {\r\n          return function(block, text, start, end, startLoc, endLoc) {\r\n            var comment = {\r\n              type: block ? \"Block\" : \"Line\",\r\n              value: text,\r\n              start: start,\r\n              end: end\r\n            };\r\n            if (options.locations)\r\n              { comment.loc = new SourceLocation(this, startLoc, endLoc); }\r\n            if (options.ranges)\r\n              { comment.range = [start, end]; }\r\n            array.push(comment);\r\n          }\r\n        }\r\n      \r\n        var\r\n            SCOPE_TOP = 1,\r\n            SCOPE_FUNCTION = 2,\r\n            SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\r\n            SCOPE_ASYNC = 4,\r\n            SCOPE_GENERATOR = 8,\r\n            SCOPE_ARROW = 16,\r\n            SCOPE_SIMPLE_CATCH = 32,\r\n            SCOPE_SUPER = 64,\r\n            SCOPE_DIRECT_SUPER = 128;\r\n      \r\n        function functionFlags(async, generator) {\r\n          return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\r\n        }\r\n      \r\n        var\r\n            BIND_NONE = 0, \r\n            BIND_VAR = 1, \r\n            BIND_LEXICAL = 2, \r\n            BIND_FUNCTION = 3, \r\n            BIND_SIMPLE_CATCH = 4, \r\n            BIND_OUTSIDE = 5; \r\n      \r\n        var Parser = function Parser(options, input, startPos) {\r\n          this.options = options = getOptions(options);\r\n          this.sourceFile = options.sourceFile;\r\n          this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\r\n          var reserved = \"\";\r\n          if (options.allowReserved !== true) {\r\n            for (var v = options.ecmaVersion;; v--)\r\n              { if (reserved = reservedWords[v]) { break } }\r\n            if (options.sourceType === \"module\") { reserved += \" await\"; }\r\n          }\r\n          this.reservedWords = wordsRegexp(reserved);\r\n          var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\r\n          this.reservedWordsStrict = wordsRegexp(reservedStrict);\r\n          this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\r\n          this.input = String(input);\r\n      \r\n          this.containsEsc = false;\r\n      \r\n      \r\n          if (startPos) {\r\n            this.pos = startPos;\r\n            this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\r\n            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\r\n          } else {\r\n            this.pos = this.lineStart = 0;\r\n            this.curLine = 1;\r\n          }\r\n      \r\n          this.type = types.eof;\r\n          this.value = null;\r\n          this.start = this.end = this.pos;\r\n          this.startLoc = this.endLoc = this.curPosition();\r\n      \r\n          this.lastTokEndLoc = this.lastTokStartLoc = null;\r\n          this.lastTokStart = this.lastTokEnd = this.pos;\r\n      \r\n          this.context = this.initialContext();\r\n          this.exprAllowed = true;\r\n      \r\n          this.inModule = options.sourceType === \"module\";\r\n          this.strict = this.inModule || this.strictDirective(this.pos);\r\n      \r\n          this.potentialArrowAt = -1;\r\n      \r\n          this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\r\n          this.labels = [];\r\n          this.undefinedExports = {};\r\n      \r\n          if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\r\n            { this.skipLineComment(2); }\r\n      \r\n          this.scopeStack = [];\r\n          this.enterScope(SCOPE_TOP);\r\n      \r\n          this.regexpState = null;\r\n        };\r\n      \r\n        var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\r\n      \r\n        Parser.prototype.parse = function parse () {\r\n          var node = this.options.program || this.startNode();\r\n          this.nextToken();\r\n          return this.parseTopLevel(node)\r\n        };\r\n      \r\n        prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\r\n        prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\r\n        prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\r\n        prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\r\n        prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\r\n        prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\r\n      \r\n        Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\r\n      \r\n        Parser.extend = function extend () {\r\n            var plugins = [], len = arguments.length;\r\n            while ( len-- ) plugins[ len ] = arguments[ len ];\r\n      \r\n          var cls = this;\r\n          for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\r\n          return cls\r\n        };\r\n      \r\n        Parser.parse = function parse (input, options) {\r\n          return new this(options, input).parse()\r\n        };\r\n      \r\n        Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\r\n          var parser = new this(options, input, pos);\r\n          parser.nextToken();\r\n          return parser.parseExpression()\r\n        };\r\n      \r\n        Parser.tokenizer = function tokenizer (input, options) {\r\n          return new this(options, input)\r\n        };\r\n      \r\n        Object.defineProperties( Parser.prototype, prototypeAccessors );\r\n      \r\n        var pp = Parser.prototype;\r\n      \r\n      \r\n        var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\r\n        pp.strictDirective = function(start) {\r\n          for (;;) {\r\n            skipWhiteSpace.lastIndex = start;\r\n            start += skipWhiteSpace.exec(this.input)[0].length;\r\n            var match = literal.exec(this.input.slice(start));\r\n            if (!match) { return false }\r\n            if ((match[1] || match[2]) === \"use strict\") { return true }\r\n            start += match[0].length;\r\n      \r\n            skipWhiteSpace.lastIndex = start;\r\n            start += skipWhiteSpace.exec(this.input)[0].length;\r\n            if (this.input[start] === \";\")\r\n              { start++; }\r\n          }\r\n        };\r\n      \r\n      \r\n        pp.eat = function(type) {\r\n          if (this.type === type) {\r\n            this.next();\r\n            return true\r\n          } else {\r\n            return false\r\n          }\r\n        };\r\n      \r\n      \r\n        pp.isContextual = function(name) {\r\n          return this.type === types.name && this.value === name && !this.containsEsc\r\n        };\r\n      \r\n      \r\n        pp.eatContextual = function(name) {\r\n          if (!this.isContextual(name)) { return false }\r\n          this.next();\r\n          return true\r\n        };\r\n      \r\n      \r\n        pp.expectContextual = function(name) {\r\n          if (!this.eatContextual(name)) { this.unexpected(); }\r\n        };\r\n      \r\n      \r\n        pp.canInsertSemicolon = function() {\r\n          return this.type === types.eof ||\r\n            this.type === types.braceR ||\r\n            lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\r\n        };\r\n      \r\n        pp.insertSemicolon = function() {\r\n          if (this.canInsertSemicolon()) {\r\n            if (this.options.onInsertedSemicolon)\r\n              { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\r\n            return true\r\n          }\r\n        };\r\n      \r\n      \r\n        pp.semicolon = function() {\r\n          if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\r\n        };\r\n      \r\n        pp.afterTrailingComma = function(tokType, notNext) {\r\n          if (this.type === tokType) {\r\n            if (this.options.onTrailingComma)\r\n              { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\r\n            if (!notNext)\r\n              { this.next(); }\r\n            return true\r\n          }\r\n        };\r\n      \r\n      \r\n        pp.expect = function(type) {\r\n          this.eat(type) || this.unexpected();\r\n        };\r\n      \r\n      \r\n        pp.unexpected = function(pos) {\r\n          this.raise(pos != null ? pos : this.start, \"Unexpected token\");\r\n        };\r\n      \r\n        function DestructuringErrors() {\r\n          this.shorthandAssign =\r\n          this.trailingComma =\r\n          this.parenthesizedAssign =\r\n          this.parenthesizedBind =\r\n          this.doubleProto =\r\n            -1;\r\n        }\r\n      \r\n        pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\r\n          if (!refDestructuringErrors) { return }\r\n          if (refDestructuringErrors.trailingComma > -1)\r\n            { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\r\n          var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\r\n          if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\r\n        };\r\n      \r\n        pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\r\n          if (!refDestructuringErrors) { return false }\r\n          var shorthandAssign = refDestructuringErrors.shorthandAssign;\r\n          var doubleProto = refDestructuringErrors.doubleProto;\r\n          if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\r\n          if (shorthandAssign >= 0)\r\n            { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\r\n          if (doubleProto >= 0)\r\n            { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\r\n        };\r\n      \r\n        pp.checkYieldAwaitInDefaultParams = function() {\r\n          if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\r\n            { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\r\n          if (this.awaitPos)\r\n            { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\r\n        };\r\n      \r\n        pp.isSimpleAssignTarget = function(expr) {\r\n          if (expr.type === \"ParenthesizedExpression\")\r\n            { return this.isSimpleAssignTarget(expr.expression) }\r\n          return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\r\n        };\r\n      \r\n        var pp$1 = Parser.prototype;\r\n      \r\n      \r\n      \r\n        pp$1.parseTopLevel = function(node) {\r\n          var exports = {};\r\n          if (!node.body) { node.body = []; }\r\n          while (this.type !== types.eof) {\r\n            var stmt = this.parseStatement(null, true, exports);\r\n            node.body.push(stmt);\r\n          }\r\n          if (this.inModule)\r\n            { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\r\n              {\r\n                var name = list[i];\r\n      \r\n                this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\r\n              } }\r\n          this.adaptDirectivePrologue(node.body);\r\n          this.next();\r\n          node.sourceType = this.options.sourceType;\r\n          return this.finishNode(node, \"Program\")\r\n        };\r\n      \r\n        var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\r\n      \r\n        pp$1.isLet = function(context) {\r\n          if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\r\n          skipWhiteSpace.lastIndex = this.pos;\r\n          var skip = skipWhiteSpace.exec(this.input);\r\n          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\r\n          if (nextCh === 91) { return true } \r\n          if (context) { return false }\r\n      \r\n          if (nextCh === 123) { return true } \r\n          if (isIdentifierStart(nextCh, true)) {\r\n            var pos = next + 1;\r\n            while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\r\n            var ident = this.input.slice(next, pos);\r\n            if (!keywordRelationalOperator.test(ident)) { return true }\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$1.isAsyncFunction = function() {\r\n          if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\r\n            { return false }\r\n      \r\n          skipWhiteSpace.lastIndex = this.pos;\r\n          var skip = skipWhiteSpace.exec(this.input);\r\n          var next = this.pos + skip[0].length;\r\n          return !lineBreak.test(this.input.slice(this.pos, next)) &&\r\n            this.input.slice(next, next + 8) === \"function\" &&\r\n            (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\r\n        };\r\n      \r\n      \r\n        pp$1.parseStatement = function(context, topLevel, exports) {\r\n          var starttype = this.type, node = this.startNode(), kind;\r\n      \r\n          if (this.isLet(context)) {\r\n            starttype = types._var;\r\n            kind = \"let\";\r\n          }\r\n      \r\n      \r\n          switch (starttype) {\r\n          case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\r\n          case types._debugger: return this.parseDebuggerStatement(node)\r\n          case types._do: return this.parseDoStatement(node)\r\n          case types._for: return this.parseForStatement(node)\r\n          case types._function:\r\n            if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\r\n            return this.parseFunctionStatement(node, false, !context)\r\n          case types._class:\r\n            if (context) { this.unexpected(); }\r\n            return this.parseClass(node, true)\r\n          case types._if: return this.parseIfStatement(node)\r\n          case types._return: return this.parseReturnStatement(node)\r\n          case types._switch: return this.parseSwitchStatement(node)\r\n          case types._throw: return this.parseThrowStatement(node)\r\n          case types._try: return this.parseTryStatement(node)\r\n          case types._const: case types._var:\r\n            kind = kind || this.value;\r\n            if (context && kind !== \"var\") { this.unexpected(); }\r\n            return this.parseVarStatement(node, kind)\r\n          case types._while: return this.parseWhileStatement(node)\r\n          case types._with: return this.parseWithStatement(node)\r\n          case types.braceL: return this.parseBlock(true, node)\r\n          case types.semi: return this.parseEmptyStatement(node)\r\n          case types._export:\r\n          case types._import:\r\n            if (this.options.ecmaVersion > 10 && starttype === types._import) {\r\n              skipWhiteSpace.lastIndex = this.pos;\r\n              var skip = skipWhiteSpace.exec(this.input);\r\n              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\r\n              if (nextCh === 40) \r\n                { return this.parseExpressionStatement(node, this.parseExpression()) }\r\n            }\r\n      \r\n            if (!this.options.allowImportExportEverywhere) {\r\n              if (!topLevel)\r\n                { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\r\n              if (!this.inModule)\r\n                { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\r\n            }\r\n            return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\r\n      \r\n          default:\r\n            if (this.isAsyncFunction()) {\r\n              if (context) { this.unexpected(); }\r\n              this.next();\r\n              return this.parseFunctionStatement(node, true, !context)\r\n            }\r\n      \r\n            var maybeName = this.value, expr = this.parseExpression();\r\n            if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\r\n              { return this.parseLabeledStatement(node, maybeName, expr, context) }\r\n            else { return this.parseExpressionStatement(node, expr) }\r\n          }\r\n        };\r\n      \r\n        pp$1.parseBreakContinueStatement = function(node, keyword) {\r\n          var isBreak = keyword === \"break\";\r\n          this.next();\r\n          if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\r\n          else if (this.type !== types.name) { this.unexpected(); }\r\n          else {\r\n            node.label = this.parseIdent();\r\n            this.semicolon();\r\n          }\r\n      \r\n          var i = 0;\r\n          for (; i < this.labels.length; ++i) {\r\n            var lab = this.labels[i];\r\n            if (node.label == null || lab.name === node.label.name) {\r\n              if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\r\n              if (node.label && isBreak) { break }\r\n            }\r\n          }\r\n          if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\r\n          return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\r\n        };\r\n      \r\n        pp$1.parseDebuggerStatement = function(node) {\r\n          this.next();\r\n          this.semicolon();\r\n          return this.finishNode(node, \"DebuggerStatement\")\r\n        };\r\n      \r\n        pp$1.parseDoStatement = function(node) {\r\n          this.next();\r\n          this.labels.push(loopLabel);\r\n          node.body = this.parseStatement(\"do\");\r\n          this.labels.pop();\r\n          this.expect(types._while);\r\n          node.test = this.parseParenExpression();\r\n          if (this.options.ecmaVersion >= 6)\r\n            { this.eat(types.semi); }\r\n          else\r\n            { this.semicolon(); }\r\n          return this.finishNode(node, \"DoWhileStatement\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseForStatement = function(node) {\r\n          this.next();\r\n          var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\r\n          this.labels.push(loopLabel);\r\n          this.enterScope(0);\r\n          this.expect(types.parenL);\r\n          if (this.type === types.semi) {\r\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n            return this.parseFor(node, null)\r\n          }\r\n          var isLet = this.isLet();\r\n          if (this.type === types._var || this.type === types._const || isLet) {\r\n            var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\r\n            this.next();\r\n            this.parseVar(init$1, true, kind);\r\n            this.finishNode(init$1, \"VariableDeclaration\");\r\n            if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\r\n              if (this.options.ecmaVersion >= 9) {\r\n                if (this.type === types._in) {\r\n                  if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n                } else { node.await = awaitAt > -1; }\r\n              }\r\n              return this.parseForIn(node, init$1)\r\n            }\r\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n            return this.parseFor(node, init$1)\r\n          }\r\n          var refDestructuringErrors = new DestructuringErrors;\r\n          var init = this.parseExpression(true, refDestructuringErrors);\r\n          if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\r\n            if (this.options.ecmaVersion >= 9) {\r\n              if (this.type === types._in) {\r\n                if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n              } else { node.await = awaitAt > -1; }\r\n            }\r\n            this.toAssignable(init, false, refDestructuringErrors);\r\n            this.checkLVal(init);\r\n            return this.parseForIn(node, init)\r\n          } else {\r\n            this.checkExpressionErrors(refDestructuringErrors, true);\r\n          }\r\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\r\n          return this.parseFor(node, init)\r\n        };\r\n      \r\n        pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\r\n          this.next();\r\n          return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\r\n        };\r\n      \r\n        pp$1.parseIfStatement = function(node) {\r\n          this.next();\r\n          node.test = this.parseParenExpression();\r\n          node.consequent = this.parseStatement(\"if\");\r\n          node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\r\n          return this.finishNode(node, \"IfStatement\")\r\n        };\r\n      \r\n        pp$1.parseReturnStatement = function(node) {\r\n          if (!this.inFunction && !this.options.allowReturnOutsideFunction)\r\n            { this.raise(this.start, \"'return' outside of function\"); }\r\n          this.next();\r\n      \r\n      \r\n          if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\r\n          else { node.argument = this.parseExpression(); this.semicolon(); }\r\n          return this.finishNode(node, \"ReturnStatement\")\r\n        };\r\n      \r\n        pp$1.parseSwitchStatement = function(node) {\r\n          this.next();\r\n          node.discriminant = this.parseParenExpression();\r\n          node.cases = [];\r\n          this.expect(types.braceL);\r\n          this.labels.push(switchLabel);\r\n          this.enterScope(0);\r\n      \r\n      \r\n          var cur;\r\n          for (var sawDefault = false; this.type !== types.braceR;) {\r\n            if (this.type === types._case || this.type === types._default) {\r\n              var isCase = this.type === types._case;\r\n              if (cur) { this.finishNode(cur, \"SwitchCase\"); }\r\n              node.cases.push(cur = this.startNode());\r\n              cur.consequent = [];\r\n              this.next();\r\n              if (isCase) {\r\n                cur.test = this.parseExpression();\r\n              } else {\r\n                if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\r\n                sawDefault = true;\r\n                cur.test = null;\r\n              }\r\n              this.expect(types.colon);\r\n            } else {\r\n              if (!cur) { this.unexpected(); }\r\n              cur.consequent.push(this.parseStatement(null));\r\n            }\r\n          }\r\n          this.exitScope();\r\n          if (cur) { this.finishNode(cur, \"SwitchCase\"); }\r\n          this.next(); \r\n          this.labels.pop();\r\n          return this.finishNode(node, \"SwitchStatement\")\r\n        };\r\n      \r\n        pp$1.parseThrowStatement = function(node) {\r\n          this.next();\r\n          if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\r\n            { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\r\n          node.argument = this.parseExpression();\r\n          this.semicolon();\r\n          return this.finishNode(node, \"ThrowStatement\")\r\n        };\r\n      \r\n      \r\n        var empty = [];\r\n      \r\n        pp$1.parseTryStatement = function(node) {\r\n          this.next();\r\n          node.block = this.parseBlock();\r\n          node.handler = null;\r\n          if (this.type === types._catch) {\r\n            var clause = this.startNode();\r\n            this.next();\r\n            if (this.eat(types.parenL)) {\r\n              clause.param = this.parseBindingAtom();\r\n              var simple = clause.param.type === \"Identifier\";\r\n              this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\r\n              this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\r\n              this.expect(types.parenR);\r\n            } else {\r\n              if (this.options.ecmaVersion < 10) { this.unexpected(); }\r\n              clause.param = null;\r\n              this.enterScope(0);\r\n            }\r\n            clause.body = this.parseBlock(false);\r\n            this.exitScope();\r\n            node.handler = this.finishNode(clause, \"CatchClause\");\r\n          }\r\n          node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\r\n          if (!node.handler && !node.finalizer)\r\n            { this.raise(node.start, \"Missing catch or finally clause\"); }\r\n          return this.finishNode(node, \"TryStatement\")\r\n        };\r\n      \r\n        pp$1.parseVarStatement = function(node, kind) {\r\n          this.next();\r\n          this.parseVar(node, false, kind);\r\n          this.semicolon();\r\n          return this.finishNode(node, \"VariableDeclaration\")\r\n        };\r\n      \r\n        pp$1.parseWhileStatement = function(node) {\r\n          this.next();\r\n          node.test = this.parseParenExpression();\r\n          this.labels.push(loopLabel);\r\n          node.body = this.parseStatement(\"while\");\r\n          this.labels.pop();\r\n          return this.finishNode(node, \"WhileStatement\")\r\n        };\r\n      \r\n        pp$1.parseWithStatement = function(node) {\r\n          if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\r\n          this.next();\r\n          node.object = this.parseParenExpression();\r\n          node.body = this.parseStatement(\"with\");\r\n          return this.finishNode(node, \"WithStatement\")\r\n        };\r\n      \r\n        pp$1.parseEmptyStatement = function(node) {\r\n          this.next();\r\n          return this.finishNode(node, \"EmptyStatement\")\r\n        };\r\n      \r\n        pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\r\n          for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\r\n            {\r\n            var label = list[i$1];\r\n      \r\n            if (label.name === maybeName)\r\n              { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\r\n          } }\r\n          var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\r\n          for (var i = this.labels.length - 1; i >= 0; i--) {\r\n            var label$1 = this.labels[i];\r\n            if (label$1.statementStart === node.start) {\r\n              label$1.statementStart = this.start;\r\n              label$1.kind = kind;\r\n            } else { break }\r\n          }\r\n          this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\r\n          node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\r\n          this.labels.pop();\r\n          node.label = expr;\r\n          return this.finishNode(node, \"LabeledStatement\")\r\n        };\r\n      \r\n        pp$1.parseExpressionStatement = function(node, expr) {\r\n          node.expression = expr;\r\n          this.semicolon();\r\n          return this.finishNode(node, \"ExpressionStatement\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseBlock = function(createNewLexicalScope, node) {\r\n          if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\r\n          if ( node === void 0 ) node = this.startNode();\r\n      \r\n          node.body = [];\r\n          this.expect(types.braceL);\r\n          if (createNewLexicalScope) { this.enterScope(0); }\r\n          while (!this.eat(types.braceR)) {\r\n            var stmt = this.parseStatement(null);\r\n            node.body.push(stmt);\r\n          }\r\n          if (createNewLexicalScope) { this.exitScope(); }\r\n          return this.finishNode(node, \"BlockStatement\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseFor = function(node, init) {\r\n          node.init = init;\r\n          this.expect(types.semi);\r\n          node.test = this.type === types.semi ? null : this.parseExpression();\r\n          this.expect(types.semi);\r\n          node.update = this.type === types.parenR ? null : this.parseExpression();\r\n          this.expect(types.parenR);\r\n          node.body = this.parseStatement(\"for\");\r\n          this.exitScope();\r\n          this.labels.pop();\r\n          return this.finishNode(node, \"ForStatement\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseForIn = function(node, init) {\r\n          var isForIn = this.type === types._in;\r\n          this.next();\r\n      \r\n          if (\r\n            init.type === \"VariableDeclaration\" &&\r\n            init.declarations[0].init != null &&\r\n            (\r\n              !isForIn ||\r\n              this.options.ecmaVersion < 8 ||\r\n              this.strict ||\r\n              init.kind !== \"var\" ||\r\n              init.declarations[0].id.type !== \"Identifier\"\r\n            )\r\n          ) {\r\n            this.raise(\r\n              init.start,\r\n              ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\r\n            );\r\n          } else if (init.type === \"AssignmentPattern\") {\r\n            this.raise(init.start, \"Invalid left-hand side in for-loop\");\r\n          }\r\n          node.left = init;\r\n          node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\r\n          this.expect(types.parenR);\r\n          node.body = this.parseStatement(\"for\");\r\n          this.exitScope();\r\n          this.labels.pop();\r\n          return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseVar = function(node, isFor, kind) {\r\n          node.declarations = [];\r\n          node.kind = kind;\r\n          for (;;) {\r\n            var decl = this.startNode();\r\n            this.parseVarId(decl, kind);\r\n            if (this.eat(types.eq)) {\r\n              decl.init = this.parseMaybeAssign(isFor);\r\n            } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\r\n              this.unexpected();\r\n            } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\r\n              this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\r\n            } else {\r\n              decl.init = null;\r\n            }\r\n            node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\r\n            if (!this.eat(types.comma)) { break }\r\n          }\r\n          return node\r\n        };\r\n      \r\n        pp$1.parseVarId = function(decl, kind) {\r\n          decl.id = this.parseBindingAtom();\r\n          this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\r\n        };\r\n      \r\n        var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\r\n      \r\n      \r\n        pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\r\n          this.initFunction(node);\r\n          if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\r\n            if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\r\n              { this.unexpected(); }\r\n            node.generator = this.eat(types.star);\r\n          }\r\n          if (this.options.ecmaVersion >= 8)\r\n            { node.async = !!isAsync; }\r\n      \r\n          if (statement & FUNC_STATEMENT) {\r\n            node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\r\n            if (node.id && !(statement & FUNC_HANGING_STATEMENT))\r\n              { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\r\n          }\r\n      \r\n          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\r\n          this.yieldPos = 0;\r\n          this.awaitPos = 0;\r\n          this.awaitIdentPos = 0;\r\n          this.enterScope(functionFlags(node.async, node.generator));\r\n      \r\n          if (!(statement & FUNC_STATEMENT))\r\n            { node.id = this.type === types.name ? this.parseIdent() : null; }\r\n      \r\n          this.parseFunctionParams(node);\r\n          this.parseFunctionBody(node, allowExpressionBody, false);\r\n      \r\n          this.yieldPos = oldYieldPos;\r\n          this.awaitPos = oldAwaitPos;\r\n          this.awaitIdentPos = oldAwaitIdentPos;\r\n          return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\r\n        };\r\n      \r\n        pp$1.parseFunctionParams = function(node) {\r\n          this.expect(types.parenL);\r\n          node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\r\n          this.checkYieldAwaitInDefaultParams();\r\n        };\r\n      \r\n      \r\n        pp$1.parseClass = function(node, isStatement) {\r\n          this.next();\r\n      \r\n          var oldStrict = this.strict;\r\n          this.strict = true;\r\n      \r\n          this.parseClassId(node, isStatement);\r\n          this.parseClassSuper(node);\r\n          var classBody = this.startNode();\r\n          var hadConstructor = false;\r\n          classBody.body = [];\r\n          this.expect(types.braceL);\r\n          while (!this.eat(types.braceR)) {\r\n            var element = this.parseClassElement(node.superClass !== null);\r\n            if (element) {\r\n              classBody.body.push(element);\r\n              if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\r\n                if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\r\n                hadConstructor = true;\r\n              }\r\n            }\r\n          }\r\n          node.body = this.finishNode(classBody, \"ClassBody\");\r\n          this.strict = oldStrict;\r\n          return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\r\n        };\r\n      \r\n        pp$1.parseClassElement = function(constructorAllowsSuper) {\r\n          var this$1 = this;\r\n      \r\n          if (this.eat(types.semi)) { return null }\r\n      \r\n          var method = this.startNode();\r\n          var tryContextual = function (k, noLineBreak) {\r\n            if ( noLineBreak === void 0 ) noLineBreak = false;\r\n      \r\n            var start = this$1.start, startLoc = this$1.startLoc;\r\n            if (!this$1.eatContextual(k)) { return false }\r\n            if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\r\n            if (method.key) { this$1.unexpected(); }\r\n            method.computed = false;\r\n            method.key = this$1.startNodeAt(start, startLoc);\r\n            method.key.name = k;\r\n            this$1.finishNode(method.key, \"Identifier\");\r\n            return false\r\n          };\r\n      \r\n          method.kind = \"method\";\r\n          method.static = tryContextual(\"static\");\r\n          var isGenerator = this.eat(types.star);\r\n          var isAsync = false;\r\n          if (!isGenerator) {\r\n            if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\r\n              isAsync = true;\r\n              isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\r\n            } else if (tryContextual(\"get\")) {\r\n              method.kind = \"get\";\r\n            } else if (tryContextual(\"set\")) {\r\n              method.kind = \"set\";\r\n            }\r\n          }\r\n          if (!method.key) { this.parsePropertyName(method); }\r\n          var key = method.key;\r\n          var allowsDirectSuper = false;\r\n          if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\r\n              key.type === \"Literal\" && key.value === \"constructor\")) {\r\n            if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\r\n            if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\r\n            if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\r\n            method.kind = \"constructor\";\r\n            allowsDirectSuper = constructorAllowsSuper;\r\n          } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\r\n            this.raise(key.start, \"Classes may not have a static property named prototype\");\r\n          }\r\n          this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\r\n          if (method.kind === \"get\" && method.value.params.length !== 0)\r\n            { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\r\n          if (method.kind === \"set\" && method.value.params.length !== 1)\r\n            { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\r\n          if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\r\n            { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\r\n          return method\r\n        };\r\n      \r\n        pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\r\n          method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\r\n          return this.finishNode(method, \"MethodDefinition\")\r\n        };\r\n      \r\n        pp$1.parseClassId = function(node, isStatement) {\r\n          if (this.type === types.name) {\r\n            node.id = this.parseIdent();\r\n            if (isStatement)\r\n              { this.checkLVal(node.id, BIND_LEXICAL, false); }\r\n          } else {\r\n            if (isStatement === true)\r\n              { this.unexpected(); }\r\n            node.id = null;\r\n          }\r\n        };\r\n      \r\n        pp$1.parseClassSuper = function(node) {\r\n          node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\r\n        };\r\n      \r\n      \r\n        pp$1.parseExport = function(node, exports) {\r\n          this.next();\r\n          if (this.eat(types.star)) {\r\n            this.expectContextual(\"from\");\r\n            if (this.type !== types.string) { this.unexpected(); }\r\n            node.source = this.parseExprAtom();\r\n            this.semicolon();\r\n            return this.finishNode(node, \"ExportAllDeclaration\")\r\n          }\r\n          if (this.eat(types._default)) { \r\n            this.checkExport(exports, \"default\", this.lastTokStart);\r\n            var isAsync;\r\n            if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\r\n              var fNode = this.startNode();\r\n              this.next();\r\n              if (isAsync) { this.next(); }\r\n              node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\r\n            } else if (this.type === types._class) {\r\n              var cNode = this.startNode();\r\n              node.declaration = this.parseClass(cNode, \"nullableID\");\r\n            } else {\r\n              node.declaration = this.parseMaybeAssign();\r\n              this.semicolon();\r\n            }\r\n            return this.finishNode(node, \"ExportDefaultDeclaration\")\r\n          }\r\n          if (this.shouldParseExportStatement()) {\r\n            node.declaration = this.parseStatement(null);\r\n            if (node.declaration.type === \"VariableDeclaration\")\r\n              { this.checkVariableExport(exports, node.declaration.declarations); }\r\n            else\r\n              { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\r\n            node.specifiers = [];\r\n            node.source = null;\r\n          } else { \r\n            node.declaration = null;\r\n            node.specifiers = this.parseExportSpecifiers(exports);\r\n            if (this.eatContextual(\"from\")) {\r\n              if (this.type !== types.string) { this.unexpected(); }\r\n              node.source = this.parseExprAtom();\r\n            } else {\r\n              for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\r\n                var spec = list[i];\r\n      \r\n                this.checkUnreserved(spec.local);\r\n                this.checkLocalExport(spec.local);\r\n              }\r\n      \r\n              node.source = null;\r\n            }\r\n            this.semicolon();\r\n          }\r\n          return this.finishNode(node, \"ExportNamedDeclaration\")\r\n        };\r\n      \r\n        pp$1.checkExport = function(exports, name, pos) {\r\n          if (!exports) { return }\r\n          if (has(exports, name))\r\n            { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\r\n          exports[name] = true;\r\n        };\r\n      \r\n        pp$1.checkPatternExport = function(exports, pat) {\r\n          var type = pat.type;\r\n          if (type === \"Identifier\")\r\n            { this.checkExport(exports, pat.name, pat.start); }\r\n          else if (type === \"ObjectPattern\")\r\n            { for (var i = 0, list = pat.properties; i < list.length; i += 1)\r\n              {\r\n                var prop = list[i];\r\n      \r\n                this.checkPatternExport(exports, prop);\r\n              } }\r\n          else if (type === \"ArrayPattern\")\r\n            { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\r\n              var elt = list$1[i$1];\r\n      \r\n                if (elt) { this.checkPatternExport(exports, elt); }\r\n            } }\r\n          else if (type === \"Property\")\r\n            { this.checkPatternExport(exports, pat.value); }\r\n          else if (type === \"AssignmentPattern\")\r\n            { this.checkPatternExport(exports, pat.left); }\r\n          else if (type === \"RestElement\")\r\n            { this.checkPatternExport(exports, pat.argument); }\r\n          else if (type === \"ParenthesizedExpression\")\r\n            { this.checkPatternExport(exports, pat.expression); }\r\n        };\r\n      \r\n        pp$1.checkVariableExport = function(exports, decls) {\r\n          if (!exports) { return }\r\n          for (var i = 0, list = decls; i < list.length; i += 1)\r\n            {\r\n            var decl = list[i];\r\n      \r\n            this.checkPatternExport(exports, decl.id);\r\n          }\r\n        };\r\n      \r\n        pp$1.shouldParseExportStatement = function() {\r\n          return this.type.keyword === \"var\" ||\r\n            this.type.keyword === \"const\" ||\r\n            this.type.keyword === \"class\" ||\r\n            this.type.keyword === \"function\" ||\r\n            this.isLet() ||\r\n            this.isAsyncFunction()\r\n        };\r\n      \r\n      \r\n        pp$1.parseExportSpecifiers = function(exports) {\r\n          var nodes = [], first = true;\r\n          this.expect(types.braceL);\r\n          while (!this.eat(types.braceR)) {\r\n            if (!first) {\r\n              this.expect(types.comma);\r\n              if (this.afterTrailingComma(types.braceR)) { break }\r\n            } else { first = false; }\r\n      \r\n            var node = this.startNode();\r\n            node.local = this.parseIdent(true);\r\n            node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\r\n            this.checkExport(exports, node.exported.name, node.exported.start);\r\n            nodes.push(this.finishNode(node, \"ExportSpecifier\"));\r\n          }\r\n          return nodes\r\n        };\r\n      \r\n      \r\n        pp$1.parseImport = function(node) {\r\n          this.next();\r\n          if (this.type === types.string) {\r\n            node.specifiers = empty;\r\n            node.source = this.parseExprAtom();\r\n          } else {\r\n            node.specifiers = this.parseImportSpecifiers();\r\n            this.expectContextual(\"from\");\r\n            node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\r\n          }\r\n          this.semicolon();\r\n          return this.finishNode(node, \"ImportDeclaration\")\r\n        };\r\n      \r\n      \r\n        pp$1.parseImportSpecifiers = function() {\r\n          var nodes = [], first = true;\r\n          if (this.type === types.name) {\r\n            var node = this.startNode();\r\n            node.local = this.parseIdent();\r\n            this.checkLVal(node.local, BIND_LEXICAL);\r\n            nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\r\n            if (!this.eat(types.comma)) { return nodes }\r\n          }\r\n          if (this.type === types.star) {\r\n            var node$1 = this.startNode();\r\n            this.next();\r\n            this.expectContextual(\"as\");\r\n            node$1.local = this.parseIdent();\r\n            this.checkLVal(node$1.local, BIND_LEXICAL);\r\n            nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\r\n            return nodes\r\n          }\r\n          this.expect(types.braceL);\r\n          while (!this.eat(types.braceR)) {\r\n            if (!first) {\r\n              this.expect(types.comma);\r\n              if (this.afterTrailingComma(types.braceR)) { break }\r\n            } else { first = false; }\r\n      \r\n            var node$2 = this.startNode();\r\n            node$2.imported = this.parseIdent(true);\r\n            if (this.eatContextual(\"as\")) {\r\n              node$2.local = this.parseIdent();\r\n            } else {\r\n              this.checkUnreserved(node$2.imported);\r\n              node$2.local = node$2.imported;\r\n            }\r\n            this.checkLVal(node$2.local, BIND_LEXICAL);\r\n            nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\r\n          }\r\n          return nodes\r\n        };\r\n      \r\n        pp$1.adaptDirectivePrologue = function(statements) {\r\n          for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\r\n            statements[i].directive = statements[i].expression.raw.slice(1, -1);\r\n          }\r\n        };\r\n        pp$1.isDirectiveCandidate = function(statement) {\r\n          return (\r\n            statement.type === \"ExpressionStatement\" &&\r\n            statement.expression.type === \"Literal\" &&\r\n            typeof statement.expression.value === \"string\" &&\r\n            (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\r\n          )\r\n        };\r\n      \r\n        var pp$2 = Parser.prototype;\r\n      \r\n      \r\n        pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\r\n          if (this.options.ecmaVersion >= 6 && node) {\r\n            switch (node.type) {\r\n            case \"Identifier\":\r\n              if (this.inAsync && node.name === \"await\")\r\n                { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\r\n              break\r\n      \r\n            case \"ObjectPattern\":\r\n            case \"ArrayPattern\":\r\n            case \"RestElement\":\r\n              break\r\n      \r\n            case \"ObjectExpression\":\r\n              node.type = \"ObjectPattern\";\r\n              if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n              for (var i = 0, list = node.properties; i < list.length; i += 1) {\r\n                var prop = list[i];\r\n      \r\n              this.toAssignable(prop, isBinding);\r\n                if (\r\n                  prop.type === \"RestElement\" &&\r\n                  (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\r\n                ) {\r\n                  this.raise(prop.argument.start, \"Unexpected token\");\r\n                }\r\n              }\r\n              break\r\n      \r\n            case \"Property\":\r\n              if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\r\n              this.toAssignable(node.value, isBinding);\r\n              break\r\n      \r\n            case \"ArrayExpression\":\r\n              node.type = \"ArrayPattern\";\r\n              if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n              this.toAssignableList(node.elements, isBinding);\r\n              break\r\n      \r\n            case \"SpreadElement\":\r\n              node.type = \"RestElement\";\r\n              this.toAssignable(node.argument, isBinding);\r\n              if (node.argument.type === \"AssignmentPattern\")\r\n                { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\r\n              break\r\n      \r\n            case \"AssignmentExpression\":\r\n              if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\r\n              node.type = \"AssignmentPattern\";\r\n              delete node.operator;\r\n              this.toAssignable(node.left, isBinding);\r\n      \r\n            case \"AssignmentPattern\":\r\n              break\r\n      \r\n            case \"ParenthesizedExpression\":\r\n              this.toAssignable(node.expression, isBinding, refDestructuringErrors);\r\n              break\r\n      \r\n            case \"MemberExpression\":\r\n              if (!isBinding) { break }\r\n      \r\n            default:\r\n              this.raise(node.start, \"Assigning to rvalue\");\r\n            }\r\n          } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\r\n          return node\r\n        };\r\n      \r\n      \r\n        pp$2.toAssignableList = function(exprList, isBinding) {\r\n          var end = exprList.length;\r\n          for (var i = 0; i < end; i++) {\r\n            var elt = exprList[i];\r\n            if (elt) { this.toAssignable(elt, isBinding); }\r\n          }\r\n          if (end) {\r\n            var last = exprList[end - 1];\r\n            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\r\n              { this.unexpected(last.argument.start); }\r\n          }\r\n          return exprList\r\n        };\r\n      \r\n      \r\n        pp$2.parseSpread = function(refDestructuringErrors) {\r\n          var node = this.startNode();\r\n          this.next();\r\n          node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\r\n          return this.finishNode(node, \"SpreadElement\")\r\n        };\r\n      \r\n        pp$2.parseRestBinding = function() {\r\n          var node = this.startNode();\r\n          this.next();\r\n      \r\n          if (this.options.ecmaVersion === 6 && this.type !== types.name)\r\n            { this.unexpected(); }\r\n      \r\n          node.argument = this.parseBindingAtom();\r\n      \r\n          return this.finishNode(node, \"RestElement\")\r\n        };\r\n      \r\n      \r\n        pp$2.parseBindingAtom = function() {\r\n          if (this.options.ecmaVersion >= 6) {\r\n            switch (this.type) {\r\n            case types.bracketL:\r\n              var node = this.startNode();\r\n              this.next();\r\n              node.elements = this.parseBindingList(types.bracketR, true, true);\r\n              return this.finishNode(node, \"ArrayPattern\")\r\n      \r\n            case types.braceL:\r\n              return this.parseObj(true)\r\n            }\r\n          }\r\n          return this.parseIdent()\r\n        };\r\n      \r\n        pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\r\n          var elts = [], first = true;\r\n          while (!this.eat(close)) {\r\n            if (first) { first = false; }\r\n            else { this.expect(types.comma); }\r\n            if (allowEmpty && this.type === types.comma) {\r\n              elts.push(null);\r\n            } else if (allowTrailingComma && this.afterTrailingComma(close)) {\r\n              break\r\n            } else if (this.type === types.ellipsis) {\r\n              var rest = this.parseRestBinding();\r\n              this.parseBindingListItem(rest);\r\n              elts.push(rest);\r\n              if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\r\n              this.expect(close);\r\n              break\r\n            } else {\r\n              var elem = this.parseMaybeDefault(this.start, this.startLoc);\r\n              this.parseBindingListItem(elem);\r\n              elts.push(elem);\r\n            }\r\n          }\r\n          return elts\r\n        };\r\n      \r\n        pp$2.parseBindingListItem = function(param) {\r\n          return param\r\n        };\r\n      \r\n      \r\n        pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\r\n          left = left || this.parseBindingAtom();\r\n          if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\r\n          var node = this.startNodeAt(startPos, startLoc);\r\n          node.left = left;\r\n          node.right = this.parseMaybeAssign();\r\n          return this.finishNode(node, \"AssignmentPattern\")\r\n        };\r\n      \r\n      \r\n        pp$2.checkLVal = function(expr, bindingType, checkClashes) {\r\n          if ( bindingType === void 0 ) bindingType = BIND_NONE;\r\n      \r\n          switch (expr.type) {\r\n          case \"Identifier\":\r\n            if (bindingType === BIND_LEXICAL && expr.name === \"let\")\r\n              { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\r\n            if (this.strict && this.reservedWordsStrictBind.test(expr.name))\r\n              { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\r\n            if (checkClashes) {\r\n              if (has(checkClashes, expr.name))\r\n                { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\r\n              checkClashes[expr.name] = true;\r\n            }\r\n            if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\r\n            break\r\n      \r\n          case \"MemberExpression\":\r\n            if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\r\n            break\r\n      \r\n          case \"ObjectPattern\":\r\n            for (var i = 0, list = expr.properties; i < list.length; i += 1)\r\n              {\r\n            var prop = list[i];\r\n      \r\n            this.checkLVal(prop, bindingType, checkClashes);\r\n          }\r\n            break\r\n      \r\n          case \"Property\":\r\n            this.checkLVal(expr.value, bindingType, checkClashes);\r\n            break\r\n      \r\n          case \"ArrayPattern\":\r\n            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\r\n              var elem = list$1[i$1];\r\n      \r\n            if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\r\n            }\r\n            break\r\n      \r\n          case \"AssignmentPattern\":\r\n            this.checkLVal(expr.left, bindingType, checkClashes);\r\n            break\r\n      \r\n          case \"RestElement\":\r\n            this.checkLVal(expr.argument, bindingType, checkClashes);\r\n            break\r\n      \r\n          case \"ParenthesizedExpression\":\r\n            this.checkLVal(expr.expression, bindingType, checkClashes);\r\n            break\r\n      \r\n          default:\r\n            this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\r\n          }\r\n        };\r\n      \r\n      \r\n        var pp$3 = Parser.prototype;\r\n      \r\n      \r\n        pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\r\n          if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\r\n            { return }\r\n          if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\r\n            { return }\r\n          var key = prop.key;\r\n          var name;\r\n          switch (key.type) {\r\n          case \"Identifier\": name = key.name; break\r\n          case \"Literal\": name = String(key.value); break\r\n          default: return\r\n          }\r\n          var kind = prop.kind;\r\n          if (this.options.ecmaVersion >= 6) {\r\n            if (name === \"__proto__\" && kind === \"init\") {\r\n              if (propHash.proto) {\r\n                if (refDestructuringErrors) {\r\n                  if (refDestructuringErrors.doubleProto < 0)\r\n                    { refDestructuringErrors.doubleProto = key.start; }\r\n                } else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\r\n              }\r\n              propHash.proto = true;\r\n            }\r\n            return\r\n          }\r\n          name = \"$\" + name;\r\n          var other = propHash[name];\r\n          if (other) {\r\n            var redefinition;\r\n            if (kind === \"init\") {\r\n              redefinition = this.strict && other.init || other.get || other.set;\r\n            } else {\r\n              redefinition = other.init || other[kind];\r\n            }\r\n            if (redefinition)\r\n              { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\r\n          } else {\r\n            other = propHash[name] = {\r\n              init: false,\r\n              get: false,\r\n              set: false\r\n            };\r\n          }\r\n          other[kind] = true;\r\n        };\r\n      \r\n      \r\n      \r\n      \r\n        pp$3.parseExpression = function(noIn, refDestructuringErrors) {\r\n          var startPos = this.start, startLoc = this.startLoc;\r\n          var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\r\n          if (this.type === types.comma) {\r\n            var node = this.startNodeAt(startPos, startLoc);\r\n            node.expressions = [expr];\r\n            while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\r\n            return this.finishNode(node, \"SequenceExpression\")\r\n          }\r\n          return expr\r\n        };\r\n      \r\n      \r\n        pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\r\n          if (this.isContextual(\"yield\")) {\r\n            if (this.inGenerator) { return this.parseYield(noIn) }\r\n            else { this.exprAllowed = false; }\r\n          }\r\n      \r\n          var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\r\n          if (refDestructuringErrors) {\r\n            oldParenAssign = refDestructuringErrors.parenthesizedAssign;\r\n            oldTrailingComma = refDestructuringErrors.trailingComma;\r\n            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\r\n          } else {\r\n            refDestructuringErrors = new DestructuringErrors;\r\n            ownDestructuringErrors = true;\r\n          }\r\n      \r\n          var startPos = this.start, startLoc = this.startLoc;\r\n          if (this.type === types.parenL || this.type === types.name)\r\n            { this.potentialArrowAt = this.start; }\r\n          var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\r\n          if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\r\n          if (this.type.isAssign) {\r\n            var node = this.startNodeAt(startPos, startLoc);\r\n            node.operator = this.value;\r\n            node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\r\n            if (!ownDestructuringErrors) {\r\n              refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\r\n            }\r\n            if (refDestructuringErrors.shorthandAssign >= node.left.start)\r\n              { refDestructuringErrors.shorthandAssign = -1; } \r\n            this.checkLVal(left);\r\n            this.next();\r\n            node.right = this.parseMaybeAssign(noIn);\r\n            return this.finishNode(node, \"AssignmentExpression\")\r\n          } else {\r\n            if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\r\n          }\r\n          if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\r\n          if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\r\n          return left\r\n        };\r\n      \r\n      \r\n        pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\r\n          var startPos = this.start, startLoc = this.startLoc;\r\n          var expr = this.parseExprOps(noIn, refDestructuringErrors);\r\n          if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n          if (this.eat(types.question)) {\r\n            var node = this.startNodeAt(startPos, startLoc);\r\n            node.test = expr;\r\n            node.consequent = this.parseMaybeAssign();\r\n            this.expect(types.colon);\r\n            node.alternate = this.parseMaybeAssign(noIn);\r\n            return this.finishNode(node, \"ConditionalExpression\")\r\n          }\r\n          return expr\r\n        };\r\n      \r\n      \r\n        pp$3.parseExprOps = function(noIn, refDestructuringErrors) {\r\n          var startPos = this.start, startLoc = this.startLoc;\r\n          var expr = this.parseMaybeUnary(refDestructuringErrors, false);\r\n          if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n          return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\r\n        };\r\n      \r\n      \r\n        pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\r\n          var prec = this.type.binop;\r\n          if (prec != null && (!noIn || this.type !== types._in)) {\r\n            if (prec > minPrec) {\r\n              var logical = this.type === types.logicalOR || this.type === types.logicalAND;\r\n              var op = this.value;\r\n              this.next();\r\n              var startPos = this.start, startLoc = this.startLoc;\r\n              var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\r\n              var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\r\n              return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\r\n            }\r\n          }\r\n          return left\r\n        };\r\n      \r\n        pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\r\n          var node = this.startNodeAt(startPos, startLoc);\r\n          node.left = left;\r\n          node.operator = op;\r\n          node.right = right;\r\n          return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\r\n        };\r\n      \r\n      \r\n        pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\r\n          var startPos = this.start, startLoc = this.startLoc, expr;\r\n          if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\r\n            expr = this.parseAwait();\r\n            sawUnary = true;\r\n          } else if (this.type.prefix) {\r\n            var node = this.startNode(), update = this.type === types.incDec;\r\n            node.operator = this.value;\r\n            node.prefix = true;\r\n            this.next();\r\n            node.argument = this.parseMaybeUnary(null, true);\r\n            this.checkExpressionErrors(refDestructuringErrors, true);\r\n            if (update) { this.checkLVal(node.argument); }\r\n            else if (this.strict && node.operator === \"delete\" &&\r\n                     node.argument.type === \"Identifier\")\r\n              { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\r\n            else { sawUnary = true; }\r\n            expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\r\n          } else {\r\n            expr = this.parseExprSubscripts(refDestructuringErrors);\r\n            if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\r\n            while (this.type.postfix && !this.canInsertSemicolon()) {\r\n              var node$1 = this.startNodeAt(startPos, startLoc);\r\n              node$1.operator = this.value;\r\n              node$1.prefix = false;\r\n              node$1.argument = expr;\r\n              this.checkLVal(expr);\r\n              this.next();\r\n              expr = this.finishNode(node$1, \"UpdateExpression\");\r\n            }\r\n          }\r\n      \r\n          if (!sawUnary && this.eat(types.starstar))\r\n            { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\r\n          else\r\n            { return expr }\r\n        };\r\n      \r\n      \r\n        pp$3.parseExprSubscripts = function(refDestructuringErrors) {\r\n          var startPos = this.start, startLoc = this.startLoc;\r\n          var expr = this.parseExprAtom(refDestructuringErrors);\r\n          if (expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\")\r\n            { return expr }\r\n          var result = this.parseSubscripts(expr, startPos, startLoc);\r\n          if (refDestructuringErrors && result.type === \"MemberExpression\") {\r\n            if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\r\n            if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\r\n          }\r\n          return result\r\n        };\r\n      \r\n        pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\r\n          var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\r\n              this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\r\n          while (true) {\r\n            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\r\n            if (element === base || element.type === \"ArrowFunctionExpression\") { return element }\r\n            base = element;\r\n          }\r\n        };\r\n      \r\n        pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\r\n          var computed = this.eat(types.bracketL);\r\n          if (computed || this.eat(types.dot)) {\r\n            var node = this.startNodeAt(startPos, startLoc);\r\n            node.object = base;\r\n            node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\r\n            node.computed = !!computed;\r\n            if (computed) { this.expect(types.bracketR); }\r\n            base = this.finishNode(node, \"MemberExpression\");\r\n          } else if (!noCalls && this.eat(types.parenL)) {\r\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\r\n            this.yieldPos = 0;\r\n            this.awaitPos = 0;\r\n            this.awaitIdentPos = 0;\r\n            var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\r\n            if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\r\n              this.checkPatternErrors(refDestructuringErrors, false);\r\n              this.checkYieldAwaitInDefaultParams();\r\n              if (this.awaitIdentPos > 0)\r\n                { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\r\n              this.yieldPos = oldYieldPos;\r\n              this.awaitPos = oldAwaitPos;\r\n              this.awaitIdentPos = oldAwaitIdentPos;\r\n              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\r\n            }\r\n            this.checkExpressionErrors(refDestructuringErrors, true);\r\n            this.yieldPos = oldYieldPos || this.yieldPos;\r\n            this.awaitPos = oldAwaitPos || this.awaitPos;\r\n            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\r\n            var node$1 = this.startNodeAt(startPos, startLoc);\r\n            node$1.callee = base;\r\n            node$1.arguments = exprList;\r\n            base = this.finishNode(node$1, \"CallExpression\");\r\n          } else if (this.type === types.backQuote) {\r\n            var node$2 = this.startNodeAt(startPos, startLoc);\r\n            node$2.tag = base;\r\n            node$2.quasi = this.parseTemplate({isTagged: true});\r\n            base = this.finishNode(node$2, \"TaggedTemplateExpression\");\r\n          }\r\n          return base\r\n        };\r\n      \r\n      \r\n        pp$3.parseExprAtom = function(refDestructuringErrors) {\r\n          if (this.type === types.slash) { this.readRegexp(); }\r\n      \r\n          var node, canBeArrow = this.potentialArrowAt === this.start;\r\n          switch (this.type) {\r\n          case types._super:\r\n            if (!this.allowSuper)\r\n              { this.raise(this.start, \"'super' keyword outside a method\"); }\r\n            node = this.startNode();\r\n            this.next();\r\n            if (this.type === types.parenL && !this.allowDirectSuper)\r\n              { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\r\n            if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\r\n              { this.unexpected(); }\r\n            return this.finishNode(node, \"Super\")\r\n      \r\n          case types._this:\r\n            node = this.startNode();\r\n            this.next();\r\n            return this.finishNode(node, \"ThisExpression\")\r\n      \r\n          case types.name:\r\n            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\r\n            var id = this.parseIdent(false);\r\n            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\r\n              { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\r\n            if (canBeArrow && !this.canInsertSemicolon()) {\r\n              if (this.eat(types.arrow))\r\n                { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\r\n              if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\r\n                id = this.parseIdent(false);\r\n                if (this.canInsertSemicolon() || !this.eat(types.arrow))\r\n                  { this.unexpected(); }\r\n                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\r\n              }\r\n            }\r\n            return id\r\n      \r\n          case types.regexp:\r\n            var value = this.value;\r\n            node = this.parseLiteral(value.value);\r\n            node.regex = {pattern: value.pattern, flags: value.flags};\r\n            return node\r\n      \r\n          case types.num: case types.string:\r\n            return this.parseLiteral(this.value)\r\n      \r\n          case types._null: case types._true: case types._false:\r\n            node = this.startNode();\r\n            node.value = this.type === types._null ? null : this.type === types._true;\r\n            node.raw = this.type.keyword;\r\n            this.next();\r\n            return this.finishNode(node, \"Literal\")\r\n      \r\n          case types.parenL:\r\n            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\r\n            if (refDestructuringErrors) {\r\n              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\r\n                { refDestructuringErrors.parenthesizedAssign = start; }\r\n              if (refDestructuringErrors.parenthesizedBind < 0)\r\n                { refDestructuringErrors.parenthesizedBind = start; }\r\n            }\r\n            return expr\r\n      \r\n          case types.bracketL:\r\n            node = this.startNode();\r\n            this.next();\r\n            node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\r\n            return this.finishNode(node, \"ArrayExpression\")\r\n      \r\n          case types.braceL:\r\n            return this.parseObj(false, refDestructuringErrors)\r\n      \r\n          case types._function:\r\n            node = this.startNode();\r\n            this.next();\r\n            return this.parseFunction(node, 0)\r\n      \r\n          case types._class:\r\n            return this.parseClass(this.startNode(), false)\r\n      \r\n          case types._new:\r\n            return this.parseNew()\r\n      \r\n          case types.backQuote:\r\n            return this.parseTemplate()\r\n      \r\n          case types._import:\r\n            if (this.options.ecmaVersion >= 11) {\r\n              return this.parseExprImport()\r\n            } else {\r\n              return this.unexpected()\r\n            }\r\n      \r\n          default:\r\n            this.unexpected();\r\n          }\r\n        };\r\n      \r\n        pp$3.parseExprImport = function() {\r\n          var node = this.startNode();\r\n          this.next(); \r\n          switch (this.type) {\r\n          case types.parenL:\r\n            return this.parseDynamicImport(node)\r\n          default:\r\n            this.unexpected();\r\n          }\r\n        };\r\n      \r\n        pp$3.parseDynamicImport = function(node) {\r\n          this.next(); \r\n      \r\n          node.source = this.parseMaybeAssign();\r\n      \r\n          if (!this.eat(types.parenR)) {\r\n            var errorPos = this.start;\r\n            if (this.eat(types.comma) && this.eat(types.parenR)) {\r\n              this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\r\n            } else {\r\n              this.unexpected(errorPos);\r\n            }\r\n          }\r\n      \r\n          return this.finishNode(node, \"ImportExpression\")\r\n        };\r\n      \r\n        pp$3.parseLiteral = function(value) {\r\n          var node = this.startNode();\r\n          node.value = value;\r\n          node.raw = this.input.slice(this.start, this.end);\r\n          if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\r\n          this.next();\r\n          return this.finishNode(node, \"Literal\")\r\n        };\r\n      \r\n        pp$3.parseParenExpression = function() {\r\n          this.expect(types.parenL);\r\n          var val = this.parseExpression();\r\n          this.expect(types.parenR);\r\n          return val\r\n        };\r\n      \r\n        pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\r\n          var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\r\n          if (this.options.ecmaVersion >= 6) {\r\n            this.next();\r\n      \r\n            var innerStartPos = this.start, innerStartLoc = this.startLoc;\r\n            var exprList = [], first = true, lastIsComma = false;\r\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\r\n            this.yieldPos = 0;\r\n            this.awaitPos = 0;\r\n            while (this.type !== types.parenR) {\r\n              first ? first = false : this.expect(types.comma);\r\n              if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\r\n                lastIsComma = true;\r\n                break\r\n              } else if (this.type === types.ellipsis) {\r\n                spreadStart = this.start;\r\n                exprList.push(this.parseParenItem(this.parseRestBinding()));\r\n                if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\r\n                break\r\n              } else {\r\n                exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\r\n              }\r\n            }\r\n            var innerEndPos = this.start, innerEndLoc = this.startLoc;\r\n            this.expect(types.parenR);\r\n      \r\n            if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\r\n              this.checkPatternErrors(refDestructuringErrors, false);\r\n              this.checkYieldAwaitInDefaultParams();\r\n              this.yieldPos = oldYieldPos;\r\n              this.awaitPos = oldAwaitPos;\r\n              return this.parseParenArrowList(startPos, startLoc, exprList)\r\n            }\r\n      \r\n            if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\r\n            if (spreadStart) { this.unexpected(spreadStart); }\r\n            this.checkExpressionErrors(refDestructuringErrors, true);\r\n            this.yieldPos = oldYieldPos || this.yieldPos;\r\n            this.awaitPos = oldAwaitPos || this.awaitPos;\r\n      \r\n            if (exprList.length > 1) {\r\n              val = this.startNodeAt(innerStartPos, innerStartLoc);\r\n              val.expressions = exprList;\r\n              this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\r\n            } else {\r\n              val = exprList[0];\r\n            }\r\n          } else {\r\n            val = this.parseParenExpression();\r\n          }\r\n      \r\n          if (this.options.preserveParens) {\r\n            var par = this.startNodeAt(startPos, startLoc);\r\n            par.expression = val;\r\n            return this.finishNode(par, \"ParenthesizedExpression\")\r\n          } else {\r\n            return val\r\n          }\r\n        };\r\n      \r\n        pp$3.parseParenItem = function(item) {\r\n          return item\r\n        };\r\n      \r\n        pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\r\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\r\n        };\r\n      \r\n      \r\n        var empty$1 = [];\r\n      \r\n        pp$3.parseNew = function() {\r\n          if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword new\"); }\r\n          var node = this.startNode();\r\n          var meta = this.parseIdent(true);\r\n          if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\r\n            node.meta = meta;\r\n            var containsEsc = this.containsEsc;\r\n            node.property = this.parseIdent(true);\r\n            if (node.property.name !== \"target\" || containsEsc)\r\n              { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\r\n            if (!this.inNonArrowFunction())\r\n              { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\r\n            return this.finishNode(node, \"MetaProperty\")\r\n          }\r\n          var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;\r\n          node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\r\n          if (isImport && node.callee.type === \"ImportExpression\") {\r\n            this.raise(startPos, \"Cannot use new with import()\");\r\n          }\r\n          if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\r\n          else { node.arguments = empty$1; }\r\n          return this.finishNode(node, \"NewExpression\")\r\n        };\r\n      \r\n      \r\n        pp$3.parseTemplateElement = function(ref) {\r\n          var isTagged = ref.isTagged;\r\n      \r\n          var elem = this.startNode();\r\n          if (this.type === types.invalidTemplate) {\r\n            if (!isTagged) {\r\n              this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\r\n            }\r\n            elem.value = {\r\n              raw: this.value,\r\n              cooked: null\r\n            };\r\n          } else {\r\n            elem.value = {\r\n              raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\r\n              cooked: this.value\r\n            };\r\n          }\r\n          this.next();\r\n          elem.tail = this.type === types.backQuote;\r\n          return this.finishNode(elem, \"TemplateElement\")\r\n        };\r\n      \r\n        pp$3.parseTemplate = function(ref) {\r\n          if ( ref === void 0 ) ref = {};\r\n          var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\r\n      \r\n          var node = this.startNode();\r\n          this.next();\r\n          node.expressions = [];\r\n          var curElt = this.parseTemplateElement({isTagged: isTagged});\r\n          node.quasis = [curElt];\r\n          while (!curElt.tail) {\r\n            if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\r\n            this.expect(types.dollarBraceL);\r\n            node.expressions.push(this.parseExpression());\r\n            this.expect(types.braceR);\r\n            node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\r\n          }\r\n          this.next();\r\n          return this.finishNode(node, \"TemplateLiteral\")\r\n        };\r\n      \r\n        pp$3.isAsyncProp = function(prop) {\r\n          return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\r\n            (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\r\n            !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\r\n        };\r\n      \r\n      \r\n        pp$3.parseObj = function(isPattern, refDestructuringErrors) {\r\n          var node = this.startNode(), first = true, propHash = {};\r\n          node.properties = [];\r\n          this.next();\r\n          while (!this.eat(types.braceR)) {\r\n            if (!first) {\r\n              this.expect(types.comma);\r\n              if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }\r\n            } else { first = false; }\r\n      \r\n            var prop = this.parseProperty(isPattern, refDestructuringErrors);\r\n            if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\r\n            node.properties.push(prop);\r\n          }\r\n          return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\r\n        };\r\n      \r\n        pp$3.parseProperty = function(isPattern, refDestructuringErrors) {\r\n          var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\r\n          if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\r\n            if (isPattern) {\r\n              prop.argument = this.parseIdent(false);\r\n              if (this.type === types.comma) {\r\n                this.raise(this.start, \"Comma is not permitted after the rest element\");\r\n              }\r\n              return this.finishNode(prop, \"RestElement\")\r\n            }\r\n            if (this.type === types.parenL && refDestructuringErrors) {\r\n              if (refDestructuringErrors.parenthesizedAssign < 0) {\r\n                refDestructuringErrors.parenthesizedAssign = this.start;\r\n              }\r\n              if (refDestructuringErrors.parenthesizedBind < 0) {\r\n                refDestructuringErrors.parenthesizedBind = this.start;\r\n              }\r\n            }\r\n            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\r\n            if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\r\n              refDestructuringErrors.trailingComma = this.start;\r\n            }\r\n            return this.finishNode(prop, \"SpreadElement\")\r\n          }\r\n          if (this.options.ecmaVersion >= 6) {\r\n            prop.method = false;\r\n            prop.shorthand = false;\r\n            if (isPattern || refDestructuringErrors) {\r\n              startPos = this.start;\r\n              startLoc = this.startLoc;\r\n            }\r\n            if (!isPattern)\r\n              { isGenerator = this.eat(types.star); }\r\n          }\r\n          var containsEsc = this.containsEsc;\r\n          this.parsePropertyName(prop);\r\n          if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\r\n            isAsync = true;\r\n            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\r\n            this.parsePropertyName(prop, refDestructuringErrors);\r\n          } else {\r\n            isAsync = false;\r\n          }\r\n          this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\r\n          return this.finishNode(prop, \"Property\")\r\n        };\r\n      \r\n        pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\r\n          if ((isGenerator || isAsync) && this.type === types.colon)\r\n            { this.unexpected(); }\r\n      \r\n          if (this.eat(types.colon)) {\r\n            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\r\n            prop.kind = \"init\";\r\n          } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\r\n            if (isPattern) { this.unexpected(); }\r\n            prop.kind = \"init\";\r\n            prop.method = true;\r\n            prop.value = this.parseMethod(isGenerator, isAsync);\r\n          } else if (!isPattern && !containsEsc &&\r\n                     this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\r\n                     (prop.key.name === \"get\" || prop.key.name === \"set\") &&\r\n                     (this.type !== types.comma && this.type !== types.braceR)) {\r\n            if (isGenerator || isAsync) { this.unexpected(); }\r\n            prop.kind = prop.key.name;\r\n            this.parsePropertyName(prop);\r\n            prop.value = this.parseMethod(false);\r\n            var paramCount = prop.kind === \"get\" ? 0 : 1;\r\n            if (prop.value.params.length !== paramCount) {\r\n              var start = prop.value.start;\r\n              if (prop.kind === \"get\")\r\n                { this.raiseRecoverable(start, \"getter should have no params\"); }\r\n              else\r\n                { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\r\n            } else {\r\n              if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\r\n                { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\r\n            }\r\n          } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\r\n            if (isGenerator || isAsync) { this.unexpected(); }\r\n            this.checkUnreserved(prop.key);\r\n            if (prop.key.name === \"await\" && !this.awaitIdentPos)\r\n              { this.awaitIdentPos = startPos; }\r\n            prop.kind = \"init\";\r\n            if (isPattern) {\r\n              prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\r\n            } else if (this.type === types.eq && refDestructuringErrors) {\r\n              if (refDestructuringErrors.shorthandAssign < 0)\r\n                { refDestructuringErrors.shorthandAssign = this.start; }\r\n              prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\r\n            } else {\r\n              prop.value = prop.key;\r\n            }\r\n            prop.shorthand = true;\r\n          } else { this.unexpected(); }\r\n        };\r\n      \r\n        pp$3.parsePropertyName = function(prop) {\r\n          if (this.options.ecmaVersion >= 6) {\r\n            if (this.eat(types.bracketL)) {\r\n              prop.computed = true;\r\n              prop.key = this.parseMaybeAssign();\r\n              this.expect(types.bracketR);\r\n              return prop.key\r\n            } else {\r\n              prop.computed = false;\r\n            }\r\n          }\r\n          return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\r\n        };\r\n      \r\n      \r\n        pp$3.initFunction = function(node) {\r\n          node.id = null;\r\n          if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\r\n          if (this.options.ecmaVersion >= 8) { node.async = false; }\r\n        };\r\n      \r\n      \r\n        pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\r\n          var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\r\n      \r\n          this.initFunction(node);\r\n          if (this.options.ecmaVersion >= 6)\r\n            { node.generator = isGenerator; }\r\n          if (this.options.ecmaVersion >= 8)\r\n            { node.async = !!isAsync; }\r\n      \r\n          this.yieldPos = 0;\r\n          this.awaitPos = 0;\r\n          this.awaitIdentPos = 0;\r\n          this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\r\n      \r\n          this.expect(types.parenL);\r\n          node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\r\n          this.checkYieldAwaitInDefaultParams();\r\n          this.parseFunctionBody(node, false, true);\r\n      \r\n          this.yieldPos = oldYieldPos;\r\n          this.awaitPos = oldAwaitPos;\r\n          this.awaitIdentPos = oldAwaitIdentPos;\r\n          return this.finishNode(node, \"FunctionExpression\")\r\n        };\r\n      \r\n      \r\n        pp$3.parseArrowExpression = function(node, params, isAsync) {\r\n          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\r\n      \r\n          this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\r\n          this.initFunction(node);\r\n          if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\r\n      \r\n          this.yieldPos = 0;\r\n          this.awaitPos = 0;\r\n          this.awaitIdentPos = 0;\r\n      \r\n          node.params = this.toAssignableList(params, true);\r\n          this.parseFunctionBody(node, true, false);\r\n      \r\n          this.yieldPos = oldYieldPos;\r\n          this.awaitPos = oldAwaitPos;\r\n          this.awaitIdentPos = oldAwaitIdentPos;\r\n          return this.finishNode(node, \"ArrowFunctionExpression\")\r\n        };\r\n      \r\n      \r\n        pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\r\n          var isExpression = isArrowFunction && this.type !== types.braceL;\r\n          var oldStrict = this.strict, useStrict = false;\r\n      \r\n          if (isExpression) {\r\n            node.body = this.parseMaybeAssign();\r\n            node.expression = true;\r\n            this.checkParams(node, false);\r\n          } else {\r\n            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\r\n            if (!oldStrict || nonSimple) {\r\n              useStrict = this.strictDirective(this.end);\r\n              if (useStrict && nonSimple)\r\n                { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\r\n            }\r\n            var oldLabels = this.labels;\r\n            this.labels = [];\r\n            if (useStrict) { this.strict = true; }\r\n      \r\n            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\r\n            node.body = this.parseBlock(false);\r\n            node.expression = false;\r\n            this.adaptDirectivePrologue(node.body.body);\r\n            this.labels = oldLabels;\r\n          }\r\n          this.exitScope();\r\n      \r\n          if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\r\n          this.strict = oldStrict;\r\n        };\r\n      \r\n        pp$3.isSimpleParamList = function(params) {\r\n          for (var i = 0, list = params; i < list.length; i += 1)\r\n            {\r\n            var param = list[i];\r\n      \r\n            if (param.type !== \"Identifier\") { return false\r\n          } }\r\n          return true\r\n        };\r\n      \r\n      \r\n        pp$3.checkParams = function(node, allowDuplicates) {\r\n          var nameHash = {};\r\n          for (var i = 0, list = node.params; i < list.length; i += 1)\r\n            {\r\n            var param = list[i];\r\n      \r\n            this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\r\n          }\r\n        };\r\n      \r\n      \r\n        pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\r\n          var elts = [], first = true;\r\n          while (!this.eat(close)) {\r\n            if (!first) {\r\n              this.expect(types.comma);\r\n              if (allowTrailingComma && this.afterTrailingComma(close)) { break }\r\n            } else { first = false; }\r\n      \r\n            var elt = (void 0);\r\n            if (allowEmpty && this.type === types.comma)\r\n              { elt = null; }\r\n            else if (this.type === types.ellipsis) {\r\n              elt = this.parseSpread(refDestructuringErrors);\r\n              if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\r\n                { refDestructuringErrors.trailingComma = this.start; }\r\n            } else {\r\n              elt = this.parseMaybeAssign(false, refDestructuringErrors);\r\n            }\r\n            elts.push(elt);\r\n          }\r\n          return elts\r\n        };\r\n      \r\n        pp$3.checkUnreserved = function(ref) {\r\n          var start = ref.start;\r\n          var end = ref.end;\r\n          var name = ref.name;\r\n      \r\n          if (this.inGenerator && name === \"yield\")\r\n            { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\r\n          if (this.inAsync && name === \"await\")\r\n            { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\r\n          if (this.keywords.test(name))\r\n            { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\r\n          if (this.options.ecmaVersion < 6 &&\r\n            this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\r\n          var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\r\n          if (re.test(name)) {\r\n            if (!this.inAsync && name === \"await\")\r\n              { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\r\n            this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\r\n          }\r\n        };\r\n      \r\n      \r\n        pp$3.parseIdent = function(liberal, isBinding) {\r\n          var node = this.startNode();\r\n          if (this.type === types.name) {\r\n            node.name = this.value;\r\n          } else if (this.type.keyword) {\r\n            node.name = this.type.keyword;\r\n      \r\n            if ((node.name === \"class\" || node.name === \"function\") &&\r\n                (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\r\n              this.context.pop();\r\n            }\r\n          } else {\r\n            this.unexpected();\r\n          }\r\n          this.next(!!liberal);\r\n          this.finishNode(node, \"Identifier\");\r\n          if (!liberal) {\r\n            this.checkUnreserved(node);\r\n            if (node.name === \"await\" && !this.awaitIdentPos)\r\n              { this.awaitIdentPos = node.start; }\r\n          }\r\n          return node\r\n        };\r\n      \r\n      \r\n        pp$3.parseYield = function(noIn) {\r\n          if (!this.yieldPos) { this.yieldPos = this.start; }\r\n      \r\n          var node = this.startNode();\r\n          this.next();\r\n          if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\r\n            node.delegate = false;\r\n            node.argument = null;\r\n          } else {\r\n            node.delegate = this.eat(types.star);\r\n            node.argument = this.parseMaybeAssign(noIn);\r\n          }\r\n          return this.finishNode(node, \"YieldExpression\")\r\n        };\r\n      \r\n        pp$3.parseAwait = function() {\r\n          if (!this.awaitPos) { this.awaitPos = this.start; }\r\n      \r\n          var node = this.startNode();\r\n          this.next();\r\n          node.argument = this.parseMaybeUnary(null, false);\r\n          return this.finishNode(node, \"AwaitExpression\")\r\n        };\r\n      \r\n        var pp$4 = Parser.prototype;\r\n      \r\n      \r\n        pp$4.raise = function(pos, message) {\r\n          var loc = getLineInfo(this.input, pos);\r\n          message += \" (\" + loc.line + \":\" + loc.column + \")\";\r\n          var err = new SyntaxError(message);\r\n          err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\r\n          throw err\r\n        };\r\n      \r\n        pp$4.raiseRecoverable = pp$4.raise;\r\n      \r\n        pp$4.curPosition = function() {\r\n          if (this.options.locations) {\r\n            return new Position(this.curLine, this.pos - this.lineStart)\r\n          }\r\n        };\r\n      \r\n        var pp$5 = Parser.prototype;\r\n      \r\n        var Scope = function Scope(flags) {\r\n          this.flags = flags;\r\n          this.var = [];\r\n          this.lexical = [];\r\n          this.functions = [];\r\n        };\r\n      \r\n      \r\n        pp$5.enterScope = function(flags) {\r\n          this.scopeStack.push(new Scope(flags));\r\n        };\r\n      \r\n        pp$5.exitScope = function() {\r\n          this.scopeStack.pop();\r\n        };\r\n      \r\n        pp$5.treatFunctionsAsVarInScope = function(scope) {\r\n          return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\r\n        };\r\n      \r\n        pp$5.declareName = function(name, bindingType, pos) {\r\n          var redeclared = false;\r\n          if (bindingType === BIND_LEXICAL) {\r\n            var scope = this.currentScope();\r\n            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\r\n            scope.lexical.push(name);\r\n            if (this.inModule && (scope.flags & SCOPE_TOP))\r\n              { delete this.undefinedExports[name]; }\r\n          } else if (bindingType === BIND_SIMPLE_CATCH) {\r\n            var scope$1 = this.currentScope();\r\n            scope$1.lexical.push(name);\r\n          } else if (bindingType === BIND_FUNCTION) {\r\n            var scope$2 = this.currentScope();\r\n            if (this.treatFunctionsAsVar)\r\n              { redeclared = scope$2.lexical.indexOf(name) > -1; }\r\n            else\r\n              { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\r\n            scope$2.functions.push(name);\r\n          } else {\r\n            for (var i = this.scopeStack.length - 1; i >= 0; --i) {\r\n              var scope$3 = this.scopeStack[i];\r\n              if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\r\n                  !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\r\n                redeclared = true;\r\n                break\r\n              }\r\n              scope$3.var.push(name);\r\n              if (this.inModule && (scope$3.flags & SCOPE_TOP))\r\n                { delete this.undefinedExports[name]; }\r\n              if (scope$3.flags & SCOPE_VAR) { break }\r\n            }\r\n          }\r\n          if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\r\n        };\r\n      \r\n        pp$5.checkLocalExport = function(id) {\r\n          if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\r\n              this.scopeStack[0].var.indexOf(id.name) === -1) {\r\n            this.undefinedExports[id.name] = id;\r\n          }\r\n        };\r\n      \r\n        pp$5.currentScope = function() {\r\n          return this.scopeStack[this.scopeStack.length - 1]\r\n        };\r\n      \r\n        pp$5.currentVarScope = function() {\r\n          for (var i = this.scopeStack.length - 1;; i--) {\r\n            var scope = this.scopeStack[i];\r\n            if (scope.flags & SCOPE_VAR) { return scope }\r\n          }\r\n        };\r\n      \r\n        pp$5.currentThisScope = function() {\r\n          for (var i = this.scopeStack.length - 1;; i--) {\r\n            var scope = this.scopeStack[i];\r\n            if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\r\n          }\r\n        };\r\n      \r\n        var Node = function Node(parser, pos, loc) {\r\n          this.type = \"\";\r\n          this.start = pos;\r\n          this.end = 0;\r\n          if (parser.options.locations)\r\n            { this.loc = new SourceLocation(parser, loc); }\r\n          if (parser.options.directSourceFile)\r\n            { this.sourceFile = parser.options.directSourceFile; }\r\n          if (parser.options.ranges)\r\n            { this.range = [pos, 0]; }\r\n        };\r\n      \r\n      \r\n        var pp$6 = Parser.prototype;\r\n      \r\n        pp$6.startNode = function() {\r\n          return new Node(this, this.start, this.startLoc)\r\n        };\r\n      \r\n        pp$6.startNodeAt = function(pos, loc) {\r\n          return new Node(this, pos, loc)\r\n        };\r\n      \r\n      \r\n        function finishNodeAt(node, type, pos, loc) {\r\n          node.type = type;\r\n          node.end = pos;\r\n          if (this.options.locations)\r\n            { node.loc.end = loc; }\r\n          if (this.options.ranges)\r\n            { node.range[1] = pos; }\r\n          return node\r\n        }\r\n      \r\n        pp$6.finishNode = function(node, type) {\r\n          return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\r\n        };\r\n      \r\n      \r\n        pp$6.finishNodeAt = function(node, type, pos, loc) {\r\n          return finishNodeAt.call(this, node, type, pos, loc)\r\n        };\r\n      \r\n      \r\n        var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\r\n          this.token = token;\r\n          this.isExpr = !!isExpr;\r\n          this.preserveSpace = !!preserveSpace;\r\n          this.override = override;\r\n          this.generator = !!generator;\r\n        };\r\n      \r\n        var types$1 = {\r\n          b_stat: new TokContext(\"{\", false),\r\n          b_expr: new TokContext(\"{\", true),\r\n          b_tmpl: new TokContext(\"${\", false),\r\n          p_stat: new TokContext(\"(\", false),\r\n          p_expr: new TokContext(\"(\", true),\r\n          q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\r\n          f_stat: new TokContext(\"function\", false),\r\n          f_expr: new TokContext(\"function\", true),\r\n          f_expr_gen: new TokContext(\"function\", true, false, null, true),\r\n          f_gen: new TokContext(\"function\", false, false, null, true)\r\n        };\r\n      \r\n        var pp$7 = Parser.prototype;\r\n      \r\n        pp$7.initialContext = function() {\r\n          return [types$1.b_stat]\r\n        };\r\n      \r\n        pp$7.braceIsBlock = function(prevType) {\r\n          var parent = this.curContext();\r\n          if (parent === types$1.f_expr || parent === types$1.f_stat)\r\n            { return true }\r\n          if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\r\n            { return !parent.isExpr }\r\n      \r\n          if (prevType === types._return || prevType === types.name && this.exprAllowed)\r\n            { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\r\n          if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\r\n            { return true }\r\n          if (prevType === types.braceL)\r\n            { return parent === types$1.b_stat }\r\n          if (prevType === types._var || prevType === types._const || prevType === types.name)\r\n            { return false }\r\n          return !this.exprAllowed\r\n        };\r\n      \r\n        pp$7.inGeneratorContext = function() {\r\n          for (var i = this.context.length - 1; i >= 1; i--) {\r\n            var context = this.context[i];\r\n            if (context.token === \"function\")\r\n              { return context.generator }\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$7.updateContext = function(prevType) {\r\n          var update, type = this.type;\r\n          if (type.keyword && prevType === types.dot)\r\n            { this.exprAllowed = false; }\r\n          else if (update = type.updateContext)\r\n            { update.call(this, prevType); }\r\n          else\r\n            { this.exprAllowed = type.beforeExpr; }\r\n        };\r\n      \r\n      \r\n        types.parenR.updateContext = types.braceR.updateContext = function() {\r\n          if (this.context.length === 1) {\r\n            this.exprAllowed = true;\r\n            return\r\n          }\r\n          var out = this.context.pop();\r\n          if (out === types$1.b_stat && this.curContext().token === \"function\") {\r\n            out = this.context.pop();\r\n          }\r\n          this.exprAllowed = !out.isExpr;\r\n        };\r\n      \r\n        types.braceL.updateContext = function(prevType) {\r\n          this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\r\n          this.exprAllowed = true;\r\n        };\r\n      \r\n        types.dollarBraceL.updateContext = function() {\r\n          this.context.push(types$1.b_tmpl);\r\n          this.exprAllowed = true;\r\n        };\r\n      \r\n        types.parenL.updateContext = function(prevType) {\r\n          var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\r\n          this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\r\n          this.exprAllowed = true;\r\n        };\r\n      \r\n        types.incDec.updateContext = function() {\r\n        };\r\n      \r\n        types._function.updateContext = types._class.updateContext = function(prevType) {\r\n          if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\r\n              !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\r\n              !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\r\n            { this.context.push(types$1.f_expr); }\r\n          else\r\n            { this.context.push(types$1.f_stat); }\r\n          this.exprAllowed = false;\r\n        };\r\n      \r\n        types.backQuote.updateContext = function() {\r\n          if (this.curContext() === types$1.q_tmpl)\r\n            { this.context.pop(); }\r\n          else\r\n            { this.context.push(types$1.q_tmpl); }\r\n          this.exprAllowed = false;\r\n        };\r\n      \r\n        types.star.updateContext = function(prevType) {\r\n          if (prevType === types._function) {\r\n            var index = this.context.length - 1;\r\n            if (this.context[index] === types$1.f_expr)\r\n              { this.context[index] = types$1.f_expr_gen; }\r\n            else\r\n              { this.context[index] = types$1.f_gen; }\r\n          }\r\n          this.exprAllowed = true;\r\n        };\r\n      \r\n        types.name.updateContext = function(prevType) {\r\n          var allowed = false;\r\n          if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\r\n            if (this.value === \"of\" && !this.exprAllowed ||\r\n                this.value === \"yield\" && this.inGeneratorContext())\r\n              { allowed = true; }\r\n          }\r\n          this.exprAllowed = allowed;\r\n        };\r\n      \r\n      \r\n        var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\r\n        var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\r\n        var ecma11BinaryProperties = ecma10BinaryProperties;\r\n        var unicodeBinaryProperties = {\r\n          9: ecma9BinaryProperties,\r\n          10: ecma10BinaryProperties,\r\n          11: ecma11BinaryProperties\r\n        };\r\n      \r\n        var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\r\n      \r\n        var ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\r\n        var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\r\n        var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\r\n        var unicodeScriptValues = {\r\n          9: ecma9ScriptValues,\r\n          10: ecma10ScriptValues,\r\n          11: ecma11ScriptValues\r\n        };\r\n      \r\n        var data = {};\r\n        function buildUnicodeData(ecmaVersion) {\r\n          var d = data[ecmaVersion] = {\r\n            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\r\n            nonBinary: {\r\n              General_Category: wordsRegexp(unicodeGeneralCategoryValues),\r\n              Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\r\n            }\r\n          };\r\n          d.nonBinary.Script_Extensions = d.nonBinary.Script;\r\n      \r\n          d.nonBinary.gc = d.nonBinary.General_Category;\r\n          d.nonBinary.sc = d.nonBinary.Script;\r\n          d.nonBinary.scx = d.nonBinary.Script_Extensions;\r\n        }\r\n        buildUnicodeData(9);\r\n        buildUnicodeData(10);\r\n        buildUnicodeData(11);\r\n      \r\n        var pp$8 = Parser.prototype;\r\n      \r\n        var RegExpValidationState = function RegExpValidationState(parser) {\r\n          this.parser = parser;\r\n          this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\r\n          this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\r\n          this.source = \"\";\r\n          this.flags = \"\";\r\n          this.start = 0;\r\n          this.switchU = false;\r\n          this.switchN = false;\r\n          this.pos = 0;\r\n          this.lastIntValue = 0;\r\n          this.lastStringValue = \"\";\r\n          this.lastAssertionIsQuantifiable = false;\r\n          this.numCapturingParens = 0;\r\n          this.maxBackReference = 0;\r\n          this.groupNames = [];\r\n          this.backReferenceNames = [];\r\n        };\r\n      \r\n        RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\r\n          var unicode = flags.indexOf(\"u\") !== -1;\r\n          this.start = start | 0;\r\n          this.source = pattern + \"\";\r\n          this.flags = flags;\r\n          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\r\n          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\r\n        };\r\n      \r\n        RegExpValidationState.prototype.raise = function raise (message) {\r\n          this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\r\n        };\r\n      \r\n        RegExpValidationState.prototype.at = function at (i) {\r\n          var s = this.source;\r\n          var l = s.length;\r\n          if (i >= l) {\r\n            return -1\r\n          }\r\n          var c = s.charCodeAt(i);\r\n          if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\r\n            return c\r\n          }\r\n          var next = s.charCodeAt(i + 1);\r\n          return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\r\n        };\r\n      \r\n        RegExpValidationState.prototype.nextIndex = function nextIndex (i) {\r\n          var s = this.source;\r\n          var l = s.length;\r\n          if (i >= l) {\r\n            return l\r\n          }\r\n          var c = s.charCodeAt(i), next;\r\n          if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\r\n              (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\r\n            return i + 1\r\n          }\r\n          return i + 2\r\n        };\r\n      \r\n        RegExpValidationState.prototype.current = function current () {\r\n          return this.at(this.pos)\r\n        };\r\n      \r\n        RegExpValidationState.prototype.lookahead = function lookahead () {\r\n          return this.at(this.nextIndex(this.pos))\r\n        };\r\n      \r\n        RegExpValidationState.prototype.advance = function advance () {\r\n          this.pos = this.nextIndex(this.pos);\r\n        };\r\n      \r\n        RegExpValidationState.prototype.eat = function eat (ch) {\r\n          if (this.current() === ch) {\r\n            this.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        function codePointToString(ch) {\r\n          if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\r\n          ch -= 0x10000;\r\n          return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\r\n        }\r\n      \r\n        pp$8.validateRegExpFlags = function(state) {\r\n          var validFlags = state.validFlags;\r\n          var flags = state.flags;\r\n      \r\n          for (var i = 0; i < flags.length; i++) {\r\n            var flag = flags.charAt(i);\r\n            if (validFlags.indexOf(flag) === -1) {\r\n              this.raise(state.start, \"Invalid regular expression flag\");\r\n            }\r\n            if (flags.indexOf(flag, i + 1) > -1) {\r\n              this.raise(state.start, \"Duplicate regular expression flag\");\r\n            }\r\n          }\r\n        };\r\n      \r\n        pp$8.validateRegExpPattern = function(state) {\r\n          this.regexp_pattern(state);\r\n      \r\n          if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\r\n            state.switchN = true;\r\n            this.regexp_pattern(state);\r\n          }\r\n        };\r\n      \r\n        pp$8.regexp_pattern = function(state) {\r\n          state.pos = 0;\r\n          state.lastIntValue = 0;\r\n          state.lastStringValue = \"\";\r\n          state.lastAssertionIsQuantifiable = false;\r\n          state.numCapturingParens = 0;\r\n          state.maxBackReference = 0;\r\n          state.groupNames.length = 0;\r\n          state.backReferenceNames.length = 0;\r\n      \r\n          this.regexp_disjunction(state);\r\n      \r\n          if (state.pos !== state.source.length) {\r\n            if (state.eat(0x29 )) {\r\n              state.raise(\"Unmatched ')'\");\r\n            }\r\n            if (state.eat(0x5D ) || state.eat(0x7D )) {\r\n              state.raise(\"Lone quantifier brackets\");\r\n            }\r\n          }\r\n          if (state.maxBackReference > state.numCapturingParens) {\r\n            state.raise(\"Invalid escape\");\r\n          }\r\n          for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\r\n            var name = list[i];\r\n      \r\n            if (state.groupNames.indexOf(name) === -1) {\r\n              state.raise(\"Invalid named capture referenced\");\r\n            }\r\n          }\r\n        };\r\n      \r\n        pp$8.regexp_disjunction = function(state) {\r\n          this.regexp_alternative(state);\r\n          while (state.eat(0x7C )) {\r\n            this.regexp_alternative(state);\r\n          }\r\n      \r\n          if (this.regexp_eatQuantifier(state, true)) {\r\n            state.raise(\"Nothing to repeat\");\r\n          }\r\n          if (state.eat(0x7B )) {\r\n            state.raise(\"Lone quantifier brackets\");\r\n          }\r\n        };\r\n      \r\n        pp$8.regexp_alternative = function(state) {\r\n          while (state.pos < state.source.length && this.regexp_eatTerm(state))\r\n            { }\r\n        };\r\n      \r\n        pp$8.regexp_eatTerm = function(state) {\r\n          if (this.regexp_eatAssertion(state)) {\r\n            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\r\n              if (state.switchU) {\r\n                state.raise(\"Invalid quantifier\");\r\n              }\r\n            }\r\n            return true\r\n          }\r\n      \r\n          if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\r\n            this.regexp_eatQuantifier(state);\r\n            return true\r\n          }\r\n      \r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatAssertion = function(state) {\r\n          var start = state.pos;\r\n          state.lastAssertionIsQuantifiable = false;\r\n      \r\n          if (state.eat(0x5E ) || state.eat(0x24 )) {\r\n            return true\r\n          }\r\n      \r\n          if (state.eat(0x5C )) {\r\n            if (state.eat(0x42 ) || state.eat(0x62 )) {\r\n              return true\r\n            }\r\n            state.pos = start;\r\n          }\r\n      \r\n          if (state.eat(0x28 ) && state.eat(0x3F )) {\r\n            var lookbehind = false;\r\n            if (this.options.ecmaVersion >= 9) {\r\n              lookbehind = state.eat(0x3C );\r\n            }\r\n            if (state.eat(0x3D ) || state.eat(0x21 )) {\r\n              this.regexp_disjunction(state);\r\n              if (!state.eat(0x29 )) {\r\n                state.raise(\"Unterminated group\");\r\n              }\r\n              state.lastAssertionIsQuantifiable = !lookbehind;\r\n              return true\r\n            }\r\n          }\r\n      \r\n          state.pos = start;\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatQuantifier = function(state, noError) {\r\n          if ( noError === void 0 ) noError = false;\r\n      \r\n          if (this.regexp_eatQuantifierPrefix(state, noError)) {\r\n            state.eat(0x3F );\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatQuantifierPrefix = function(state, noError) {\r\n          return (\r\n            state.eat(0x2A ) ||\r\n            state.eat(0x2B ) ||\r\n            state.eat(0x3F ) ||\r\n            this.regexp_eatBracedQuantifier(state, noError)\r\n          )\r\n        };\r\n        pp$8.regexp_eatBracedQuantifier = function(state, noError) {\r\n          var start = state.pos;\r\n          if (state.eat(0x7B )) {\r\n            var min = 0, max = -1;\r\n            if (this.regexp_eatDecimalDigits(state)) {\r\n              min = state.lastIntValue;\r\n              if (state.eat(0x2C ) && this.regexp_eatDecimalDigits(state)) {\r\n                max = state.lastIntValue;\r\n              }\r\n              if (state.eat(0x7D )) {\r\n                if (max !== -1 && max < min && !noError) {\r\n                  state.raise(\"numbers out of order in {} quantifier\");\r\n                }\r\n                return true\r\n              }\r\n            }\r\n            if (state.switchU && !noError) {\r\n              state.raise(\"Incomplete quantifier\");\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatAtom = function(state) {\r\n          return (\r\n            this.regexp_eatPatternCharacters(state) ||\r\n            state.eat(0x2E ) ||\r\n            this.regexp_eatReverseSolidusAtomEscape(state) ||\r\n            this.regexp_eatCharacterClass(state) ||\r\n            this.regexp_eatUncapturingGroup(state) ||\r\n            this.regexp_eatCapturingGroup(state)\r\n          )\r\n        };\r\n        pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\r\n          var start = state.pos;\r\n          if (state.eat(0x5C )) {\r\n            if (this.regexp_eatAtomEscape(state)) {\r\n              return true\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_eatUncapturingGroup = function(state) {\r\n          var start = state.pos;\r\n          if (state.eat(0x28 )) {\r\n            if (state.eat(0x3F ) && state.eat(0x3A )) {\r\n              this.regexp_disjunction(state);\r\n              if (state.eat(0x29 )) {\r\n                return true\r\n              }\r\n              state.raise(\"Unterminated group\");\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_eatCapturingGroup = function(state) {\r\n          if (state.eat(0x28 )) {\r\n            if (this.options.ecmaVersion >= 9) {\r\n              this.regexp_groupSpecifier(state);\r\n            } else if (state.current() === 0x3F ) {\r\n              state.raise(\"Invalid group\");\r\n            }\r\n            this.regexp_disjunction(state);\r\n            if (state.eat(0x29 )) {\r\n              state.numCapturingParens += 1;\r\n              return true\r\n            }\r\n            state.raise(\"Unterminated group\");\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatExtendedAtom = function(state) {\r\n          return (\r\n            state.eat(0x2E ) ||\r\n            this.regexp_eatReverseSolidusAtomEscape(state) ||\r\n            this.regexp_eatCharacterClass(state) ||\r\n            this.regexp_eatUncapturingGroup(state) ||\r\n            this.regexp_eatCapturingGroup(state) ||\r\n            this.regexp_eatInvalidBracedQuantifier(state) ||\r\n            this.regexp_eatExtendedPatternCharacter(state)\r\n          )\r\n        };\r\n      \r\n        pp$8.regexp_eatInvalidBracedQuantifier = function(state) {\r\n          if (this.regexp_eatBracedQuantifier(state, true)) {\r\n            state.raise(\"Nothing to repeat\");\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatSyntaxCharacter = function(state) {\r\n          var ch = state.current();\r\n          if (isSyntaxCharacter(ch)) {\r\n            state.lastIntValue = ch;\r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n        function isSyntaxCharacter(ch) {\r\n          return (\r\n            ch === 0x24  ||\r\n            ch >= 0x28  && ch <= 0x2B  ||\r\n            ch === 0x2E  ||\r\n            ch === 0x3F  ||\r\n            ch >= 0x5B  && ch <= 0x5E  ||\r\n            ch >= 0x7B  && ch <= 0x7D \r\n          )\r\n        }\r\n      \r\n        pp$8.regexp_eatPatternCharacters = function(state) {\r\n          var start = state.pos;\r\n          var ch = 0;\r\n          while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\r\n            state.advance();\r\n          }\r\n          return state.pos !== start\r\n        };\r\n      \r\n        pp$8.regexp_eatExtendedPatternCharacter = function(state) {\r\n          var ch = state.current();\r\n          if (\r\n            ch !== -1 &&\r\n            ch !== 0x24  &&\r\n            !(ch >= 0x28  && ch <= 0x2B ) &&\r\n            ch !== 0x2E  &&\r\n            ch !== 0x3F  &&\r\n            ch !== 0x5B  &&\r\n            ch !== 0x5E  &&\r\n            ch !== 0x7C \r\n          ) {\r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_groupSpecifier = function(state) {\r\n          if (state.eat(0x3F )) {\r\n            if (this.regexp_eatGroupName(state)) {\r\n              if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\r\n                state.raise(\"Duplicate capture group name\");\r\n              }\r\n              state.groupNames.push(state.lastStringValue);\r\n              return\r\n            }\r\n            state.raise(\"Invalid group\");\r\n          }\r\n        };\r\n      \r\n        pp$8.regexp_eatGroupName = function(state) {\r\n          state.lastStringValue = \"\";\r\n          if (state.eat(0x3C )) {\r\n            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E )) {\r\n              return true\r\n            }\r\n            state.raise(\"Invalid capture group name\");\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatRegExpIdentifierName = function(state) {\r\n          state.lastStringValue = \"\";\r\n          if (this.regexp_eatRegExpIdentifierStart(state)) {\r\n            state.lastStringValue += codePointToString(state.lastIntValue);\r\n            while (this.regexp_eatRegExpIdentifierPart(state)) {\r\n              state.lastStringValue += codePointToString(state.lastIntValue);\r\n            }\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatRegExpIdentifierStart = function(state) {\r\n          var start = state.pos;\r\n          var ch = state.current();\r\n          state.advance();\r\n      \r\n          if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\r\n            ch = state.lastIntValue;\r\n          }\r\n          if (isRegExpIdentifierStart(ch)) {\r\n            state.lastIntValue = ch;\r\n            return true\r\n          }\r\n      \r\n          state.pos = start;\r\n          return false\r\n        };\r\n        function isRegExpIdentifierStart(ch) {\r\n          return isIdentifierStart(ch, true) || ch === 0x24  || ch === 0x5F \r\n        }\r\n      \r\n        pp$8.regexp_eatRegExpIdentifierPart = function(state) {\r\n          var start = state.pos;\r\n          var ch = state.current();\r\n          state.advance();\r\n      \r\n          if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\r\n            ch = state.lastIntValue;\r\n          }\r\n          if (isRegExpIdentifierPart(ch)) {\r\n            state.lastIntValue = ch;\r\n            return true\r\n          }\r\n      \r\n          state.pos = start;\r\n          return false\r\n        };\r\n        function isRegExpIdentifierPart(ch) {\r\n          return isIdentifierChar(ch, true) || ch === 0x24  || ch === 0x5F  || ch === 0x200C  || ch === 0x200D \r\n        }\r\n      \r\n        pp$8.regexp_eatAtomEscape = function(state) {\r\n          if (\r\n            this.regexp_eatBackReference(state) ||\r\n            this.regexp_eatCharacterClassEscape(state) ||\r\n            this.regexp_eatCharacterEscape(state) ||\r\n            (state.switchN && this.regexp_eatKGroupName(state))\r\n          ) {\r\n            return true\r\n          }\r\n          if (state.switchU) {\r\n            if (state.current() === 0x63 ) {\r\n              state.raise(\"Invalid unicode escape\");\r\n            }\r\n            state.raise(\"Invalid escape\");\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_eatBackReference = function(state) {\r\n          var start = state.pos;\r\n          if (this.regexp_eatDecimalEscape(state)) {\r\n            var n = state.lastIntValue;\r\n            if (state.switchU) {\r\n              if (n > state.maxBackReference) {\r\n                state.maxBackReference = n;\r\n              }\r\n              return true\r\n            }\r\n            if (n <= state.numCapturingParens) {\r\n              return true\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_eatKGroupName = function(state) {\r\n          if (state.eat(0x6B )) {\r\n            if (this.regexp_eatGroupName(state)) {\r\n              state.backReferenceNames.push(state.lastStringValue);\r\n              return true\r\n            }\r\n            state.raise(\"Invalid named reference\");\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatCharacterEscape = function(state) {\r\n          return (\r\n            this.regexp_eatControlEscape(state) ||\r\n            this.regexp_eatCControlLetter(state) ||\r\n            this.regexp_eatZero(state) ||\r\n            this.regexp_eatHexEscapeSequence(state) ||\r\n            this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\r\n            (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\r\n            this.regexp_eatIdentityEscape(state)\r\n          )\r\n        };\r\n        pp$8.regexp_eatCControlLetter = function(state) {\r\n          var start = state.pos;\r\n          if (state.eat(0x63 )) {\r\n            if (this.regexp_eatControlLetter(state)) {\r\n              return true\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_eatZero = function(state) {\r\n          if (state.current() === 0x30  && !isDecimalDigit(state.lookahead())) {\r\n            state.lastIntValue = 0;\r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatControlEscape = function(state) {\r\n          var ch = state.current();\r\n          if (ch === 0x74 ) {\r\n            state.lastIntValue = 0x09; \r\n            state.advance();\r\n            return true\r\n          }\r\n          if (ch === 0x6E ) {\r\n            state.lastIntValue = 0x0A; \r\n            state.advance();\r\n            return true\r\n          }\r\n          if (ch === 0x76 ) {\r\n            state.lastIntValue = 0x0B; \r\n            state.advance();\r\n            return true\r\n          }\r\n          if (ch === 0x66 ) {\r\n            state.lastIntValue = 0x0C; \r\n            state.advance();\r\n            return true\r\n          }\r\n          if (ch === 0x72 ) {\r\n            state.lastIntValue = 0x0D; \r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatControlLetter = function(state) {\r\n          var ch = state.current();\r\n          if (isControlLetter(ch)) {\r\n            state.lastIntValue = ch % 0x20;\r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n        function isControlLetter(ch) {\r\n          return (\r\n            (ch >= 0x41  && ch <= 0x5A ) ||\r\n            (ch >= 0x61  && ch <= 0x7A )\r\n          )\r\n        }\r\n      \r\n        pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\r\n          var start = state.pos;\r\n      \r\n          if (state.eat(0x75 )) {\r\n            if (this.regexp_eatFixedHexDigits(state, 4)) {\r\n              var lead = state.lastIntValue;\r\n              if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\r\n                var leadSurrogateEnd = state.pos;\r\n                if (state.eat(0x5C ) && state.eat(0x75 ) && this.regexp_eatFixedHexDigits(state, 4)) {\r\n                  var trail = state.lastIntValue;\r\n                  if (trail >= 0xDC00 && trail <= 0xDFFF) {\r\n                    state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\r\n                    return true\r\n                  }\r\n                }\r\n                state.pos = leadSurrogateEnd;\r\n                state.lastIntValue = lead;\r\n              }\r\n              return true\r\n            }\r\n            if (\r\n              state.switchU &&\r\n              state.eat(0x7B ) &&\r\n              this.regexp_eatHexDigits(state) &&\r\n              state.eat(0x7D ) &&\r\n              isValidUnicode(state.lastIntValue)\r\n            ) {\r\n              return true\r\n            }\r\n            if (state.switchU) {\r\n              state.raise(\"Invalid unicode escape\");\r\n            }\r\n            state.pos = start;\r\n          }\r\n      \r\n          return false\r\n        };\r\n        function isValidUnicode(ch) {\r\n          return ch >= 0 && ch <= 0x10FFFF\r\n        }\r\n      \r\n        pp$8.regexp_eatIdentityEscape = function(state) {\r\n          if (state.switchU) {\r\n            if (this.regexp_eatSyntaxCharacter(state)) {\r\n              return true\r\n            }\r\n            if (state.eat(0x2F )) {\r\n              state.lastIntValue = 0x2F; \r\n              return true\r\n            }\r\n            return false\r\n          }\r\n      \r\n          var ch = state.current();\r\n          if (ch !== 0x63  && (!state.switchN || ch !== 0x6B )) {\r\n            state.lastIntValue = ch;\r\n            state.advance();\r\n            return true\r\n          }\r\n      \r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatDecimalEscape = function(state) {\r\n          state.lastIntValue = 0;\r\n          var ch = state.current();\r\n          if (ch >= 0x31  && ch <= 0x39 ) {\r\n            do {\r\n              state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );\r\n              state.advance();\r\n            } while ((ch = state.current()) >= 0x30  && ch <= 0x39 )\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatCharacterClassEscape = function(state) {\r\n          var ch = state.current();\r\n      \r\n          if (isCharacterClassEscape(ch)) {\r\n            state.lastIntValue = -1;\r\n            state.advance();\r\n            return true\r\n          }\r\n      \r\n          if (\r\n            state.switchU &&\r\n            this.options.ecmaVersion >= 9 &&\r\n            (ch === 0x50  || ch === 0x70 )\r\n          ) {\r\n            state.lastIntValue = -1;\r\n            state.advance();\r\n            if (\r\n              state.eat(0x7B ) &&\r\n              this.regexp_eatUnicodePropertyValueExpression(state) &&\r\n              state.eat(0x7D )\r\n            ) {\r\n              return true\r\n            }\r\n            state.raise(\"Invalid property name\");\r\n          }\r\n      \r\n          return false\r\n        };\r\n        function isCharacterClassEscape(ch) {\r\n          return (\r\n            ch === 0x64  ||\r\n            ch === 0x44  ||\r\n            ch === 0x73  ||\r\n            ch === 0x53  ||\r\n            ch === 0x77  ||\r\n            ch === 0x57 \r\n          )\r\n        }\r\n      \r\n        pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\r\n          var start = state.pos;\r\n      \r\n          if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D )) {\r\n            var name = state.lastStringValue;\r\n            if (this.regexp_eatUnicodePropertyValue(state)) {\r\n              var value = state.lastStringValue;\r\n              this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\r\n              return true\r\n            }\r\n          }\r\n          state.pos = start;\r\n      \r\n          if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\r\n            var nameOrValue = state.lastStringValue;\r\n            this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n        pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\r\n          if (!has(state.unicodeProperties.nonBinary, name))\r\n            { state.raise(\"Invalid property name\"); }\r\n          if (!state.unicodeProperties.nonBinary[name].test(value))\r\n            { state.raise(\"Invalid property value\"); }\r\n        };\r\n        pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\r\n          if (!state.unicodeProperties.binary.test(nameOrValue))\r\n            { state.raise(\"Invalid property name\"); }\r\n        };\r\n      \r\n        pp$8.regexp_eatUnicodePropertyName = function(state) {\r\n          var ch = 0;\r\n          state.lastStringValue = \"\";\r\n          while (isUnicodePropertyNameCharacter(ch = state.current())) {\r\n            state.lastStringValue += codePointToString(ch);\r\n            state.advance();\r\n          }\r\n          return state.lastStringValue !== \"\"\r\n        };\r\n        function isUnicodePropertyNameCharacter(ch) {\r\n          return isControlLetter(ch) || ch === 0x5F \r\n        }\r\n      \r\n        pp$8.regexp_eatUnicodePropertyValue = function(state) {\r\n          var ch = 0;\r\n          state.lastStringValue = \"\";\r\n          while (isUnicodePropertyValueCharacter(ch = state.current())) {\r\n            state.lastStringValue += codePointToString(ch);\r\n            state.advance();\r\n          }\r\n          return state.lastStringValue !== \"\"\r\n        };\r\n        function isUnicodePropertyValueCharacter(ch) {\r\n          return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\r\n        }\r\n      \r\n        pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\r\n          return this.regexp_eatUnicodePropertyValue(state)\r\n        };\r\n      \r\n        pp$8.regexp_eatCharacterClass = function(state) {\r\n          if (state.eat(0x5B )) {\r\n            state.eat(0x5E );\r\n            this.regexp_classRanges(state);\r\n            if (state.eat(0x5D )) {\r\n              return true\r\n            }\r\n            state.raise(\"Unterminated character class\");\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_classRanges = function(state) {\r\n          while (this.regexp_eatClassAtom(state)) {\r\n            var left = state.lastIntValue;\r\n            if (state.eat(0x2D ) && this.regexp_eatClassAtom(state)) {\r\n              var right = state.lastIntValue;\r\n              if (state.switchU && (left === -1 || right === -1)) {\r\n                state.raise(\"Invalid character class\");\r\n              }\r\n              if (left !== -1 && right !== -1 && left > right) {\r\n                state.raise(\"Range out of order in character class\");\r\n              }\r\n            }\r\n          }\r\n        };\r\n      \r\n        pp$8.regexp_eatClassAtom = function(state) {\r\n          var start = state.pos;\r\n      \r\n          if (state.eat(0x5C )) {\r\n            if (this.regexp_eatClassEscape(state)) {\r\n              return true\r\n            }\r\n            if (state.switchU) {\r\n              var ch$1 = state.current();\r\n              if (ch$1 === 0x63  || isOctalDigit(ch$1)) {\r\n                state.raise(\"Invalid class escape\");\r\n              }\r\n              state.raise(\"Invalid escape\");\r\n            }\r\n            state.pos = start;\r\n          }\r\n      \r\n          var ch = state.current();\r\n          if (ch !== 0x5D ) {\r\n            state.lastIntValue = ch;\r\n            state.advance();\r\n            return true\r\n          }\r\n      \r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatClassEscape = function(state) {\r\n          var start = state.pos;\r\n      \r\n          if (state.eat(0x62 )) {\r\n            state.lastIntValue = 0x08; \r\n            return true\r\n          }\r\n      \r\n          if (state.switchU && state.eat(0x2D )) {\r\n            state.lastIntValue = 0x2D; \r\n            return true\r\n          }\r\n      \r\n          if (!state.switchU && state.eat(0x63 )) {\r\n            if (this.regexp_eatClassControlLetter(state)) {\r\n              return true\r\n            }\r\n            state.pos = start;\r\n          }\r\n      \r\n          return (\r\n            this.regexp_eatCharacterClassEscape(state) ||\r\n            this.regexp_eatCharacterEscape(state)\r\n          )\r\n        };\r\n      \r\n        pp$8.regexp_eatClassControlLetter = function(state) {\r\n          var ch = state.current();\r\n          if (isDecimalDigit(ch) || ch === 0x5F ) {\r\n            state.lastIntValue = ch % 0x20;\r\n            state.advance();\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatHexEscapeSequence = function(state) {\r\n          var start = state.pos;\r\n          if (state.eat(0x78 )) {\r\n            if (this.regexp_eatFixedHexDigits(state, 2)) {\r\n              return true\r\n            }\r\n            if (state.switchU) {\r\n              state.raise(\"Invalid escape\");\r\n            }\r\n            state.pos = start;\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatDecimalDigits = function(state) {\r\n          var start = state.pos;\r\n          var ch = 0;\r\n          state.lastIntValue = 0;\r\n          while (isDecimalDigit(ch = state.current())) {\r\n            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );\r\n            state.advance();\r\n          }\r\n          return state.pos !== start\r\n        };\r\n        function isDecimalDigit(ch) {\r\n          return ch >= 0x30  && ch <= 0x39 \r\n        }\r\n      \r\n        pp$8.regexp_eatHexDigits = function(state) {\r\n          var start = state.pos;\r\n          var ch = 0;\r\n          state.lastIntValue = 0;\r\n          while (isHexDigit(ch = state.current())) {\r\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\r\n            state.advance();\r\n          }\r\n          return state.pos !== start\r\n        };\r\n        function isHexDigit(ch) {\r\n          return (\r\n            (ch >= 0x30  && ch <= 0x39 ) ||\r\n            (ch >= 0x41  && ch <= 0x46 ) ||\r\n            (ch >= 0x61  && ch <= 0x66 )\r\n          )\r\n        }\r\n        function hexToInt(ch) {\r\n          if (ch >= 0x41  && ch <= 0x46 ) {\r\n            return 10 + (ch - 0x41 )\r\n          }\r\n          if (ch >= 0x61  && ch <= 0x66 ) {\r\n            return 10 + (ch - 0x61 )\r\n          }\r\n          return ch - 0x30 \r\n        }\r\n      \r\n        pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\r\n          if (this.regexp_eatOctalDigit(state)) {\r\n            var n1 = state.lastIntValue;\r\n            if (this.regexp_eatOctalDigit(state)) {\r\n              var n2 = state.lastIntValue;\r\n              if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\r\n                state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\r\n              } else {\r\n                state.lastIntValue = n1 * 8 + n2;\r\n              }\r\n            } else {\r\n              state.lastIntValue = n1;\r\n            }\r\n            return true\r\n          }\r\n          return false\r\n        };\r\n      \r\n        pp$8.regexp_eatOctalDigit = function(state) {\r\n          var ch = state.current();\r\n          if (isOctalDigit(ch)) {\r\n            state.lastIntValue = ch - 0x30; \r\n            state.advance();\r\n            return true\r\n          }\r\n          state.lastIntValue = 0;\r\n          return false\r\n        };\r\n        function isOctalDigit(ch) {\r\n          return ch >= 0x30  && ch <= 0x37 \r\n        }\r\n      \r\n        pp$8.regexp_eatFixedHexDigits = function(state, length) {\r\n          var start = state.pos;\r\n          state.lastIntValue = 0;\r\n          for (var i = 0; i < length; ++i) {\r\n            var ch = state.current();\r\n            if (!isHexDigit(ch)) {\r\n              state.pos = start;\r\n              return false\r\n            }\r\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\r\n            state.advance();\r\n          }\r\n          return true\r\n        };\r\n      \r\n      \r\n        var Token = function Token(p) {\r\n          this.type = p.type;\r\n          this.value = p.value;\r\n          this.start = p.start;\r\n          this.end = p.end;\r\n          if (p.options.locations)\r\n            { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\r\n          if (p.options.ranges)\r\n            { this.range = [p.start, p.end]; }\r\n        };\r\n      \r\n      \r\n        var pp$9 = Parser.prototype;\r\n      \r\n      \r\n        pp$9.next = function(ignoreEscapeSequenceInKeyword) {\r\n          if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\r\n            { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + this.type.keyword); }\r\n          if (this.options.onToken)\r\n            { this.options.onToken(new Token(this)); }\r\n      \r\n          this.lastTokEnd = this.end;\r\n          this.lastTokStart = this.start;\r\n          this.lastTokEndLoc = this.endLoc;\r\n          this.lastTokStartLoc = this.startLoc;\r\n          this.nextToken();\r\n        };\r\n      \r\n        pp$9.getToken = function() {\r\n          this.next();\r\n          return new Token(this)\r\n        };\r\n      \r\n        if (typeof Symbol !== \"undefined\")\r\n          { pp$9[Symbol.iterator] = function() {\r\n            var this$1 = this;\r\n      \r\n            return {\r\n              next: function () {\r\n                var token = this$1.getToken();\r\n                return {\r\n                  done: token.type === types.eof,\r\n                  value: token\r\n                }\r\n              }\r\n            }\r\n          }; }\r\n      \r\n      \r\n        pp$9.curContext = function() {\r\n          return this.context[this.context.length - 1]\r\n        };\r\n      \r\n      \r\n        pp$9.nextToken = function() {\r\n          var curContext = this.curContext();\r\n          if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\r\n      \r\n          this.start = this.pos;\r\n          if (this.options.locations) { this.startLoc = this.curPosition(); }\r\n          if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\r\n      \r\n          if (curContext.override) { return curContext.override(this) }\r\n          else { this.readToken(this.fullCharCodeAtPos()); }\r\n        };\r\n      \r\n        pp$9.readToken = function(code) {\r\n          if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 )\r\n            { return this.readWord() }\r\n      \r\n          return this.getTokenFromCode(code)\r\n        };\r\n      \r\n        pp$9.fullCharCodeAtPos = function() {\r\n          var code = this.input.charCodeAt(this.pos);\r\n          if (code <= 0xd7ff || code >= 0xe000) { return code }\r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          return (code << 10) + next - 0x35fdc00\r\n        };\r\n      \r\n        pp$9.skipBlockComment = function() {\r\n          var startLoc = this.options.onComment && this.curPosition();\r\n          var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\r\n          if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\r\n          this.pos = end + 2;\r\n          if (this.options.locations) {\r\n            lineBreakG.lastIndex = start;\r\n            var match;\r\n            while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\r\n              ++this.curLine;\r\n              this.lineStart = match.index + match[0].length;\r\n            }\r\n          }\r\n          if (this.options.onComment)\r\n            { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\r\n                                   startLoc, this.curPosition()); }\r\n        };\r\n      \r\n        pp$9.skipLineComment = function(startSkip) {\r\n          var start = this.pos;\r\n          var startLoc = this.options.onComment && this.curPosition();\r\n          var ch = this.input.charCodeAt(this.pos += startSkip);\r\n          while (this.pos < this.input.length && !isNewLine(ch)) {\r\n            ch = this.input.charCodeAt(++this.pos);\r\n          }\r\n          if (this.options.onComment)\r\n            { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\r\n                                   startLoc, this.curPosition()); }\r\n        };\r\n      \r\n      \r\n        pp$9.skipSpace = function() {\r\n          loop: while (this.pos < this.input.length) {\r\n            var ch = this.input.charCodeAt(this.pos);\r\n            switch (ch) {\r\n            case 32: case 160: \r\n              ++this.pos;\r\n              break\r\n            case 13:\r\n              if (this.input.charCodeAt(this.pos + 1) === 10) {\r\n                ++this.pos;\r\n              }\r\n            case 10: case 8232: case 8233:\r\n              ++this.pos;\r\n              if (this.options.locations) {\r\n                ++this.curLine;\r\n                this.lineStart = this.pos;\r\n              }\r\n              break\r\n            case 47: \r\n              switch (this.input.charCodeAt(this.pos + 1)) {\r\n              case 42: \r\n                this.skipBlockComment();\r\n                break\r\n              case 47:\r\n                this.skipLineComment(2);\r\n                break\r\n              default:\r\n                break loop\r\n              }\r\n              break\r\n            default:\r\n              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\r\n                ++this.pos;\r\n              } else {\r\n                break loop\r\n              }\r\n            }\r\n          }\r\n        };\r\n      \r\n      \r\n        pp$9.finishToken = function(type, val) {\r\n          this.end = this.pos;\r\n          if (this.options.locations) { this.endLoc = this.curPosition(); }\r\n          var prevType = this.type;\r\n          this.type = type;\r\n          this.value = val;\r\n      \r\n          this.updateContext(prevType);\r\n        };\r\n      \r\n      \r\n        pp$9.readToken_dot = function() {\r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (next >= 48 && next <= 57) { return this.readNumber(true) }\r\n          var next2 = this.input.charCodeAt(this.pos + 2);\r\n          if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { \r\n            this.pos += 3;\r\n            return this.finishToken(types.ellipsis)\r\n          } else {\r\n            ++this.pos;\r\n            return this.finishToken(types.dot)\r\n          }\r\n        };\r\n      \r\n        pp$9.readToken_slash = function() { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\r\n          if (next === 61) { return this.finishOp(types.assign, 2) }\r\n          return this.finishOp(types.slash, 1)\r\n        };\r\n      \r\n        pp$9.readToken_mult_modulo_exp = function(code) { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          var size = 1;\r\n          var tokentype = code === 42 ? types.star : types.modulo;\r\n      \r\n          if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\r\n            ++size;\r\n            tokentype = types.starstar;\r\n            next = this.input.charCodeAt(this.pos + 2);\r\n          }\r\n      \r\n          if (next === 61) { return this.finishOp(types.assign, size + 1) }\r\n          return this.finishOp(tokentype, size)\r\n        };\r\n      \r\n        pp$9.readToken_pipe_amp = function(code) { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\r\n          if (next === 61) { return this.finishOp(types.assign, 2) }\r\n          return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\r\n        };\r\n      \r\n        pp$9.readToken_caret = function() { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (next === 61) { return this.finishOp(types.assign, 2) }\r\n          return this.finishOp(types.bitwiseXOR, 1)\r\n        };\r\n      \r\n        pp$9.readToken_plus_min = function(code) { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (next === code) {\r\n            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\r\n                (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\r\n              this.skipLineComment(3);\r\n              this.skipSpace();\r\n              return this.nextToken()\r\n            }\r\n            return this.finishOp(types.incDec, 2)\r\n          }\r\n          if (next === 61) { return this.finishOp(types.assign, 2) }\r\n          return this.finishOp(types.plusMin, 1)\r\n        };\r\n      \r\n        pp$9.readToken_lt_gt = function(code) { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          var size = 1;\r\n          if (next === code) {\r\n            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\r\n            if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\r\n            return this.finishOp(types.bitShift, size)\r\n          }\r\n          if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\r\n              this.input.charCodeAt(this.pos + 3) === 45) {\r\n            this.skipLineComment(4);\r\n            this.skipSpace();\r\n            return this.nextToken()\r\n          }\r\n          if (next === 61) { size = 2; }\r\n          return this.finishOp(types.relational, size)\r\n        };\r\n      \r\n        pp$9.readToken_eq_excl = function(code) { \r\n          var next = this.input.charCodeAt(this.pos + 1);\r\n          if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\r\n          if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { \r\n            this.pos += 2;\r\n            return this.finishToken(types.arrow)\r\n          }\r\n          return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\r\n        };\r\n      \r\n        pp$9.getTokenFromCode = function(code) {\r\n          switch (code) {\r\n          case 46: \r\n            return this.readToken_dot()\r\n      \r\n          case 40: ++this.pos; return this.finishToken(types.parenL)\r\n          case 41: ++this.pos; return this.finishToken(types.parenR)\r\n          case 59: ++this.pos; return this.finishToken(types.semi)\r\n          case 44: ++this.pos; return this.finishToken(types.comma)\r\n          case 91: ++this.pos; return this.finishToken(types.bracketL)\r\n          case 93: ++this.pos; return this.finishToken(types.bracketR)\r\n          case 123: ++this.pos; return this.finishToken(types.braceL)\r\n          case 125: ++this.pos; return this.finishToken(types.braceR)\r\n          case 58: ++this.pos; return this.finishToken(types.colon)\r\n          case 63: ++this.pos; return this.finishToken(types.question)\r\n      \r\n          case 96: \r\n            if (this.options.ecmaVersion < 6) { break }\r\n            ++this.pos;\r\n            return this.finishToken(types.backQuote)\r\n      \r\n          case 48: \r\n            var next = this.input.charCodeAt(this.pos + 1);\r\n            if (next === 120 || next === 88) { return this.readRadixNumber(16) } \r\n            if (this.options.ecmaVersion >= 6) {\r\n              if (next === 111 || next === 79) { return this.readRadixNumber(8) } \r\n              if (next === 98 || next === 66) { return this.readRadixNumber(2) } \r\n            }\r\n      \r\n          case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: \r\n            return this.readNumber(false)\r\n      \r\n          case 34: case 39: \r\n            return this.readString(code)\r\n      \r\n      \r\n          case 47: \r\n            return this.readToken_slash()\r\n      \r\n          case 37: case 42: \r\n            return this.readToken_mult_modulo_exp(code)\r\n      \r\n          case 124: case 38: \r\n            return this.readToken_pipe_amp(code)\r\n      \r\n          case 94: \r\n            return this.readToken_caret()\r\n      \r\n          case 43: case 45: \r\n            return this.readToken_plus_min(code)\r\n      \r\n          case 60: case 62: \r\n            return this.readToken_lt_gt(code)\r\n      \r\n          case 61: case 33: \r\n            return this.readToken_eq_excl(code)\r\n      \r\n          case 126: \r\n            return this.finishOp(types.prefix, 1)\r\n          }\r\n      \r\n          this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\r\n        };\r\n      \r\n        pp$9.finishOp = function(type, size) {\r\n          var str = this.input.slice(this.pos, this.pos + size);\r\n          this.pos += size;\r\n          return this.finishToken(type, str)\r\n        };\r\n      \r\n        pp$9.readRegexp = function() {\r\n          var escaped, inClass, start = this.pos;\r\n          for (;;) {\r\n            if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\r\n            var ch = this.input.charAt(this.pos);\r\n            if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\r\n            if (!escaped) {\r\n              if (ch === \"[\") { inClass = true; }\r\n              else if (ch === \"]\" && inClass) { inClass = false; }\r\n              else if (ch === \"/\" && !inClass) { break }\r\n              escaped = ch === \"\\\\\";\r\n            } else { escaped = false; }\r\n            ++this.pos;\r\n          }\r\n          var pattern = this.input.slice(start, this.pos);\r\n          ++this.pos;\r\n          var flagsStart = this.pos;\r\n          var flags = this.readWord1();\r\n          if (this.containsEsc) { this.unexpected(flagsStart); }\r\n      \r\n          var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\r\n          state.reset(start, pattern, flags);\r\n          this.validateRegExpFlags(state);\r\n          this.validateRegExpPattern(state);\r\n      \r\n          var value = null;\r\n          try {\r\n            value = new RegExp(pattern, flags);\r\n          } catch (e) {\r\n          }\r\n      \r\n          return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\r\n        };\r\n      \r\n      \r\n        pp$9.readInt = function(radix, len) {\r\n          var start = this.pos, total = 0;\r\n          for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\r\n            var code = this.input.charCodeAt(this.pos), val = (void 0);\r\n            if (code >= 97) { val = code - 97 + 10; } \r\n            else if (code >= 65) { val = code - 65 + 10; } \r\n            else if (code >= 48 && code <= 57) { val = code - 48; } \r\n            else { val = Infinity; }\r\n            if (val >= radix) { break }\r\n            ++this.pos;\r\n            total = total * radix + val;\r\n          }\r\n          if (this.pos === start || len != null && this.pos - start !== len) { return null }\r\n      \r\n          return total\r\n        };\r\n      \r\n        pp$9.readRadixNumber = function(radix) {\r\n          var start = this.pos;\r\n          this.pos += 2; \r\n          var val = this.readInt(radix);\r\n          if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\r\n          if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\r\n            val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\r\n            ++this.pos;\r\n          } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\r\n          return this.finishToken(types.num, val)\r\n        };\r\n      \r\n      \r\n        pp$9.readNumber = function(startsWithDot) {\r\n          var start = this.pos;\r\n          if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\r\n          var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\r\n          if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\r\n          var next = this.input.charCodeAt(this.pos);\r\n          if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\r\n            var str$1 = this.input.slice(start, this.pos);\r\n            var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\r\n            ++this.pos;\r\n            if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\r\n            return this.finishToken(types.num, val$1)\r\n          }\r\n          if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\r\n          if (next === 46 && !octal) { \r\n            ++this.pos;\r\n            this.readInt(10);\r\n            next = this.input.charCodeAt(this.pos);\r\n          }\r\n          if ((next === 69 || next === 101) && !octal) { \r\n            next = this.input.charCodeAt(++this.pos);\r\n            if (next === 43 || next === 45) { ++this.pos; } \r\n            if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\r\n          }\r\n          if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\r\n      \r\n          var str = this.input.slice(start, this.pos);\r\n          var val = octal ? parseInt(str, 8) : parseFloat(str);\r\n          return this.finishToken(types.num, val)\r\n        };\r\n      \r\n      \r\n        pp$9.readCodePoint = function() {\r\n          var ch = this.input.charCodeAt(this.pos), code;\r\n      \r\n          if (ch === 123) { \r\n            if (this.options.ecmaVersion < 6) { this.unexpected(); }\r\n            var codePos = ++this.pos;\r\n            code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\r\n            ++this.pos;\r\n            if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\r\n          } else {\r\n            code = this.readHexChar(4);\r\n          }\r\n          return code\r\n        };\r\n      \r\n        function codePointToString$1(code) {\r\n          if (code <= 0xFFFF) { return String.fromCharCode(code) }\r\n          code -= 0x10000;\r\n          return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\r\n        }\r\n      \r\n        pp$9.readString = function(quote) {\r\n          var out = \"\", chunkStart = ++this.pos;\r\n          for (;;) {\r\n            if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\r\n            var ch = this.input.charCodeAt(this.pos);\r\n            if (ch === quote) { break }\r\n            if (ch === 92) { \r\n              out += this.input.slice(chunkStart, this.pos);\r\n              out += this.readEscapedChar(false);\r\n              chunkStart = this.pos;\r\n            } else {\r\n              if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\r\n              ++this.pos;\r\n            }\r\n          }\r\n          out += this.input.slice(chunkStart, this.pos++);\r\n          return this.finishToken(types.string, out)\r\n        };\r\n      \r\n      \r\n        var INVALID_TEMPLATE_ESCAPE_ERROR = {};\r\n      \r\n        pp$9.tryReadTemplateToken = function() {\r\n          this.inTemplateElement = true;\r\n          try {\r\n            this.readTmplToken();\r\n          } catch (err) {\r\n            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\r\n              this.readInvalidTemplateToken();\r\n            } else {\r\n              throw err\r\n            }\r\n          }\r\n      \r\n          this.inTemplateElement = false;\r\n        };\r\n      \r\n        pp$9.invalidStringToken = function(position, message) {\r\n          if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\r\n            throw INVALID_TEMPLATE_ESCAPE_ERROR\r\n          } else {\r\n            this.raise(position, message);\r\n          }\r\n        };\r\n      \r\n        pp$9.readTmplToken = function() {\r\n          var out = \"\", chunkStart = this.pos;\r\n          for (;;) {\r\n            if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\r\n            var ch = this.input.charCodeAt(this.pos);\r\n            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { \r\n              if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\r\n                if (ch === 36) {\r\n                  this.pos += 2;\r\n                  return this.finishToken(types.dollarBraceL)\r\n                } else {\r\n                  ++this.pos;\r\n                  return this.finishToken(types.backQuote)\r\n                }\r\n              }\r\n              out += this.input.slice(chunkStart, this.pos);\r\n              return this.finishToken(types.template, out)\r\n            }\r\n            if (ch === 92) { \r\n              out += this.input.slice(chunkStart, this.pos);\r\n              out += this.readEscapedChar(true);\r\n              chunkStart = this.pos;\r\n            } else if (isNewLine(ch)) {\r\n              out += this.input.slice(chunkStart, this.pos);\r\n              ++this.pos;\r\n              switch (ch) {\r\n              case 13:\r\n                if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\r\n              case 10:\r\n                out += \"\\n\";\r\n                break\r\n              default:\r\n                out += String.fromCharCode(ch);\r\n                break\r\n              }\r\n              if (this.options.locations) {\r\n                ++this.curLine;\r\n                this.lineStart = this.pos;\r\n              }\r\n              chunkStart = this.pos;\r\n            } else {\r\n              ++this.pos;\r\n            }\r\n          }\r\n        };\r\n      \r\n        pp$9.readInvalidTemplateToken = function() {\r\n          for (; this.pos < this.input.length; this.pos++) {\r\n            switch (this.input[this.pos]) {\r\n            case \"\\\\\":\r\n              ++this.pos;\r\n              break\r\n      \r\n            case \"$\":\r\n              if (this.input[this.pos + 1] !== \"{\") {\r\n                break\r\n              }\r\n      \r\n            case \"`\":\r\n              return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\r\n      \r\n            }\r\n          }\r\n          this.raise(this.start, \"Unterminated template\");\r\n        };\r\n      \r\n      \r\n        pp$9.readEscapedChar = function(inTemplate) {\r\n          var ch = this.input.charCodeAt(++this.pos);\r\n          ++this.pos;\r\n          switch (ch) {\r\n          case 110: return \"\\n\" \r\n          case 114: return \"\\r\" \r\n          case 120: return String.fromCharCode(this.readHexChar(2)) \r\n          case 117: return codePointToString$1(this.readCodePoint()) \r\n          case 116: return \"\\t\" \r\n          case 98: return \"\\b\" \r\n          case 118: return \"\\u000b\" \r\n          case 102: return \"\\f\" \r\n          case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } \r\n          case 10: \r\n            if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\r\n            return \"\"\r\n          case 56:\r\n          case 57:\r\n            if (inTemplate) {\r\n              var codePos = this.pos - 1;\r\n      \r\n              this.invalidStringToken(\r\n                codePos,\r\n                \"Invalid escape sequence in template string\"\r\n              );\r\n      \r\n              return null\r\n            }\r\n          default:\r\n            if (ch >= 48 && ch <= 55) {\r\n              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\r\n              var octal = parseInt(octalStr, 8);\r\n              if (octal > 255) {\r\n                octalStr = octalStr.slice(0, -1);\r\n                octal = parseInt(octalStr, 8);\r\n              }\r\n              this.pos += octalStr.length - 1;\r\n              ch = this.input.charCodeAt(this.pos);\r\n              if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\r\n                this.invalidStringToken(\r\n                  this.pos - 1 - octalStr.length,\r\n                  inTemplate\r\n                    ? \"Octal literal in template string\"\r\n                    : \"Octal literal in strict mode\"\r\n                );\r\n              }\r\n              return String.fromCharCode(octal)\r\n            }\r\n            if (isNewLine(ch)) {\r\n              return \"\"\r\n            }\r\n            return String.fromCharCode(ch)\r\n          }\r\n        };\r\n      \r\n      \r\n        pp$9.readHexChar = function(len) {\r\n          var codePos = this.pos;\r\n          var n = this.readInt(16, len);\r\n          if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\r\n          return n\r\n        };\r\n      \r\n      \r\n        pp$9.readWord1 = function() {\r\n          this.containsEsc = false;\r\n          var word = \"\", first = true, chunkStart = this.pos;\r\n          var astral = this.options.ecmaVersion >= 6;\r\n          while (this.pos < this.input.length) {\r\n            var ch = this.fullCharCodeAtPos();\r\n            if (isIdentifierChar(ch, astral)) {\r\n              this.pos += ch <= 0xffff ? 1 : 2;\r\n            } else if (ch === 92) { \r\n              this.containsEsc = true;\r\n              word += this.input.slice(chunkStart, this.pos);\r\n              var escStart = this.pos;\r\n              if (this.input.charCodeAt(++this.pos) !== 117) \r\n                { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\r\n              ++this.pos;\r\n              var esc = this.readCodePoint();\r\n              if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\r\n                { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\r\n              word += codePointToString$1(esc);\r\n              chunkStart = this.pos;\r\n            } else {\r\n              break\r\n            }\r\n            first = false;\r\n          }\r\n          return word + this.input.slice(chunkStart, this.pos)\r\n        };\r\n      \r\n      \r\n        pp$9.readWord = function() {\r\n          var word = this.readWord1();\r\n          var type = types.name;\r\n          if (this.keywords.test(word)) {\r\n            type = keywords$1[word];\r\n          }\r\n          return this.finishToken(type, word)\r\n        };\r\n      \r\n      \r\n        var version = \"7.1.0\";\r\n      \r\n        Parser.acorn = {\r\n          Parser: Parser,\r\n          version: version,\r\n          defaultOptions: defaultOptions,\r\n          Position: Position,\r\n          SourceLocation: SourceLocation,\r\n          getLineInfo: getLineInfo,\r\n          Node: Node,\r\n          TokenType: TokenType,\r\n          tokTypes: types,\r\n          keywordTypes: keywords$1,\r\n          TokContext: TokContext,\r\n          tokContexts: types$1,\r\n          isIdentifierChar: isIdentifierChar,\r\n          isIdentifierStart: isIdentifierStart,\r\n          Token: Token,\r\n          isNewLine: isNewLine,\r\n          lineBreak: lineBreak,\r\n          lineBreakG: lineBreakG,\r\n          nonASCIIwhitespace: nonASCIIwhitespace\r\n        };\r\n      \r\n      \r\n        function parse(input, options) {\r\n          return Parser.parse(input, options)\r\n        }\r\n      \r\n      \r\n        function parseExpressionAt(input, pos, options) {\r\n          return Parser.parseExpressionAt(input, pos, options)\r\n        }\r\n      \r\n      \r\n        function tokenizer(input, options) {\r\n          return Parser.tokenizer(input, options)\r\n        }\r\n      \r\n        exports.Node = Node;\r\n        exports.Parser = Parser;\r\n        exports.Position = Position;\r\n        exports.SourceLocation = SourceLocation;\r\n        exports.TokContext = TokContext;\r\n        exports.Token = Token;\r\n        exports.TokenType = TokenType;\r\n        exports.defaultOptions = defaultOptions;\r\n        exports.getLineInfo = getLineInfo;\r\n        exports.isIdentifierChar = isIdentifierChar;\r\n        exports.isIdentifierStart = isIdentifierStart;\r\n        exports.isNewLine = isNewLine;\r\n        exports.keywordTypes = keywords$1;\r\n        exports.lineBreak = lineBreak;\r\n        exports.lineBreakG = lineBreakG;\r\n        exports.nonASCIIwhitespace = nonASCIIwhitespace;\r\n        exports.parse = parse;\r\n        exports.parseExpressionAt = parseExpressionAt;\r\n        exports.tokContexts = types$1;\r\n        exports.tokTypes = types;\r\n        exports.tokenizer = tokenizer;\r\n        exports.version = version;\r\n      \r\n        Object.defineProperty(exports, '__esModule', { value: true });\r\n      \r\n      }));\r\n      \r\n      },{}],2:[function(require,module,exports){\r\n      \r\n      },{}],3:[function(require,module,exports){\r\n      function glWiretap(gl, options = {}) {\r\n        const {\r\n          contextName = 'gl',\r\n          throwGetError,\r\n          useTrackablePrimitives,\r\n          readPixelsFile,\r\n          recording = [],\r\n          variables = {},\r\n          onReadPixels,\r\n          onUnrecognizedArgumentLookup,\r\n        } = options;\r\n        const proxy = new Proxy(gl, { get: listen });\r\n        const contextVariables = [];\r\n        const entityNames = {};\r\n        let imageCount = 0;\r\n        let indent = '';\r\n        let readPixelsVariableName;\r\n        return proxy;\r\n        function listen(obj, property) {\r\n          switch (property) {\r\n            case 'addComment': return addComment;\r\n            case 'checkThrowError': return checkThrowError;\r\n            case 'getReadPixelsVariableName': return readPixelsVariableName;\r\n            case 'insertVariable': return insertVariable;\r\n            case 'reset': return reset;\r\n            case 'setIndent': return setIndent;\r\n            case 'toString': return toString;\r\n            case 'getContextVariableName': return getContextVariableName;\r\n          }\r\n          if (typeof gl[property] === 'function') {\r\n            return function() { \r\n              switch (property) {\r\n                case 'getError':\r\n                  if (throwGetError) {\r\n                    recording.push(`${indent}if (${contextName}.getError() !== ${contextName}.NONE) throw new Error('error');`);\r\n                  } else {\r\n                    recording.push(`${indent}${contextName}.getError();`); \r\n                  }\r\n                  return gl.getError();\r\n                case 'getExtension': {\r\n                  const variableName = `${contextName}Variables${contextVariables.length}`;\r\n                  recording.push(`${indent}const ${variableName} = ${contextName}.getExtension('${arguments[0]}');`);\r\n                  const extension = gl.getExtension(arguments[0]);\r\n                  if (extension && typeof extension === 'object') {\r\n                    const tappedExtension = glExtensionWiretap(extension, {\r\n                      getEntity,\r\n                      useTrackablePrimitives,\r\n                      recording,\r\n                      contextName: variableName,\r\n                      contextVariables,\r\n                      variables,\r\n                      indent,\r\n                      onUnrecognizedArgumentLookup,\r\n                    });\r\n                    contextVariables.push(tappedExtension);\r\n                    return tappedExtension;\r\n                  } else {\r\n                    contextVariables.push(null);\r\n                  }\r\n                  return extension;\r\n                }\r\n                case 'readPixels':\r\n                  const i = contextVariables.indexOf(arguments[6]);\r\n                  let targetVariableName;\r\n                  if (i === -1) {\r\n                    const variableName = getVariableName(arguments[6]);\r\n                    if (variableName) {\r\n                      targetVariableName = variableName;\r\n                      recording.push(`${indent}${variableName}`);\r\n                    } else {\r\n                      targetVariableName = `${contextName}Variable${contextVariables.length}`;\r\n                      contextVariables.push(arguments[6]);\r\n                      recording.push(`${indent}const ${targetVariableName} = new ${arguments[6].constructor.name}(${arguments[6].length});`);\r\n                    }\r\n                  } else {\r\n                    targetVariableName = `${contextName}Variable${i}`;\r\n                  }\r\n                  readPixelsVariableName = targetVariableName;\r\n                  const argumentAsStrings = [\r\n                    arguments[0],\r\n                    arguments[1],\r\n                    arguments[2],\r\n                    arguments[3],\r\n                    getEntity(arguments[4]),\r\n                    getEntity(arguments[5]),\r\n                    targetVariableName\r\n                  ];\r\n                  recording.push(`${indent}${contextName}.readPixels(${argumentAsStrings.join(', ')});`);\r\n                  if (readPixelsFile) {\r\n                    writePPM(arguments[2], arguments[3]);\r\n                  }\r\n                  if (onReadPixels) {\r\n                    onReadPixels(targetVariableName, argumentAsStrings);\r\n                  }\r\n                  return gl.readPixels.apply(gl, arguments);\r\n                case 'drawBuffers':\r\n                  recording.push(`${indent}${contextName}.drawBuffers([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup } )}]);`);\r\n                  return gl.drawBuffers(arguments[0]);\r\n              }\r\n              let result = gl[property].apply(gl, arguments);\r\n              switch (typeof result) {\r\n                case 'undefined':\r\n                  recording.push(`${indent}${methodCallToString(property, arguments)};`);\r\n                  return;\r\n                case 'number':\r\n                case 'boolean':\r\n                  if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {\r\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\r\n                    contextVariables.push(result = trackablePrimitive(result));\r\n                    break;\r\n                  }\r\n                default:\r\n                  if (result === null) {\r\n                    recording.push(`${methodCallToString(property, arguments)};`);\r\n                  } else {\r\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\r\n                  }\r\n      \r\n                  contextVariables.push(result);\r\n              }\r\n              return result;\r\n            }\r\n          }\r\n          entityNames[gl[property]] = property;\r\n          return gl[property];\r\n        }\r\n        function toString() {\r\n          return recording.join('\\n');\r\n        }\r\n        function reset() {\r\n          while (recording.length > 0) {\r\n            recording.pop();\r\n          }\r\n        }\r\n        function insertVariable(name, value) {\r\n          variables[name] = value;\r\n        }\r\n        function getEntity(value) {\r\n          const name = entityNames[value];\r\n          if (name) {\r\n            return contextName + '.' + name;\r\n          }\r\n          return value;\r\n        }\r\n        function setIndent(spaces) {\r\n          indent = ' '.repeat(spaces);\r\n        }\r\n        function addVariable(value, source) {\r\n          const variableName = `${contextName}Variable${contextVariables.length}`;\r\n          recording.push(`${indent}const ${variableName} = ${source};`);\r\n          contextVariables.push(value);\r\n          return variableName;\r\n        }\r\n        function writePPM(width, height) {\r\n          const sourceVariable = `${contextName}Variable${contextVariables.length}`;\r\n          const imageVariable = `imageDatum${imageCount}`;\r\n          recording.push(`${indent}let ${imageVariable} = [\"P3\\\\n# ${readPixelsFile}.ppm\\\\n\", ${width}, ' ', ${height}, \"\\\\n255\\\\n\"].join(\"\");`);\r\n          recording.push(`${indent}for (let i = 0; i < ${imageVariable}.length; i += 4) {`);\r\n          recording.push(`${indent}  ${imageVariable} += ${sourceVariable}[i] + ' ' + ${sourceVariable}[i + 1] + ' ' + ${sourceVariable}[i + 2] + ' ';`);\r\n          recording.push(`${indent}}`);\r\n          recording.push(`${indent}if (typeof require !== \"undefined\") {`);\r\n          recording.push(`${indent}  require('fs').writeFileSync('./${readPixelsFile}.ppm', ${imageVariable});`);\r\n          recording.push(`${indent}}`);\r\n          imageCount++;\r\n        }\r\n        function addComment(value) {\r\n          recording.push(`${indent}// ${value}`);\r\n        }\r\n        function checkThrowError() {\r\n          recording.push(`${indent}(() => {\r\n      ${indent}const error = ${contextName}.getError();\r\n      ${indent}if (error !== ${contextName}.NONE) {\r\n      ${indent}  const names = Object.getOwnPropertyNames(gl);\r\n      ${indent}  for (let i = 0; i < names.length; i++) {\r\n      ${indent}    const name = names[i];\r\n      ${indent}    if (${contextName}[name] === error) {\r\n      ${indent}      throw new Error('${contextName} threw ' + name);\r\n      ${indent}    }\r\n      ${indent}  }\r\n      ${indent}}\r\n      ${indent}})();`);\r\n        }\r\n        function methodCallToString(method, args) {\r\n          return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;\r\n        }\r\n      \r\n        function getVariableName(value) {\r\n          if (variables) {\r\n            for (const name in variables) {\r\n              if (variables[name] === value) {\r\n                return name;\r\n              }\r\n            }\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        function getContextVariableName(value) {\r\n          const i = contextVariables.indexOf(value);\r\n          if (i !== -1) {\r\n            return `${contextName}Variable${i}`;\r\n          }\r\n          return null;\r\n        }\r\n      }\r\n      \r\n      function glExtensionWiretap(extension, options) {\r\n        const proxy = new Proxy(extension, { get: listen });\r\n        const extensionEntityNames = {};\r\n        const {\r\n          contextName,\r\n          contextVariables,\r\n          getEntity,\r\n          useTrackablePrimitives,\r\n          recording,\r\n          variables,\r\n          indent,\r\n          onUnrecognizedArgumentLookup,\r\n        } = options;\r\n        return proxy;\r\n        function listen(obj, property) {\r\n          if (typeof obj[property] === 'function') {\r\n            return function() {\r\n              switch (property) {\r\n                case 'drawBuffersWEBGL':\r\n                  recording.push(`${indent}${contextName}.drawBuffersWEBGL([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })}]);`);\r\n                  return extension.drawBuffersWEBGL(arguments[0]);\r\n              }\r\n              let result = extension[property].apply(extension, arguments);\r\n              switch (typeof result) {\r\n                case 'undefined':\r\n                  recording.push(`${indent}${methodCallToString(property, arguments)};`);\r\n                  return;\r\n                case 'number':\r\n                case 'boolean':\r\n                  if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {\r\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\r\n                    contextVariables.push(result = trackablePrimitive(result));\r\n                  } else {\r\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\r\n                    contextVariables.push(result);\r\n                  }\r\n                  break;\r\n                default:\r\n                  if (result === null) {\r\n                    recording.push(`${methodCallToString(property, arguments)};`);\r\n                  } else {\r\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\r\n                  }\r\n                  contextVariables.push(result);\r\n              }\r\n              return result;\r\n            };\r\n          }\r\n          extensionEntityNames[extension[property]] = property;\r\n          return extension[property];\r\n        }\r\n      \r\n        function getExtensionEntity(value) {\r\n          if (extensionEntityNames.hasOwnProperty(value)) {\r\n            return `${contextName}.${extensionEntityNames[value]}`;\r\n          }\r\n          return getEntity(value);\r\n        }\r\n      \r\n        function methodCallToString(method, args) {\r\n          return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;\r\n        }\r\n      \r\n        function addVariable(value, source) {\r\n          const variableName = `${contextName}Variable${contextVariables.length}`;\r\n          contextVariables.push(value);\r\n          recording.push(`${indent}const ${variableName} = ${source};`);\r\n          return variableName;\r\n        }\r\n      }\r\n      \r\n      function argumentsToString(args, options) {\r\n        const { variables, onUnrecognizedArgumentLookup } = options;\r\n        return (Array.from(args).map((arg) => {\r\n          const variableName = getVariableName(arg);\r\n          if (variableName) {\r\n            return variableName;\r\n          }\r\n          return argumentToString(arg, options);\r\n        }).join(', '));\r\n      \r\n        function getVariableName(value) {\r\n          if (variables) {\r\n            for (const name in variables) {\r\n              if (!variables.hasOwnProperty(name)) continue;\r\n              if (variables[name] === value) {\r\n                return name;\r\n              }\r\n            }\r\n          }\r\n          if (onUnrecognizedArgumentLookup) {\r\n            return onUnrecognizedArgumentLookup(value);\r\n          }\r\n          return null;\r\n        }\r\n      }\r\n      \r\n      function argumentToString(arg, options) {\r\n        const { contextName, contextVariables, getEntity, addVariable, onUnrecognizedArgumentLookup } = options;\r\n        if (typeof arg === 'undefined') {\r\n          return 'undefined';\r\n        }\r\n        if (arg === null) {\r\n          return 'null';\r\n        }\r\n        const i = contextVariables.indexOf(arg);\r\n        if (i > -1) {\r\n          return `${contextName}Variable${i}`;\r\n        }\r\n        switch (arg.constructor.name) {\r\n          case 'String':\r\n            const hasLines = /\\n/.test(arg);\r\n            const hasSingleQuotes = /'/.test(arg);\r\n            const hasDoubleQuotes = /\"/.test(arg);\r\n            if (hasLines) {\r\n              return '`' + arg + '`';\r\n            } else if (hasSingleQuotes && !hasDoubleQuotes) {\r\n              return '\"' + arg + '\"';\r\n            } else if (!hasSingleQuotes && hasDoubleQuotes) {\r\n              return \"'\" + arg + \"'\";\r\n            } else {\r\n              return '\\'' + arg + '\\'';\r\n            }\r\n          case 'Number': return getEntity(arg);\r\n          case 'Boolean': return getEntity(arg);\r\n          case 'Array':\r\n            return addVariable(arg, `new ${arg.constructor.name}([${Array.from(arg).join(',')}])`);\r\n          case 'Float32Array':\r\n          case 'Uint8Array':\r\n          case 'Uint16Array':\r\n          case 'Int32Array':\r\n            return addVariable(arg, `new ${arg.constructor.name}(${JSON.stringify(Array.from(arg))})`);\r\n          default:\r\n            if (onUnrecognizedArgumentLookup) {\r\n              const instantiationString = onUnrecognizedArgumentLookup(arg);\r\n              if (instantiationString) {\r\n                return instantiationString;\r\n              }\r\n            }\r\n            throw new Error(`unrecognized argument type ${arg.constructor.name}`);\r\n        }\r\n      }\r\n      \r\n      function trackablePrimitive(value) {\r\n        return new value.constructor(value);\r\n      }\r\n      \r\n      if (typeof module !== 'undefined') {\r\n        module.exports = { glWiretap, glExtensionWiretap };\r\n      }\r\n      \r\n      if (typeof window !== 'undefined') {\r\n        glWiretap.glExtensionWiretap = glExtensionWiretap;\r\n        window.glWiretap = glWiretap;\r\n      }\r\n      \r\n      },{}],4:[function(require,module,exports){\r\n      function setupArguments(args) {\r\n        const newArguments = new Array(args.length);\r\n        for (let i = 0; i < args.length; i++) {\r\n          const arg = args[i];\r\n          if (arg.toArray) {\r\n            newArguments[i] = arg.toArray();\r\n          } else {\r\n            newArguments[i] = arg;\r\n          }\r\n        }\r\n        return newArguments;\r\n      }\r\n      \r\n      function mock1D() {\r\n        const args = setupArguments(arguments);\r\n        const row = new Float32Array(this.output.x);\r\n        for (let x = 0; x < this.output.x; x++) {\r\n          this.thread.x = x;\r\n          this.thread.y = 0;\r\n          this.thread.z = 0;\r\n          row[x] = this._fn.apply(this, args);\r\n        }\r\n        return row;\r\n      }\r\n      \r\n      function mock2D() {\r\n        const args = setupArguments(arguments);\r\n        const matrix = new Array(this.output.y);\r\n        for (let y = 0; y < this.output.y; y++) {\r\n          const row = new Float32Array(this.output.x);\r\n          for (let x = 0; x < this.output.x; x++) {\r\n            this.thread.x = x;\r\n            this.thread.y = y;\r\n            this.thread.z = 0;\r\n            row[x] = this._fn.apply(this, args);\r\n          }\r\n          matrix[y] = row;\r\n        }\r\n        return matrix;\r\n      }\r\n      \r\n      function mock2DGraphical() {\r\n        const args = setupArguments(arguments);\r\n        for (let y = 0; y < this.output.y; y++) {\r\n          for (let x = 0; x < this.output.x; x++) {\r\n            this.thread.x = x;\r\n            this.thread.y = y;\r\n            this.thread.z = 0;\r\n            this._fn.apply(this, args);\r\n          }\r\n        }\r\n      }\r\n      \r\n      function mock3D() {\r\n        const args = setupArguments(arguments);\r\n        const cube = new Array(this.output.z);\r\n        for (let z = 0; z < this.output.z; z++) {\r\n          const matrix = new Array(this.output.y);\r\n          for (let y = 0; y < this.output.y; y++) {\r\n            const row = new Float32Array(this.output.x);\r\n            for (let x = 0; x < this.output.x; x++) {\r\n              this.thread.x = x;\r\n              this.thread.y = y;\r\n              this.thread.z = z;\r\n              row[x] = this._fn.apply(this, args);\r\n            }\r\n            matrix[y] = row;\r\n          }\r\n          cube[z] = matrix;\r\n        }\r\n        return cube;\r\n      }\r\n      \r\n      function apiDecorate(kernel) {\r\n        kernel.setOutput = (output) => {\r\n          kernel.output = setupOutput(output);\r\n          if (kernel.graphical) {\r\n            setupGraphical(kernel);\r\n          }\r\n        };\r\n        kernel.toJSON = () => {\r\n          throw new Error('Not usable with gpuMock');\r\n        };\r\n        kernel.setConstants = (flag) => {\r\n          kernel.constants = flag;\r\n          return kernel;\r\n        };\r\n        kernel.setGraphical = (flag) => {\r\n          kernel.graphical = flag;\r\n          return kernel;\r\n        };\r\n        kernel.setCanvas = (flag) => {\r\n          kernel.canvas = flag;\r\n          return kernel;\r\n        };\r\n        kernel.setContext = (flag) => {\r\n          kernel.context = flag;\r\n          return kernel;\r\n        };\r\n        kernel.destroy = () => {};\r\n        kernel.validateSettings = () => {};\r\n        if (kernel.graphical && kernel.output) {\r\n          setupGraphical(kernel);\r\n        }\r\n        kernel.exec = function() {\r\n          return new Promise((resolve, reject) => {\r\n            try {\r\n              resolve(kernel.apply(kernel, arguments));\r\n            } catch(e) {\r\n              reject(e);\r\n            }\r\n          });\r\n        };\r\n        kernel.getPixels = (flip) => {\r\n          const {x, y} = kernel.output;\r\n          return flip ? flipPixels(kernel._imageData.data, x, y) : kernel._imageData.data.slice(0);\r\n        };\r\n        kernel.color = function(r, g, b, a) {\r\n          if (typeof a === 'undefined') {\r\n            a = 1;\r\n          }\r\n      \r\n          r = Math.floor(r * 255);\r\n          g = Math.floor(g * 255);\r\n          b = Math.floor(b * 255);\r\n          a = Math.floor(a * 255);\r\n      \r\n          const width = kernel.output.x;\r\n          const height = kernel.output.y;\r\n      \r\n          const x = kernel.thread.x;\r\n          const y = height - kernel.thread.y - 1;\r\n      \r\n          const index = x + y * width;\r\n      \r\n          kernel._colorData[index * 4 + 0] = r;\r\n          kernel._colorData[index * 4 + 1] = g;\r\n          kernel._colorData[index * 4 + 2] = b;\r\n          kernel._colorData[index * 4 + 3] = a;\r\n        };\r\n      \r\n        const mockMethod = () => kernel;\r\n        const methods = [\r\n          'setWarnVarUsage',\r\n          'setArgumentTypes',\r\n          'setTactic',\r\n          'setOptimizeFloatMemory',\r\n          'setDebug',\r\n          'setLoopMaxIterations',\r\n          'setConstantTypes',\r\n          'setFunctions',\r\n          'setNativeFunctions',\r\n          'setInjectedNative',\r\n          'setPipeline',\r\n          'setPrecision',\r\n          'setOutputToTexture',\r\n          'setImmutable',\r\n          'setStrictIntegers',\r\n          'setDynamicOutput',\r\n          'setHardcodeConstants',\r\n          'setDynamicArguments',\r\n          'setUseLegacyEncoder',\r\n          'setWarnVarUsage',\r\n          'addSubKernel',\r\n        ];\r\n        for (let i = 0; i < methods.length; i++) {\r\n          kernel[methods[i]] = mockMethod;\r\n        }\r\n        return kernel;\r\n      }\r\n      \r\n      function setupGraphical(kernel) {\r\n        const {x, y} = kernel.output;\r\n        if (kernel.context && kernel.context.createImageData) {\r\n          const data = new Uint8ClampedArray(x * y * 4);\r\n          kernel._imageData = kernel.context.createImageData(x, y);\r\n          kernel._colorData = data;\r\n        } else {\r\n          const data = new Uint8ClampedArray(x * y * 4);\r\n          kernel._imageData = { data };\r\n          kernel._colorData = data;\r\n        }\r\n      }\r\n      \r\n      function setupOutput(output) {\r\n        let result = null;\r\n        if (output.length) {\r\n          if (output.length === 3) {\r\n            const [x,y,z] = output;\r\n            result = { x, y, z };\r\n          } else if (output.length === 2) {\r\n            const [x,y] = output;\r\n            result = { x, y };\r\n          } else {\r\n            const [x] = output;\r\n            result = { x };\r\n          }\r\n        } else {\r\n          result = output;\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      function gpuMock(fn, settings = {}) {\r\n        const output = settings.output ? setupOutput(settings.output) : null;\r\n        function kernel() {\r\n          if (kernel.output.z) {\r\n            return mock3D.apply(kernel, arguments);\r\n          } else if (kernel.output.y) {\r\n            if (kernel.graphical) {\r\n              return mock2DGraphical.apply(kernel, arguments);\r\n            }\r\n            return mock2D.apply(kernel, arguments);\r\n          } else {\r\n            return mock1D.apply(kernel, arguments);\r\n          }\r\n        }\r\n        kernel._fn = fn;\r\n        kernel.constants = settings.constants || null;\r\n        kernel.context = settings.context || null;\r\n        kernel.canvas = settings.canvas || null;\r\n        kernel.graphical = settings.graphical || false;\r\n        kernel._imageData = null;\r\n        kernel._colorData = null;\r\n        kernel.output = output;\r\n        kernel.thread = {\r\n          x: 0,\r\n          y: 0,\r\n          z: 0\r\n        };\r\n        return apiDecorate(kernel);\r\n      }\r\n      \r\n      function flipPixels(pixels, width, height) {\r\n        const halfHeight = height / 2 | 0; \r\n        const bytesPerRow = width * 4;\r\n        const temp = new Uint8ClampedArray(width * 4);\r\n        const result = pixels.slice(0);\r\n        for (let y = 0; y < halfHeight; ++y) {\r\n          const topOffset = y * bytesPerRow;\r\n          const bottomOffset = (height - y - 1) * bytesPerRow;\r\n      \r\n          temp.set(result.subarray(topOffset, topOffset + bytesPerRow));\r\n      \r\n          result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);\r\n      \r\n          result.set(temp, bottomOffset);\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      module.exports = {\r\n        gpuMock\r\n      };\r\n      \r\n      },{}],5:[function(require,module,exports){\r\n      const { utils } = require('./utils');\r\n      \r\n      function alias(name, source) {\r\n        const fnString = source.toString();\r\n        return new Function(`return function ${ name } (${ utils.getArgumentNamesFromString(fnString).join(', ') }) {\r\n        ${ utils.getFunctionBodyFromString(fnString) }\r\n      }`)();\r\n      }\r\n      \r\n      module.exports = {\r\n        alias\r\n      };\r\n      },{\"./utils\":114}],6:[function(require,module,exports){\r\n      const { FunctionNode } = require('../function-node');\r\n      \r\n      class CPUFunctionNode extends FunctionNode {\r\n        astFunction(ast, retArr) {\r\n      \r\n          if (!this.isRootKernel) {\r\n            retArr.push('function');\r\n            retArr.push(' ');\r\n            retArr.push(this.name);\r\n            retArr.push('(');\r\n      \r\n            for (let i = 0; i < this.argumentNames.length; ++i) {\r\n              const argumentName = this.argumentNames[i];\r\n      \r\n              if (i > 0) {\r\n                retArr.push(', ');\r\n              }\r\n              retArr.push('user_');\r\n              retArr.push(argumentName);\r\n            }\r\n      \r\n            retArr.push(') {\\n');\r\n          }\r\n      \r\n          for (let i = 0; i < ast.body.body.length; ++i) {\r\n            this.astGeneric(ast.body.body[i], retArr);\r\n            retArr.push('\\n');\r\n          }\r\n      \r\n          if (!this.isRootKernel) {\r\n            retArr.push('}\\n');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astReturnStatement(ast, retArr) {\r\n          const type = this.returnType || this.getType(ast.argument);\r\n      \r\n          if (!this.returnType) {\r\n            this.returnType = type;\r\n          }\r\n      \r\n          if (this.isRootKernel) {\r\n            retArr.push(this.leadingReturnStatement);\r\n            this.astGeneric(ast.argument, retArr);\r\n            retArr.push(';\\n');\r\n            retArr.push(this.followingReturnStatement);\r\n            retArr.push('continue;\\n');\r\n          } else if (this.isSubKernel) {\r\n            retArr.push(`subKernelResult_${ this.name } = `);\r\n            this.astGeneric(ast.argument, retArr);\r\n            retArr.push(';');\r\n            retArr.push(`return subKernelResult_${ this.name };`);\r\n          } else {\r\n            retArr.push('return ');\r\n            this.astGeneric(ast.argument, retArr);\r\n            retArr.push(';');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astLiteral(ast, retArr) {\r\n      \r\n          if (isNaN(ast.value)) {\r\n            throw this.astErrorOutput(\r\n              'Non-numeric literal not supported : ' + ast.value,\r\n              ast\r\n            );\r\n          }\r\n      \r\n          retArr.push(ast.value);\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astBinaryExpression(ast, retArr) {\r\n          retArr.push('(');\r\n          this.astGeneric(ast.left, retArr);\r\n          retArr.push(ast.operator);\r\n          this.astGeneric(ast.right, retArr);\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        astIdentifierExpression(idtNode, retArr) {\r\n          if (idtNode.type !== 'Identifier') {\r\n            throw this.astErrorOutput(\r\n              'IdentifierExpression - not an Identifier',\r\n              idtNode\r\n            );\r\n          }\r\n      \r\n          switch (idtNode.name) {\r\n            case 'Infinity':\r\n              retArr.push('Infinity');\r\n              break;\r\n            default:\r\n              if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {\r\n                retArr.push('constants_' + idtNode.name);\r\n              } else {\r\n                retArr.push('user_' + idtNode.name);\r\n              }\r\n          }\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astForStatement(forNode, retArr) {\r\n          if (forNode.type !== 'ForStatement') {\r\n            throw this.astErrorOutput('Invalid for statement', forNode);\r\n          }\r\n      \r\n          const initArr = [];\r\n          const testArr = [];\r\n          const updateArr = [];\r\n          const bodyArr = [];\r\n          let isSafe = null;\r\n      \r\n          if (forNode.init) {\r\n            this.pushState('in-for-loop-init');\r\n            this.astGeneric(forNode.init, initArr);\r\n            for (let i = 0; i < initArr.length; i++) {\r\n              if (initArr[i].includes && initArr[i].includes(',')) {\r\n                isSafe = false;\r\n              }\r\n            }\r\n            this.popState('in-for-loop-init');\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.test) {\r\n            this.astGeneric(forNode.test, testArr);\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.update) {\r\n            this.astGeneric(forNode.update, updateArr);\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.body) {\r\n            this.pushState('loop-body');\r\n            this.astGeneric(forNode.body, bodyArr);\r\n            this.popState('loop-body');\r\n          }\r\n      \r\n          if (isSafe === null) {\r\n            isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);\r\n          }\r\n      \r\n          if (isSafe) {\r\n            retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\\n`);\r\n            retArr.push(bodyArr.join(''));\r\n            retArr.push('}\\n');\r\n          } else {\r\n            const iVariableName = this.getInternalVariableName('safeI');\r\n            if (initArr.length > 0) {\r\n              retArr.push(initArr.join(''), ';\\n');\r\n            }\r\n            retArr.push(`for (let ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\n`);\r\n            if (testArr.length > 0) {\r\n              retArr.push(`if (!${testArr.join('')}) break;\\n`);\r\n            }\r\n            retArr.push(bodyArr.join(''));\r\n            retArr.push(`\\n${updateArr.join('')};`);\r\n            retArr.push('}\\n');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astWhileStatement(whileNode, retArr) {\r\n          if (whileNode.type !== 'WhileStatement') {\r\n            throw this.astErrorOutput(\r\n              'Invalid while statement',\r\n              whileNode\r\n            );\r\n          }\r\n      \r\n          retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');\r\n          retArr.push('if (');\r\n          this.astGeneric(whileNode.test, retArr);\r\n          retArr.push(') {\\n');\r\n          this.astGeneric(whileNode.body, retArr);\r\n          retArr.push('} else {\\n');\r\n          retArr.push('break;\\n');\r\n          retArr.push('}\\n');\r\n          retArr.push('}\\n');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astDoWhileStatement(doWhileNode, retArr) {\r\n          if (doWhileNode.type !== 'DoWhileStatement') {\r\n            throw this.astErrorOutput(\r\n              'Invalid while statement',\r\n              doWhileNode\r\n            );\r\n          }\r\n      \r\n          retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');\r\n          this.astGeneric(doWhileNode.body, retArr);\r\n          retArr.push('if (!');\r\n          this.astGeneric(doWhileNode.test, retArr);\r\n          retArr.push(') {\\n');\r\n          retArr.push('break;\\n');\r\n          retArr.push('}\\n');\r\n          retArr.push('}\\n');\r\n      \r\n          return retArr;\r\n      \r\n        }\r\n      \r\n        astAssignmentExpression(assNode, retArr) {\r\n          const declaration = this.getDeclaration(assNode.left);\r\n          if (declaration && !declaration.assignable) {\r\n            throw this.astErrorOutput(`Variable ${assNode.left.name} is not assignable here`, assNode);\r\n          }\r\n          this.astGeneric(assNode.left, retArr);\r\n          retArr.push(assNode.operator);\r\n          this.astGeneric(assNode.right, retArr);\r\n          return retArr;\r\n        }\r\n      \r\n        astBlockStatement(bNode, retArr) {\r\n          if (this.isState('loop-body')) {\r\n            this.pushState('block-body'); \r\n            for (let i = 0; i < bNode.body.length; i++) {\r\n              this.astGeneric(bNode.body[i], retArr);\r\n            }\r\n            this.popState('block-body');\r\n          } else {\r\n            retArr.push('{\\n');\r\n            for (let i = 0; i < bNode.body.length; i++) {\r\n              this.astGeneric(bNode.body[i], retArr);\r\n            }\r\n            retArr.push('}\\n');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astVariableDeclaration(varDecNode, retArr) {\r\n          retArr.push(`${varDecNode.kind} `);\r\n          const { declarations } = varDecNode;\r\n          for (let i = 0; i < declarations.length; i++) {\r\n            if (i > 0) {\r\n              retArr.push(',');\r\n            }\r\n            const declaration = declarations[i];\r\n            const info = this.getDeclaration(declaration.id);\r\n            if (!info.valueType) {\r\n              info.valueType = this.getType(declaration.init);\r\n            }\r\n            this.astGeneric(declaration, retArr);\r\n          }\r\n          if (!this.isState('in-for-loop-init')) {\r\n            retArr.push(';');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astIfStatement(ifNode, retArr) {\r\n          retArr.push('if (');\r\n          this.astGeneric(ifNode.test, retArr);\r\n          retArr.push(')');\r\n          if (ifNode.consequent.type === 'BlockStatement') {\r\n            this.astGeneric(ifNode.consequent, retArr);\r\n          } else {\r\n            retArr.push(' {\\n');\r\n            this.astGeneric(ifNode.consequent, retArr);\r\n            retArr.push('\\n}\\n');\r\n          }\r\n      \r\n          if (ifNode.alternate) {\r\n            retArr.push('else ');\r\n            if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {\r\n              this.astGeneric(ifNode.alternate, retArr);\r\n            } else {\r\n              retArr.push(' {\\n');\r\n              this.astGeneric(ifNode.alternate, retArr);\r\n              retArr.push('\\n}\\n');\r\n            }\r\n          }\r\n          return retArr;\r\n      \r\n        }\r\n      \r\n        astSwitchStatement(ast, retArr) {\r\n          const { discriminant, cases } = ast;\r\n          retArr.push('switch (');\r\n          this.astGeneric(discriminant, retArr);\r\n          retArr.push(') {\\n');\r\n          for (let i = 0; i < cases.length; i++) {\r\n            if (cases[i].test === null) {\r\n              retArr.push('default:\\n');\r\n              this.astGeneric(cases[i].consequent, retArr);\r\n              if (cases[i].consequent && cases[i].consequent.length > 0) {\r\n                retArr.push('break;\\n');\r\n              }\r\n              continue;\r\n            }\r\n            retArr.push('case ');\r\n            this.astGeneric(cases[i].test, retArr);\r\n            retArr.push(':\\n');\r\n            if (cases[i].consequent && cases[i].consequent.length > 0) {\r\n              this.astGeneric(cases[i].consequent, retArr);\r\n              retArr.push('break;\\n');\r\n            }\r\n          }\r\n          retArr.push('\\n}');\r\n        }\r\n      \r\n        astThisExpression(tNode, retArr) {\r\n          retArr.push('_this');\r\n          return retArr;\r\n        }\r\n      \r\n        astMemberExpression(mNode, retArr) {\r\n          const {\r\n            signature,\r\n            type,\r\n            property,\r\n            xProperty,\r\n            yProperty,\r\n            zProperty,\r\n            name,\r\n            origin\r\n          } = this.getMemberExpressionDetails(mNode);\r\n          switch (signature) {\r\n            case 'this.thread.value':\r\n              retArr.push(`_this.thread.${ name }`);\r\n              return retArr;\r\n            case 'this.output.value':\r\n              switch (name) {\r\n                case 'x':\r\n                  retArr.push('outputX');\r\n                  break;\r\n                case 'y':\r\n                  retArr.push('outputY');\r\n                  break;\r\n                case 'z':\r\n                  retArr.push('outputZ');\r\n                  break;\r\n                default:\r\n                  throw this.astErrorOutput('Unexpected expression', mNode);\r\n              }\r\n              return retArr;\r\n            case 'value':\r\n              throw this.astErrorOutput('Unexpected expression', mNode);\r\n            case 'value[]':\r\n            case 'value[][]':\r\n            case 'value[][][]':\r\n            case 'value.value':\r\n              if (origin === 'Math') {\r\n                retArr.push(Math[name]);\r\n                return retArr;\r\n              }\r\n              switch (property) {\r\n                case 'r':\r\n                  retArr.push(`user_${ name }[0]`);\r\n                  return retArr;\r\n                case 'g':\r\n                  retArr.push(`user_${ name }[1]`);\r\n                  return retArr;\r\n                case 'b':\r\n                  retArr.push(`user_${ name }[2]`);\r\n                  return retArr;\r\n                case 'a':\r\n                  retArr.push(`user_${ name }[3]`);\r\n                  return retArr;\r\n              }\r\n              break;\r\n            case 'this.constants.value':\r\n            case 'this.constants.value[]':\r\n            case 'this.constants.value[][]':\r\n            case 'this.constants.value[][][]':\r\n              break;\r\n            case 'fn()[]':\r\n              this.astGeneric(mNode.object, retArr);\r\n              retArr.push('[');\r\n              this.astGeneric(mNode.property, retArr);\r\n              retArr.push(']');\r\n              return retArr;\r\n            case 'fn()[][]':\r\n              this.astGeneric(mNode.object.object, retArr);\r\n              retArr.push('[');\r\n              this.astGeneric(mNode.object.property, retArr);\r\n              retArr.push(']');\r\n              retArr.push('[');\r\n              this.astGeneric(mNode.property, retArr);\r\n              retArr.push(']');\r\n              return retArr;\r\n            default:\r\n              throw this.astErrorOutput('Unexpected expression', mNode);\r\n          }\r\n      \r\n          if (!mNode.computed) {\r\n            switch (type) {\r\n              case 'Number':\r\n              case 'Integer':\r\n              case 'Float':\r\n              case 'Boolean':\r\n                retArr.push(`${origin}_${name}`);\r\n                return retArr;\r\n            }\r\n          }\r\n      \r\n          const markupName = `${origin}_${name}`;\r\n      \r\n          switch (type) {\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n            case 'HTMLImageArray':\r\n            case 'ArrayTexture(1)':\r\n            case 'ArrayTexture(2)':\r\n            case 'ArrayTexture(3)':\r\n            case 'ArrayTexture(4)':\r\n            case 'HTMLImage':\r\n            default:\r\n              let size;\r\n              let isInput;\r\n              if (origin === 'constants') {\r\n                const constant = this.constants[name];\r\n                isInput = this.constantTypes[name] === 'Input';\r\n                size = isInput ? constant.size : null;\r\n              } else {\r\n                isInput = this.isInput(name);\r\n                size = isInput ? this.argumentSizes[this.argumentNames.indexOf(name)] : null;\r\n              }\r\n              retArr.push(`${ markupName }`);\r\n              if (zProperty && yProperty) {\r\n                if (isInput) {\r\n                  retArr.push('[(');\r\n                  this.astGeneric(zProperty, retArr);\r\n                  retArr.push(`*${ this.dynamicArguments ? '(outputY * outputX)' : size[1] * size[0] })+(`);\r\n                  this.astGeneric(yProperty, retArr);\r\n                  retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);\r\n                  this.astGeneric(xProperty, retArr);\r\n                  retArr.push(']');\r\n                } else {\r\n                  retArr.push('[');\r\n                  this.astGeneric(zProperty, retArr);\r\n                  retArr.push(']');\r\n                  retArr.push('[');\r\n                  this.astGeneric(yProperty, retArr);\r\n                  retArr.push(']');\r\n                  retArr.push('[');\r\n                  this.astGeneric(xProperty, retArr);\r\n                  retArr.push(']');\r\n                }\r\n              } else if (yProperty) {\r\n                if (isInput) {\r\n                  retArr.push('[(');\r\n                  this.astGeneric(yProperty, retArr);\r\n                  retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);\r\n                  this.astGeneric(xProperty, retArr);\r\n                  retArr.push(']');\r\n                } else {\r\n                  retArr.push('[');\r\n                  this.astGeneric(yProperty, retArr);\r\n                  retArr.push(']');\r\n                  retArr.push('[');\r\n                  this.astGeneric(xProperty, retArr);\r\n                  retArr.push(']');\r\n                }\r\n              } else if (typeof xProperty !== 'undefined') {\r\n                retArr.push('[');\r\n                this.astGeneric(xProperty, retArr);\r\n                retArr.push(']');\r\n              }\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astCallExpression(ast, retArr) {\r\n          if (ast.type !== 'CallExpression') {\r\n            throw this.astErrorOutput('Unknown CallExpression', ast);\r\n          }\r\n          let functionName = this.astMemberExpressionUnroll(ast.callee);\r\n      \r\n          if (this.calledFunctions.indexOf(functionName) < 0) {\r\n            this.calledFunctions.push(functionName);\r\n          }\r\n      \r\n          const isMathFunction = this.isAstMathFunction(ast);\r\n      \r\n          if (this.onFunctionCall) {\r\n            this.onFunctionCall(this.name, functionName, ast.arguments);\r\n          }\r\n      \r\n          retArr.push(functionName);\r\n      \r\n          retArr.push('(');\r\n          const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];\r\n          for (let i = 0; i < ast.arguments.length; ++i) {\r\n            const argument = ast.arguments[i];\r\n      \r\n            let argumentType = this.getType(argument);\r\n            if (!targetTypes[i]) {\r\n              this.triggerImplyArgumentType(functionName, i, argumentType, this);\r\n            }\r\n      \r\n            if (i > 0) {\r\n              retArr.push(', ');\r\n            }\r\n            this.astGeneric(argument, retArr);\r\n          }\r\n          retArr.push(')');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astArrayExpression(arrNode, retArr) {\r\n          const returnType = this.getType(arrNode);\r\n          const arrLen = arrNode.elements.length;\r\n          const elements = [];\r\n          for (let i = 0; i < arrLen; ++i) {\r\n            const element = [];\r\n            this.astGeneric(arrNode.elements[i], element);\r\n            elements.push(element.join(''));\r\n          }\r\n          switch (returnType) {\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n              retArr.push(`[${elements.join(', ')}]`);\r\n              break;\r\n            default:\r\n              retArr.push(`new Float32Array([${elements.join(', ')}])`);\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astDebuggerStatement(arrNode, retArr) {\r\n          retArr.push('debugger;');\r\n          return retArr;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        CPUFunctionNode\r\n      };\r\n      },{\"../function-node\":10}],7:[function(require,module,exports){\r\n      const { utils } = require('../../utils');\r\n      \r\n      function constantsToString(constants, types) {\r\n        const results = [];\r\n        for (const name in types) {\r\n          if (!types.hasOwnProperty(name)) continue;\r\n          const type = types[name];\r\n          const constant = constants[name];\r\n          switch (type) {\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n            case 'Boolean':\r\n              results.push(`${name}:${constant}`);\r\n              break;\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n              results.push(`${name}:new ${constant.constructor.name}(${JSON.stringify(Array.from(constant))})`);\r\n              break;\r\n          }\r\n        }\r\n        return `{ ${ results.join() } }`;\r\n      }\r\n      \r\n      function cpuKernelString(cpuKernel, name) {\r\n        const header = [];\r\n        const thisProperties = [];\r\n        const beforeReturn = [];\r\n      \r\n        const useFunctionKeyword = !/^function/.test(cpuKernel.color.toString());\r\n      \r\n        header.push(\r\n          '  const { context, canvas, constants: incomingConstants } = settings;',\r\n          `  const output = new Int32Array(${JSON.stringify(Array.from(cpuKernel.output))});`,\r\n          `  const _constantTypes = ${JSON.stringify(cpuKernel.constantTypes)};`,\r\n          `  const _constants = ${constantsToString(cpuKernel.constants, cpuKernel.constantTypes)};`,\r\n        );\r\n      \r\n        thisProperties.push(\r\n          '    constants: _constants,',\r\n          '    context,',\r\n          '    output,',\r\n          '    thread: {x: 0, y: 0, z: 0},',\r\n        );\r\n      \r\n        if (cpuKernel.graphical) {\r\n          header.push(`  const _imageData = context.createImageData(${cpuKernel.output[0]}, ${cpuKernel.output[1]});`);\r\n          header.push(`  const _colorData = new Uint8ClampedArray(${cpuKernel.output[0]} * ${cpuKernel.output[1]} * 4);`);\r\n      \r\n          const colorFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.color.toString(), {\r\n            thisLookup: (propertyName) => {\r\n              switch (propertyName) {\r\n                case '_colorData':\r\n                  return '_colorData';\r\n                case '_imageData':\r\n                  return '_imageData';\r\n                case 'output':\r\n                  return 'output';\r\n                case 'thread':\r\n                  return 'this.thread';\r\n              }\r\n              return JSON.stringify(cpuKernel[propertyName]);\r\n            },\r\n            findDependency: (object, name) => {\r\n              return null;\r\n            }\r\n          });\r\n      \r\n          const getPixelsFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.getPixels.toString(), {\r\n            thisLookup: (propertyName) => {\r\n              switch (propertyName) {\r\n                case '_colorData':\r\n                  return '_colorData';\r\n                case '_imageData':\r\n                  return '_imageData';\r\n                case 'output':\r\n                  return 'output';\r\n                case 'thread':\r\n                  return 'this.thread';\r\n              }\r\n              return JSON.stringify(cpuKernel[propertyName]);\r\n            },\r\n            findDependency: () => {\r\n              return null;\r\n            }\r\n          });\r\n      \r\n          thisProperties.push(\r\n            '    _imageData,',\r\n            '    _colorData,',\r\n            `    color: ${colorFn},`,\r\n          );\r\n      \r\n          beforeReturn.push(\r\n            `  kernel.getPixels = ${getPixelsFn};`\r\n          );\r\n        }\r\n      \r\n        const constantTypes = [];\r\n        const constantKeys = Object.keys(cpuKernel.constantTypes);\r\n        for (let i = 0; i < constantKeys.length; i++) {\r\n          constantTypes.push(cpuKernel.constantTypes[constantKeys]);\r\n        }\r\n        if (cpuKernel.argumentTypes.indexOf('HTMLImageArray') !== -1 || constantTypes.indexOf('HTMLImageArray') !== -1) {\r\n          const flattenedImageTo3DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo3DArray.toString(), {\r\n            doNotDefine: ['canvas'],\r\n            findDependency: (object, name) => {\r\n              if (object === 'this') {\r\n                return (useFunctionKeyword ? 'function ' : '') + cpuKernel[name].toString();\r\n              }\r\n              return null;\r\n            },\r\n            thisLookup: (propertyName) => {\r\n              switch (propertyName) {\r\n                case 'canvas':\r\n                  return;\r\n                case 'context':\r\n                  return 'context';\r\n              }\r\n            }\r\n          });\r\n          beforeReturn.push(flattenedImageTo3DArray);\r\n          thisProperties.push(`    _mediaTo2DArray,`);\r\n          thisProperties.push(`    _imageTo3DArray,`);\r\n        } else if (cpuKernel.argumentTypes.indexOf('HTMLImage') !== -1 || constantTypes.indexOf('HTMLImage') !== -1) {\r\n          const flattenedImageTo2DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._mediaTo2DArray.toString(), {\r\n            findDependency: (object, name) => {\r\n              return null;\r\n            },\r\n            thisLookup: (propertyName) => {\r\n              switch (propertyName) {\r\n                case 'canvas':\r\n                  return 'settings.canvas';\r\n                case 'context':\r\n                  return 'settings.context';\r\n              }\r\n              throw new Error('unhandled thisLookup');\r\n            }\r\n          });\r\n          beforeReturn.push(flattenedImageTo2DArray);\r\n          thisProperties.push(`    _mediaTo2DArray,`);\r\n        }\r\n      \r\n        return `function(settings) {\r\n      ${ header.join('\\n') }\r\n        for (const p in _constantTypes) {\r\n          if (!_constantTypes.hasOwnProperty(p)) continue;\r\n          const type = _constantTypes[p];\r\n          switch (type) {\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n            case 'Boolean':\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n              if (incomingConstants.hasOwnProperty(p)) {\r\n                console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');\r\n              }\r\n              continue;\r\n          }\r\n          if (!incomingConstants.hasOwnProperty(p)) {\r\n            throw new Error('constant ' + p + ' not found');\r\n          }\r\n          _constants[p] = incomingConstants[p];\r\n        }\r\n        const kernel = (function() {\r\n      ${cpuKernel._kernelString}\r\n        })\r\n          .apply({ ${thisProperties.join('\\n')} });\r\n        ${ beforeReturn.join('\\n') }\r\n        return kernel;\r\n      }`;\r\n      }\r\n      \r\n      module.exports = {\r\n        cpuKernelString\r\n      };\r\n      },{\"../../utils\":114}],8:[function(require,module,exports){\r\n      const { Kernel } = require('../kernel');\r\n      const { FunctionBuilder } = require('../function-builder');\r\n      const { CPUFunctionNode } = require('./function-node');\r\n      const { utils } = require('../../utils');\r\n      const { cpuKernelString } = require('./kernel-string');\r\n      \r\n      class CPUKernel extends Kernel {\r\n        static getFeatures() {\r\n          return this.features;\r\n        }\r\n        static get features() {\r\n          return Object.freeze({\r\n            kernelMap: true,\r\n            isIntegerDivisionAccurate: true\r\n          });\r\n        }\r\n        static get isSupported() {\r\n          return true;\r\n        }\r\n        static isContextMatch(context) {\r\n          return false;\r\n        }\r\n        static get mode() {\r\n          return 'cpu';\r\n        }\r\n      \r\n        static nativeFunctionArguments() {\r\n          return null;\r\n        }\r\n      \r\n        static nativeFunctionReturnType() {\r\n          throw new Error(`Looking up native function return type not supported on ${this.name}`);\r\n        }\r\n      \r\n        static combineKernels(combinedKernel) {\r\n          return combinedKernel;\r\n        }\r\n      \r\n        static getSignature(kernel, argumentTypes) {\r\n          return 'cpu' + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');\r\n        }\r\n      \r\n        constructor(source, settings) {\r\n          super(source, settings);\r\n          this.mergeSettings(source.settings || settings);\r\n      \r\n          this._imageData = null;\r\n          this._colorData = null;\r\n          this._kernelString = null;\r\n          this._prependedString = [];\r\n          this.thread = {\r\n            x: 0,\r\n            y: 0,\r\n            z: 0\r\n          };\r\n          this.translatedSources = null;\r\n        }\r\n      \r\n        initCanvas() {\r\n          if (typeof document !== 'undefined') {\r\n            return document.createElement('canvas');\r\n          } else if (typeof OffscreenCanvas !== 'undefined') {\r\n            return new OffscreenCanvas(0, 0);\r\n          }\r\n        }\r\n      \r\n        initContext() {\r\n          if (!this.canvas) return null;\r\n          return this.canvas.getContext('2d');\r\n        }\r\n      \r\n        initPlugins(settings) {\r\n          return [];\r\n        }\r\n      \r\n        validateSettings(args) {\r\n          if (!this.output || this.output.length === 0) {\r\n            if (args.length !== 1) {\r\n              throw new Error('Auto output only supported for kernels with only one input');\r\n            }\r\n      \r\n            const argType = utils.getVariableType(args[0], this.strictIntegers);\r\n            if (argType === 'Array') {\r\n              this.output = utils.getDimensions(argType);\r\n            } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {\r\n              this.output = args[0].output;\r\n            } else {\r\n              throw new Error('Auto output not supported for input type: ' + argType);\r\n            }\r\n          }\r\n      \r\n          if (this.graphical) {\r\n            if (this.output.length !== 2) {\r\n              throw new Error('Output must have 2 dimensions on graphical mode');\r\n            }\r\n          }\r\n      \r\n          this.checkOutput();\r\n        }\r\n      \r\n        translateSource() {\r\n          this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';\r\n          if (this.subKernels) {\r\n            const followingReturnStatement = [];\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              const {\r\n                name\r\n              } = this.subKernels[i];\r\n              followingReturnStatement.push(this.output.length > 1 ? `resultX_${ name }[x] = subKernelResult_${ name };\\n` : `result_${ name }[x] = subKernelResult_${ name };\\n`);\r\n            }\r\n            this.followingReturnStatement = followingReturnStatement.join('');\r\n          }\r\n          const functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);\r\n          this.translatedSources = functionBuilder.getPrototypes('kernel');\r\n          if (!this.graphical && !this.returnType) {\r\n            this.returnType = functionBuilder.getKernelResultType();\r\n          }\r\n        }\r\n      \r\n        build() {\r\n          if (this.built) return;\r\n          this.setupConstants();\r\n          this.setupArguments(arguments);\r\n          this.validateSettings(arguments);\r\n          this.translateSource();\r\n      \r\n          if (this.graphical) {\r\n            const {\r\n              canvas,\r\n              output\r\n            } = this;\r\n            if (!canvas) {\r\n              throw new Error('no canvas available for using graphical output');\r\n            }\r\n            const width = output[0];\r\n            const height = output[1] || 1;\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            this._imageData = this.context.createImageData(width, height);\r\n            this._colorData = new Uint8ClampedArray(width * height * 4);\r\n          }\r\n      \r\n          const kernelString = this.getKernelString();\r\n          this.kernelString = kernelString;\r\n      \r\n          if (this.debug) {\r\n            console.log('Function output:');\r\n            console.log(kernelString);\r\n          }\r\n      \r\n          try {\r\n            this.run = new Function([], kernelString).bind(this)();\r\n          } catch (e) {\r\n            console.error('An error occurred compiling the javascript: ', e);\r\n          }\r\n          this.buildSignature(arguments);\r\n          this.built = true;\r\n        }\r\n      \r\n        color(r, g, b, a) {\r\n          if (typeof a === 'undefined') {\r\n            a = 1;\r\n          }\r\n      \r\n          r = Math.floor(r * 255);\r\n          g = Math.floor(g * 255);\r\n          b = Math.floor(b * 255);\r\n          a = Math.floor(a * 255);\r\n      \r\n          const width = this.output[0];\r\n          const height = this.output[1];\r\n      \r\n          const x = this.thread.x;\r\n          const y = height - this.thread.y - 1;\r\n      \r\n          const index = x + y * width;\r\n      \r\n          this._colorData[index * 4 + 0] = r;\r\n          this._colorData[index * 4 + 1] = g;\r\n          this._colorData[index * 4 + 2] = b;\r\n          this._colorData[index * 4 + 3] = a;\r\n        }\r\n      \r\n        getKernelString() {\r\n          if (this._kernelString !== null) return this._kernelString;\r\n      \r\n          let kernelThreadString = null;\r\n          let {\r\n            translatedSources\r\n          } = this;\r\n          if (translatedSources.length > 1) {\r\n            translatedSources = translatedSources.filter(fn => {\r\n              if (/^function/.test(fn)) return fn;\r\n              kernelThreadString = fn;\r\n              return false;\r\n            });\r\n          } else {\r\n            kernelThreadString = translatedSources.shift();\r\n          }\r\n          return this._kernelString = `  const LOOP_MAX = ${ this._getLoopMaxString() };\r\n        ${ this.injectedNative || '' }\r\n        const _this = this;\r\n        ${ this._resultKernelHeader() }\r\n        ${ this._processConstants() }\r\n        return (${ this.argumentNames.map(argumentName => 'user_' + argumentName).join(', ') }) => {\r\n          ${ this._prependedString.join('') }\r\n          ${ this._earlyThrows() }\r\n          ${ this._processArguments() }\r\n          ${ this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString) }\r\n          ${ translatedSources.length > 0 ? translatedSources.join('\\n') : '' }\r\n        };`;\r\n        }\r\n      \r\n        toString() {\r\n          return cpuKernelString(this);\r\n        }\r\n      \r\n        _getLoopMaxString() {\r\n          return (\r\n            this.loopMaxIterations ?\r\n            ` ${ parseInt(this.loopMaxIterations) };` :\r\n            ' 1000;'\r\n          );\r\n        }\r\n      \r\n        _processConstants() {\r\n          if (!this.constants) return '';\r\n      \r\n          const result = [];\r\n          for (let p in this.constants) {\r\n            const type = this.constantTypes[p];\r\n            switch (type) {\r\n              case 'HTMLCanvas':\r\n              case 'HTMLImage':\r\n              case 'HTMLVideo':\r\n                result.push(`    const constants_${p} = this._mediaTo2DArray(this.constants.${p});\\n`);\r\n                break;\r\n              case 'HTMLImageArray':\r\n                result.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});\\n`);\r\n                break;\r\n              case 'Input':\r\n                result.push(`    const constants_${p} = this.constants.${p}.value;\\n`);\r\n                break;\r\n              default:\r\n                result.push(`    const constants_${p} = this.constants.${p};\\n`);\r\n            }\r\n          }\r\n          return result.join('');\r\n        }\r\n      \r\n        _earlyThrows() {\r\n          if (this.graphical) return '';\r\n          if (this.immutable) return '';\r\n          if (!this.pipeline) return '';\r\n          const arrayArguments = [];\r\n          for (let i = 0; i < this.argumentTypes.length; i++) {\r\n            if (this.argumentTypes[i] === 'Array') {\r\n              arrayArguments.push(this.argumentNames[i]);\r\n            }\r\n          }\r\n          if (arrayArguments.length === 0) return '';\r\n          const checks = [];\r\n          for (let i = 0; i < arrayArguments.length; i++) {\r\n            const argumentName = arrayArguments[i];\r\n            const checkSubKernels = this._mapSubKernels(subKernel => `user_${argumentName} === result_${subKernel.name}`).join(' || ');\r\n            checks.push(`user_${argumentName} === result${checkSubKernels ? ` || ${checkSubKernels}` : ''}`);\r\n          }\r\n          return `if (${checks.join(' || ')}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`;\r\n        }\r\n      \r\n        _processArguments() {\r\n          const result = [];\r\n          for (let i = 0; i < this.argumentTypes.length; i++) {\r\n            const variableName = `user_${this.argumentNames[i]}`;\r\n            switch (this.argumentTypes[i]) {\r\n              case 'HTMLCanvas':\r\n              case 'HTMLImage':\r\n              case 'HTMLVideo':\r\n                result.push(`    ${variableName} = this._mediaTo2DArray(${variableName});\\n`);\r\n                break;\r\n              case 'HTMLImageArray':\r\n                result.push(`    ${variableName} = this._imageTo3DArray(${variableName});\\n`);\r\n                break;\r\n              case 'Input':\r\n                result.push(`    ${variableName} = ${variableName}.value;\\n`);\r\n                break;\r\n              case 'ArrayTexture(1)':\r\n              case 'ArrayTexture(2)':\r\n              case 'ArrayTexture(3)':\r\n              case 'ArrayTexture(4)':\r\n              case 'NumberTexture':\r\n              case 'MemoryOptimizedNumberTexture':\r\n                result.push(`\r\n          if (${variableName}.toArray) {\r\n            if (!_this.textureCache) {\r\n              _this.textureCache = [];\r\n              _this.arrayCache = [];\r\n            }\r\n            const textureIndex = _this.textureCache.indexOf(${variableName});\r\n            if (textureIndex !== -1) {\r\n              ${variableName} = _this.arrayCache[textureIndex];\r\n            } else {\r\n              _this.textureCache.push(${variableName});\r\n              ${variableName} = ${variableName}.toArray();\r\n              _this.arrayCache.push(${variableName});\r\n            }\r\n          }`);\r\n                break;\r\n            }\r\n          }\r\n          return result.join('');\r\n        }\r\n      \r\n        _mediaTo2DArray(media) {\r\n          const canvas = this.canvas;\r\n          const width = media.width > 0 ? media.width : media.videoWidth;\r\n          const height = media.height > 0 ? media.height : media.videoHeight;\r\n          if (canvas.width < width) {\r\n            canvas.width = width;\r\n          }\r\n          if (canvas.height < height) {\r\n            canvas.height = height;\r\n          }\r\n          const ctx = this.context;\r\n          ctx.drawImage(media, 0, 0, width, height);\r\n          const pixelsData = ctx.getImageData(0, 0, width, height).data;\r\n          const imageArray = new Array(height);\r\n          let index = 0;\r\n          for (let y = height - 1; y >= 0; y--) {\r\n            const row = imageArray[y] = new Array(width);\r\n            for (let x = 0; x < width; x++) {\r\n              const pixel = new Float32Array(4);\r\n              pixel[0] = pixelsData[index++] / 255; \r\n              pixel[1] = pixelsData[index++] / 255; \r\n              pixel[2] = pixelsData[index++] / 255; \r\n              pixel[3] = pixelsData[index++] / 255; \r\n              row[x] = pixel;\r\n            }\r\n          }\r\n          return imageArray;\r\n        }\r\n      \r\n        getPixels(flip) {\r\n          const [width, height] = this.output;\r\n          return flip ? utils.flipPixels(this._imageData.data, width, height) : this._imageData.data.slice(0);\r\n        }\r\n      \r\n        _imageTo3DArray(images) {\r\n          const imagesArray = new Array(images.length);\r\n          for (let i = 0; i < images.length; i++) {\r\n            imagesArray[i] = this._mediaTo2DArray(images[i]);\r\n          }\r\n          return imagesArray;\r\n        }\r\n      \r\n        _resultKernelHeader() {\r\n          if (this.graphical) return '';\r\n          if (this.immutable) return '';\r\n          if (!this.pipeline) return '';\r\n          switch (this.output.length) {\r\n            case 1:\r\n              return this._mutableKernel1DResults();\r\n            case 2:\r\n              return this._mutableKernel2DResults();\r\n            case 3:\r\n              return this._mutableKernel3DResults();\r\n          }\r\n        }\r\n      \r\n        _resultKernelBody(kernelString) {\r\n          switch (this.output.length) {\r\n            case 1:\r\n              return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(kernelString) : this._resultImmutableKernel1DLoop(kernelString)) + this._kernelOutput();\r\n            case 2:\r\n              return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(kernelString) : this._resultImmutableKernel2DLoop(kernelString)) + this._kernelOutput();\r\n            case 3:\r\n              return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(kernelString) : this._resultImmutableKernel3DLoop(kernelString)) + this._kernelOutput();\r\n            default:\r\n              throw new Error('unsupported size kernel');\r\n          }\r\n        }\r\n      \r\n        _graphicalKernelBody(kernelThreadString) {\r\n          switch (this.output.length) {\r\n            case 2:\r\n              return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();\r\n            default:\r\n              throw new Error('unsupported size kernel');\r\n          }\r\n        }\r\n      \r\n        _graphicalOutput() {\r\n          return `\r\n          this._imageData.data.set(this._colorData);\r\n          this.context.putImageData(this._imageData, 0, 0);\r\n          return;`\r\n        }\r\n      \r\n        _getKernelResultTypeConstructorString() {\r\n          switch (this.returnType) {\r\n            case 'LiteralInteger':\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n              return 'Float32Array';\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n              return 'Array';\r\n            default:\r\n              if (this.graphical) {\r\n                return 'Float32Array';\r\n              }\r\n              throw new Error(`unhandled returnType ${ this.returnType }`);\r\n          }\r\n        }\r\n      \r\n        _resultImmutableKernel1DLoop(kernelString) {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const result = new ${constructorString}(outputX);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }\r\n          for (let x = 0; x < outputX; x++) {\r\n            this.thread.x = x;\r\n            this.thread.y = 0;\r\n            this.thread.z = 0;\r\n            ${ kernelString }\r\n          }`;\r\n        }\r\n      \r\n        _mutableKernel1DResults() {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const result = new ${constructorString}(outputX);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }`;\r\n        }\r\n      \r\n        _resultMutableKernel1DLoop(kernelString) {\r\n          return `  const outputX = _this.output[0];\r\n          for (let x = 0; x < outputX; x++) {\r\n            this.thread.x = x;\r\n            this.thread.y = 0;\r\n            this.thread.z = 0;\r\n            ${ kernelString }\r\n          }`;\r\n        }\r\n      \r\n        _resultImmutableKernel2DLoop(kernelString) {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          const result = new Array(outputY);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }\r\n          for (let y = 0; y < outputY; y++) {\r\n            this.thread.z = 0;\r\n            this.thread.y = y;\r\n            const resultX = result[y] = new ${constructorString}(outputX);\r\n            ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\\n`).join('') }\r\n            for (let x = 0; x < outputX; x++) {\r\n              this.thread.x = x;\r\n              ${ kernelString }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _mutableKernel2DResults() {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          const result = new Array(outputY);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }\r\n          for (let y = 0; y < outputY; y++) {\r\n            const resultX = result[y] = new ${constructorString}(outputX);\r\n            ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\\n`).join('') }\r\n          }`;\r\n        }\r\n      \r\n        _resultMutableKernel2DLoop(kernelString) {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          for (let y = 0; y < outputY; y++) {\r\n            this.thread.z = 0;\r\n            this.thread.y = y;\r\n            const resultX = result[y];\r\n            ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\\n`).join('') }\r\n            for (let x = 0; x < outputX; x++) {\r\n              this.thread.x = x;\r\n              ${ kernelString }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _graphicalKernel2DLoop(kernelString) {\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          for (let y = 0; y < outputY; y++) {\r\n            this.thread.z = 0;\r\n            this.thread.y = y;\r\n            for (let x = 0; x < outputX; x++) {\r\n              this.thread.x = x;\r\n              ${ kernelString }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _resultImmutableKernel3DLoop(kernelString) {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          const outputZ = _this.output[2];\r\n          const result = new Array(outputZ);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }\r\n          for (let z = 0; z < outputZ; z++) {\r\n            this.thread.z = z;\r\n            const resultY = result[z] = new Array(outputY);\r\n            ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\\n`).join('      ') }\r\n            for (let y = 0; y < outputY; y++) {\r\n              this.thread.y = y;\r\n              const resultX = resultY[y] = new ${constructorString}(outputX);\r\n              ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\\n`).join('        ') }\r\n              for (let x = 0; x < outputX; x++) {\r\n                this.thread.x = x;\r\n                ${ kernelString }\r\n              }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _mutableKernel3DResults() {\r\n          const constructorString = this._getKernelResultTypeConstructorString();\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          const outputZ = _this.output[2];\r\n          const result = new Array(outputZ);\r\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\\n`).join('    ') }\r\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\n`).join('    ') }\r\n          for (let z = 0; z < outputZ; z++) {\r\n            const resultY = result[z] = new Array(outputY);\r\n            ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\\n`).join('      ') }\r\n            for (let y = 0; y < outputY; y++) {\r\n              const resultX = resultY[y] = new ${constructorString}(outputX);\r\n              ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\\n`).join('        ') }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _resultMutableKernel3DLoop(kernelString) {\r\n          return `  const outputX = _this.output[0];\r\n          const outputY = _this.output[1];\r\n          const outputZ = _this.output[2];\r\n          for (let z = 0; z < outputZ; z++) {\r\n            this.thread.z = z;\r\n            const resultY = result[z];\r\n            for (let y = 0; y < outputY; y++) {\r\n              this.thread.y = y;\r\n              const resultX = resultY[y];\r\n              for (let x = 0; x < outputX; x++) {\r\n                this.thread.x = x;\r\n                ${ kernelString }\r\n              }\r\n            }\r\n          }`;\r\n        }\r\n      \r\n        _kernelOutput() {\r\n          if (!this.subKernels) {\r\n            return '\\n    return result;';\r\n          }\r\n          return `\\n    return {\r\n            result: result,\r\n            ${ this.subKernels.map(subKernel => `${ subKernel.property }: result_${ subKernel.name }`).join(',\\n      ') }\r\n          };`;\r\n        }\r\n      \r\n        _mapSubKernels(fn) {\r\n          return this.subKernels === null ? [''] :\r\n            this.subKernels.map(fn);\r\n        }\r\n      \r\n        destroy(removeCanvasReference) {\r\n          if (removeCanvasReference) {\r\n            delete this.canvas;\r\n          }\r\n        }\r\n      \r\n        static destroyContext(context) {}\r\n      \r\n        toJSON() {\r\n          const json = super.toJSON();\r\n          json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();\r\n          return json;\r\n        }\r\n      \r\n        setOutput(output) {\r\n          super.setOutput(output);\r\n          const [width, height] = this.output;\r\n          if (this.graphical) {\r\n            this._imageData = this.context.createImageData(width, height);\r\n            this._colorData = new Uint8ClampedArray(width * height * 4);\r\n          }\r\n        }\r\n      \r\n        prependString(value) {\r\n          if (this._kernelString) throw new Error('Kernel already built');\r\n          this._prependedString.push(value);\r\n        }\r\n      \r\n        hasPrependString(value) {\r\n          return this._prependedString.indexOf(value) > -1;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        CPUKernel\r\n      };\r\n      },{\"../../utils\":114,\"../function-builder\":9,\"../kernel\":36,\"./function-node\":6,\"./kernel-string\":7}],9:[function(require,module,exports){\r\n      class FunctionBuilder {\r\n        static fromKernel(kernel, FunctionNode, extraNodeOptions) {\r\n          const {\r\n            kernelArguments,\r\n            kernelConstants,\r\n            argumentNames,\r\n            argumentSizes,\r\n            argumentBitRatios,\r\n            constants,\r\n            constantBitRatios,\r\n            debug,\r\n            loopMaxIterations,\r\n            nativeFunctions,\r\n            output,\r\n            optimizeFloatMemory,\r\n            precision,\r\n            plugins,\r\n            source,\r\n            subKernels,\r\n            functions,\r\n            leadingReturnStatement,\r\n            followingReturnStatement,\r\n            dynamicArguments,\r\n            dynamicOutput,\r\n          } = kernel;\r\n      \r\n          const argumentTypes = new Array(kernelArguments.length);\r\n          const constantTypes = {};\r\n      \r\n          for (let i = 0; i < kernelArguments.length; i++) {\r\n            argumentTypes[i] = kernelArguments[i].type;\r\n          }\r\n      \r\n          for (let i = 0; i < kernelConstants.length; i++) {\r\n            const kernelConstant = kernelConstants[i];\r\n            constantTypes[kernelConstant.name] = kernelConstant.type;\r\n          }\r\n      \r\n          const needsArgumentType = (functionName, index) => {\r\n            return functionBuilder.needsArgumentType(functionName, index);\r\n          };\r\n      \r\n          const assignArgumentType = (functionName, index, type) => {\r\n            functionBuilder.assignArgumentType(functionName, index, type);\r\n          };\r\n      \r\n          const lookupReturnType = (functionName, ast, requestingNode) => {\r\n            return functionBuilder.lookupReturnType(functionName, ast, requestingNode);\r\n          };\r\n      \r\n          const lookupFunctionArgumentTypes = (functionName) => {\r\n            return functionBuilder.lookupFunctionArgumentTypes(functionName);\r\n          };\r\n      \r\n          const lookupFunctionArgumentName = (functionName, argumentIndex) => {\r\n            return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);\r\n          };\r\n      \r\n          const lookupFunctionArgumentBitRatio = (functionName, argumentName) => {\r\n            return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);\r\n          };\r\n      \r\n          const triggerImplyArgumentType = (functionName, i, argumentType, requestingNode) => {\r\n            functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);\r\n          };\r\n      \r\n          const triggerImplyArgumentBitRatio = (functionName, argumentName, calleeFunctionName, argumentIndex) => {\r\n            functionBuilder.assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex);\r\n          };\r\n      \r\n          const onFunctionCall = (functionName, calleeFunctionName, args) => {\r\n            functionBuilder.trackFunctionCall(functionName, calleeFunctionName, args);\r\n          };\r\n      \r\n          const onNestedFunction = (ast, source) => {\r\n            const argumentNames = [];\r\n            for (let i = 0; i < ast.params.length; i++) {\r\n              argumentNames.push(ast.params[i].name);\r\n            }\r\n            const nestedFunction = new FunctionNode(source, Object.assign({}, nodeOptions, {\r\n              returnType: null,\r\n              ast,\r\n              name: ast.id.name,\r\n              argumentNames,\r\n              lookupReturnType,\r\n              lookupFunctionArgumentTypes,\r\n              lookupFunctionArgumentName,\r\n              lookupFunctionArgumentBitRatio,\r\n              needsArgumentType,\r\n              assignArgumentType,\r\n              triggerImplyArgumentType,\r\n              triggerImplyArgumentBitRatio,\r\n              onFunctionCall,\r\n            }));\r\n            nestedFunction.traceFunctionAST(ast);\r\n            functionBuilder.addFunctionNode(nestedFunction);\r\n          };\r\n      \r\n          const nodeOptions = Object.assign({\r\n            isRootKernel: false,\r\n            onNestedFunction,\r\n            lookupReturnType,\r\n            lookupFunctionArgumentTypes,\r\n            lookupFunctionArgumentName,\r\n            lookupFunctionArgumentBitRatio,\r\n            needsArgumentType,\r\n            assignArgumentType,\r\n            triggerImplyArgumentType,\r\n            triggerImplyArgumentBitRatio,\r\n            onFunctionCall,\r\n            optimizeFloatMemory,\r\n            precision,\r\n            constants,\r\n            constantTypes,\r\n            constantBitRatios,\r\n            debug,\r\n            loopMaxIterations,\r\n            output,\r\n            plugins,\r\n            dynamicArguments,\r\n            dynamicOutput,\r\n          }, extraNodeOptions || {});\r\n      \r\n          const rootNodeOptions = Object.assign({}, nodeOptions, {\r\n            isRootKernel: true,\r\n            name: 'kernel',\r\n            argumentNames,\r\n            argumentTypes,\r\n            argumentSizes,\r\n            argumentBitRatios,\r\n            leadingReturnStatement,\r\n            followingReturnStatement,\r\n          });\r\n      \r\n          if (typeof source === 'object' && source.functionNodes) {\r\n            return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);\r\n          }\r\n      \r\n          const rootNode = new FunctionNode(source, rootNodeOptions);\r\n      \r\n          let functionNodes = null;\r\n          if (functions) {\r\n            functionNodes = functions.map((fn) => new FunctionNode(fn.source, {\r\n              returnType: fn.returnType,\r\n              argumentTypes: fn.argumentTypes,\r\n              output,\r\n              plugins,\r\n              constants,\r\n              constantTypes,\r\n              constantBitRatios,\r\n              optimizeFloatMemory,\r\n              precision,\r\n              lookupReturnType,\r\n              lookupFunctionArgumentTypes,\r\n              lookupFunctionArgumentName,\r\n              lookupFunctionArgumentBitRatio,\r\n              needsArgumentType,\r\n              assignArgumentType,\r\n              triggerImplyArgumentType,\r\n              triggerImplyArgumentBitRatio,\r\n              onFunctionCall,\r\n              onNestedFunction,\r\n            }));\r\n          }\r\n      \r\n          let subKernelNodes = null;\r\n          if (subKernels) {\r\n            subKernelNodes = subKernels.map((subKernel) => {\r\n              const { name, source } = subKernel;\r\n              return new FunctionNode(source, Object.assign({}, nodeOptions, {\r\n                name,\r\n                isSubKernel: true,\r\n                isRootKernel: false,\r\n              }));\r\n            });\r\n          }\r\n      \r\n          const functionBuilder = new FunctionBuilder({\r\n            kernel,\r\n            rootNode,\r\n            functionNodes,\r\n            nativeFunctions,\r\n            subKernelNodes\r\n          });\r\n      \r\n          return functionBuilder;\r\n        }\r\n      \r\n        constructor(settings) {\r\n          settings = settings || {};\r\n          this.kernel = settings.kernel;\r\n          this.rootNode = settings.rootNode;\r\n          this.functionNodes = settings.functionNodes || [];\r\n          this.subKernelNodes = settings.subKernelNodes || [];\r\n          this.nativeFunctions = settings.nativeFunctions || [];\r\n          this.functionMap = {};\r\n          this.nativeFunctionNames = [];\r\n          this.lookupChain = [];\r\n          this.functionNodeDependencies = {};\r\n          this.functionCalls = {};\r\n      \r\n          if (this.rootNode) {\r\n            this.functionMap['kernel'] = this.rootNode;\r\n          }\r\n      \r\n          if (this.functionNodes) {\r\n            for (let i = 0; i < this.functionNodes.length; i++) {\r\n              this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];\r\n            }\r\n          }\r\n      \r\n          if (this.subKernelNodes) {\r\n            for (let i = 0; i < this.subKernelNodes.length; i++) {\r\n              this.functionMap[this.subKernelNodes[i].name] = this.subKernelNodes[i];\r\n            }\r\n          }\r\n      \r\n          if (this.nativeFunctions) {\r\n            for (let i = 0; i < this.nativeFunctions.length; i++) {\r\n              const nativeFunction = this.nativeFunctions[i];\r\n              this.nativeFunctionNames.push(nativeFunction.name);\r\n            }\r\n          }\r\n        }\r\n      \r\n        addFunctionNode(functionNode) {\r\n          if (!functionNode.name) throw new Error('functionNode.name needs set');\r\n          this.functionMap[functionNode.name] = functionNode;\r\n          if (functionNode.isRootKernel) {\r\n            this.rootNode = functionNode;\r\n          }\r\n        }\r\n      \r\n        traceFunctionCalls(functionName, retList) {\r\n          functionName = functionName || 'kernel';\r\n          retList = retList || [];\r\n      \r\n          if (this.nativeFunctionNames.indexOf(functionName) > -1) {\r\n            const nativeFunctionIndex = retList.indexOf(functionName);\r\n            if (nativeFunctionIndex === -1) {\r\n              retList.push(functionName);\r\n            } else {\r\n              const dependantNativeFunctionName = retList.splice(nativeFunctionIndex, 1)[0];\r\n              retList.push(dependantNativeFunctionName);\r\n            }\r\n            return retList;\r\n          }\r\n      \r\n          const functionNode = this.functionMap[functionName];\r\n          if (functionNode) {\r\n            const functionIndex = retList.indexOf(functionName);\r\n            if (functionIndex === -1) {\r\n              retList.push(functionName);\r\n              functionNode.toString(); \r\n              for (let i = 0; i < functionNode.calledFunctions.length; ++i) {\r\n                this.traceFunctionCalls(functionNode.calledFunctions[i], retList);\r\n              }\r\n            } else {\r\n              const dependantFunctionName = retList.splice(functionIndex, 1)[0];\r\n              retList.push(dependantFunctionName);\r\n            }\r\n          }\r\n      \r\n          return retList;\r\n        }\r\n      \r\n        getPrototypeString(functionName) {\r\n          return this.getPrototypes(functionName).join('\\n');\r\n        }\r\n      \r\n        getPrototypes(functionName) {\r\n          if (this.rootNode) {\r\n            this.rootNode.toString();\r\n          }\r\n          if (functionName) {\r\n            return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());\r\n          }\r\n          return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));\r\n        }\r\n      \r\n        getStringFromFunctionNames(functionList) {\r\n          const ret = [];\r\n          for (let i = 0; i < functionList.length; ++i) {\r\n            const node = this.functionMap[functionList[i]];\r\n            if (node) {\r\n              ret.push(this.functionMap[functionList[i]].toString());\r\n            }\r\n          }\r\n          return ret.join('\\n');\r\n        }\r\n      \r\n        getPrototypesFromFunctionNames(functionList) {\r\n          const ret = [];\r\n          for (let i = 0; i < functionList.length; ++i) {\r\n            const functionName = functionList[i];\r\n            const functionIndex = this.nativeFunctionNames.indexOf(functionName);\r\n            if (functionIndex > -1) {\r\n              ret.push(this.nativeFunctions[functionIndex].source);\r\n              continue;\r\n            }\r\n            const node = this.functionMap[functionName];\r\n            if (node) {\r\n              ret.push(node.toString());\r\n            }\r\n          }\r\n          return ret;\r\n        }\r\n      \r\n        toJSON() {\r\n          return this.traceFunctionCalls(this.rootNode.name).reverse().map(name => {\r\n            const nativeIndex = this.nativeFunctions.indexOf(name);\r\n            if (nativeIndex > -1) {\r\n              return {\r\n                name,\r\n                source: this.nativeFunctions[nativeIndex].source\r\n              };\r\n            } else if (this.functionMap[name]) {\r\n              return this.functionMap[name].toJSON();\r\n            } else {\r\n              throw new Error(`function ${ name } not found`);\r\n            }\r\n          });\r\n        }\r\n      \r\n        fromJSON(jsonFunctionNodes, FunctionNode) {\r\n          this.functionMap = {};\r\n          for (let i = 0; i < jsonFunctionNodes.length; i++) {\r\n            const jsonFunctionNode = jsonFunctionNodes[i];\r\n            this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);\r\n          }\r\n          return this;\r\n        }\r\n      \r\n        getString(functionName) {\r\n          if (functionName) {\r\n            return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());\r\n          }\r\n          return this.getStringFromFunctionNames(Object.keys(this.functionMap));\r\n        }\r\n      \r\n        lookupReturnType(functionName, ast, requestingNode) {\r\n          if (ast.type !== 'CallExpression') {\r\n            throw new Error(`expected ast type of \"CallExpression\", but is ${ ast.type }`);\r\n          }\r\n          if (this._isNativeFunction(functionName)) {\r\n            return this._lookupNativeFunctionReturnType(functionName);\r\n          } else if (this._isFunction(functionName)) {\r\n            const node = this._getFunction(functionName);\r\n            if (node.returnType) {\r\n              return node.returnType;\r\n            } else {\r\n              for (let i = 0; i < this.lookupChain.length; i++) {\r\n                if (this.lookupChain[i].ast === ast) {\r\n                  if (node.argumentTypes.length === 0 && ast.arguments.length > 0) {\r\n                    const args = ast.arguments;\r\n                    for (let j = 0; j < args.length; j++) {\r\n                      this.lookupChain.push({\r\n                        name: requestingNode.name,\r\n                        ast: args[i],\r\n                        requestingNode\r\n                      });\r\n                      node.argumentTypes[j] = requestingNode.getType(args[j]);\r\n                      this.lookupChain.pop();\r\n                    }\r\n                    return node.returnType = node.getType(node.getJsAST());\r\n                  }\r\n      \r\n                  throw new Error('circlical logic detected!');\r\n                }\r\n              }\r\n              this.lookupChain.push({\r\n                name: requestingNode.name,\r\n                ast,\r\n                requestingNode\r\n              });\r\n              const type = node.getType(node.getJsAST());\r\n              this.lookupChain.pop();\r\n              return node.returnType = type;\r\n            }\r\n          }\r\n      \r\n          return null;\r\n        }\r\n      \r\n        _getFunction(functionName) {\r\n          if (!this._isFunction(functionName)) {\r\n            new Error(`Function ${functionName} not found`);\r\n          }\r\n          return this.functionMap[functionName];\r\n        }\r\n      \r\n        _isFunction(functionName) {\r\n          return Boolean(this.functionMap[functionName]);\r\n        }\r\n      \r\n        _getNativeFunction(functionName) {\r\n          for (let i = 0; i < this.nativeFunctions.length; i++) {\r\n            if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        _isNativeFunction(functionName) {\r\n          return Boolean(this._getNativeFunction(functionName));\r\n        }\r\n      \r\n        _lookupNativeFunctionReturnType(functionName) {\r\n          let nativeFunction = this._getNativeFunction(functionName);\r\n          if (nativeFunction) {\r\n            return nativeFunction.returnType;\r\n          }\r\n          throw new Error(`Native function ${ functionName } not found`);\r\n        }\r\n      \r\n        lookupFunctionArgumentTypes(functionName) {\r\n          if (this._isNativeFunction(functionName)) {\r\n            return this._getNativeFunction(functionName).argumentTypes;\r\n          } else if (this._isFunction(functionName)) {\r\n            return this._getFunction(functionName).argumentTypes;\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        lookupFunctionArgumentName(functionName, argumentIndex) {\r\n          return this._getFunction(functionName).argumentNames[argumentIndex];\r\n        }\r\n      \r\n        lookupFunctionArgumentBitRatio(functionName, argumentName) {\r\n          if (!this._isFunction(functionName)) {\r\n            throw new Error('function not found');\r\n          }\r\n          if (this.rootNode.name === functionName) {\r\n            const i = this.rootNode.argumentNames.indexOf(argumentName);\r\n            if (i !== -1) {\r\n              return this.rootNode.argumentBitRatios[i];\r\n            }\r\n          }\r\n          const node = this._getFunction(functionName);\r\n          const i = node.argumentNames.indexOf(argumentName);\r\n          if (i === -1) {\r\n            throw new Error('argument not found');\r\n          }\r\n          const bitRatio = node.argumentBitRatios[i];\r\n          if (typeof bitRatio !== 'number') {\r\n            throw new Error('argument bit ratio not found');\r\n          }\r\n          return bitRatio;\r\n        }\r\n      \r\n        needsArgumentType(functionName, i) {\r\n          if (!this._isFunction(functionName)) return false;\r\n          const fnNode = this._getFunction(functionName);\r\n          return !fnNode.argumentTypes[i];\r\n        }\r\n      \r\n        assignArgumentType(functionName, i, argumentType, requestingNode) {\r\n          if (!this._isFunction(functionName)) return;\r\n          const fnNode = this._getFunction(functionName);\r\n          if (!fnNode.argumentTypes[i]) {\r\n            fnNode.argumentTypes[i] = argumentType;\r\n          }\r\n        }\r\n      \r\n        assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex) {\r\n          const node = this._getFunction(functionName);\r\n          if (this._isNativeFunction(calleeFunctionName)) return null;\r\n          const calleeNode = this._getFunction(calleeFunctionName);\r\n          const i = node.argumentNames.indexOf(argumentName);\r\n          if (i === -1) {\r\n            throw new Error(`Argument ${argumentName} not found in arguments from function ${functionName}`);\r\n          }\r\n          const bitRatio = node.argumentBitRatios[i];\r\n          if (typeof bitRatio !== 'number') {\r\n            throw new Error(`Bit ratio for argument ${argumentName} not found in function ${functionName}`);\r\n          }\r\n          if (!calleeNode.argumentBitRatios) {\r\n            calleeNode.argumentBitRatios = new Array(calleeNode.argumentNames.length);\r\n          }\r\n          const calleeBitRatio = calleeNode.argumentBitRatios[i];\r\n          if (typeof calleeBitRatio === 'number') {\r\n            if (calleeBitRatio !== bitRatio) {\r\n              throw new Error(`Incompatible bit ratio found at function ${functionName} at argument ${argumentName}`);\r\n            }\r\n            return calleeBitRatio;\r\n          }\r\n          calleeNode.argumentBitRatios[i] = bitRatio;\r\n          return bitRatio;\r\n        }\r\n      \r\n        trackFunctionCall(functionName, calleeFunctionName, args) {\r\n          if (!this.functionNodeDependencies[functionName]) {\r\n            this.functionNodeDependencies[functionName] = new Set();\r\n            this.functionCalls[functionName] = [];\r\n          }\r\n          this.functionNodeDependencies[functionName].add(calleeFunctionName);\r\n          this.functionCalls[functionName].push(args);\r\n        }\r\n      \r\n        getKernelResultType() {\r\n          return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);\r\n        }\r\n      \r\n        getSubKernelResultType(index) {\r\n          const subKernelNode = this.subKernelNodes[index];\r\n          let called = false;\r\n          for (let functionCallIndex = 0; functionCallIndex < this.rootNode.functionCalls.length; functionCallIndex++) {\r\n            const functionCall = this.rootNode.functionCalls[functionCallIndex];\r\n            if (functionCall.ast.callee.name === subKernelNode.name) {\r\n              called = true;\r\n            }\r\n          }\r\n          if (!called) {\r\n            throw new Error(`SubKernel ${ subKernelNode.name } never called by kernel`);\r\n          }\r\n          return subKernelNode.returnType || subKernelNode.getType(subKernelNode.getJsAST());\r\n        }\r\n      \r\n        getReturnTypes() {\r\n          const result = {\r\n            [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast),\r\n          };\r\n          const list = this.traceFunctionCalls(this.rootNode.name);\r\n          for (let i = 0; i < list.length; i++) {\r\n            const functionName = list[i];\r\n            const functionNode = this.functionMap[functionName];\r\n            result[functionName] = functionNode.getType(functionNode.ast);\r\n          }\r\n          return result;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        FunctionBuilder\r\n      };\r\n      },{}],10:[function(require,module,exports){\r\n      const acorn = require('acorn');\r\n      const { utils } = require('../utils');\r\n      const { FunctionTracer } = require('./function-tracer');\r\n      \r\n      class FunctionNode {\r\n        constructor(source, settings) {\r\n          if (!source && !settings.ast) {\r\n            throw new Error('source parameter is missing');\r\n          }\r\n          settings = settings || {};\r\n          this.source = source;\r\n          this.ast = null;\r\n          this.name = typeof source === 'string' ? settings.isRootKernel ?\r\n            'kernel' :\r\n            (settings.name || utils.getFunctionNameFromString(source)) : null;\r\n          this.calledFunctions = [];\r\n          this.constants = {};\r\n          this.constantTypes = {};\r\n          this.constantBitRatios = {};\r\n          this.isRootKernel = false;\r\n          this.isSubKernel = false;\r\n          this.debug = null;\r\n          this.functions = null;\r\n          this.identifiers = null;\r\n          this.contexts = null;\r\n          this.functionCalls = null;\r\n          this.states = [];\r\n          this.needsArgumentType = null;\r\n          this.assignArgumentType = null;\r\n          this.lookupReturnType = null;\r\n          this.lookupFunctionArgumentTypes = null;\r\n          this.lookupFunctionArgumentBitRatio = null;\r\n          this.triggerImplyArgumentType = null;\r\n          this.triggerImplyArgumentBitRatio = null;\r\n          this.onNestedFunction = null;\r\n          this.onFunctionCall = null;\r\n          this.optimizeFloatMemory = null;\r\n          this.precision = null;\r\n          this.loopMaxIterations = null;\r\n          this.argumentNames = (typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null);\r\n          this.argumentTypes = [];\r\n          this.argumentSizes = [];\r\n          this.argumentBitRatios = null;\r\n          this.returnType = null;\r\n          this.output = [];\r\n          this.plugins = null;\r\n          this.leadingReturnStatement = null;\r\n          this.followingReturnStatement = null;\r\n          this.dynamicOutput = null;\r\n          this.dynamicArguments = null;\r\n          this.strictTypingChecking = false;\r\n          this.fixIntegerDivisionAccuracy = null;\r\n      \r\n          if (settings) {\r\n            for (const p in settings) {\r\n              if (!settings.hasOwnProperty(p)) continue;\r\n              if (!this.hasOwnProperty(p)) continue;\r\n              this[p] = settings[p];\r\n            }\r\n          }\r\n      \r\n          this.literalTypes = {};\r\n      \r\n          this.validate();\r\n          this._string = null;\r\n          this._internalVariableNames = {};\r\n        }\r\n      \r\n        validate() {\r\n          if (typeof this.source !== 'string' && !this.ast) {\r\n            throw new Error('this.source not a string');\r\n          }\r\n      \r\n          if (!this.ast && !utils.isFunctionString(this.source)) {\r\n            throw new Error('this.source not a function string');\r\n          }\r\n      \r\n          if (!this.name) {\r\n            throw new Error('this.name could not be set');\r\n          }\r\n      \r\n          if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {\r\n            throw new Error(`argumentTypes count of ${ this.argumentTypes.length } exceeds ${ this.argumentNames.length }`);\r\n          }\r\n      \r\n          if (this.output.length < 1) {\r\n            throw new Error('this.output is not big enough');\r\n          }\r\n        }\r\n      \r\n        isIdentifierConstant(name) {\r\n          if (!this.constants) return false;\r\n          return this.constants.hasOwnProperty(name);\r\n        }\r\n      \r\n        isInput(argumentName) {\r\n          return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';\r\n        }\r\n      \r\n        pushState(state) {\r\n          this.states.push(state);\r\n        }\r\n      \r\n        popState(state) {\r\n          if (this.state !== state) {\r\n            throw new Error(`Cannot popState ${ state } when in ${ this.state }`);\r\n          }\r\n          this.states.pop();\r\n        }\r\n      \r\n        isState(state) {\r\n          return this.state === state;\r\n        }\r\n      \r\n        get state() {\r\n          return this.states[this.states.length - 1];\r\n        }\r\n      \r\n        astMemberExpressionUnroll(ast) {\r\n          if (ast.type === 'Identifier') {\r\n            return ast.name;\r\n          } else if (ast.type === 'ThisExpression') {\r\n            return 'this';\r\n          }\r\n      \r\n          if (ast.type === 'MemberExpression') {\r\n            if (ast.object && ast.property) {\r\n              if (ast.object.hasOwnProperty('name') && ast.object.name !== 'Math') {\r\n                return this.astMemberExpressionUnroll(ast.property);\r\n              }\r\n      \r\n              return (\r\n                this.astMemberExpressionUnroll(ast.object) +\r\n                '.' +\r\n                this.astMemberExpressionUnroll(ast.property)\r\n              );\r\n            }\r\n          }\r\n      \r\n          if (ast.hasOwnProperty('expressions')) {\r\n            const firstExpression = ast.expressions[0];\r\n            if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {\r\n              return this.astMemberExpressionUnroll(ast.expressions[1]);\r\n            }\r\n          }\r\n      \r\n          throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);\r\n        }\r\n      \r\n        getJsAST(inParser) {\r\n          if (this.ast) {\r\n            return this.ast;\r\n          }\r\n          if (typeof this.source === 'object') {\r\n            this.traceFunctionAST(this.source);\r\n            return this.ast = this.source;\r\n          }\r\n      \r\n          inParser = inParser || acorn;\r\n          if (inParser === null) {\r\n            throw new Error('Missing JS to AST parser');\r\n          }\r\n      \r\n          const ast = Object.freeze(inParser.parse(`const parser_${ this.name } = ${ this.source };`, {\r\n            locations: true\r\n          }));\r\n          const functionAST = ast.body[0].declarations[0].init;\r\n          this.traceFunctionAST(functionAST);\r\n      \r\n          if (!ast) {\r\n            throw new Error('Failed to parse JS code');\r\n          }\r\n      \r\n          return this.ast = functionAST;\r\n        }\r\n      \r\n        traceFunctionAST(ast) {\r\n          const { contexts, declarations, functions, identifiers, functionCalls } = new FunctionTracer(ast);\r\n          this.contexts = contexts;\r\n          this.identifiers = identifiers;\r\n          this.functionCalls = functionCalls;\r\n          this.functions = functions;\r\n          for (let i = 0; i < declarations.length; i++) {\r\n            const declaration = declarations[i];\r\n            const { ast, inForLoopInit, inForLoopTest } = declaration;\r\n            const { init } = ast;\r\n            const dependencies = this.getDependencies(init);\r\n            let valueType = null;\r\n      \r\n            if (inForLoopInit && inForLoopTest) {\r\n              valueType = 'Integer';\r\n            } else {\r\n              if (init) {\r\n                const realType = this.getType(init);\r\n                switch (realType) {\r\n                  case 'Integer':\r\n                  case 'Float':\r\n                  case 'Number':\r\n                    if (init.type === 'MemberExpression') {\r\n                      valueType = realType;\r\n                    } else {\r\n                      valueType = 'Number';\r\n                    }\r\n                    break;\r\n                  case 'LiteralInteger':\r\n                    valueType = 'Number';\r\n                    break;\r\n                  default:\r\n                    valueType = realType;\r\n                }\r\n              }\r\n            }\r\n            declaration.valueType = valueType;\r\n            declaration.dependencies = dependencies;\r\n            declaration.isSafe = this.isSafeDependencies(dependencies);\r\n          }\r\n      \r\n          for (let i = 0; i < functions.length; i++) {\r\n            this.onNestedFunction(functions[i], this.source);\r\n          }\r\n        }\r\n      \r\n        getDeclaration(ast) {\r\n          for (let i = 0; i < this.identifiers.length; i++) {\r\n            const identifier = this.identifiers[i];\r\n            if (ast === identifier.ast) {\r\n              return identifier.declaration;\r\n            }\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        getVariableType(ast) {\r\n          if (ast.type !== 'Identifier') {\r\n            throw new Error(`ast of ${ast.type} not \"Identifier\"`);\r\n          }\r\n          let type = null;\r\n          const argumentIndex = this.argumentNames.indexOf(ast.name);\r\n          if (argumentIndex === -1) {\r\n            const declaration = this.getDeclaration(ast);\r\n            if (declaration) {\r\n              return declaration.valueType;\r\n            }\r\n          } else {\r\n            const argumentType = this.argumentTypes[argumentIndex];\r\n            if (argumentType) {\r\n              type = argumentType;\r\n            }\r\n          }\r\n          if (!type && this.strictTypingChecking) {\r\n            throw new Error(`Declaration of ${name} not found`);\r\n          }\r\n          return type;\r\n        }\r\n      \r\n        getLookupType(type) {\r\n          if (!typeLookupMap.hasOwnProperty(type)) {\r\n            throw new Error(`unknown typeLookupMap ${ type }`);\r\n          }\r\n          return typeLookupMap[type];\r\n        }\r\n      \r\n        getConstantType(constantName) {\r\n          if (this.constantTypes[constantName]) {\r\n            const type = this.constantTypes[constantName];\r\n            if (type === 'Float') {\r\n              return 'Number';\r\n            } else {\r\n              return type;\r\n            }\r\n          }\r\n          throw new Error(`Type for constant \"${ constantName }\" not declared`);\r\n        }\r\n      \r\n        toString() {\r\n          if (this._string) return this._string;\r\n          return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();\r\n        }\r\n      \r\n        toJSON() {\r\n          const settings = {\r\n            source: this.source,\r\n            name: this.name,\r\n            constants: this.constants,\r\n            constantTypes: this.constantTypes,\r\n            isRootKernel: this.isRootKernel,\r\n            isSubKernel: this.isSubKernel,\r\n            debug: this.debug,\r\n            output: this.output,\r\n            loopMaxIterations: this.loopMaxIterations,\r\n            argumentNames: this.argumentNames,\r\n            argumentTypes: this.argumentTypes,\r\n            argumentSizes: this.argumentSizes,\r\n            returnType: this.returnType,\r\n            leadingReturnStatement: this.leadingReturnStatement,\r\n            followingReturnStatement: this.followingReturnStatement,\r\n          };\r\n      \r\n          return {\r\n            ast: this.ast,\r\n            settings\r\n          };\r\n        }\r\n      \r\n        getType(ast) {\r\n          if (Array.isArray(ast)) {\r\n            return this.getType(ast[ast.length - 1]);\r\n          }\r\n          switch (ast.type) {\r\n            case 'BlockStatement':\r\n              return this.getType(ast.body);\r\n            case 'ArrayExpression':\r\n              const childType = this.getType(ast.elements[0]);\r\n              switch (childType) {\r\n                case 'Array(2)':\r\n                case 'Array(3)':\r\n                case 'Array(4)':\r\n                  return `Matrix(${ast.elements.length})`;\r\n              }\r\n              return `Array(${ ast.elements.length })`;\r\n            case 'Literal':\r\n              const literalKey = this.astKey(ast);\r\n              if (this.literalTypes[literalKey]) {\r\n                return this.literalTypes[literalKey];\r\n              }\r\n              if (Number.isInteger(ast.value)) {\r\n                return 'LiteralInteger';\r\n              } else if (ast.value === true || ast.value === false) {\r\n                return 'Boolean';\r\n              } else {\r\n                return 'Number';\r\n              }\r\n              case 'AssignmentExpression':\r\n                return this.getType(ast.left);\r\n              case 'CallExpression':\r\n                if (this.isAstMathFunction(ast)) {\r\n                  return 'Number';\r\n                }\r\n                if (!ast.callee || !ast.callee.name) {\r\n                  if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {\r\n                    const functionName = ast.callee.expressions[ast.callee.expressions.length - 1].property.name;\r\n                    this.inferArgumentTypesIfNeeded(functionName, ast.arguments);\r\n                    return this.lookupReturnType(functionName, ast, this);\r\n                  }\r\n                  if (this.getVariableSignature(ast.callee, true) === 'this.color') {\r\n                    return null;\r\n                  }\r\n                  if (ast.callee.type === 'MemberExpression' && ast.callee.object && ast.callee.property && ast.callee.property.name && ast.arguments) {\r\n                    const functionName = ast.callee.property.name;\r\n                    this.inferArgumentTypesIfNeeded(functionName, ast.arguments);\r\n                    return this.lookupReturnType(functionName, ast, this);\r\n                  }\r\n                  throw this.astErrorOutput('Unknown call expression', ast);\r\n                }\r\n                if (ast.callee && ast.callee.name) {\r\n                  const functionName = ast.callee.name;\r\n                  this.inferArgumentTypesIfNeeded(functionName, ast.arguments);\r\n                  return this.lookupReturnType(functionName, ast, this);\r\n                }\r\n                throw this.astErrorOutput(`Unhandled getType Type \"${ ast.type }\"`, ast);\r\n              case 'LogicalExpression':\r\n                return 'Boolean';\r\n              case 'BinaryExpression':\r\n                switch (ast.operator) {\r\n                  case '%':\r\n                  case '/':\r\n                    if (this.fixIntegerDivisionAccuracy) {\r\n                      return 'Number';\r\n                    } else {\r\n                      break;\r\n                    }\r\n                    case '>':\r\n                    case '<':\r\n                      return 'Boolean';\r\n                    case '&':\r\n                    case '|':\r\n                    case '^':\r\n                    case '<<':\r\n                    case '>>':\r\n                    case '>>>':\r\n                      return 'Integer';\r\n                }\r\n                const type = this.getType(ast.left);\r\n                if (this.isState('skip-literal-correction')) return type;\r\n                if (type === 'LiteralInteger') {\r\n                  const rightType = this.getType(ast.right);\r\n                  if (rightType === 'LiteralInteger') {\r\n                    if (ast.left.value % 1 === 0) {\r\n                      return 'Integer';\r\n                    } else {\r\n                      return 'Float';\r\n                    }\r\n                  }\r\n                  return rightType;\r\n                }\r\n                return typeLookupMap[type] || type;\r\n              case 'UpdateExpression':\r\n                return this.getType(ast.argument);\r\n              case 'UnaryExpression':\r\n                if (ast.operator === '~') {\r\n                  return 'Integer';\r\n                }\r\n                return this.getType(ast.argument);\r\n              case 'VariableDeclaration': {\r\n                const declarations = ast.declarations;\r\n                let lastType;\r\n                for (let i = 0; i < declarations.length; i++) {\r\n                  const declaration = declarations[i];\r\n                  lastType = this.getType(declaration);\r\n                }\r\n                if (!lastType) {\r\n                  throw this.astErrorOutput(`Unable to find type for declaration`, ast);\r\n                }\r\n                return lastType;\r\n              }\r\n              case 'VariableDeclarator':\r\n                const declaration = this.getDeclaration(ast.id);\r\n                if (!declaration) {\r\n                  throw this.astErrorOutput(`Unable to find declarator`, ast);\r\n                }\r\n      \r\n                if (!declaration.valueType) {\r\n                  throw this.astErrorOutput(`Unable to find declarator valueType`, ast);\r\n                }\r\n      \r\n                return declaration.valueType;\r\n              case 'Identifier':\r\n                if (ast.name === 'Infinity') {\r\n                  return 'Number';\r\n                }\r\n                if (this.isAstVariable(ast)) {\r\n                  const signature = this.getVariableSignature(ast);\r\n                  if (signature === 'value') {\r\n                    return this.getCheckVariableType(ast);\r\n                  }\r\n                }\r\n                const origin = this.findIdentifierOrigin(ast);\r\n                if (origin && origin.init) {\r\n                  return this.getType(origin.init);\r\n                }\r\n                return null;\r\n              case 'ReturnStatement':\r\n                return this.getType(ast.argument);\r\n              case 'MemberExpression':\r\n                if (this.isAstMathFunction(ast)) {\r\n                  switch (ast.property.name) {\r\n                    case 'ceil':\r\n                      return 'Integer';\r\n                    case 'floor':\r\n                      return 'Integer';\r\n                    case 'round':\r\n                      return 'Integer';\r\n                  }\r\n                  return 'Number';\r\n                }\r\n                if (this.isAstVariable(ast)) {\r\n                  const variableSignature = this.getVariableSignature(ast);\r\n                  switch (variableSignature) {\r\n                    case 'value[]':\r\n                      return this.getLookupType(this.getCheckVariableType(ast.object));\r\n                    case 'value[][]':\r\n                      return this.getLookupType(this.getCheckVariableType(ast.object.object));\r\n                    case 'value[][][]':\r\n                      return this.getLookupType(this.getCheckVariableType(ast.object.object.object));\r\n                    case 'value[][][][]':\r\n                      return this.getLookupType(this.getCheckVariableType(ast.object.object.object.object));\r\n                    case 'value.thread.value':\r\n                    case 'this.thread.value':\r\n                      return 'Integer';\r\n                    case 'this.output.value':\r\n                      return this.dynamicOutput ? 'Integer' : 'LiteralInteger';\r\n                    case 'this.constants.value':\r\n                      return this.getConstantType(ast.property.name);\r\n                    case 'this.constants.value[]':\r\n                      return this.getLookupType(this.getConstantType(ast.object.property.name));\r\n                    case 'this.constants.value[][]':\r\n                      return this.getLookupType(this.getConstantType(ast.object.object.property.name));\r\n                    case 'this.constants.value[][][]':\r\n                      return this.getLookupType(this.getConstantType(ast.object.object.object.property.name));\r\n                    case 'this.constants.value[][][][]':\r\n                      return this.getLookupType(this.getConstantType(ast.object.object.object.object.property.name));\r\n                    case 'fn()[]':\r\n                    case 'fn()[][]':\r\n                    case 'fn()[][][]':\r\n                      return this.getLookupType(this.getType(ast.object));\r\n                    case 'value.value':\r\n                      if (this.isAstMathVariable(ast)) {\r\n                        return 'Number';\r\n                      }\r\n                      switch (ast.property.name) {\r\n                        case 'r':\r\n                        case 'g':\r\n                        case 'b':\r\n                        case 'a':\r\n                          return this.getLookupType(this.getCheckVariableType(ast.object));\r\n                      }\r\n                      case '[][]':\r\n                        return 'Number';\r\n                  }\r\n                  throw this.astErrorOutput('Unhandled getType MemberExpression', ast);\r\n                }\r\n                throw this.astErrorOutput('Unhandled getType MemberExpression', ast);\r\n              case 'ConditionalExpression':\r\n                return this.getType(ast.consequent);\r\n              case 'FunctionDeclaration':\r\n              case 'FunctionExpression':\r\n                const lastReturn = this.findLastReturn(ast.body);\r\n                if (lastReturn) {\r\n                  return this.getType(lastReturn);\r\n                }\r\n                return null;\r\n              case 'IfStatement':\r\n                return this.getType(ast.consequent);\r\n              case 'SequenceExpression':\r\n                return this.getType(ast.expressions[ast.expressions.length - 1]);\r\n              default:\r\n                throw this.astErrorOutput(`Unhandled getType Type \"${ ast.type }\"`, ast);\r\n          }\r\n        }\r\n      \r\n        getCheckVariableType(ast) {\r\n          const type = this.getVariableType(ast);\r\n          if (!type) {\r\n            throw this.astErrorOutput(`${ast.type} is not defined`, ast);\r\n          }\r\n          return type;\r\n        }\r\n      \r\n        inferArgumentTypesIfNeeded(functionName, args) {\r\n          for (let i = 0; i < args.length; i++) {\r\n            if (!this.needsArgumentType(functionName, i)) continue;\r\n            const type = this.getType(args[i]);\r\n            if (!type) {\r\n              throw this.astErrorOutput(`Unable to infer argument ${i}`, args[i]);\r\n            }\r\n            this.assignArgumentType(functionName, i, type);\r\n          }\r\n        }\r\n      \r\n        isAstMathVariable(ast) {\r\n          const mathProperties = [\r\n            'E',\r\n            'PI',\r\n            'SQRT2',\r\n            'SQRT1_2',\r\n            'LN2',\r\n            'LN10',\r\n            'LOG2E',\r\n            'LOG10E',\r\n          ];\r\n          return ast.type === 'MemberExpression' &&\r\n            ast.object && ast.object.type === 'Identifier' &&\r\n            ast.object.name === 'Math' &&\r\n            ast.property &&\r\n            ast.property.type === 'Identifier' &&\r\n            mathProperties.indexOf(ast.property.name) > -1;\r\n        }\r\n      \r\n        isAstMathFunction(ast) {\r\n          const mathFunctions = [\r\n            'abs',\r\n            'acos',\r\n            'acosh',\r\n            'asin',\r\n            'asinh',\r\n            'atan',\r\n            'atan2',\r\n            'atanh',\r\n            'cbrt',\r\n            'ceil',\r\n            'clz32',\r\n            'cos',\r\n            'cosh',\r\n            'expm1',\r\n            'exp',\r\n            'floor',\r\n            'fround',\r\n            'imul',\r\n            'log',\r\n            'log2',\r\n            'log10',\r\n            'log1p',\r\n            'max',\r\n            'min',\r\n            'pow',\r\n            'random',\r\n            'round',\r\n            'sign',\r\n            'sin',\r\n            'sinh',\r\n            'sqrt',\r\n            'tan',\r\n            'tanh',\r\n            'trunc',\r\n          ];\r\n          return ast.type === 'CallExpression' &&\r\n            ast.callee &&\r\n            ast.callee.type === 'MemberExpression' &&\r\n            ast.callee.object &&\r\n            ast.callee.object.type === 'Identifier' &&\r\n            ast.callee.object.name === 'Math' &&\r\n            ast.callee.property &&\r\n            ast.callee.property.type === 'Identifier' &&\r\n            mathFunctions.indexOf(ast.callee.property.name) > -1;\r\n        }\r\n      \r\n        isAstVariable(ast) {\r\n          return ast.type === 'Identifier' || ast.type === 'MemberExpression';\r\n        }\r\n      \r\n        isSafe(ast) {\r\n          return this.isSafeDependencies(this.getDependencies(ast));\r\n        }\r\n      \r\n        isSafeDependencies(dependencies) {\r\n          return dependencies && dependencies.every ? dependencies.every(dependency => dependency.isSafe) : true;\r\n        }\r\n      \r\n        getDependencies(ast, dependencies, isNotSafe) {\r\n          if (!dependencies) {\r\n            dependencies = [];\r\n          }\r\n          if (!ast) return null;\r\n          if (Array.isArray(ast)) {\r\n            for (let i = 0; i < ast.length; i++) {\r\n              this.getDependencies(ast[i], dependencies, isNotSafe);\r\n            }\r\n            return dependencies;\r\n          }\r\n          switch (ast.type) {\r\n            case 'AssignmentExpression':\r\n              this.getDependencies(ast.left, dependencies, isNotSafe);\r\n              this.getDependencies(ast.right, dependencies, isNotSafe);\r\n              return dependencies;\r\n            case 'ConditionalExpression':\r\n              this.getDependencies(ast.test, dependencies, isNotSafe);\r\n              this.getDependencies(ast.alternate, dependencies, isNotSafe);\r\n              this.getDependencies(ast.consequent, dependencies, isNotSafe);\r\n              return dependencies;\r\n            case 'Literal':\r\n              dependencies.push({\r\n                origin: 'literal',\r\n                value: ast.value,\r\n                isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)\r\n              });\r\n              break;\r\n            case 'VariableDeclarator':\r\n              return this.getDependencies(ast.init, dependencies, isNotSafe);\r\n            case 'Identifier':\r\n              const declaration = this.getDeclaration(ast);\r\n              if (declaration) {\r\n                dependencies.push({\r\n                  name: ast.name,\r\n                  origin: 'declaration',\r\n                  isSafe: isNotSafe ? false : this.isSafeDependencies(declaration.dependencies),\r\n                });\r\n              } else if (this.argumentNames.indexOf(ast.name) > -1) {\r\n                dependencies.push({\r\n                  name: ast.name,\r\n                  origin: 'argument',\r\n                  isSafe: false,\r\n                });\r\n              } else if (this.strictTypingChecking) {\r\n                throw new Error(`Cannot find identifier origin \"${ast.name}\"`);\r\n              }\r\n              break;\r\n            case 'FunctionDeclaration':\r\n              return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);\r\n            case 'ReturnStatement':\r\n              return this.getDependencies(ast.argument, dependencies);\r\n            case 'BinaryExpression':\r\n            case 'LogicalExpression':\r\n              isNotSafe = (ast.operator === '/' || ast.operator === '*');\r\n              this.getDependencies(ast.left, dependencies, isNotSafe);\r\n              this.getDependencies(ast.right, dependencies, isNotSafe);\r\n              return dependencies;\r\n            case 'UnaryExpression':\r\n            case 'UpdateExpression':\r\n              return this.getDependencies(ast.argument, dependencies, isNotSafe);\r\n            case 'VariableDeclaration':\r\n              return this.getDependencies(ast.declarations, dependencies, isNotSafe);\r\n            case 'ArrayExpression':\r\n              dependencies.push({\r\n                origin: 'declaration',\r\n                isSafe: true,\r\n              });\r\n              return dependencies;\r\n            case 'CallExpression':\r\n              dependencies.push({\r\n                origin: 'function',\r\n                isSafe: true,\r\n              });\r\n              return dependencies;\r\n            case 'MemberExpression':\r\n              const details = this.getMemberExpressionDetails(ast);\r\n              switch (details.signature) {\r\n                case 'value[]':\r\n                  this.getDependencies(ast.object, dependencies, isNotSafe);\r\n                  break;\r\n                case 'value[][]':\r\n                  this.getDependencies(ast.object.object, dependencies, isNotSafe);\r\n                  break;\r\n                case 'value[][][]':\r\n                  this.getDependencies(ast.object.object.object, dependencies, isNotSafe);\r\n                  break;\r\n                case 'this.output.value':\r\n                  if (this.dynamicOutput) {\r\n                    dependencies.push({\r\n                      name: details.name,\r\n                      origin: 'output',\r\n                      isSafe: false,\r\n                    });\r\n                  }\r\n                  break;\r\n              }\r\n              if (details) {\r\n                if (details.property) {\r\n                  this.getDependencies(details.property, dependencies, isNotSafe);\r\n                }\r\n                if (details.xProperty) {\r\n                  this.getDependencies(details.xProperty, dependencies, isNotSafe);\r\n                }\r\n                if (details.yProperty) {\r\n                  this.getDependencies(details.yProperty, dependencies, isNotSafe);\r\n                }\r\n                if (details.zProperty) {\r\n                  this.getDependencies(details.zProperty, dependencies, isNotSafe);\r\n                }\r\n                return dependencies;\r\n              }\r\n              case 'SequenceExpression':\r\n                return this.getDependencies(ast.expressions, dependencies, isNotSafe);\r\n              default:\r\n                throw this.astErrorOutput(`Unhandled type ${ ast.type } in getDependencies`, ast);\r\n          }\r\n          return dependencies;\r\n        }\r\n      \r\n        getVariableSignature(ast, returnRawValue) {\r\n          if (!this.isAstVariable(ast)) {\r\n            throw new Error(`ast of type \"${ ast.type }\" is not a variable signature`);\r\n          }\r\n          if (ast.type === 'Identifier') {\r\n            return 'value';\r\n          }\r\n          const signature = [];\r\n          while (true) {\r\n            if (!ast) break;\r\n            if (ast.computed) {\r\n              signature.push('[]');\r\n            } else if (ast.type === 'ThisExpression') {\r\n              signature.unshift('this');\r\n            } else if (ast.property && ast.property.name) {\r\n              if (\r\n                ast.property.name === 'x' ||\r\n                ast.property.name === 'y' ||\r\n                ast.property.name === 'z'\r\n              ) {\r\n                signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');\r\n              } else if (\r\n                ast.property.name === 'constants' ||\r\n                ast.property.name === 'thread' ||\r\n                ast.property.name === 'output'\r\n              ) {\r\n                signature.unshift('.' + ast.property.name);\r\n              } else {\r\n                signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');\r\n              }\r\n            } else if (ast.name) {\r\n              signature.unshift(returnRawValue ? ast.name : 'value');\r\n            } else if (ast.callee && ast.callee.name) {\r\n              signature.unshift(returnRawValue ? ast.callee.name + '()' : 'fn()');\r\n            } else if (ast.elements) {\r\n              signature.unshift('[]');\r\n            } else {\r\n              signature.unshift('unknown');\r\n            }\r\n            ast = ast.object;\r\n          }\r\n      \r\n          const signatureString = signature.join('');\r\n          if (returnRawValue) {\r\n            return signatureString;\r\n          }\r\n      \r\n          const allowedExpressions = [\r\n            'value',\r\n            'value[]',\r\n            'value[][]',\r\n            'value[][][]',\r\n            'value[][][][]',\r\n            'value.value',\r\n            'value.thread.value',\r\n            'this.thread.value',\r\n            'this.output.value',\r\n            'this.constants.value',\r\n            'this.constants.value[]',\r\n            'this.constants.value[][]',\r\n            'this.constants.value[][][]',\r\n            'this.constants.value[][][][]',\r\n            'fn()[]',\r\n            'fn()[][]',\r\n            'fn()[][][]',\r\n            '[][]',\r\n          ];\r\n          if (allowedExpressions.indexOf(signatureString) > -1) {\r\n            return signatureString;\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        build() {\r\n          return this.toString().length > 0;\r\n        }\r\n      \r\n        astGeneric(ast, retArr) {\r\n          if (ast === null) {\r\n            throw this.astErrorOutput('NULL ast', ast);\r\n          } else {\r\n            if (Array.isArray(ast)) {\r\n              for (let i = 0; i < ast.length; i++) {\r\n                this.astGeneric(ast[i], retArr);\r\n              }\r\n              return retArr;\r\n            }\r\n      \r\n            switch (ast.type) {\r\n              case 'FunctionDeclaration':\r\n                return this.astFunctionDeclaration(ast, retArr);\r\n              case 'FunctionExpression':\r\n                return this.astFunctionExpression(ast, retArr);\r\n              case 'ReturnStatement':\r\n                return this.astReturnStatement(ast, retArr);\r\n              case 'Literal':\r\n                return this.astLiteral(ast, retArr);\r\n              case 'BinaryExpression':\r\n                return this.astBinaryExpression(ast, retArr);\r\n              case 'Identifier':\r\n                return this.astIdentifierExpression(ast, retArr);\r\n              case 'AssignmentExpression':\r\n                return this.astAssignmentExpression(ast, retArr);\r\n              case 'ExpressionStatement':\r\n                return this.astExpressionStatement(ast, retArr);\r\n              case 'EmptyStatement':\r\n                return this.astEmptyStatement(ast, retArr);\r\n              case 'BlockStatement':\r\n                return this.astBlockStatement(ast, retArr);\r\n              case 'IfStatement':\r\n                return this.astIfStatement(ast, retArr);\r\n              case 'SwitchStatement':\r\n                return this.astSwitchStatement(ast, retArr);\r\n              case 'BreakStatement':\r\n                return this.astBreakStatement(ast, retArr);\r\n              case 'ContinueStatement':\r\n                return this.astContinueStatement(ast, retArr);\r\n              case 'ForStatement':\r\n                return this.astForStatement(ast, retArr);\r\n              case 'WhileStatement':\r\n                return this.astWhileStatement(ast, retArr);\r\n              case 'DoWhileStatement':\r\n                return this.astDoWhileStatement(ast, retArr);\r\n              case 'VariableDeclaration':\r\n                return this.astVariableDeclaration(ast, retArr);\r\n              case 'VariableDeclarator':\r\n                return this.astVariableDeclarator(ast, retArr);\r\n              case 'ThisExpression':\r\n                return this.astThisExpression(ast, retArr);\r\n              case 'SequenceExpression':\r\n                return this.astSequenceExpression(ast, retArr);\r\n              case 'UnaryExpression':\r\n                return this.astUnaryExpression(ast, retArr);\r\n              case 'UpdateExpression':\r\n                return this.astUpdateExpression(ast, retArr);\r\n              case 'LogicalExpression':\r\n                return this.astLogicalExpression(ast, retArr);\r\n              case 'MemberExpression':\r\n                return this.astMemberExpression(ast, retArr);\r\n              case 'CallExpression':\r\n                return this.astCallExpression(ast, retArr);\r\n              case 'ArrayExpression':\r\n                return this.astArrayExpression(ast, retArr);\r\n              case 'DebuggerStatement':\r\n                return this.astDebuggerStatement(ast, retArr);\r\n              case 'ConditionalExpression':\r\n                return this.astConditionalExpression(ast, retArr);\r\n            }\r\n      \r\n            throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);\r\n          }\r\n        }\r\n        astErrorOutput(error, ast) {\r\n          if (typeof this.source !== 'string') {\r\n            return new Error(error);\r\n          }\r\n      \r\n          const debugString = utils.getAstString(this.source, ast);\r\n          const leadingSource = this.source.substr(ast.start);\r\n          const splitLines = leadingSource.split(/\\n/);\r\n          const lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;\r\n          return new Error(`${error} on line ${ splitLines.length }, position ${ lineBefore.length }:\\n ${ debugString }`);\r\n        }\r\n      \r\n        astDebuggerStatement(arrNode, retArr) {\r\n          return retArr;\r\n        }\r\n      \r\n        astConditionalExpression(ast, retArr) {\r\n          if (ast.type !== 'ConditionalExpression') {\r\n            throw this.astErrorOutput('Not a conditional expression', ast);\r\n          }\r\n          retArr.push('(');\r\n          this.astGeneric(ast.test, retArr);\r\n          retArr.push('?');\r\n          this.astGeneric(ast.consequent, retArr);\r\n          retArr.push(':');\r\n          this.astGeneric(ast.alternate, retArr);\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        astFunction(ast, retArr) {\r\n          throw new Error(`\"astFunction\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        astFunctionDeclaration(ast, retArr) {\r\n          if (this.isChildFunction(ast)) {\r\n            return retArr;\r\n          }\r\n          return this.astFunction(ast, retArr);\r\n        }\r\n        astFunctionExpression(ast, retArr) {\r\n          if (this.isChildFunction(ast)) {\r\n            return retArr;\r\n          }\r\n          return this.astFunction(ast, retArr);\r\n        }\r\n        isChildFunction(ast) {\r\n          for (let i = 0; i < this.functions.length; i++) {\r\n            if (this.functions[i] === ast) {\r\n              return true;\r\n            }\r\n          }\r\n          return false;\r\n        }\r\n        astReturnStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astLiteral(ast, retArr) {\r\n          this.literalTypes[this.astKey(ast)] = 'Number';\r\n          return retArr;\r\n        }\r\n        astBinaryExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astIdentifierExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astAssignmentExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astExpressionStatement(esNode, retArr) {\r\n          this.astGeneric(esNode.expression, retArr);\r\n          retArr.push(';');\r\n          return retArr;\r\n        }\r\n        astEmptyStatement(eNode, retArr) {\r\n          return retArr;\r\n        }\r\n        astBlockStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astIfStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astSwitchStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astBreakStatement(brNode, retArr) {\r\n          retArr.push('break;');\r\n          return retArr;\r\n        }\r\n        astContinueStatement(crNode, retArr) {\r\n          retArr.push('continue;\\n');\r\n          return retArr;\r\n        }\r\n        astForStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astWhileStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astDoWhileStatement(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astVariableDeclarator(iVarDecNode, retArr) {\r\n          this.astGeneric(iVarDecNode.id, retArr);\r\n          if (iVarDecNode.init !== null) {\r\n            retArr.push('=');\r\n            this.astGeneric(iVarDecNode.init, retArr);\r\n          }\r\n          return retArr;\r\n        }\r\n        astThisExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astSequenceExpression(sNode, retArr) {\r\n          const { expressions } = sNode;\r\n          const sequenceResult = [];\r\n          for (let i = 0; i < expressions.length; i++) {\r\n            const expression = expressions[i];\r\n            const expressionResult = [];\r\n            this.astGeneric(expression, expressionResult);\r\n            sequenceResult.push(expressionResult.join(''));\r\n          }\r\n          if (sequenceResult.length > 1) {\r\n            retArr.push('(', sequenceResult.join(','), ')');\r\n          } else {\r\n            retArr.push(sequenceResult[0]);\r\n          }\r\n          return retArr;\r\n        }\r\n        astUnaryExpression(uNode, retArr) {\r\n          const unaryResult = this.checkAndUpconvertBitwiseUnary(uNode, retArr);\r\n          if (unaryResult) {\r\n            return retArr;\r\n          }\r\n      \r\n          if (uNode.prefix) {\r\n            retArr.push(uNode.operator);\r\n            this.astGeneric(uNode.argument, retArr);\r\n          } else {\r\n            this.astGeneric(uNode.argument, retArr);\r\n            retArr.push(uNode.operator);\r\n          }\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        checkAndUpconvertBitwiseUnary(uNode, retArr) {}\r\n      \r\n        astUpdateExpression(uNode, retArr) {\r\n          if (uNode.prefix) {\r\n            retArr.push(uNode.operator);\r\n            this.astGeneric(uNode.argument, retArr);\r\n          } else {\r\n            this.astGeneric(uNode.argument, retArr);\r\n            retArr.push(uNode.operator);\r\n          }\r\n      \r\n          return retArr;\r\n        }\r\n        astLogicalExpression(logNode, retArr) {\r\n          retArr.push('(');\r\n          this.astGeneric(logNode.left, retArr);\r\n          retArr.push(logNode.operator);\r\n          this.astGeneric(logNode.right, retArr);\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n        astMemberExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astCallExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n        astArrayExpression(ast, retArr) {\r\n          return retArr;\r\n        }\r\n      \r\n        getMemberExpressionDetails(ast) {\r\n          if (ast.type !== 'MemberExpression') {\r\n            throw this.astErrorOutput(`Expression ${ ast.type } not a MemberExpression`, ast);\r\n          }\r\n          let name = null;\r\n          let type = null;\r\n          const variableSignature = this.getVariableSignature(ast);\r\n          switch (variableSignature) {\r\n            case 'value':\r\n              return null;\r\n            case 'value.thread.value':\r\n            case 'this.thread.value':\r\n            case 'this.output.value':\r\n              return {\r\n                signature: variableSignature,\r\n                  type: 'Integer',\r\n                  name: ast.property.name\r\n              };\r\n            case 'value[]':\r\n              if (typeof ast.object.name !== 'string') {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              name = ast.object.name;\r\n              return {\r\n                name,\r\n                origin: 'user',\r\n                  signature: variableSignature,\r\n                  type: this.getVariableType(ast.object),\r\n                  xProperty: ast.property\r\n              };\r\n            case 'value[][]':\r\n              if (typeof ast.object.object.name !== 'string') {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              name = ast.object.object.name;\r\n              return {\r\n                name,\r\n                origin: 'user',\r\n                  signature: variableSignature,\r\n                  type: this.getVariableType(ast.object.object),\r\n                  yProperty: ast.object.property,\r\n                  xProperty: ast.property,\r\n              };\r\n            case 'value[][][]':\r\n              if (typeof ast.object.object.object.name !== 'string') {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              name = ast.object.object.object.name;\r\n              return {\r\n                name,\r\n                origin: 'user',\r\n                  signature: variableSignature,\r\n                  type: this.getVariableType(ast.object.object.object),\r\n                  zProperty: ast.object.object.property,\r\n                  yProperty: ast.object.property,\r\n                  xProperty: ast.property,\r\n              };\r\n            case 'value[][][][]':\r\n              if (typeof ast.object.object.object.object.name !== 'string') {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              name = ast.object.object.object.object.name;\r\n              return {\r\n                name,\r\n                origin: 'user',\r\n                  signature: variableSignature,\r\n                  type: this.getVariableType(ast.object.object.object.object),\r\n                  zProperty: ast.object.object.property,\r\n                  yProperty: ast.object.property,\r\n                  xProperty: ast.property,\r\n              };\r\n            case 'value.value':\r\n              if (typeof ast.property.name !== 'string') {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              if (this.isAstMathVariable(ast)) {\r\n                name = ast.property.name;\r\n                return {\r\n                  name,\r\n                  origin: 'Math',\r\n                  type: 'Number',\r\n                  signature: variableSignature,\r\n                };\r\n              }\r\n              switch (ast.property.name) {\r\n                case 'r':\r\n                case 'g':\r\n                case 'b':\r\n                case 'a':\r\n                  name = ast.object.name;\r\n                  return {\r\n                    name,\r\n                    property: ast.property.name,\r\n                      origin: 'user',\r\n                      signature: variableSignature,\r\n                      type: 'Number'\r\n                  };\r\n                default:\r\n                  throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              case 'this.constants.value':\r\n                if (typeof ast.property.name !== 'string') {\r\n                  throw this.astErrorOutput('Unexpected expression', ast);\r\n                }\r\n                name = ast.property.name;\r\n                type = this.getConstantType(name);\r\n                if (!type) {\r\n                  throw this.astErrorOutput('Constant has no type', ast);\r\n                }\r\n                return {\r\n                  name,\r\n                  type,\r\n                  origin: 'constants',\r\n                    signature: variableSignature,\r\n                };\r\n              case 'this.constants.value[]':\r\n                if (typeof ast.object.property.name !== 'string') {\r\n                  throw this.astErrorOutput('Unexpected expression', ast);\r\n                }\r\n                name = ast.object.property.name;\r\n                type = this.getConstantType(name);\r\n                if (!type) {\r\n                  throw this.astErrorOutput('Constant has no type', ast);\r\n                }\r\n                return {\r\n                  name,\r\n                  type,\r\n                  origin: 'constants',\r\n                    signature: variableSignature,\r\n                    xProperty: ast.property,\r\n                };\r\n              case 'this.constants.value[][]': {\r\n                if (typeof ast.object.object.property.name !== 'string') {\r\n                  throw this.astErrorOutput('Unexpected expression', ast);\r\n                }\r\n                name = ast.object.object.property.name;\r\n                type = this.getConstantType(name);\r\n                if (!type) {\r\n                  throw this.astErrorOutput('Constant has no type', ast);\r\n                }\r\n                return {\r\n                  name,\r\n                  type,\r\n                  origin: 'constants',\r\n                  signature: variableSignature,\r\n                  yProperty: ast.object.property,\r\n                  xProperty: ast.property,\r\n                };\r\n              }\r\n              case 'this.constants.value[][][]': {\r\n                if (typeof ast.object.object.object.property.name !== 'string') {\r\n                  throw this.astErrorOutput('Unexpected expression', ast);\r\n                }\r\n                name = ast.object.object.object.property.name;\r\n                type = this.getConstantType(name);\r\n                if (!type) {\r\n                  throw this.astErrorOutput('Constant has no type', ast);\r\n                }\r\n                return {\r\n                  name,\r\n                  type,\r\n                  origin: 'constants',\r\n                  signature: variableSignature,\r\n                  zProperty: ast.object.object.property,\r\n                  yProperty: ast.object.property,\r\n                  xProperty: ast.property,\r\n                };\r\n              }\r\n              case 'fn()[]':\r\n              case 'fn()[][]':\r\n              case '[][]':\r\n                return {\r\n                  signature: variableSignature,\r\n                    property: ast.property,\r\n                };\r\n              default:\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n          }\r\n        }\r\n      \r\n        findIdentifierOrigin(astToFind) {\r\n          const stack = [this.ast];\r\n      \r\n          while (stack.length > 0) {\r\n            const atNode = stack[0];\r\n            if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {\r\n              return atNode;\r\n            }\r\n            stack.shift();\r\n            if (atNode.argument) {\r\n              stack.push(atNode.argument);\r\n            } else if (atNode.body) {\r\n              stack.push(atNode.body);\r\n            } else if (atNode.declarations) {\r\n              stack.push(atNode.declarations);\r\n            } else if (Array.isArray(atNode)) {\r\n              for (let i = 0; i < atNode.length; i++) {\r\n                stack.push(atNode[i]);\r\n              }\r\n            }\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        findLastReturn(ast) {\r\n          const stack = [ast || this.ast];\r\n      \r\n          while (stack.length > 0) {\r\n            const atNode = stack.pop();\r\n            if (atNode.type === 'ReturnStatement') {\r\n              return atNode;\r\n            }\r\n            if (atNode.type === 'FunctionDeclaration') {\r\n              continue;\r\n            }\r\n            if (atNode.argument) {\r\n              stack.push(atNode.argument);\r\n            } else if (atNode.body) {\r\n              stack.push(atNode.body);\r\n            } else if (atNode.declarations) {\r\n              stack.push(atNode.declarations);\r\n            } else if (Array.isArray(atNode)) {\r\n              for (let i = 0; i < atNode.length; i++) {\r\n                stack.push(atNode[i]);\r\n              }\r\n            } else if (atNode.consequent) {\r\n              stack.push(atNode.consequent);\r\n            } else if (atNode.cases) {\r\n              stack.push(atNode.cases);\r\n            }\r\n          }\r\n          return null;\r\n        }\r\n      \r\n        getInternalVariableName(name) {\r\n          if (!this._internalVariableNames.hasOwnProperty(name)) {\r\n            this._internalVariableNames[name] = 0;\r\n          }\r\n          this._internalVariableNames[name]++;\r\n          if (this._internalVariableNames[name] === 1) {\r\n            return name;\r\n          }\r\n          return name + this._internalVariableNames[name];\r\n        }\r\n      \r\n        astKey(ast, separator = ',') {\r\n          if (!ast.start || !ast.end) throw new Error('AST start and end needed');\r\n          return `${ast.start}${separator}${ast.end}`;\r\n        }\r\n      }\r\n      \r\n      const typeLookupMap = {\r\n        'Number': 'Number',\r\n        'Float': 'Float',\r\n        'Integer': 'Integer',\r\n        'Array': 'Number',\r\n        'Array(2)': 'Number',\r\n        'Array(3)': 'Number',\r\n        'Array(4)': 'Number',\r\n        'Matrix(2)': 'Number',\r\n        'Matrix(3)': 'Number',\r\n        'Matrix(4)': 'Number',\r\n        'Array2D': 'Number',\r\n        'Array3D': 'Number',\r\n        'Input': 'Number',\r\n        'HTMLCanvas': 'Array(4)',\r\n        'HTMLImage': 'Array(4)',\r\n        'HTMLVideo': 'Array(4)',\r\n        'HTMLImageArray': 'Array(4)',\r\n        'NumberTexture': 'Number',\r\n        'MemoryOptimizedNumberTexture': 'Number',\r\n        'Array1D(2)': 'Array(2)',\r\n        'Array1D(3)': 'Array(3)',\r\n        'Array1D(4)': 'Array(4)',\r\n        'Array2D(2)': 'Array(2)',\r\n        'Array2D(3)': 'Array(3)',\r\n        'Array2D(4)': 'Array(4)',\r\n        'Array3D(2)': 'Array(2)',\r\n        'Array3D(3)': 'Array(3)',\r\n        'Array3D(4)': 'Array(4)',\r\n        'ArrayTexture(1)': 'Number',\r\n        'ArrayTexture(2)': 'Array(2)',\r\n        'ArrayTexture(3)': 'Array(3)',\r\n        'ArrayTexture(4)': 'Array(4)',\r\n      };\r\n      \r\n      module.exports = {\r\n        FunctionNode\r\n      };\r\n      },{\"../utils\":114,\"./function-tracer\":11,\"acorn\":1}],11:[function(require,module,exports){\r\n      const { utils } = require('../utils');\r\n      \r\n      function last(array) {\r\n        return array.length > 0 ? array[array.length - 1] : null;\r\n      }\r\n      \r\n      const states = {\r\n        trackIdentifiers: 'trackIdentifiers',\r\n        memberExpression: 'memberExpression',\r\n        inForLoopInit: 'inForLoopInit'\r\n      };\r\n      \r\n      class FunctionTracer {\r\n        constructor(ast) {\r\n          this.runningContexts = [];\r\n          this.functionContexts = [];\r\n          this.contexts = [];\r\n          this.functionCalls = [];\r\n          this.declarations = [];\r\n          this.identifiers = [];\r\n          this.functions = [];\r\n          this.returnStatements = [];\r\n          this.trackedIdentifiers = null;\r\n          this.states = [];\r\n          this.newFunctionContext();\r\n          this.scan(ast);\r\n        }\r\n      \r\n        isState(state) {\r\n          return this.states[this.states.length - 1] === state;\r\n        }\r\n      \r\n        hasState(state) {\r\n          return this.states.indexOf(state) > -1;\r\n        }\r\n      \r\n        pushState(state) {\r\n          this.states.push(state);\r\n        }\r\n      \r\n        popState(state) {\r\n          if (this.isState(state)) {\r\n            this.states.pop();\r\n          } else {\r\n            throw new Error(`Cannot pop the non-active state \"${state}\"`);\r\n          }\r\n        }\r\n      \r\n        get currentFunctionContext() {\r\n          return last(this.functionContexts);\r\n        }\r\n      \r\n        get currentContext() {\r\n          return last(this.runningContexts);\r\n        }\r\n      \r\n        newFunctionContext() {\r\n          const newContext = { '@contextType': 'function' };\r\n          this.contexts.push(newContext);\r\n          this.functionContexts.push(newContext);\r\n        }\r\n      \r\n        newContext(run) {\r\n          const newContext = Object.assign({ '@contextType': 'const/let' }, this.currentContext);\r\n          this.contexts.push(newContext);\r\n          this.runningContexts.push(newContext);\r\n          run();\r\n          const { currentFunctionContext } = this;\r\n          for (const p in currentFunctionContext) {\r\n            if (!currentFunctionContext.hasOwnProperty(p) || newContext.hasOwnProperty(p)) continue;\r\n            newContext[p] = currentFunctionContext[p];\r\n          }\r\n          this.runningContexts.pop();\r\n          return newContext;\r\n        }\r\n      \r\n        useFunctionContext(run) {\r\n          const functionContext = last(this.functionContexts);\r\n          this.runningContexts.push(functionContext);\r\n          run();\r\n          this.runningContexts.pop();\r\n        }\r\n      \r\n        getIdentifiers(run) {\r\n          const trackedIdentifiers = this.trackedIdentifiers = [];\r\n          this.pushState(states.trackIdentifiers);\r\n          run();\r\n          this.trackedIdentifiers = null;\r\n          this.popState(states.trackIdentifiers);\r\n          return trackedIdentifiers;\r\n        }\r\n      \r\n        getDeclaration(name) {\r\n          const { currentContext, currentFunctionContext, runningContexts } = this;\r\n          const declaration = currentContext[name] || currentFunctionContext[name] || null;\r\n      \r\n          if (\r\n            !declaration &&\r\n            currentContext === currentFunctionContext &&\r\n            runningContexts.length > 0\r\n          ) {\r\n            const previousRunningContext = runningContexts[runningContexts.length - 2];\r\n            if (previousRunningContext[name]) {\r\n              return previousRunningContext[name];\r\n            }\r\n          }\r\n      \r\n          return declaration;\r\n        }\r\n      \r\n        scan(ast) {\r\n          if (!ast) return;\r\n          if (Array.isArray(ast)) {\r\n            for (let i = 0; i < ast.length; i++) {\r\n              this.scan(ast[i]);\r\n            }\r\n            return;\r\n          }\r\n          switch (ast.type) {\r\n            case 'Program':\r\n              this.useFunctionContext(() => {\r\n                this.scan(ast.body);\r\n              });\r\n              break;\r\n            case 'BlockStatement':\r\n              this.newContext(() => {\r\n                this.scan(ast.body);\r\n              });\r\n              break;\r\n            case 'AssignmentExpression':\r\n            case 'LogicalExpression':\r\n              this.scan(ast.left);\r\n              this.scan(ast.right);\r\n              break;\r\n            case 'BinaryExpression':\r\n              this.scan(ast.left);\r\n              this.scan(ast.right);\r\n              break;\r\n            case 'UpdateExpression':\r\n              if (ast.operator === '++') {\r\n                const declaration = this.getDeclaration(ast.argument.name);\r\n                if (declaration) {\r\n                  declaration.suggestedType = 'Integer';\r\n                }\r\n              }\r\n              this.scan(ast.argument);\r\n              break;\r\n            case 'UnaryExpression':\r\n              this.scan(ast.argument);\r\n              break;\r\n            case 'VariableDeclaration':\r\n              if (ast.kind === 'var') {\r\n                this.useFunctionContext(() => {\r\n                  ast.declarations = utils.normalizeDeclarations(ast);\r\n                  this.scan(ast.declarations);\r\n                });\r\n              } else {\r\n                ast.declarations = utils.normalizeDeclarations(ast);\r\n                this.scan(ast.declarations);\r\n              }\r\n              break;\r\n            case 'VariableDeclarator': {\r\n              const { currentContext } = this;\r\n              const inForLoopInit = this.hasState(states.inForLoopInit);\r\n              const declaration = {\r\n                ast: ast,\r\n                context: currentContext,\r\n                name: ast.id.name,\r\n                origin: 'declaration',\r\n                inForLoopInit,\r\n                inForLoopTest: null,\r\n                assignable: currentContext === this.currentFunctionContext || (!inForLoopInit && !currentContext.hasOwnProperty(ast.id.name)),\r\n                suggestedType: null,\r\n                valueType: null,\r\n                dependencies: null,\r\n                isSafe: null,\r\n              };\r\n              if (!currentContext[ast.id.name]) {\r\n                currentContext[ast.id.name] = declaration;\r\n              }\r\n              this.declarations.push(declaration);\r\n              this.scan(ast.id);\r\n              this.scan(ast.init);\r\n              break;\r\n            }\r\n            case 'FunctionExpression':\r\n            case 'FunctionDeclaration':\r\n              if (this.runningContexts.length === 0) {\r\n                this.scan(ast.body);\r\n              } else {\r\n                this.functions.push(ast);\r\n              }\r\n              break;\r\n            case 'IfStatement':\r\n              this.scan(ast.test);\r\n              this.scan(ast.consequent);\r\n              if (ast.alternate) this.scan(ast.alternate);\r\n              break;\r\n            case 'ForStatement': {\r\n              let testIdentifiers;\r\n              const context = this.newContext(() => {\r\n                this.pushState(states.inForLoopInit);\r\n                this.scan(ast.init);\r\n                this.popState(states.inForLoopInit);\r\n      \r\n                testIdentifiers = this.getIdentifiers(() => {\r\n                  this.scan(ast.test);\r\n                });\r\n      \r\n                this.scan(ast.update);\r\n                this.newContext(() => {\r\n                  this.scan(ast.body);\r\n                });\r\n              });\r\n      \r\n              if (testIdentifiers) {\r\n                for (const p in context) {\r\n                  if (p === '@contextType') continue;\r\n                  if (testIdentifiers.indexOf(p) > -1) {\r\n                    context[p].inForLoopTest = true;\r\n                  }\r\n                }\r\n              }\r\n              break;\r\n            }\r\n            case 'DoWhileStatement':\r\n            case 'WhileStatement':\r\n              this.newContext(() => {\r\n                this.scan(ast.body);\r\n                this.scan(ast.test);\r\n              });\r\n              break;\r\n            case 'Identifier': {\r\n              if (this.isState(states.trackIdentifiers)) {\r\n                this.trackedIdentifiers.push(ast.name);\r\n              }\r\n              this.identifiers.push({\r\n                context: this.currentContext,\r\n                declaration: this.getDeclaration(ast.name),\r\n                ast,\r\n              });\r\n              break;\r\n            }\r\n            case 'ReturnStatement':\r\n              this.returnStatements.push(ast);\r\n              this.scan(ast.argument);\r\n              break;\r\n            case 'MemberExpression':\r\n              this.pushState(states.memberExpression);\r\n              this.scan(ast.object);\r\n              this.scan(ast.property);\r\n              this.popState(states.memberExpression);\r\n              break;\r\n            case 'ExpressionStatement':\r\n              this.scan(ast.expression);\r\n              break;\r\n            case 'SequenceExpression':\r\n              this.scan(ast.expressions);\r\n              break;\r\n            case 'CallExpression':\r\n              this.functionCalls.push({\r\n                context: this.currentContext,\r\n                ast,\r\n              });\r\n              this.scan(ast.arguments);\r\n              break;\r\n            case 'ArrayExpression':\r\n              this.scan(ast.elements);\r\n              break;\r\n            case 'ConditionalExpression':\r\n              this.scan(ast.test);\r\n              this.scan(ast.alternate);\r\n              this.scan(ast.consequent);\r\n              break;\r\n            case 'SwitchStatement':\r\n              this.scan(ast.discriminant);\r\n              this.scan(ast.cases);\r\n              break;\r\n            case 'SwitchCase':\r\n              this.scan(ast.test);\r\n              this.scan(ast.consequent);\r\n              break;\r\n      \r\n            case 'ThisExpression':\r\n            case 'Literal':\r\n            case 'DebuggerStatement':\r\n            case 'EmptyStatement':\r\n            case 'BreakStatement':\r\n            case 'ContinueStatement':\r\n              break;\r\n            default:\r\n              throw new Error(`unhandled type \"${ast.type}\"`);\r\n          }\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        FunctionTracer,\r\n      };\r\n      },{\"../utils\":114}],12:[function(require,module,exports){\r\n      const { glWiretap } = require('gl-wiretap');\r\n      const { utils } = require('../../utils');\r\n      \r\n      function toStringWithoutUtils(fn) {\r\n        return fn.toString()\r\n          .replace('=>', '')\r\n          .replace(/^function /, '')\r\n          .replace(/utils[.]/g, '/*utils.*/');\r\n      }\r\n      \r\n      function glKernelString(Kernel, args, originKernel, setupContextString, destroyContextString) {\r\n        if (!originKernel.built) {\r\n          originKernel.build.apply(originKernel, args);\r\n        }\r\n        args = args ? Array.from(args).map(arg => {\r\n          switch (typeof arg) {\r\n            case 'boolean':\r\n              return new Boolean(arg);\r\n            case 'number':\r\n              return new Number(arg);\r\n            default:\r\n              return arg;\r\n          }\r\n        }) : null;\r\n        const uploadedValues = [];\r\n        const postResult = [];\r\n        const context = glWiretap(originKernel.context, {\r\n          useTrackablePrimitives: true,\r\n          onReadPixels: (targetName) => {\r\n            if (kernel.subKernels) {\r\n              if (!subKernelsResultVariableSetup) {\r\n                postResult.push(`    const result = { result: ${getRenderString(targetName, kernel)} };`);\r\n                subKernelsResultVariableSetup = true;\r\n              } else {\r\n                const property = kernel.subKernels[subKernelsResultIndex++].property;\r\n                postResult.push(`    result${isNaN(property) ? '.' + property : `[${property}]`} = ${getRenderString(targetName, kernel)};`);\r\n              }\r\n              if (subKernelsResultIndex === kernel.subKernels.length) {\r\n                postResult.push('    return result;');\r\n              }\r\n              return;\r\n            }\r\n            if (targetName) {\r\n              postResult.push(`    return ${getRenderString(targetName, kernel)};`);\r\n            } else {\r\n              postResult.push(`    return null;`);\r\n            }\r\n          },\r\n          onUnrecognizedArgumentLookup: (argument) => {\r\n            const argumentName = findKernelValue(argument, kernel.kernelArguments, [], context, uploadedValues);\r\n            if (argumentName) {\r\n              return argumentName;\r\n            }\r\n            const constantName = findKernelValue(argument, kernel.kernelConstants, constants ? Object.keys(constants).map(key => constants[key]) : [], context, uploadedValues);\r\n            if (constantName) {\r\n              return constantName;\r\n            }\r\n            return null;\r\n          }\r\n        });\r\n        let subKernelsResultVariableSetup = false;\r\n        let subKernelsResultIndex = 0;\r\n        const {\r\n          source,\r\n          canvas,\r\n          output,\r\n          pipeline,\r\n          graphical,\r\n          loopMaxIterations,\r\n          constants,\r\n          optimizeFloatMemory,\r\n          precision,\r\n          fixIntegerDivisionAccuracy,\r\n          functions,\r\n          nativeFunctions,\r\n          subKernels,\r\n          immutable,\r\n          argumentTypes,\r\n          constantTypes,\r\n          kernelArguments,\r\n          kernelConstants,\r\n          tactic,\r\n        } = originKernel;\r\n        const kernel = new Kernel(source, {\r\n          canvas,\r\n          context,\r\n          checkContext: false,\r\n          output,\r\n          pipeline,\r\n          graphical,\r\n          loopMaxIterations,\r\n          constants,\r\n          optimizeFloatMemory,\r\n          precision,\r\n          fixIntegerDivisionAccuracy,\r\n          functions,\r\n          nativeFunctions,\r\n          subKernels,\r\n          immutable,\r\n          argumentTypes,\r\n          constantTypes,\r\n          tactic,\r\n        });\r\n        let result = [];\r\n        context.setIndent(2);\r\n        kernel.build.apply(kernel, args);\r\n        result.push(context.toString());\r\n        context.reset();\r\n      \r\n        kernel.kernelArguments.forEach((kernelArgument, i) => {\r\n          switch (kernelArgument.type) {\r\n            case 'Integer':\r\n            case 'Boolean':\r\n            case 'Number':\r\n            case 'Float':\r\n            case 'Array':\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n            case 'HTMLCanvas':\r\n            case 'HTMLImage':\r\n            case 'HTMLVideo':\r\n              context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);\r\n              break;\r\n            case 'HTMLImageArray':\r\n              for (let imageIndex = 0; imageIndex < args[i].length; imageIndex++) {\r\n                const arg = args[i];\r\n                context.insertVariable(`uploadValue_${kernelArgument.name}[${imageIndex}]`, arg[imageIndex]);\r\n              }\r\n              break;\r\n            case 'Input':\r\n              context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);\r\n              break;\r\n            case 'MemoryOptimizedNumberTexture':\r\n            case 'NumberTexture':\r\n            case 'Array1D(2)':\r\n            case 'Array1D(3)':\r\n            case 'Array1D(4)':\r\n            case 'Array2D(2)':\r\n            case 'Array2D(3)':\r\n            case 'Array2D(4)':\r\n            case 'Array3D(2)':\r\n            case 'Array3D(3)':\r\n            case 'Array3D(4)':\r\n            case 'ArrayTexture(1)':\r\n            case 'ArrayTexture(2)':\r\n            case 'ArrayTexture(3)':\r\n            case 'ArrayTexture(4)':\r\n              context.insertVariable(`uploadValue_${kernelArgument.name}`, args[i].texture);\r\n              break;\r\n            default:\r\n              throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${kernelArgument.type}`);\r\n          }\r\n        });\r\n        result.push('/** start of injected functions **/');\r\n        result.push(`function ${toStringWithoutUtils(utils.flattenTo)}`);\r\n        result.push(`function ${toStringWithoutUtils(utils.flatten2dArrayTo)}`);\r\n        result.push(`function ${toStringWithoutUtils(utils.flatten3dArrayTo)}`);\r\n        result.push(`function ${toStringWithoutUtils(utils.flatten4dArrayTo)}`);\r\n        result.push(`function ${toStringWithoutUtils(utils.isArray)}`);\r\n        if (kernel.renderOutput !== kernel.renderTexture && kernel.formatValues) {\r\n          result.push(\r\n            `  const renderOutput = function ${toStringWithoutUtils(kernel.formatValues)};`\r\n          );\r\n        }\r\n        result.push('/** end of injected functions **/');\r\n        result.push(`  const innerKernel = function (${kernel.kernelArguments.map(kernelArgument => kernelArgument.varName).join(', ')}) {`);\r\n        context.setIndent(4);\r\n        kernel.run.apply(kernel, args);\r\n        if (kernel.renderKernels) {\r\n          kernel.renderKernels();\r\n        } else if (kernel.renderOutput) {\r\n          kernel.renderOutput();\r\n        }\r\n        result.push('    /** start setup uploads for kernel values **/');\r\n        kernel.kernelArguments.forEach(kernelArgument => {\r\n          result.push('    ' + kernelArgument.getStringValueHandler().split('\\n').join('\\n    '));\r\n        });\r\n        result.push('    /** end setup uploads for kernel values **/');\r\n        result.push(context.toString());\r\n        if (kernel.renderOutput === kernel.renderTexture) {\r\n          context.reset();\r\n          const framebufferName = context.getContextVariableName(kernel.framebuffer);\r\n          if (kernel.renderKernels) {\r\n            const results = kernel.renderKernels();\r\n            const textureName = context.getContextVariableName(kernel.texture.texture);\r\n            result.push(`    return {\r\n            result: {\r\n              texture: ${ textureName },\r\n              type: '${ results.result.type }',\r\n              toArray: ${ getToArrayString(results.result, textureName, framebufferName) }\r\n            },`);\r\n            const { subKernels, mappedTextures } = kernel;\r\n            for (let i = 0; i < subKernels.length; i++) {\r\n              const texture = mappedTextures[i];\r\n              const subKernel = subKernels[i];\r\n              const subKernelResult = results[subKernel.property];\r\n              const subKernelTextureName = context.getContextVariableName(texture.texture);\r\n              result.push(`\r\n            ${subKernel.property}: {\r\n              texture: ${ subKernelTextureName },\r\n              type: '${ subKernelResult.type }',\r\n              toArray: ${ getToArrayString(subKernelResult, subKernelTextureName, framebufferName) }\r\n            },`);\r\n            }\r\n            result.push(`    };`);\r\n          } else {\r\n            const rendered = kernel.renderOutput();\r\n            const textureName = context.getContextVariableName(kernel.texture.texture);\r\n            result.push(`    return {\r\n              texture: ${ textureName },\r\n              type: '${ rendered.type }',\r\n              toArray: ${ getToArrayString(rendered, textureName, framebufferName) }\r\n            };`);\r\n          }\r\n        }\r\n        result.push(`    ${destroyContextString ? '\\n' + destroyContextString + '    ': ''}`);\r\n        result.push(postResult.join('\\n'));\r\n        result.push('  };');\r\n        if (kernel.graphical) {\r\n          result.push(getGetPixelsString(kernel));\r\n          result.push(`  innerKernel.getPixels = getPixels;`);\r\n        }\r\n        result.push('  return innerKernel;');\r\n      \r\n        let constantsUpload = [];\r\n        kernelConstants.forEach((kernelConstant) => {\r\n          constantsUpload.push(`${kernelConstant.getStringValueHandler()}`);\r\n        });\r\n        return `function kernel(settings) {\r\n        const { context, constants } = settings;\r\n        ${constantsUpload.join('')}\r\n        ${setupContextString ? setupContextString : ''}\r\n      ${result.join('\\n')}\r\n      }`;\r\n      }\r\n      \r\n      function getRenderString(targetName, kernel) {\r\n        const readBackValue = kernel.precision === 'single' ? targetName : `new Float32Array(${targetName}.buffer)`;\r\n        if (kernel.output[2]) {\r\n          return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]}, ${kernel.output[2]})`;\r\n        }\r\n        if (kernel.output[1]) {\r\n          return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]})`;\r\n        }\r\n      \r\n        return `renderOutput(${readBackValue}, ${kernel.output[0]})`;\r\n      }\r\n      \r\n      function getGetPixelsString(kernel) {\r\n        const getPixels = kernel.getPixels.toString();\r\n        const useFunctionKeyword = !/^function/.test(getPixels);\r\n        return utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ getPixels }`, {\r\n          findDependency: (object, name) => {\r\n            if (object === 'utils') {\r\n              return `const ${name} = ${utils[name].toString()};`;\r\n            }\r\n            return null;\r\n          },\r\n          thisLookup: (property) => {\r\n            if (property === 'context') {\r\n              return null;\r\n            }\r\n            if (kernel.hasOwnProperty(property)) {\r\n              return JSON.stringify(kernel[property]);\r\n            }\r\n            throw new Error(`unhandled thisLookup ${ property }`);\r\n          }\r\n        });\r\n      }\r\n      \r\n      function getToArrayString(kernelResult, textureName, framebufferName) {\r\n        const toArray = kernelResult.toArray.toString();\r\n        const useFunctionKeyword = !/^function/.test(toArray);\r\n        const flattenedFunctions = utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ toArray }`, {\r\n          findDependency: (object, name) => {\r\n            if (object === 'utils') {\r\n              return `const ${name} = ${utils[name].toString()};`;\r\n            } else if (object === 'this') {\r\n              if (name === 'framebuffer') {\r\n                return '';\r\n              }\r\n              return `${useFunctionKeyword ? 'function ' : ''}${kernelResult[name].toString()}`;\r\n            } else {\r\n              throw new Error('unhandled fromObject');\r\n            }\r\n          },\r\n          thisLookup: (property, isDeclaration) => {\r\n            if (property === 'texture') {\r\n              return textureName;\r\n            }\r\n            if (property === 'context') {\r\n              if (isDeclaration) return null;\r\n              return 'gl';\r\n            }\r\n            if (kernelResult.hasOwnProperty(property)) {\r\n              return JSON.stringify(kernelResult[property]);\r\n            }\r\n            throw new Error(`unhandled thisLookup ${ property }`);\r\n          }\r\n        });\r\n        return `() => {\r\n        function framebuffer() { return ${framebufferName}; };\r\n        ${flattenedFunctions}\r\n        return toArray();\r\n        }`;\r\n      }\r\n      \r\n      function findKernelValue(argument, kernelValues, values, context, uploadedValues) {\r\n        if (argument === null) return null;\r\n        if (kernelValues === null) return null;\r\n        switch (typeof argument) {\r\n          case 'boolean':\r\n          case 'number':\r\n            return null;\r\n        }\r\n        if (\r\n          typeof HTMLImageElement !== 'undefined' &&\r\n          argument instanceof HTMLImageElement\r\n        ) {\r\n          for (let i = 0; i < kernelValues.length; i++) {\r\n            const kernelValue = kernelValues[i];\r\n            if (kernelValue.type !== 'HTMLImageArray' && kernelValue) continue;\r\n            if (kernelValue.uploadValue !== argument) continue;\r\n            const variableIndex = values[i].indexOf(argument);\r\n            if (variableIndex === -1) continue;\r\n            const variableName = `uploadValue_${kernelValue.name}[${variableIndex}]`;\r\n            context.insertVariable(variableName, argument);\r\n            return variableName;\r\n          }\r\n        }\r\n      \r\n        for (let i = 0; i < kernelValues.length; i++) {\r\n          const kernelValue = kernelValues[i];\r\n          if (argument !== kernelValue.uploadValue) continue;\r\n          const variable = `uploadValue_${kernelValue.name}`;\r\n          context.insertVariable(variable, kernelValue);\r\n          return variable;\r\n        }\r\n        return null;\r\n      }\r\n      \r\n      module.exports = {\r\n        glKernelString\r\n      };\r\n      },{\"../../utils\":114,\"gl-wiretap\":3}],13:[function(require,module,exports){\r\n      const { Kernel } = require('../kernel');\r\n      const { utils } = require('../../utils');\r\n      const { GLTextureArray2Float } = require('./texture/array-2-float');\r\n      const { GLTextureArray2Float2D } = require('./texture/array-2-float-2d');\r\n      const { GLTextureArray2Float3D } = require('./texture/array-2-float-3d');\r\n      const { GLTextureArray3Float } = require('./texture/array-3-float');\r\n      const { GLTextureArray3Float2D } = require('./texture/array-3-float-2d');\r\n      const { GLTextureArray3Float3D } = require('./texture/array-3-float-3d');\r\n      const { GLTextureArray4Float } = require('./texture/array-4-float');\r\n      const { GLTextureArray4Float2D } = require('./texture/array-4-float-2d');\r\n      const { GLTextureArray4Float3D } = require('./texture/array-4-float-3d');\r\n      const { GLTextureFloat } = require('./texture/float');\r\n      const { GLTextureFloat2D } = require('./texture/float-2d');\r\n      const { GLTextureFloat3D } = require('./texture/float-3d');\r\n      const { GLTextureMemoryOptimized } = require('./texture/memory-optimized');\r\n      const { GLTextureMemoryOptimized2D } = require('./texture/memory-optimized-2d');\r\n      const { GLTextureMemoryOptimized3D } = require('./texture/memory-optimized-3d');\r\n      const { GLTextureUnsigned } = require('./texture/unsigned');\r\n      const { GLTextureUnsigned2D } = require('./texture/unsigned-2d');\r\n      const { GLTextureUnsigned3D } = require('./texture/unsigned-3d');\r\n      const { GLTextureGraphical } = require('./texture/graphical');\r\n      \r\n      class GLKernel extends Kernel {\r\n        static get mode() {\r\n          return 'gpu';\r\n        }\r\n      \r\n        static getIsFloatRead() {\r\n          const kernelString = `function kernelFunction() {\r\n            return 1;\r\n          }`;\r\n          const kernel = new this(kernelString, {\r\n            context: this.testContext,\r\n            canvas: this.testCanvas,\r\n            validate: false,\r\n            output: [1],\r\n            precision: 'single',\r\n            returnType: 'Number',\r\n            tactic: 'speed',\r\n          });\r\n          kernel.build();\r\n          kernel.run();\r\n          const result = kernel.renderOutput();\r\n          kernel.destroy(true);\r\n          return result[0] === 1;\r\n        }\r\n      \r\n        static getIsIntegerDivisionAccurate() {\r\n          function kernelFunction(v1, v2) {\r\n            return v1[this.thread.x] / v2[this.thread.x];\r\n          }\r\n          const kernel = new this(kernelFunction.toString(), {\r\n            context: this.testContext,\r\n            canvas: this.testCanvas,\r\n            validate: false,\r\n            output: [2],\r\n            returnType: 'Number',\r\n            precision: 'unsigned',\r\n            tactic: 'speed',\r\n          });\r\n          const args = [\r\n            [6, 6030401],\r\n            [3, 3991]\r\n          ];\r\n          kernel.build.apply(kernel, args);\r\n          kernel.run.apply(kernel, args);\r\n          const result = kernel.renderOutput();\r\n          kernel.destroy(true);\r\n          return result[0] === 2 && result[1] === 1511;\r\n        }\r\n      \r\n        static getIsSpeedTacticSupported() {\r\n          function kernelFunction(value) {\r\n            return value[this.thread.x];\r\n          }\r\n          const kernel = new this(kernelFunction.toString(), {\r\n            context: this.testContext,\r\n            canvas: this.testCanvas,\r\n            validate: false,\r\n            output: [4],\r\n            returnType: 'Number',\r\n            precision: 'unsigned',\r\n            tactic: 'speed',\r\n          });\r\n          const args = [\r\n            [0, 1, 2, 3]\r\n          ];\r\n          kernel.build.apply(kernel, args);\r\n          kernel.run.apply(kernel, args);\r\n          const result = kernel.renderOutput();\r\n          kernel.destroy(true);\r\n          return Math.round(result[0]) === 0 && Math.round(result[1]) === 1 && Math.round(result[2]) === 2 && Math.round(result[3]) === 3;\r\n        }\r\n      \r\n        static get testCanvas() {\r\n          throw new Error(`\"testCanvas\" not defined on ${ this.name }`);\r\n        }\r\n      \r\n        static get testContext() {\r\n          throw new Error(`\"testContext\" not defined on ${ this.name }`);\r\n        }\r\n      \r\n        static getFeatures() {\r\n          const gl = this.testContext;\r\n          const isDrawBuffers = this.getIsDrawBuffers();\r\n          return Object.freeze({\r\n            isFloatRead: this.getIsFloatRead(),\r\n            isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),\r\n            isSpeedTacticSupported: this.getIsSpeedTacticSupported(),\r\n            isTextureFloat: this.getIsTextureFloat(),\r\n            isDrawBuffers,\r\n            kernelMap: isDrawBuffers,\r\n            channelCount: this.getChannelCount(),\r\n            maxTextureSize: this.getMaxTextureSize(),\r\n            lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),\r\n            lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),\r\n            mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),\r\n            mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),\r\n            highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),\r\n            highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),\r\n          });\r\n        }\r\n      \r\n        static setupFeatureChecks() {\r\n          throw new Error(`\"setupFeatureChecks\" not defined on ${ this.name }`);\r\n        }\r\n      \r\n        static getSignature(kernel, argumentTypes) {\r\n          return kernel.getVariablePrecisionString() + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');\r\n        }\r\n      \r\n        setFixIntegerDivisionAccuracy(fix) {\r\n          this.fixIntegerDivisionAccuracy = fix;\r\n          return this;\r\n        }\r\n      \r\n        setPrecision(flag) {\r\n          this.precision = flag;\r\n          return this;\r\n        }\r\n      \r\n        setFloatTextures(flag) {\r\n          utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');\r\n          this.floatTextures = flag;\r\n          return this;\r\n        }\r\n      \r\n        static nativeFunctionArguments(source) {\r\n          const argumentTypes = [];\r\n          const argumentNames = [];\r\n          const states = [];\r\n          const isStartingVariableName = /^[a-zA-Z_]/;\r\n          const isVariableChar = /[a-zA-Z_0-9]/;\r\n          let i = 0;\r\n          let argumentName = null;\r\n          let argumentType = null;\r\n          while (i < source.length) {\r\n            const char = source[i];\r\n            const nextChar = source[i + 1];\r\n            const state = states.length > 0 ? states[states.length - 1] : null;\r\n      \r\n            if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {\r\n              states.push('MULTI_LINE_COMMENT');\r\n              i += 2;\r\n              continue;\r\n            } else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {\r\n              states.pop();\r\n              i += 2;\r\n              continue;\r\n            }\r\n      \r\n            else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {\r\n              states.push('COMMENT');\r\n              i += 2;\r\n              continue;\r\n            } else if (state === 'COMMENT' && char === '\\n') {\r\n              states.pop();\r\n              i++;\r\n              continue;\r\n            }\r\n      \r\n            else if (state === null && char === '(') {\r\n              states.push('FUNCTION_ARGUMENTS');\r\n              i++;\r\n              continue;\r\n            } else if (state === 'FUNCTION_ARGUMENTS') {\r\n              if (char === ')') {\r\n                states.pop();\r\n                break;\r\n              }\r\n              if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {\r\n                states.push('DECLARE_VARIABLE');\r\n                argumentType = 'float';\r\n                argumentName = '';\r\n                i += 6;\r\n                continue;\r\n              } else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {\r\n                states.push('DECLARE_VARIABLE');\r\n                argumentType = 'int';\r\n                argumentName = '';\r\n                i += 4;\r\n                continue;\r\n              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {\r\n                states.push('DECLARE_VARIABLE');\r\n                argumentType = 'vec2';\r\n                argumentName = '';\r\n                i += 5;\r\n                continue;\r\n              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {\r\n                states.push('DECLARE_VARIABLE');\r\n                argumentType = 'vec3';\r\n                argumentName = '';\r\n                i += 5;\r\n                continue;\r\n              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {\r\n                states.push('DECLARE_VARIABLE');\r\n                argumentType = 'vec4';\r\n                argumentName = '';\r\n                i += 5;\r\n                continue;\r\n              }\r\n            }\r\n      \r\n            else if (state === 'DECLARE_VARIABLE') {\r\n              if (argumentName === '') {\r\n                if (char === ' ') {\r\n                  i++;\r\n                  continue;\r\n                }\r\n                if (!isStartingVariableName.test(char)) {\r\n                  throw new Error('variable name is not expected string');\r\n                }\r\n              }\r\n              argumentName += char;\r\n              if (!isVariableChar.test(nextChar)) {\r\n                states.pop();\r\n                argumentNames.push(argumentName);\r\n                argumentTypes.push(typeMap[argumentType]);\r\n              }\r\n            }\r\n      \r\n            i++;\r\n          }\r\n          if (states.length > 0) {\r\n            throw new Error('GLSL function was not parsable');\r\n          }\r\n          return {\r\n            argumentNames,\r\n            argumentTypes,\r\n          };\r\n        }\r\n      \r\n        static nativeFunctionReturnType(source) {\r\n          return typeMap[source.match(/int|float|vec[2-4]/)[0]];\r\n        }\r\n      \r\n        static combineKernels(combinedKernel, lastKernel) {\r\n          combinedKernel.apply(null, arguments);\r\n          const {\r\n            texSize,\r\n            context,\r\n            threadDim\r\n          } = lastKernel.texSize;\r\n          let result;\r\n          if (lastKernel.precision === 'single') {\r\n            const w = texSize[0];\r\n            const h = Math.ceil(texSize[1] / 4);\r\n            result = new Float32Array(w * h * 4 * 4);\r\n            context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);\r\n          } else {\r\n            const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);\r\n            context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);\r\n            result = new Float32Array(bytes.buffer);\r\n          }\r\n      \r\n          result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);\r\n      \r\n          if (lastKernel.output.length === 1) {\r\n            return result;\r\n          } else if (lastKernel.output.length === 2) {\r\n            return utils.splitArray(result, lastKernel.output[0]);\r\n          } else if (lastKernel.output.length === 3) {\r\n            const cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);\r\n            return cube.map(function(x) {\r\n              return utils.splitArray(x, lastKernel.output[0]);\r\n            });\r\n          }\r\n        }\r\n      \r\n        constructor(source, settings) {\r\n          super(source, settings);\r\n          this.transferValues = null;\r\n          this.formatValues = null;\r\n          this.TextureConstructor = null;\r\n          this.renderOutput = null;\r\n          this.renderRawOutput = null;\r\n          this.texSize = null;\r\n          this.translatedSource = null;\r\n          this.compiledFragmentShader = null;\r\n          this.compiledVertexShader = null;\r\n          this.switchingKernels = null;\r\n          this._textureSwitched = null;\r\n          this._mappedTextureSwitched = null;\r\n        }\r\n      \r\n        checkTextureSize() {\r\n          const { features } = this.constructor;\r\n          if (this.texSize[0] > features.maxTextureSize || this.texSize[1] > features.maxTextureSize) {\r\n            throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${features.maxTextureSize},${features.maxTextureSize}]`);\r\n          }\r\n        }\r\n      \r\n        translateSource() {\r\n          throw new Error(`\"translateSource\" not defined on ${this.constructor.name}`);\r\n        }\r\n      \r\n        pickRenderStrategy(args) {\r\n          if (this.graphical) {\r\n            this.renderRawOutput = this.readPackedPixelsToUint8Array;\r\n            this.transferValues = (pixels) => pixels;\r\n            this.TextureConstructor = GLTextureGraphical;\r\n            return null;\r\n          }\r\n          if (this.precision === 'unsigned') {\r\n            this.renderRawOutput = this.readPackedPixelsToUint8Array;\r\n            this.transferValues = this.readPackedPixelsToFloat32Array;\r\n            if (this.pipeline) {\r\n              this.renderOutput = this.renderTexture;\r\n              if (this.subKernels !== null) {\r\n                this.renderKernels = this.renderKernelsToTextures;\r\n              }\r\n              switch (this.returnType) {\r\n                case 'LiteralInteger':\r\n                case 'Float':\r\n                case 'Number':\r\n                case 'Integer':\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureUnsigned3D;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureUnsigned2D;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureUnsigned;\r\n                    return null;\r\n                  }\r\n                  case 'Array(2)':\r\n                  case 'Array(3)':\r\n                  case 'Array(4)':\r\n                    return this.requestFallback(args);\r\n              }\r\n            } else {\r\n              if (this.subKernels !== null) {\r\n                this.renderKernels = this.renderKernelsToArrays;\r\n              }\r\n              switch (this.returnType) {\r\n                case 'LiteralInteger':\r\n                case 'Float':\r\n                case 'Number':\r\n                case 'Integer':\r\n                  this.renderOutput = this.renderValues;\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureUnsigned3D;\r\n                    this.formatValues = utils.erect3DPackedFloat;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureUnsigned2D;\r\n                    this.formatValues = utils.erect2DPackedFloat;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureUnsigned;\r\n                    this.formatValues = utils.erectPackedFloat;\r\n                    return null;\r\n                  }\r\n                  case 'Array(2)':\r\n                  case 'Array(3)':\r\n                  case 'Array(4)':\r\n                    return this.requestFallback(args);\r\n              }\r\n            }\r\n          } else if (this.precision === 'single') {\r\n            this.renderRawOutput = this.readFloatPixelsToFloat32Array;\r\n            this.transferValues = this.readFloatPixelsToFloat32Array;\r\n            if (this.pipeline) {\r\n              this.renderOutput = this.renderTexture;\r\n              if (this.subKernels !== null) {\r\n                this.renderKernels = this.renderKernelsToTextures;\r\n              }\r\n              switch (this.returnType) {\r\n                case 'LiteralInteger':\r\n                case 'Float':\r\n                case 'Number':\r\n                case 'Integer': {\r\n                  if (this.optimizeFloatMemory) {\r\n                    if (this.output[2] > 0) {\r\n                      this.TextureConstructor = GLTextureMemoryOptimized3D;\r\n                      return null;\r\n                    } else if (this.output[1] > 0) {\r\n                      this.TextureConstructor = GLTextureMemoryOptimized2D;\r\n                      return null;\r\n                    } else {\r\n                      this.TextureConstructor = GLTextureMemoryOptimized;\r\n                      return null;\r\n                    }\r\n                  } else {\r\n                    if (this.output[2] > 0) {\r\n                      this.TextureConstructor = GLTextureFloat3D;\r\n                      return null;\r\n                    } else if (this.output[1] > 0) {\r\n                      this.TextureConstructor = GLTextureFloat2D;\r\n                      return null;\r\n                    } else {\r\n                      this.TextureConstructor = GLTextureFloat;\r\n                      return null;\r\n                    }\r\n                  }\r\n                }\r\n                case 'Array(2)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float3D;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float2D;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray2Float;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(3)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float3D;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float2D;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray3Float;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(4)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float3D;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float2D;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray4Float;\r\n                    return null;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n            this.renderOutput = this.renderValues;\r\n            if (this.subKernels !== null) {\r\n              this.renderKernels = this.renderKernelsToArrays;\r\n            }\r\n            if (this.optimizeFloatMemory) {\r\n              switch (this.returnType) {\r\n                case 'LiteralInteger':\r\n                case 'Float':\r\n                case 'Number':\r\n                case 'Integer': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureMemoryOptimized3D;\r\n                    this.formatValues = utils.erectMemoryOptimized3DFloat;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureMemoryOptimized2D;\r\n                    this.formatValues = utils.erectMemoryOptimized2DFloat;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureMemoryOptimized;\r\n                    this.formatValues = utils.erectMemoryOptimizedFloat;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(2)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float3D;\r\n                    this.formatValues = utils.erect3DArray2;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float2D;\r\n                    this.formatValues = utils.erect2DArray2;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray2Float;\r\n                    this.formatValues = utils.erectArray2;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(3)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float3D;\r\n                    this.formatValues = utils.erect3DArray3;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float2D;\r\n                    this.formatValues = utils.erect2DArray3;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray3Float;\r\n                    this.formatValues = utils.erectArray3;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(4)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float3D;\r\n                    this.formatValues = utils.erect3DArray4;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float2D;\r\n                    this.formatValues = utils.erect2DArray4;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray4Float;\r\n                    this.formatValues = utils.erectArray4;\r\n                    return null;\r\n                  }\r\n                }\r\n              }\r\n            } else {\r\n              switch (this.returnType) {\r\n                case 'LiteralInteger':\r\n                case 'Float':\r\n                case 'Number':\r\n                case 'Integer': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureFloat3D;\r\n                    this.formatValues = utils.erect3DFloat;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureFloat2D;\r\n                    this.formatValues = utils.erect2DFloat;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureFloat;\r\n                    this.formatValues = utils.erectFloat;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(2)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float3D;\r\n                    this.formatValues = utils.erect3DArray2;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray2Float2D;\r\n                    this.formatValues = utils.erect2DArray2;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray2Float;\r\n                    this.formatValues = utils.erectArray2;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(3)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float3D;\r\n                    this.formatValues = utils.erect3DArray3;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray3Float2D;\r\n                    this.formatValues = utils.erect2DArray3;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray3Float;\r\n                    this.formatValues = utils.erectArray3;\r\n                    return null;\r\n                  }\r\n                }\r\n                case 'Array(4)': {\r\n                  if (this.output[2] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float3D;\r\n                    this.formatValues = utils.erect3DArray4;\r\n                    return null;\r\n                  } else if (this.output[1] > 0) {\r\n                    this.TextureConstructor = GLTextureArray4Float2D;\r\n                    this.formatValues = utils.erect2DArray4;\r\n                    return null;\r\n                  } else {\r\n                    this.TextureConstructor = GLTextureArray4Float;\r\n                    this.formatValues = utils.erectArray4;\r\n                    return null;\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          } else {\r\n            throw new Error(`unhandled precision of \"${this.precision}\"`);\r\n          }\r\n      \r\n          throw new Error(`unhandled return type \"${this.returnType}\"`);\r\n        }\r\n      \r\n        getKernelString() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n      \r\n        getMainResultTexture() {\r\n          switch (this.returnType) {\r\n            case 'LiteralInteger':\r\n            case 'Float':\r\n            case 'Integer':\r\n            case 'Number':\r\n              return this.getMainResultNumberTexture();\r\n            case 'Array(2)':\r\n              return this.getMainResultArray2Texture();\r\n            case 'Array(3)':\r\n              return this.getMainResultArray3Texture();\r\n            case 'Array(4)':\r\n              return this.getMainResultArray4Texture();\r\n            default:\r\n              throw new Error(`unhandled returnType type ${ this.returnType }`);\r\n          }\r\n        }\r\n      \r\n        getMainResultKernelNumberTexture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultSubKernelNumberTexture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultKernelArray2Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultSubKernelArray2Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultKernelArray3Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultSubKernelArray3Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultKernelArray4Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultSubKernelArray4Texture() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultGraphical() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultMemoryOptimizedFloats() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n        getMainResultPackedPixels() {\r\n          throw new Error(`abstract method call`);\r\n        }\r\n      \r\n        getMainResultString() {\r\n          if (this.graphical) {\r\n            return this.getMainResultGraphical();\r\n          } else if (this.precision === 'single') {\r\n            if (this.optimizeFloatMemory) {\r\n              return this.getMainResultMemoryOptimizedFloats();\r\n            }\r\n            return this.getMainResultTexture();\r\n          } else {\r\n            return this.getMainResultPackedPixels();\r\n          }\r\n        }\r\n      \r\n        getMainResultNumberTexture() {\r\n          return utils.linesToString(this.getMainResultKernelNumberTexture()) +\r\n            utils.linesToString(this.getMainResultSubKernelNumberTexture());\r\n        }\r\n      \r\n        getMainResultArray2Texture() {\r\n          return utils.linesToString(this.getMainResultKernelArray2Texture()) +\r\n            utils.linesToString(this.getMainResultSubKernelArray2Texture());\r\n        }\r\n      \r\n        getMainResultArray3Texture() {\r\n          return utils.linesToString(this.getMainResultKernelArray3Texture()) +\r\n            utils.linesToString(this.getMainResultSubKernelArray3Texture());\r\n        }\r\n      \r\n        getMainResultArray4Texture() {\r\n          return utils.linesToString(this.getMainResultKernelArray4Texture()) +\r\n            utils.linesToString(this.getMainResultSubKernelArray4Texture());\r\n        }\r\n      \r\n        getFloatTacticDeclaration() {\r\n          const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);\r\n          return `precision ${variablePrecision} float;\\n`;\r\n        }\r\n      \r\n        getIntTacticDeclaration() {\r\n          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic, true)} int;\\n`;\r\n        }\r\n      \r\n        getSampler2DTacticDeclaration() {\r\n          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;\\n`;\r\n        }\r\n      \r\n        getSampler2DArrayTacticDeclaration() {\r\n          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;\\n`;\r\n        }\r\n      \r\n        renderTexture() {\r\n          return this.immutable ? this.texture.clone() : this.texture;\r\n        }\r\n        readPackedPixelsToUint8Array() {\r\n          if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be \"unsigned\"');\r\n          const {\r\n            texSize,\r\n            context: gl\r\n          } = this;\r\n          const result = new Uint8Array(texSize[0] * texSize[1] * 4);\r\n          gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);\r\n          return result;\r\n        }\r\n      \r\n        readPackedPixelsToFloat32Array() {\r\n          return new Float32Array(this.readPackedPixelsToUint8Array().buffer);\r\n        }\r\n      \r\n        readFloatPixelsToFloat32Array() {\r\n          if (this.precision !== 'single') throw new Error('Requires this.precision to be \"single\"');\r\n          const {\r\n            texSize,\r\n            context: gl\r\n          } = this;\r\n          const w = texSize[0];\r\n          const h = texSize[1];\r\n          const result = new Float32Array(w * h * 4);\r\n          gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);\r\n          return result;\r\n        }\r\n      \r\n        getPixels(flip) {\r\n          const {\r\n            context: gl,\r\n            output\r\n          } = this;\r\n          const [width, height] = output;\r\n          const pixels = new Uint8Array(width * height * 4);\r\n          gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\r\n          return new Uint8ClampedArray((flip ? pixels : utils.flipPixels(pixels, width, height)).buffer);\r\n        }\r\n      \r\n        renderKernelsToArrays() {\r\n          const result = {\r\n            result: this.renderOutput(),\r\n          };\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            result[this.subKernels[i].property] = this.mappedTextures[i].toArray();\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        renderKernelsToTextures() {\r\n          const result = {\r\n            result: this.renderOutput(),\r\n          };\r\n          if (this.immutable) {\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              result[this.subKernels[i].property] = this.mappedTextures[i].clone();\r\n            }\r\n          } else {\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              result[this.subKernels[i].property] = this.mappedTextures[i];\r\n            }\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        resetSwitchingKernels() {\r\n          const existingValue = this.switchingKernels;\r\n          this.switchingKernels = null;\r\n          return existingValue;\r\n        }\r\n      \r\n        setOutput(output) {\r\n          const newOutput = this.toKernelOutput(output);\r\n          if (this.program) {\r\n            if (!this.dynamicOutput) {\r\n              throw new Error('Resizing a kernel with dynamicOutput: false is not possible');\r\n            }\r\n            const newThreadDim = [newOutput[0], newOutput[1] || 1, newOutput[2] || 1];\r\n            const newTexSize = utils.getKernelTextureSize({\r\n              optimizeFloatMemory: this.optimizeFloatMemory,\r\n              precision: this.precision,\r\n            }, newThreadDim);\r\n            const oldTexSize = this.texSize;\r\n            if (oldTexSize) {\r\n              const oldPrecision = this.getVariablePrecisionString(oldTexSize, this.tactic);\r\n              const newPrecision = this.getVariablePrecisionString(newTexSize, this.tactic);\r\n              if (oldPrecision !== newPrecision) {\r\n                if (this.debug) {\r\n                  console.warn('Precision requirement changed, asking GPU instance to recompile');\r\n                }\r\n                this.switchKernels({\r\n                  type: 'outputPrecisionMismatch',\r\n                  precision: newPrecision,\r\n                  needed: output\r\n                });\r\n                return;\r\n              }\r\n            }\r\n            this.output = newOutput;\r\n            this.threadDim = newThreadDim;\r\n            this.texSize = newTexSize;\r\n            const { context: gl } = this;\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\r\n            this.updateMaxTexSize();\r\n            this.framebuffer.width = this.texSize[0];\r\n            this.framebuffer.height = this.texSize[1];\r\n            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);\r\n            this.canvas.width = this.maxTexSize[0];\r\n            this.canvas.height = this.maxTexSize[1];\r\n            if (this.texture) {\r\n              this.texture.delete();\r\n            }\r\n            this.texture = null;\r\n            this._setupOutputTexture();\r\n            if (this.mappedTextures && this.mappedTextures.length > 0) {\r\n              for (let i = 0; i < this.mappedTextures.length; i++) {\r\n                this.mappedTextures[i].delete();\r\n              }\r\n              this.mappedTextures = null;\r\n              this._setupSubOutputTextures();\r\n            }\r\n          } else {\r\n            this.output = newOutput;\r\n          }\r\n          return this;\r\n        }\r\n        renderValues() {\r\n          return this.formatValues(\r\n            this.transferValues(),\r\n            this.output[0],\r\n            this.output[1],\r\n            this.output[2]\r\n          );\r\n        }\r\n        switchKernels(reason) {\r\n          if (this.switchingKernels) {\r\n            this.switchingKernels.push(reason);\r\n          } else {\r\n            this.switchingKernels = [reason];\r\n          }\r\n        }\r\n        getVariablePrecisionString(textureSize = this.texSize, tactic = this.tactic, isInt = false) {\r\n          if (!tactic) {\r\n            if (!this.constructor.features.isSpeedTacticSupported) return 'highp';\r\n            const low = this.constructor.features[isInt ? 'lowIntPrecision' : 'lowFloatPrecision'];\r\n            const medium = this.constructor.features[isInt ? 'mediumIntPrecision' : 'mediumFloatPrecision'];\r\n            const high = this.constructor.features[isInt ? 'highIntPrecision' : 'highFloatPrecision'];\r\n            const requiredSize = Math.log2(textureSize[0] * textureSize[1]);\r\n            if (requiredSize <= low.rangeMax) {\r\n              return 'lowp';\r\n            } else if (requiredSize <= medium.rangeMax) {\r\n              return 'mediump';\r\n            } else if (requiredSize <= high.rangeMax) {\r\n              return 'highp';\r\n            } else {\r\n              throw new Error(`The required size exceeds that of the ability of your system`);\r\n            }\r\n          }\r\n          switch (tactic) {\r\n            case 'speed':\r\n              return 'lowp';\r\n            case 'balanced':\r\n              return 'mediump';\r\n            case 'precision':\r\n              return 'highp';\r\n            default:\r\n              throw new Error(`Unknown tactic \"${tactic}\" use \"speed\", \"balanced\", \"precision\", or empty for auto`);\r\n          }\r\n        }\r\n      \r\n        updateTextureArgumentRefs(kernelValue, arg) {\r\n          if (!this.immutable) return;\r\n          if (this.texture.texture === arg.texture) {\r\n            const { prevArg } = kernelValue;\r\n            if (prevArg) {\r\n              if (prevArg.texture._refs === 1) {\r\n                this.texture.delete();\r\n                this.texture = prevArg.clone();\r\n                this._textureSwitched = true;\r\n              }\r\n              prevArg.delete();\r\n            }\r\n            kernelValue.prevArg = arg.clone();\r\n          } else if (this.mappedTextures && this.mappedTextures.length > 0) {\r\n            const { mappedTextures } = this;\r\n            for (let i = 0; i < mappedTextures.length; i++) {\r\n              const mappedTexture = mappedTextures[i];\r\n              if (mappedTexture.texture === arg.texture) {\r\n                const { prevArg } = kernelValue;\r\n                if (prevArg) {\r\n                  if (prevArg.texture._refs === 1) {\r\n                    mappedTexture.delete();\r\n                    mappedTextures[i] = prevArg.clone();\r\n                    this._mappedTextureSwitched[i] = true;\r\n                  }\r\n                  prevArg.delete();\r\n                }\r\n                kernelValue.prevArg = arg.clone();\r\n                return;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      \r\n        onActivate(previousKernel) {\r\n          this._textureSwitched = true;\r\n          this.texture = previousKernel.texture;\r\n          if (this.mappedTextures) {\r\n            for (let i = 0; i < this.mappedTextures.length; i++) {\r\n              this._mappedTextureSwitched[i] = true;\r\n            }\r\n            this.mappedTextures = previousKernel.mappedTextures;\r\n          }\r\n        }\r\n      \r\n        initCanvas() {}\r\n      }\r\n      \r\n      const typeMap = {\r\n        int: 'Integer',\r\n        float: 'Number',\r\n        vec2: 'Array(2)',\r\n        vec3: 'Array(3)',\r\n        vec4: 'Array(4)',\r\n      };\r\n      \r\n      module.exports = {\r\n        GLKernel\r\n      };\r\n      },{\"../../utils\":114,\"../kernel\":36,\"./texture/array-2-float\":16,\"./texture/array-2-float-2d\":14,\"./texture/array-2-float-3d\":15,\"./texture/array-3-float\":19,\"./texture/array-3-float-2d\":17,\"./texture/array-3-float-3d\":18,\"./texture/array-4-float\":22,\"./texture/array-4-float-2d\":20,\"./texture/array-4-float-3d\":21,\"./texture/float\":25,\"./texture/float-2d\":23,\"./texture/float-3d\":24,\"./texture/graphical\":26,\"./texture/memory-optimized\":30,\"./texture/memory-optimized-2d\":28,\"./texture/memory-optimized-3d\":29,\"./texture/unsigned\":33,\"./texture/unsigned-2d\":31,\"./texture/unsigned-3d\":32}],14:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray2Float2D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(2)';\r\n        }\r\n        toArray() {\r\n          return utils.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray2Float2D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],15:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray2Float3D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(2)';\r\n        }\r\n        toArray() {\r\n          return utils.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray2Float3D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],16:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray2Float extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(2)';\r\n        }\r\n        toArray() {\r\n          return utils.erectArray2(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray2Float\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],17:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray3Float2D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(3)';\r\n        }\r\n        toArray() {\r\n          return utils.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray3Float2D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],18:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray3Float3D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(3)';\r\n        }\r\n        toArray() {\r\n          return utils.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray3Float3D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],19:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray3Float extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(3)';\r\n        }\r\n        toArray() {\r\n          return utils.erectArray3(this.renderValues(), this.output[0]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray3Float\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],20:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray4Float2D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(4)';\r\n        }\r\n        toArray() {\r\n          return utils.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray4Float2D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],21:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray4Float3D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(4)';\r\n        }\r\n        toArray() {\r\n          return utils.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray4Float3D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],22:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureArray4Float extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(4)';\r\n        }\r\n        toArray() {\r\n          return utils.erectArray4(this.renderValues(), this.output[0]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureArray4Float\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],23:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureFloat2D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(1)';\r\n        }\r\n        toArray() {\r\n          return utils.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureFloat2D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],24:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureFloat3D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(1)';\r\n        }\r\n        toArray() {\r\n          return utils.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureFloat3D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],25:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTexture } = require('./index');\r\n      \r\n      class GLTextureFloat extends GLTexture {\r\n        get textureType() {\r\n          return this.context.FLOAT;\r\n        }\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(1)';\r\n        }\r\n        renderRawOutput() {\r\n          const gl = this.context;\r\n          const size = this.size;\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\r\n          gl.framebufferTexture2D(\r\n            gl.FRAMEBUFFER,\r\n            gl.COLOR_ATTACHMENT0,\r\n            gl.TEXTURE_2D,\r\n            this.texture,\r\n            0\r\n          );\r\n          const result = new Float32Array(size[0] * size[1] * 4);\r\n          gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.FLOAT, result);\r\n          return result;\r\n        }\r\n        renderValues() {\r\n          if (this._deleted) return null;\r\n          return this.renderRawOutput();\r\n        }\r\n        toArray() {\r\n          return utils.erectFloat(this.renderValues(), this.output[0]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureFloat\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":27}],26:[function(require,module,exports){\r\n      const { GLTextureUnsigned } = require('./unsigned');\r\n      \r\n      class GLTextureGraphical extends GLTextureUnsigned {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'ArrayTexture(4)';\r\n        }\r\n        toArray() {\r\n          return this.renderValues();\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureGraphical\r\n      };\r\n      },{\"./unsigned\":33}],27:[function(require,module,exports){\r\n      const { Texture } = require('../../../texture');\r\n      \r\n      class GLTexture extends Texture {\r\n        get textureType() {\r\n          throw new Error(`\"textureType\" not implemented on ${ this.name }`);\r\n        }\r\n      \r\n        clone() {\r\n          return new this.constructor(this);\r\n        }\r\n      \r\n        beforeMutate() {\r\n          if (this.texture._refs > 1) {\r\n            this.newTexture();\r\n            return true;\r\n          }\r\n          return false;\r\n        }\r\n      \r\n        cloneTexture() {\r\n          this.texture._refs--;\r\n          const { context: gl, size, texture, kernel } = this;\r\n          if (kernel.debug) {\r\n            console.warn('cloning internal texture');\r\n          }\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\r\n          selectTexture(gl, texture);\r\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n          const target = gl.createTexture();\r\n          selectTexture(gl, target);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);\r\n          gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, size[0], size[1]);\r\n          target._refs = 1;\r\n          this.texture = target;\r\n        }\r\n      \r\n        newTexture() {\r\n          this.texture._refs--;\r\n          const gl = this.context;\r\n          const size = this.size;\r\n          const kernel = this.kernel;\r\n          if (kernel.debug) {\r\n            console.warn('new internal texture');\r\n          }\r\n          const target = gl.createTexture();\r\n          selectTexture(gl, target);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);\r\n          target._refs = 1;\r\n          this.texture = target;\r\n        }\r\n      \r\n        clear() {\r\n          if (this.texture._refs) {\r\n            this.texture._refs--;\r\n            const gl = this.context;\r\n            const target = this.texture = gl.createTexture();\r\n            selectTexture(gl, target);\r\n            const size = this.size;\r\n            target._refs = 1;\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);\r\n          }\r\n          const { context: gl, texture } = this;\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\r\n          gl.bindTexture(gl.TEXTURE_2D, texture);\r\n          selectTexture(gl, texture);\r\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n          gl.clearColor(0, 0, 0, 0);\r\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n        }\r\n      \r\n        delete() {\r\n          if (this._deleted) return;\r\n          this._deleted = true;\r\n          if (this.texture._refs) {\r\n            this.texture._refs--;\r\n            if (this.texture._refs) return;\r\n          }\r\n          this.context.deleteTexture(this.texture);\r\n        }\r\n      \r\n        framebuffer() {\r\n          if (!this._framebuffer) {\r\n            this._framebuffer = this.kernel.getRawValueFramebuffer(this.size[0], this.size[1]);\r\n          }\r\n          return this._framebuffer;\r\n        }\r\n      }\r\n      \r\n      function selectTexture(gl, texture) {\r\n        gl.activeTexture(gl.TEXTURE15);\r\n        gl.bindTexture(gl.TEXTURE_2D, texture);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n      }\r\n      \r\n      module.exports = { GLTexture };\r\n      },{\"../../../texture\":113}],28:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureMemoryOptimized2D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'MemoryOptimizedNumberTexture';\r\n        }\r\n        toArray() {\r\n          return utils.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureMemoryOptimized2D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],29:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureMemoryOptimized3D extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'MemoryOptimizedNumberTexture';\r\n        }\r\n        toArray() {\r\n          return utils.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureMemoryOptimized3D\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],30:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureFloat } = require('./float');\r\n      \r\n      class GLTextureMemoryOptimized extends GLTextureFloat {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'MemoryOptimizedNumberTexture';\r\n        }\r\n        toArray() {\r\n          return utils.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureMemoryOptimized\r\n      };\r\n      },{\"../../../utils\":114,\"./float\":25}],31:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureUnsigned } = require('./unsigned');\r\n      \r\n      class GLTextureUnsigned2D extends GLTextureUnsigned {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'NumberTexture';\r\n        }\r\n        toArray() {\r\n          return utils.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureUnsigned2D\r\n      };\r\n      },{\"../../../utils\":114,\"./unsigned\":33}],32:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTextureUnsigned } = require('./unsigned');\r\n      \r\n      class GLTextureUnsigned3D extends GLTextureUnsigned {\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'NumberTexture';\r\n        }\r\n        toArray() {\r\n          return utils.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureUnsigned3D\r\n      };\r\n      },{\"../../../utils\":114,\"./unsigned\":33}],33:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { GLTexture } = require('./index');\r\n      \r\n      class GLTextureUnsigned extends GLTexture {\r\n        get textureType() {\r\n          return this.context.UNSIGNED_BYTE;\r\n        }\r\n        constructor(settings) {\r\n          super(settings);\r\n          this.type = 'NumberTexture';\r\n        }\r\n        renderRawOutput() {\r\n          const { context: gl } = this;\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\r\n          gl.framebufferTexture2D(\r\n            gl.FRAMEBUFFER,\r\n            gl.COLOR_ATTACHMENT0,\r\n            gl.TEXTURE_2D,\r\n            this.texture,\r\n            0\r\n          );\r\n          const result = new Uint8Array(this.size[0] * this.size[1] * 4);\r\n          gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);\r\n          return result;\r\n        }\r\n        renderValues() {\r\n          if (this._deleted) return null;\r\n          return new Float32Array(this.renderRawOutput().buffer);\r\n        }\r\n        toArray() {\r\n          return utils.erectPackedFloat(this.renderValues(), this.output[0]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        GLTextureUnsigned\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":27}],34:[function(require,module,exports){\r\n      const getContext = require('gl');\r\n      const { WebGLKernel } = require('../web-gl/kernel');\r\n      const { glKernelString } = require('../gl/kernel-string');\r\n      \r\n      let isSupported = null;\r\n      let testCanvas = null;\r\n      let testContext = null;\r\n      let testExtensions = null;\r\n      let features = null;\r\n      \r\n      class HeadlessGLKernel extends WebGLKernel {\r\n        static get isSupported() {\r\n          if (isSupported !== null) return isSupported;\r\n          this.setupFeatureChecks();\r\n          isSupported = testContext !== null;\r\n          return isSupported;\r\n        }\r\n      \r\n        static setupFeatureChecks() {\r\n          testCanvas = null;\r\n          testExtensions = null;\r\n          if (typeof getContext !== 'function') return;\r\n          try { \r\n            testContext = getContext(2, 2, {\r\n              preserveDrawingBuffer: true\r\n            });\r\n            if (!testContext || !testContext.getExtension) return;\r\n            testExtensions = {\r\n              STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),\r\n              STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),\r\n              OES_texture_float: testContext.getExtension('OES_texture_float'),\r\n              OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),\r\n              OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),\r\n              WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),\r\n              WEBGL_color_buffer_float: testContext.getExtension('WEBGL_color_buffer_float'),\r\n            };\r\n            features = this.getFeatures();\r\n          } catch (e) {\r\n            console.warn(e);\r\n          }\r\n        }\r\n      \r\n        static isContextMatch(context) {\r\n          try {\r\n            return context.getParameter(context.RENDERER) === 'ANGLE';\r\n          } catch (e) {\r\n            return false;\r\n          }\r\n        }\r\n      \r\n        static getIsTextureFloat() {\r\n          return Boolean(testExtensions.OES_texture_float);\r\n        }\r\n      \r\n        static getIsDrawBuffers() {\r\n          return Boolean(testExtensions.WEBGL_draw_buffers);\r\n        }\r\n      \r\n        static getChannelCount() {\r\n          return testExtensions.WEBGL_draw_buffers ?\r\n            testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :\r\n            1;\r\n        }\r\n      \r\n        static getMaxTextureSize() {\r\n          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);\r\n        }\r\n      \r\n        static get testCanvas() {\r\n          return testCanvas;\r\n        }\r\n      \r\n        static get testContext() {\r\n          return testContext;\r\n        }\r\n      \r\n        static get features() {\r\n          return features;\r\n        }\r\n      \r\n        initCanvas() {\r\n          return {};\r\n        }\r\n      \r\n        initContext() {\r\n          return getContext(2, 2, {\r\n            preserveDrawingBuffer: true\r\n          });\r\n        }\r\n      \r\n        initExtensions() {\r\n          this.extensions = {\r\n            STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),\r\n            STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),\r\n            OES_texture_float: this.context.getExtension('OES_texture_float'),\r\n            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),\r\n            OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),\r\n            WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),\r\n          };\r\n        }\r\n      \r\n        build() {\r\n          super.build.apply(this, arguments);\r\n          if (!this.fallbackRequested) {\r\n            this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);\r\n          }\r\n        }\r\n      \r\n        destroyExtensions() {\r\n          this.extensions.STACKGL_resize_drawingbuffer = null;\r\n          this.extensions.STACKGL_destroy_context = null;\r\n          this.extensions.OES_texture_float = null;\r\n          this.extensions.OES_texture_float_linear = null;\r\n          this.extensions.OES_element_index_uint = null;\r\n          this.extensions.WEBGL_draw_buffers = null;\r\n        }\r\n      \r\n        static destroyContext(context) {\r\n          const extension = context.getExtension('STACKGL_destroy_context');\r\n          if (extension && extension.destroy) {\r\n            extension.destroy();\r\n          }\r\n        }\r\n      \r\n        toString() {\r\n          const setupContextString = `const gl = context || require('gl')(1, 1);\\n`;\r\n          const destroyContextString = `    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\\n`;\r\n          return glKernelString(this.constructor, arguments, this, setupContextString, destroyContextString);\r\n        }\r\n      \r\n        setOutput(output) {\r\n          super.setOutput(output);\r\n          if (this.graphical && this.extensions.STACKGL_resize_drawingbuffer) {\r\n            this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);\r\n          }\r\n          return this;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        HeadlessGLKernel\r\n      };\r\n      },{\"../gl/kernel-string\":12,\"../web-gl/kernel\":70,\"gl\":2}],35:[function(require,module,exports){\r\n      class KernelValue {\r\n        constructor(value, settings) {\r\n          const {\r\n            name,\r\n            kernel,\r\n            context,\r\n            checkContext,\r\n            onRequestContextHandle,\r\n            onUpdateValueMismatch,\r\n            origin,\r\n            strictIntegers,\r\n            type,\r\n            tactic,\r\n          } = settings;\r\n          if (!name) {\r\n            throw new Error('name not set');\r\n          }\r\n          if (!type) {\r\n            throw new Error('type not set');\r\n          }\r\n          if (!origin) {\r\n            throw new Error('origin not set');\r\n          }\r\n          if (origin !== 'user' && origin !== 'constants') {\r\n            throw new Error(`origin must be \"user\" or \"constants\" value is \"${ origin }\"`);\r\n          }\r\n          if (!onRequestContextHandle) {\r\n            throw new Error('onRequestContextHandle is not set');\r\n          }\r\n          this.name = name;\r\n          this.origin = origin;\r\n          this.tactic = tactic;\r\n          this.varName = origin === 'constants' ? `constants.${name}` : name;\r\n          this.kernel = kernel;\r\n          this.strictIntegers = strictIntegers;\r\n          this.type = value.type || type;\r\n          this.size = value.size || null;\r\n          this.index = null;\r\n          this.context = context;\r\n          this.checkContext = checkContext !== null && checkContext !== undefined ? checkContext : true;\r\n          this.contextHandle = null;\r\n          this.onRequestContextHandle = onRequestContextHandle;\r\n          this.onUpdateValueMismatch = onUpdateValueMismatch;\r\n          this.forceUploadEachRun = null;\r\n        }\r\n      \r\n        get id() {\r\n          return `${this.origin}_${name}`;\r\n        }\r\n      \r\n        getSource() {\r\n          throw new Error(`\"getSource\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          throw new Error(`\"updateValue\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        KernelValue\r\n      };\r\n      },{}],36:[function(require,module,exports){\r\n      const { utils } = require('../utils');\r\n      const { Input } = require('../input');\r\n      \r\n      class Kernel {\r\n        static get isSupported() {\r\n          throw new Error(`\"isSupported\" not implemented on ${ this.name }`);\r\n        }\r\n      \r\n        static isContextMatch(context) {\r\n          throw new Error(`\"isContextMatch\" not implemented on ${ this.name }`);\r\n        }\r\n      \r\n        static getFeatures() {\r\n          throw new Error(`\"getFeatures\" not implemented on ${ this.name }`);\r\n        }\r\n      \r\n        static destroyContext(context) {\r\n          throw new Error(`\"destroyContext\" called on ${ this.name }`);\r\n        }\r\n      \r\n        static nativeFunctionArguments() {\r\n          throw new Error(`\"nativeFunctionArguments\" called on ${ this.name }`);\r\n        }\r\n      \r\n        static nativeFunctionReturnType() {\r\n          throw new Error(`\"nativeFunctionReturnType\" called on ${ this.name }`);\r\n        }\r\n      \r\n        static combineKernels() {\r\n          throw new Error(`\"combineKernels\" called on ${ this.name }`);\r\n        }\r\n      \r\n        constructor(source, settings) {\r\n          if (typeof source !== 'object') {\r\n            if (typeof source !== 'string') {\r\n              throw new Error('source not a string');\r\n            }\r\n            if (!utils.isFunctionString(source)) {\r\n              throw new Error('source not a function string');\r\n            }\r\n          }\r\n          this.useLegacyEncoder = false;\r\n          this.fallbackRequested = false;\r\n          this.onRequestFallback = null;\r\n      \r\n          this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;\r\n          this.argumentTypes = null;\r\n          this.argumentSizes = null;\r\n          this.argumentBitRatios = null;\r\n          this.kernelArguments = null;\r\n          this.kernelConstants = null;\r\n          this.forceUploadKernelConstants = null;\r\n      \r\n      \r\n          this.source = source;\r\n      \r\n          this.output = null;\r\n      \r\n          this.debug = false;\r\n      \r\n          this.graphical = false;\r\n      \r\n          this.loopMaxIterations = 0;\r\n      \r\n          this.constants = null;\r\n      \r\n          this.constantTypes = null;\r\n      \r\n          this.constantBitRatios = null;\r\n      \r\n          this.dynamicArguments = false;\r\n      \r\n          this.dynamicOutput = false;\r\n      \r\n          this.canvas = null;\r\n      \r\n          this.context = null;\r\n      \r\n          this.checkContext = null;\r\n      \r\n          this.gpu = null;\r\n      \r\n          this.functions = null;\r\n      \r\n          this.nativeFunctions = null;\r\n      \r\n          this.injectedNative = null;\r\n      \r\n          this.subKernels = null;\r\n      \r\n          this.validate = true;\r\n      \r\n          this.immutable = false;\r\n      \r\n          this.pipeline = false;\r\n      \r\n          this.precision = null;\r\n      \r\n          this.tactic = null;\r\n      \r\n          this.plugins = null;\r\n      \r\n          this.returnType = null;\r\n          this.leadingReturnStatement = null;\r\n          this.followingReturnStatement = null;\r\n          this.optimizeFloatMemory = null;\r\n          this.strictIntegers = false;\r\n          this.fixIntegerDivisionAccuracy = null;\r\n          this.built = false;\r\n          this.signature = null;\r\n        }\r\n      \r\n        mergeSettings(settings) {\r\n          for (let p in settings) {\r\n            if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;\r\n            switch (p) {\r\n              case 'output':\r\n                if (!Array.isArray(settings.output)) {\r\n                  this.setOutput(settings.output); \r\n                  continue;\r\n                }\r\n                break;\r\n              case 'functions':\r\n                this.functions = [];\r\n                for (let i = 0; i < settings.functions.length; i++) {\r\n                  this.addFunction(settings.functions[i]);\r\n                }\r\n                continue;\r\n              case 'graphical':\r\n                if (settings[p] && !settings.hasOwnProperty('precision')) {\r\n                  this.precision = 'unsigned';\r\n                }\r\n                this[p] = settings[p];\r\n                continue;\r\n              case 'nativeFunctions':\r\n                if (!settings.nativeFunctions) continue;\r\n                this.nativeFunctions = [];\r\n                for (let i = 0; i < settings.nativeFunctions.length; i++) {\r\n                  const s = settings.nativeFunctions[i];\r\n                  const { name, source } = s;\r\n                  this.addNativeFunction(name, source, s);\r\n                }\r\n                continue;\r\n            }\r\n            this[p] = settings[p];\r\n          }\r\n      \r\n          if (!this.canvas) this.canvas = this.initCanvas();\r\n          if (!this.context) this.context = this.initContext();\r\n          if (!this.plugins) this.plugins = this.initPlugins(settings);\r\n        }\r\n        build() {\r\n          throw new Error(`\"build\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        run() {\r\n          throw new Error(`\"run\" not defined on ${ this.constructor.name }`)\r\n        }\r\n      \r\n        initCanvas() {\r\n          throw new Error(`\"initCanvas\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        initContext() {\r\n          throw new Error(`\"initContext\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        initPlugins(settings) {\r\n          throw new Error(`\"initPlugins\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        addFunction(source, settings = {}) {\r\n          if (source.name && source.source && source.argumentTypes && 'returnType' in source) {\r\n            this.functions.push(source);\r\n          } else if ('settings' in source && 'source' in source) {\r\n            this.functions.push(this.functionToIGPUFunction(source.source, source.settings));\r\n          } else if (typeof source === 'string' || typeof source === 'function') {\r\n            this.functions.push(this.functionToIGPUFunction(source, settings));\r\n          } else {\r\n            throw new Error(`function not properly defined`);\r\n          }\r\n          return this;\r\n        }\r\n      \r\n        addNativeFunction(name, source, settings = {}) {\r\n          const { argumentTypes, argumentNames } = settings.argumentTypes ?\r\n            splitArgumentTypes(settings.argumentTypes) :\r\n            this.constructor.nativeFunctionArguments(source) || {};\r\n          this.nativeFunctions.push({\r\n            name,\r\n            source,\r\n            settings,\r\n            argumentTypes,\r\n            argumentNames,\r\n            returnType: settings.returnType || this.constructor.nativeFunctionReturnType(source)\r\n          });\r\n          return this;\r\n        }\r\n      \r\n        setupArguments(args) {\r\n          this.kernelArguments = [];\r\n          if (!this.argumentTypes) {\r\n            if (!this.argumentTypes) {\r\n              this.argumentTypes = [];\r\n              for (let i = 0; i < args.length; i++) {\r\n                const argType = utils.getVariableType(args[i], this.strictIntegers);\r\n                const type = argType === 'Integer' ? 'Number' : argType;\r\n                this.argumentTypes.push(type);\r\n                this.kernelArguments.push({\r\n                  type\r\n                });\r\n              }\r\n            }\r\n          } else {\r\n            for (let i = 0; i < this.argumentTypes.length; i++) {\r\n              this.kernelArguments.push({\r\n                type: this.argumentTypes[i]\r\n              });\r\n            }\r\n          }\r\n      \r\n          this.argumentSizes = new Array(args.length);\r\n          this.argumentBitRatios = new Int32Array(args.length);\r\n      \r\n          for (let i = 0; i < args.length; i++) {\r\n            const arg = args[i];\r\n            this.argumentSizes[i] = arg.constructor === Input ? arg.size : null;\r\n            this.argumentBitRatios[i] = this.getBitRatio(arg);\r\n          }\r\n      \r\n          if (this.argumentNames.length !== args.length) {\r\n            throw new Error(`arguments are miss-aligned`);\r\n          }\r\n        }\r\n      \r\n        setupConstants() {\r\n          this.kernelConstants = [];\r\n          let needsConstantTypes = this.constantTypes === null;\r\n          if (needsConstantTypes) {\r\n            this.constantTypes = {};\r\n          }\r\n          this.constantBitRatios = {};\r\n          if (this.constants) {\r\n            for (let name in this.constants) {\r\n              if (needsConstantTypes) {\r\n                const type = utils.getVariableType(this.constants[name], this.strictIntegers);\r\n                this.constantTypes[name] = type;\r\n                this.kernelConstants.push({\r\n                  name,\r\n                  type\r\n                });\r\n              } else {\r\n                this.kernelConstants.push({\r\n                  name,\r\n                  type: this.constantTypes[name]\r\n                });\r\n              }\r\n              this.constantBitRatios[name] = this.getBitRatio(this.constants[name]);\r\n            }\r\n          }\r\n        }\r\n      \r\n        setOptimizeFloatMemory(flag) {\r\n          this.optimizeFloatMemory = flag;\r\n          return this;\r\n        }\r\n      \r\n        toKernelOutput(output) {\r\n          if (output.hasOwnProperty('x')) {\r\n            if (output.hasOwnProperty('y')) {\r\n              if (output.hasOwnProperty('z')) {\r\n                return [output.x, output.y, output.z];\r\n              } else {\r\n                return [output.x, output.y];\r\n              }\r\n            } else {\r\n              return [output.x];\r\n            }\r\n          } else {\r\n            return output;\r\n          }\r\n        }\r\n      \r\n        setOutput(output) {\r\n          this.output = this.toKernelOutput(output);\r\n          return this;\r\n        }\r\n      \r\n        setDebug(flag) {\r\n          this.debug = flag;\r\n          return this;\r\n        }\r\n      \r\n        setGraphical(flag) {\r\n          this.graphical = flag;\r\n          this.precision = 'unsigned';\r\n          return this;\r\n        }\r\n      \r\n        setLoopMaxIterations(max) {\r\n          this.loopMaxIterations = max;\r\n          return this;\r\n        }\r\n      \r\n        setConstants(constants) {\r\n          this.constants = constants;\r\n          return this;\r\n        }\r\n      \r\n        setConstantTypes(constantTypes) {\r\n          this.constantTypes = constantTypes;\r\n          return this;\r\n        }\r\n      \r\n        setFunctions(functions) {\r\n          for (let i = 0; i < functions.length; i++) {\r\n            this.addFunction(functions[i]);\r\n          }\r\n          return this;\r\n        }\r\n      \r\n        setNativeFunctions(nativeFunctions) {\r\n          for (let i = 0; i < nativeFunctions.length; i++) {\r\n            const settings = nativeFunctions[i];\r\n            const { name, source } = settings;\r\n            this.addNativeFunction(name, source, settings);\r\n          }\r\n          return this;\r\n        }\r\n      \r\n        setInjectedNative(injectedNative) {\r\n          this.injectedNative = injectedNative;\r\n          return this;\r\n        }\r\n      \r\n        setPipeline(flag) {\r\n          this.pipeline = flag;\r\n          return this;\r\n        }\r\n      \r\n        setPrecision(flag) {\r\n          this.precision = flag;\r\n          return this;\r\n        }\r\n      \r\n        setDimensions(flag) {\r\n          utils.warnDeprecated('method', 'setDimensions', 'setOutput');\r\n          this.output = flag;\r\n          return this;\r\n        }\r\n      \r\n        setOutputToTexture(flag) {\r\n          utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');\r\n          this.pipeline = flag;\r\n          return this;\r\n        }\r\n      \r\n        setImmutable(flag) {\r\n          this.immutable = flag;\r\n          return this;\r\n        }\r\n      \r\n        setCanvas(canvas) {\r\n          this.canvas = canvas;\r\n          return this;\r\n        }\r\n      \r\n        setStrictIntegers(flag) {\r\n          this.strictIntegers = flag;\r\n          return this;\r\n        }\r\n      \r\n        setDynamicOutput(flag) {\r\n          this.dynamicOutput = flag;\r\n          return this;\r\n        }\r\n      \r\n        setHardcodeConstants(flag) {\r\n          utils.warnDeprecated('method', 'setHardcodeConstants');\r\n          this.setDynamicOutput(flag);\r\n          this.setDynamicArguments(flag);\r\n          return this;\r\n        }\r\n      \r\n        setDynamicArguments(flag) {\r\n          this.dynamicArguments = flag;\r\n          return this;\r\n        }\r\n      \r\n        setUseLegacyEncoder(flag) {\r\n          this.useLegacyEncoder = flag;\r\n          return this;\r\n        }\r\n      \r\n        setWarnVarUsage(flag) {\r\n          utils.warnDeprecated('method', 'setWarnVarUsage');\r\n          return this;\r\n        }\r\n      \r\n        getCanvas() {\r\n          utils.warnDeprecated('method', 'getCanvas');\r\n          return this.canvas;\r\n        }\r\n      \r\n        getWebGl() {\r\n          utils.warnDeprecated('method', 'getWebGl');\r\n          return this.context;\r\n        }\r\n      \r\n        setContext(context) {\r\n          this.context = context;\r\n          return this;\r\n        }\r\n      \r\n        setArgumentTypes(argumentTypes) {\r\n          if (Array.isArray(argumentTypes)) {\r\n            this.argumentTypes = argumentTypes;\r\n          } else {\r\n            this.argumentTypes = [];\r\n            for (const p in argumentTypes) {\r\n              if (!argumentTypes.hasOwnProperty(p)) continue;\r\n              const argumentIndex = this.argumentNames.indexOf(p);\r\n              if (argumentIndex === -1) throw new Error(`unable to find argument ${ p }`);\r\n              this.argumentTypes[argumentIndex] = argumentTypes[p];\r\n            }\r\n          }\r\n          return this;\r\n        }\r\n      \r\n        setTactic(tactic) {\r\n          this.tactic = tactic;\r\n          return this;\r\n        }\r\n      \r\n        requestFallback(args) {\r\n          if (!this.onRequestFallback) {\r\n            throw new Error(`\"onRequestFallback\" not defined on ${ this.constructor.name }`);\r\n          }\r\n          this.fallbackRequested = true;\r\n          return this.onRequestFallback(args);\r\n        }\r\n      \r\n        validateSettings() {\r\n          throw new Error(`\"validateSettings\" not defined on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        addSubKernel(subKernel) {\r\n          if (this.subKernels === null) {\r\n            this.subKernels = [];\r\n          }\r\n          if (!subKernel.source) throw new Error('subKernel missing \"source\" property');\r\n          if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing \"property\" property');\r\n          if (!subKernel.name) throw new Error('subKernel missing \"name\" property');\r\n          this.subKernels.push(subKernel);\r\n          return this;\r\n        }\r\n      \r\n        destroy(removeCanvasReferences) {\r\n          throw new Error(`\"destroy\" called on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        getBitRatio(value) {\r\n          if (this.precision === 'single') {\r\n            return 4;\r\n          } else if (Array.isArray(value[0])) {\r\n            return this.getBitRatio(value[0]);\r\n          } else if (value.constructor === Input) {\r\n            return this.getBitRatio(value.value);\r\n          }\r\n          switch (value.constructor) {\r\n            case Uint8ClampedArray:\r\n            case Uint8Array:\r\n            case Int8Array:\r\n              return 1;\r\n            case Uint16Array:\r\n            case Int16Array:\r\n              return 2;\r\n            case Float32Array:\r\n            case Int32Array:\r\n            default:\r\n              return 4;\r\n          }\r\n        }\r\n      \r\n        getPixels(flip) {\r\n          throw new Error(`\"getPixels\" called on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        checkOutput() {\r\n          if (!this.output || !utils.isArray(this.output)) throw new Error('kernel.output not an array');\r\n          if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');\r\n          for (let i = 0; i < this.output.length; i++) {\r\n            if (isNaN(this.output[i]) || this.output[i] < 1) {\r\n              throw new Error(`${ this.constructor.name }.output[${ i }] incorrectly defined as \\`${ this.output[i] }\\`, needs to be numeric, and greater than 0`);\r\n            }\r\n          }\r\n        }\r\n      \r\n        prependString(value) {\r\n          throw new Error(`\"prependString\" called on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        hasPrependString(value) {\r\n          throw new Error(`\"hasPrependString\" called on ${ this.constructor.name }`);\r\n        }\r\n      \r\n        toJSON() {\r\n          return {\r\n            settings: {\r\n              output: this.output,\r\n              pipeline: this.pipeline,\r\n              argumentNames: this.argumentNames,\r\n              argumentsTypes: this.argumentTypes,\r\n              constants: this.constants,\r\n              pluginNames: this.plugins ? this.plugins.map(plugin => plugin.name) : null,\r\n              returnType: this.returnType,\r\n            }\r\n          };\r\n        }\r\n      \r\n        buildSignature(args) {\r\n          const Constructor = this.constructor;\r\n          this.signature = Constructor.getSignature(this, Constructor.getArgumentTypes(this, args));\r\n        }\r\n      \r\n        static getArgumentTypes(kernel, args) {\r\n          const argumentTypes = new Array(args.length);\r\n          for (let i = 0; i < args.length; i++) {\r\n            const arg = args[i];\r\n            const type = kernel.argumentTypes[i];\r\n            if (arg.type) {\r\n              argumentTypes[i] = arg.type;\r\n            } else {\r\n              switch (type) {\r\n                case 'Number':\r\n                case 'Integer':\r\n                case 'Float':\r\n                case 'ArrayTexture(1)':\r\n                  argumentTypes[i] = utils.getVariableType(arg);\r\n                  break;\r\n                default:\r\n                  argumentTypes[i] = type;\r\n              }\r\n            }\r\n          }\r\n          return argumentTypes;\r\n        }\r\n      \r\n        static getSignature(kernel, argumentTypes) {\r\n          throw new Error(`\"getSignature\" not implemented on ${ this.name }`);\r\n        }\r\n      \r\n        functionToIGPUFunction(source, settings = {}) {\r\n          if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');\r\n          const sourceString = typeof source === 'string' ? source : source.toString();\r\n          let argumentTypes = [];\r\n      \r\n          if (Array.isArray(settings.argumentTypes)) {\r\n            argumentTypes = settings.argumentTypes;\r\n          } else if (typeof settings.argumentTypes === 'object') {\r\n            argumentTypes = utils.getArgumentNamesFromString(sourceString)\r\n              .map(name => settings.argumentTypes[name]) || [];\r\n          } else {\r\n            argumentTypes = settings.argumentTypes || [];\r\n          }\r\n      \r\n          return {\r\n            name: utils.getFunctionNameFromString(sourceString) || null,\r\n            source: sourceString,\r\n            argumentTypes,\r\n            returnType: settings.returnType || null,\r\n          };\r\n        }\r\n      \r\n        onActivate(previousKernel) {}\r\n      }\r\n      \r\n      function splitArgumentTypes(argumentTypesObject) {\r\n        const argumentNames = Object.keys(argumentTypesObject);\r\n        const argumentTypes = [];\r\n        for (let i = 0; i < argumentNames.length; i++) {\r\n          const argumentName = argumentNames[i];\r\n          argumentTypes.push(argumentTypesObject[argumentName]);\r\n        }\r\n        return { argumentTypes, argumentNames };\r\n      }\r\n      \r\n      module.exports = {\r\n        Kernel\r\n      };\r\n      },{\"../input\":110,\"../utils\":114}],37:[function(require,module,exports){\r\n      const fragmentShader = `__HEADER__;\r\n      __FLOAT_TACTIC_DECLARATION__;\r\n      __INT_TACTIC_DECLARATION__;\r\n      __SAMPLER_2D_TACTIC_DECLARATION__;\r\n      \r\n      const int LOOP_MAX = __LOOP_MAX__;\r\n      \r\n      __PLUGINS__;\r\n      __CONSTANTS__;\r\n      \r\n      varying vec2 vTexCoord;\r\n      \r\n      float acosh(float x) {\r\n        return log(x + sqrt(x * x - 1.0));\r\n      }\r\n      \r\n      float sinh(float x) {\r\n        return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;\r\n      }\r\n      \r\n      float asinh(float x) {\r\n        return log(x + sqrt(x * x + 1.0));\r\n      }\r\n      \r\n      float atan2(float v1, float v2) {\r\n        if (v1 == 0.0 || v2 == 0.0) return 0.0;\r\n        return atan(v1 / v2);\r\n      }\r\n      \r\n      float atanh(float x) {\r\n        x = (x + 1.0) / (x - 1.0);\r\n        if (x < 0.0) {\r\n          return 0.5 * log(-x);\r\n        }\r\n        return 0.5 * log(x);\r\n      }\r\n      \r\n      float cbrt(float x) {\r\n        if (x >= 0.0) {\r\n          return pow(x, 1.0 / 3.0);\r\n        } else {\r\n          return -pow(x, 1.0 / 3.0);\r\n        }\r\n      }\r\n      \r\n      float cosh(float x) {\r\n        return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; \r\n      }\r\n      \r\n      float expm1(float x) {\r\n        return pow(${Math.E}, x) - 1.0; \r\n      }\r\n      \r\n      float fround(highp float x) {\r\n        return x;\r\n      }\r\n      \r\n      float imul(float v1, float v2) {\r\n        return float(int(v1) * int(v2));\r\n      }\r\n      \r\n      float log10(float x) {\r\n        return log2(x) * (1.0 / log2(10.0));\r\n      }\r\n      \r\n      float log1p(float x) {\r\n        return log(1.0 + x);\r\n      }\r\n      \r\n      float _pow(float v1, float v2) {\r\n        if (v2 == 0.0) return 1.0;\r\n        return pow(v1, v2);\r\n      }\r\n      \r\n      float tanh(float x) {\r\n        float e = exp(2.0 * x);\r\n        return (e - 1.0) / (e + 1.0);\r\n      }\r\n      \r\n      float trunc(float x) {\r\n        if (x >= 0.0) {\r\n          return floor(x); \r\n        } else {\r\n          return ceil(x);\r\n        }\r\n      }\r\n      \r\n      vec4 _round(vec4 x) {\r\n        return floor(x + 0.5);\r\n      }\r\n      \r\n      float _round(float x) {\r\n        return floor(x + 0.5);\r\n      }\r\n      \r\n      const int BIT_COUNT = 32;\r\n      int modi(int x, int y) {\r\n        return x - y * (x / y);\r\n      }\r\n      \r\n      int bitwiseOr(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 || b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseXOR(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 || b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseAnd(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 && b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseNot(int a) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (modi(a, 2) == 0) {\r\n            result += n;    \r\n          }\r\n          a = a / 2;\r\n          n = n * 2;\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseZeroFillLeftShift(int n, int shift) {\r\n        int maxBytes = BIT_COUNT;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (maxBytes >= n) {\r\n            break;\r\n          }\r\n          maxBytes *= 2;\r\n        }\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= shift) {\r\n            break;\r\n          }\r\n          n *= 2;\r\n        }\r\n      \r\n        int result = 0;\r\n        int byteVal = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= maxBytes) break;\r\n          if (modi(n, 2) > 0) { result += byteVal; }\r\n          n = int(n / 2);\r\n          byteVal *= 2;\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      int bitwiseSignedRightShift(int num, int shifts) {\r\n        return int(floor(float(num) / pow(2.0, float(shifts))));\r\n      }\r\n      \r\n      int bitwiseZeroFillRightShift(int n, int shift) {\r\n        int maxBytes = BIT_COUNT;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (maxBytes >= n) {\r\n            break;\r\n          }\r\n          maxBytes *= 2;\r\n        }\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= shift) {\r\n            break;\r\n          }\r\n          n /= 2;\r\n        }\r\n        int result = 0;\r\n        int byteVal = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= maxBytes) break;\r\n          if (modi(n, 2) > 0) { result += byteVal; }\r\n          n = int(n / 2);\r\n          byteVal *= 2;\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      vec2 integerMod(vec2 x, float y) {\r\n        vec2 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      vec3 integerMod(vec3 x, float y) {\r\n        vec3 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      vec4 integerMod(vec4 x, vec4 y) {\r\n        vec4 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      float integerMod(float x, float y) {\r\n        float res = floor(mod(x, y));\r\n        return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\r\n      }\r\n      \r\n      int integerMod(int x, int y) {\r\n        return x - (y * int(x / y));\r\n      }\r\n      \r\n      __DIVIDE_WITH_INTEGER_CHECK__;\r\n      \r\n      // Here be dragons!\r\n      // DO NOT OPTIMIZE THIS CODE\r\n      // YOU WILL BREAK SOMETHING ON SOMEBODY\\'S MACHINE\r\n      // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\r\n      const vec2 MAGIC_VEC = vec2(1.0, -256.0);\r\n      const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\r\n      const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\r\n      float decode32(vec4 texel) {\r\n        __DECODE32_ENDIANNESS__;\r\n        texel *= 255.0;\r\n        vec2 gte128;\r\n        gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;\r\n        gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\r\n        float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\r\n        float res = exp2(_round(exponent));\r\n        texel.b = texel.b - 128.0 * gte128.x;\r\n        res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;\r\n        res *= gte128.y * -2.0 + 1.0;\r\n        return res;\r\n      }\r\n      \r\n      float decode16(vec4 texel, int index) {\r\n        int channel = integerMod(index, 2);\r\n        if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;\r\n        if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;\r\n        return 0.0;\r\n      }\r\n      \r\n      float decode8(vec4 texel, int index) {\r\n        int channel = integerMod(index, 4);\r\n        if (channel == 0) return texel.r * 255.0;\r\n        if (channel == 1) return texel.g * 255.0;\r\n        if (channel == 2) return texel.b * 255.0;\r\n        if (channel == 3) return texel.a * 255.0;\r\n        return 0.0;\r\n      }\r\n      \r\n      vec4 legacyEncode32(float f) {\r\n        float F = abs(f);\r\n        float sign = f < 0.0 ? 1.0 : 0.0;\r\n        float exponent = floor(log2(F));\r\n        float mantissa = (exp2(-exponent) * F);\r\n        // exponent += floor(log2(mantissa));\r\n        vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\r\n        texel.rg = integerMod(texel.rg, 256.0);\r\n        texel.b = integerMod(texel.b, 128.0);\r\n        texel.a = exponent*0.5 + 63.5;\r\n        texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\r\n        texel = floor(texel);\r\n        texel *= 0.003921569; // 1/255\r\n        __ENCODE32_ENDIANNESS__;\r\n        return texel;\r\n      }\r\n      \r\n      // https://github.com/gpujs/gpu.js/wiki/Encoder-details\r\n      vec4 encode32(float value) {\r\n        if (value == 0.0) return vec4(0, 0, 0, 0);\r\n      \r\n        float exponent;\r\n        float mantissa;\r\n        vec4  result;\r\n        float sgn;\r\n      \r\n        sgn = step(0.0, -value);\r\n        value = abs(value);\r\n      \r\n        exponent = floor(log2(value));\r\n      \r\n        mantissa = value*pow(2.0, -exponent)-1.0;\r\n        exponent = exponent+127.0;\r\n        result   = vec4(0,0,0,0);\r\n      \r\n        result.a = floor(exponent/2.0);\r\n        exponent = exponent - result.a*2.0;\r\n        result.a = result.a + 128.0*sgn;\r\n      \r\n        result.b = floor(mantissa * 128.0);\r\n        mantissa = mantissa - result.b / 128.0;\r\n        result.b = result.b + exponent*128.0;\r\n      \r\n        result.g = floor(mantissa*32768.0);\r\n        mantissa = mantissa - result.g/32768.0;\r\n      \r\n        result.r = floor(mantissa*8388608.0);\r\n        return result/255.0;\r\n      }\r\n      // Dragons end here\r\n      \r\n      int index;\r\n      ivec3 threadId;\r\n      \r\n      ivec3 indexTo3D(int idx, ivec3 texDim) {\r\n        int z = int(idx / (texDim.x * texDim.y));\r\n        idx -= z * int(texDim.x * texDim.y);\r\n        int y = int(idx / texDim.x);\r\n        int x = int(integerMod(idx, texDim.x));\r\n        return ivec3(x, y, z);\r\n      }\r\n      \r\n      float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize));\r\n        return decode32(texel);\r\n      }\r\n      \r\n      float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x * 2;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));\r\n        return decode16(texel, index);\r\n      }\r\n      \r\n      float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x * 4;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));\r\n        return decode8(texel, index);\r\n      }\r\n      \r\n      float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int channel = integerMod(index, 4);\r\n        index = index / 4;\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize));\r\n        if (channel == 0) return texel.r;\r\n        if (channel == 1) return texel.g;\r\n        if (channel == 2) return texel.b;\r\n        if (channel == 3) return texel.a;\r\n        return 0.0;\r\n      }\r\n      \r\n      vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        return texture2D(tex, st / vec2(texSize));\r\n      }\r\n      \r\n      float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return result[0];\r\n      }\r\n      \r\n      vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return vec2(result[0], result[1]);\r\n      }\r\n      \r\n      vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + (texDim.x * (y + (texDim.y * z)));\r\n        int channel = integerMod(index, 2);\r\n        index = index / 2;\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize));\r\n        if (channel == 0) return vec2(texel.r, texel.g);\r\n        if (channel == 1) return vec2(texel.b, texel.a);\r\n        return vec2(0.0, 0.0);\r\n      }\r\n      \r\n      vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return vec3(result[0], result[1], result[2]);\r\n      }\r\n      \r\n      vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));\r\n        int vectorIndex = fieldIndex / 4;\r\n        int vectorOffset = fieldIndex - vectorIndex * 4;\r\n        int readY = vectorIndex / texSize.x;\r\n        int readX = vectorIndex - readY * texSize.x;\r\n        vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));\r\n        \r\n        if (vectorOffset == 0) {\r\n          return tex1.xyz;\r\n        } else if (vectorOffset == 1) {\r\n          return tex1.yzw;\r\n        } else {\r\n          readX++;\r\n          if (readX >= texSize.x) {\r\n            readX = 0;\r\n            readY++;\r\n          }\r\n          vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));\r\n          if (vectorOffset == 2) {\r\n            return vec3(tex1.z, tex1.w, tex2.x);\r\n          } else {\r\n            return vec3(tex1.w, tex2.x, tex2.y);\r\n          }\r\n        }\r\n      }\r\n      \r\n      vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        return getImage2D(tex, texSize, texDim, z, y, x);\r\n      }\r\n      \r\n      vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int channel = integerMod(index, 2);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture2D(tex, st / vec2(texSize));\r\n        return vec4(texel.r, texel.g, texel.b, texel.a);\r\n      }\r\n      \r\n      vec4 actualColor;\r\n      void color(float r, float g, float b, float a) {\r\n        actualColor = vec4(r,g,b,a);\r\n      }\r\n      \r\n      void color(float r, float g, float b) {\r\n        color(r,g,b,1.0);\r\n      }\r\n      \r\n      void color(sampler2D image) {\r\n        actualColor = texture2D(image, vTexCoord);\r\n      }\r\n      \r\n      float modulo(float number, float divisor) {\r\n        if (number < 0.0) {\r\n          number = abs(number);\r\n          if (divisor < 0.0) {\r\n            divisor = abs(divisor);\r\n          }\r\n          return -mod(number, divisor);\r\n        }\r\n        if (divisor < 0.0) {\r\n          divisor = abs(divisor);\r\n        }\r\n        return mod(number, divisor);\r\n      }\r\n      \r\n      __INJECTED_NATIVE__;\r\n      __MAIN_CONSTANTS__;\r\n      __MAIN_ARGUMENTS__;\r\n      __KERNEL__;\r\n      \r\n      void main(void) {\r\n        index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\r\n        __MAIN_RESULT__;\r\n      }`;\r\n      \r\n      module.exports = {\r\n        fragmentShader\r\n      };\r\n      },{}],38:[function(require,module,exports){\r\n      const { utils } = require('../../utils');\r\n      const { FunctionNode } = require('../function-node');\r\n      \r\n      class WebGLFunctionNode extends FunctionNode {\r\n        constructor(source, settings) {\r\n          super(source, settings);\r\n          if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {\r\n            this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;\r\n          }\r\n        }\r\n      \r\n        astConditionalExpression(ast, retArr) {\r\n          if (ast.type !== 'ConditionalExpression') {\r\n            throw this.astErrorOutput('Not a conditional expression', ast);\r\n          }\r\n          const consequentType = this.getType(ast.consequent);\r\n          const alternateType = this.getType(ast.alternate);\r\n          if (consequentType === null && alternateType === null) {\r\n            retArr.push('if (');\r\n            this.astGeneric(ast.test, retArr);\r\n            retArr.push(') {');\r\n            this.astGeneric(ast.consequent, retArr);\r\n            retArr.push(';');\r\n            retArr.push('} else {');\r\n            this.astGeneric(ast.alternate, retArr);\r\n            retArr.push(';');\r\n            retArr.push('}');\r\n            return retArr;\r\n          }\r\n          retArr.push('(');\r\n          this.astGeneric(ast.test, retArr);\r\n          retArr.push('?');\r\n          this.astGeneric(ast.consequent, retArr);\r\n          retArr.push(':');\r\n          this.astGeneric(ast.alternate, retArr);\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        astFunction(ast, retArr) {\r\n          if (this.isRootKernel) {\r\n            retArr.push('void');\r\n          } else {\r\n            if (!this.returnType) {\r\n              const lastReturn = this.findLastReturn();\r\n              if (lastReturn) {\r\n                this.returnType = this.getType(ast.body);\r\n                if (this.returnType === 'LiteralInteger') {\r\n                  this.returnType = 'Number';\r\n                }\r\n              }\r\n            }\r\n      \r\n            const { returnType } = this;\r\n            if (!returnType) {\r\n              retArr.push('void');\r\n            } else {\r\n              const type = typeMap[returnType];\r\n              if (!type) {\r\n                throw new Error(`unknown type ${returnType}`);\r\n              }\r\n              retArr.push(type);\r\n            }\r\n          }\r\n          retArr.push(' ');\r\n          retArr.push(this.name);\r\n          retArr.push('(');\r\n      \r\n          if (!this.isRootKernel) {\r\n            for (let i = 0; i < this.argumentNames.length; ++i) {\r\n              const argumentName = this.argumentNames[i];\r\n      \r\n              if (i > 0) {\r\n                retArr.push(', ');\r\n              }\r\n              let argumentType = this.argumentTypes[this.argumentNames.indexOf(argumentName)];\r\n              if (!argumentType) {\r\n                throw this.astErrorOutput(`Unknown argument ${argumentName} type`, ast);\r\n              }\r\n              if (argumentType === 'LiteralInteger') {\r\n                this.argumentTypes[i] = argumentType = 'Number';\r\n              }\r\n              const type = typeMap[argumentType];\r\n              if (!type) {\r\n                throw this.astErrorOutput('Unexpected expression', ast);\r\n              }\r\n              const name = utils.sanitizeName(argumentName);\r\n              if (type === 'sampler2D' || type === 'sampler2DArray') {\r\n                retArr.push(`${type} user_${name},ivec2 user_${name}Size,ivec3 user_${name}Dim`);\r\n              } else {\r\n                retArr.push(`${type} user_${name}`);\r\n              }\r\n            }\r\n          }\r\n      \r\n          retArr.push(') {\\n');\r\n      \r\n          for (let i = 0; i < ast.body.body.length; ++i) {\r\n            this.astGeneric(ast.body.body[i], retArr);\r\n            retArr.push('\\n');\r\n          }\r\n      \r\n          retArr.push('}\\n');\r\n          return retArr;\r\n        }\r\n      \r\n        astReturnStatement(ast, retArr) {\r\n          if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);\r\n          this.pushState('skip-literal-correction');\r\n          const type = this.getType(ast.argument);\r\n          this.popState('skip-literal-correction');\r\n      \r\n          const result = [];\r\n      \r\n          if (!this.returnType) {\r\n            if (type === 'LiteralInteger' || type === 'Integer') {\r\n              this.returnType = 'Number';\r\n            } else {\r\n              this.returnType = type;\r\n            }\r\n          }\r\n      \r\n          switch (this.returnType) {\r\n            case 'LiteralInteger':\r\n            case 'Number':\r\n            case 'Float':\r\n              switch (type) {\r\n                case 'Integer':\r\n                  result.push('float(');\r\n                  this.astGeneric(ast.argument, result);\r\n                  result.push(')');\r\n                  break;\r\n                case 'LiteralInteger':\r\n                  this.castLiteralToFloat(ast.argument, result);\r\n      \r\n                  if (this.getType(ast) === 'Integer') {\r\n                    result.unshift('float(');\r\n                    result.push(')');\r\n                  }\r\n                  break;\r\n                default:\r\n                  this.astGeneric(ast.argument, result);\r\n              }\r\n              break;\r\n            case 'Integer':\r\n              switch (type) {\r\n                case 'Float':\r\n                case 'Number':\r\n                  this.castValueToInteger(ast.argument, result);\r\n                  break;\r\n                case 'LiteralInteger':\r\n                  this.castLiteralToInteger(ast.argument, result);\r\n                  break;\r\n                default:\r\n                  this.astGeneric(ast.argument, result);\r\n              }\r\n              break;\r\n            case 'Array(4)':\r\n            case 'Array(3)':\r\n            case 'Array(2)':\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n            case 'Input':\r\n              this.astGeneric(ast.argument, result);\r\n              break;\r\n            default:\r\n              throw this.astErrorOutput(`unhandled return type ${this.returnType}`, ast);\r\n          }\r\n      \r\n          if (this.isRootKernel) {\r\n            retArr.push(`kernelResult = ${ result.join('') };`);\r\n            retArr.push('return;');\r\n          } else if (this.isSubKernel) {\r\n            retArr.push(`subKernelResult_${ this.name } = ${ result.join('') };`);\r\n            retArr.push(`return subKernelResult_${ this.name };`);\r\n          } else {\r\n            retArr.push(`return ${ result.join('') };`);\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astLiteral(ast, retArr) {\r\n          if (isNaN(ast.value)) {\r\n            throw this.astErrorOutput(\r\n              'Non-numeric literal not supported : ' + ast.value,\r\n              ast\r\n            );\r\n          }\r\n      \r\n          const key = this.astKey(ast);\r\n          if (Number.isInteger(ast.value)) {\r\n            if (this.isState('casting-to-integer') || this.isState('building-integer')) {\r\n              this.literalTypes[key] = 'Integer';\r\n              retArr.push(`${ast.value}`);\r\n            } else if (this.isState('casting-to-float') || this.isState('building-float')) {\r\n              this.literalTypes[key] = 'Number';\r\n              retArr.push(`${ast.value}.0`);\r\n            } else {\r\n              this.literalTypes[key] = 'Number';\r\n              retArr.push(`${ast.value}.0`);\r\n            }\r\n          } else if (this.isState('casting-to-integer') || this.isState('building-integer')) {\r\n            this.literalTypes[key] = 'Integer';\r\n            retArr.push(Math.round(ast.value));\r\n          } else {\r\n            this.literalTypes[key] = 'Number';\r\n            retArr.push(`${ast.value}`);\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astBinaryExpression(ast, retArr) {\r\n          if (this.checkAndUpconvertOperator(ast, retArr)) {\r\n            return retArr;\r\n          }\r\n      \r\n          if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {\r\n            retArr.push('divWithIntCheck(');\r\n            this.pushState('building-float');\r\n            switch (this.getType(ast.left)) {\r\n              case 'Integer':\r\n                this.castValueToFloat(ast.left, retArr);\r\n                break;\r\n              case 'LiteralInteger':\r\n                this.castLiteralToFloat(ast.left, retArr);\r\n                break;\r\n              default:\r\n                this.astGeneric(ast.left, retArr);\r\n            }\r\n            retArr.push(', ');\r\n            switch (this.getType(ast.right)) {\r\n              case 'Integer':\r\n                this.castValueToFloat(ast.right, retArr);\r\n                break;\r\n              case 'LiteralInteger':\r\n                this.castLiteralToFloat(ast.right, retArr);\r\n                break;\r\n              default:\r\n                this.astGeneric(ast.right, retArr);\r\n            }\r\n            this.popState('building-float');\r\n            retArr.push(')');\r\n            return retArr;\r\n          }\r\n      \r\n          retArr.push('(');\r\n          const leftType = this.getType(ast.left) || 'Number';\r\n          const rightType = this.getType(ast.right) || 'Number';\r\n          if (!leftType || !rightType) {\r\n            throw this.astErrorOutput(`Unhandled binary expression`, ast);\r\n          }\r\n          const key = leftType + ' & ' + rightType;\r\n          switch (key) {\r\n            case 'Integer & Integer':\r\n              this.pushState('building-integer');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.astGeneric(ast.right, retArr);\r\n              this.popState('building-integer');\r\n              break;\r\n            case 'Number & Float':\r\n            case 'Float & Number':\r\n            case 'Float & Float':\r\n            case 'Number & Number':\r\n              this.pushState('building-float');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.astGeneric(ast.right, retArr);\r\n              this.popState('building-float');\r\n              break;\r\n            case 'LiteralInteger & LiteralInteger':\r\n              if (this.isState('casting-to-integer') || this.isState('building-integer')) {\r\n                this.pushState('building-integer');\r\n                this.astGeneric(ast.left, retArr);\r\n                retArr.push(operatorMap[ast.operator] || ast.operator);\r\n                this.astGeneric(ast.right, retArr);\r\n                this.popState('building-integer');\r\n              } else {\r\n                this.pushState('building-float');\r\n                this.castLiteralToFloat(ast.left, retArr);\r\n                retArr.push(operatorMap[ast.operator] || ast.operator);\r\n                this.castLiteralToFloat(ast.right, retArr);\r\n                this.popState('building-float');\r\n              }\r\n              break;\r\n      \r\n            case 'Integer & Float':\r\n            case 'Integer & Number':\r\n              if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {\r\n                if (!Number.isInteger(ast.right.value)) {\r\n                  this.pushState('building-float');\r\n                  this.castValueToFloat(ast.left, retArr);\r\n                  retArr.push(operatorMap[ast.operator] || ast.operator);\r\n                  this.astGeneric(ast.right, retArr);\r\n                  this.popState('building-float');\r\n                  break;\r\n                }\r\n              }\r\n              this.pushState('building-integer');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.pushState('casting-to-integer');\r\n              if (ast.right.type === 'Literal') {\r\n                const literalResult = [];\r\n                this.astGeneric(ast.right, literalResult);\r\n                const literalType = this.getType(ast.right);\r\n                if (literalType === 'Integer') {\r\n                  retArr.push(literalResult.join(''));\r\n                } else {\r\n                  throw this.astErrorOutput(`Unhandled binary expression with literal`, ast);\r\n                }\r\n              } else {\r\n                retArr.push('int(');\r\n                this.astGeneric(ast.right, retArr);\r\n                retArr.push(')');\r\n              }\r\n              this.popState('casting-to-integer');\r\n              this.popState('building-integer');\r\n              break;\r\n            case 'Integer & LiteralInteger':\r\n              this.pushState('building-integer');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.castLiteralToInteger(ast.right, retArr);\r\n              this.popState('building-integer');\r\n              break;\r\n      \r\n            case 'Number & Integer':\r\n              this.pushState('building-float');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.castValueToFloat(ast.right, retArr);\r\n              this.popState('building-float');\r\n              break;\r\n            case 'Float & LiteralInteger':\r\n            case 'Number & LiteralInteger':\r\n              this.pushState('building-float');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.castLiteralToFloat(ast.right, retArr);\r\n              this.popState('building-float');\r\n              break;\r\n            case 'LiteralInteger & Float':\r\n            case 'LiteralInteger & Number':\r\n              if (this.isState('casting-to-integer')) {\r\n                this.pushState('building-integer');\r\n                this.castLiteralToInteger(ast.left, retArr);\r\n                retArr.push(operatorMap[ast.operator] || ast.operator);\r\n                this.castValueToInteger(ast.right, retArr);\r\n                this.popState('building-integer');\r\n              } else {\r\n                this.pushState('building-float');\r\n                this.astGeneric(ast.left, retArr);\r\n                retArr.push(operatorMap[ast.operator] || ast.operator);\r\n                this.pushState('casting-to-float');\r\n                this.astGeneric(ast.right, retArr);\r\n                this.popState('casting-to-float');\r\n                this.popState('building-float');\r\n              }\r\n              break;\r\n            case 'LiteralInteger & Integer':\r\n              this.pushState('building-integer');\r\n              this.castLiteralToInteger(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.astGeneric(ast.right, retArr);\r\n              this.popState('building-integer');\r\n              break;\r\n      \r\n            case 'Boolean & Boolean':\r\n              this.pushState('building-boolean');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.astGeneric(ast.right, retArr);\r\n              this.popState('building-boolean');\r\n              break;\r\n      \r\n            case 'Float & Integer':\r\n              this.pushState('building-float');\r\n              this.astGeneric(ast.left, retArr);\r\n              retArr.push(operatorMap[ast.operator] || ast.operator);\r\n              this.castValueToFloat(ast.right, retArr);\r\n              this.popState('building-float');\r\n              break;\r\n      \r\n            default:\r\n              throw this.astErrorOutput(`Unhandled binary expression between ${key}`, ast);\r\n          }\r\n          retArr.push(')');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        checkAndUpconvertOperator(ast, retArr) {\r\n          const bitwiseResult = this.checkAndUpconvertBitwiseOperators(ast, retArr);\r\n          if (bitwiseResult) {\r\n            return bitwiseResult;\r\n          }\r\n          const upconvertableOperators = {\r\n            '%': this.fixIntegerDivisionAccuracy ? 'integerCorrectionModulo' : 'modulo',\r\n            '**': 'pow',\r\n          };\r\n          const foundOperator = upconvertableOperators[ast.operator];\r\n          if (!foundOperator) return null;\r\n          retArr.push(foundOperator);\r\n          retArr.push('(');\r\n          switch (this.getType(ast.left)) {\r\n            case 'Integer':\r\n              this.castValueToFloat(ast.left, retArr);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToFloat(ast.left, retArr);\r\n              break;\r\n            default:\r\n              this.astGeneric(ast.left, retArr);\r\n          }\r\n          retArr.push(',');\r\n          switch (this.getType(ast.right)) {\r\n            case 'Integer':\r\n              this.castValueToFloat(ast.right, retArr);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToFloat(ast.right, retArr);\r\n              break;\r\n            default:\r\n              this.astGeneric(ast.right, retArr);\r\n          }\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        checkAndUpconvertBitwiseOperators(ast, retArr) {\r\n          const upconvertableOperators = {\r\n            '&': 'bitwiseAnd',\r\n            '|': 'bitwiseOr',\r\n            '^': 'bitwiseXOR',\r\n            '<<': 'bitwiseZeroFillLeftShift',\r\n            '>>': 'bitwiseSignedRightShift',\r\n            '>>>': 'bitwiseZeroFillRightShift',\r\n          };\r\n          const foundOperator = upconvertableOperators[ast.operator];\r\n          if (!foundOperator) return null;\r\n          retArr.push(foundOperator);\r\n          retArr.push('(');\r\n          const leftType = this.getType(ast.left);\r\n          switch (leftType) {\r\n            case 'Number':\r\n            case 'Float':\r\n              this.castValueToInteger(ast.left, retArr);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToInteger(ast.left, retArr);\r\n              break;\r\n            default:\r\n              this.astGeneric(ast.left, retArr);\r\n          }\r\n          retArr.push(',');\r\n          const rightType = this.getType(ast.right);\r\n          switch (rightType) {\r\n            case 'Number':\r\n            case 'Float':\r\n              this.castValueToInteger(ast.right, retArr);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToInteger(ast.right, retArr);\r\n              break;\r\n            default:\r\n              this.astGeneric(ast.right, retArr);\r\n          }\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        checkAndUpconvertBitwiseUnary(ast, retArr) {\r\n          const upconvertableOperators = {\r\n            '~': 'bitwiseNot',\r\n          };\r\n          const foundOperator = upconvertableOperators[ast.operator];\r\n          if (!foundOperator) return null;\r\n          retArr.push(foundOperator);\r\n          retArr.push('(');\r\n          switch (this.getType(ast.argument)) {\r\n            case 'Number':\r\n            case 'Float':\r\n              this.castValueToInteger(ast.argument, retArr);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToInteger(ast.argument, retArr);\r\n              break;\r\n            default:\r\n              this.astGeneric(ast.argument, retArr);\r\n          }\r\n          retArr.push(')');\r\n          return retArr;\r\n        }\r\n      \r\n        castLiteralToInteger(ast, retArr) {\r\n          this.pushState('casting-to-integer');\r\n          this.astGeneric(ast, retArr);\r\n          this.popState('casting-to-integer');\r\n          return retArr;\r\n        }\r\n      \r\n        castLiteralToFloat(ast, retArr) {\r\n          this.pushState('casting-to-float');\r\n          this.astGeneric(ast, retArr);\r\n          this.popState('casting-to-float');\r\n          return retArr;\r\n        }\r\n      \r\n        castValueToInteger(ast, retArr) {\r\n          this.pushState('casting-to-integer');\r\n          retArr.push('int(');\r\n          this.astGeneric(ast, retArr);\r\n          retArr.push(')');\r\n          this.popState('casting-to-integer');\r\n          return retArr;\r\n        }\r\n      \r\n        castValueToFloat(ast, retArr) {\r\n          this.pushState('casting-to-float');\r\n          retArr.push('float(');\r\n          this.astGeneric(ast, retArr);\r\n          retArr.push(')');\r\n          this.popState('casting-to-float');\r\n          return retArr;\r\n        }\r\n      \r\n        astIdentifierExpression(idtNode, retArr) {\r\n          if (idtNode.type !== 'Identifier') {\r\n            throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);\r\n          }\r\n      \r\n          const type = this.getType(idtNode);\r\n      \r\n          const name = utils.sanitizeName(idtNode.name);\r\n          if (idtNode.name === 'Infinity') {\r\n            retArr.push('3.402823466e+38');\r\n          } else if (type === 'Boolean') {\r\n            if (this.argumentNames.indexOf(name) > -1) {\r\n              retArr.push(`bool(user_${name})`);\r\n            } else {\r\n              retArr.push(`user_${name}`);\r\n            }\r\n          } else {\r\n            retArr.push(`user_${name}`);\r\n          }\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astForStatement(forNode, retArr) {\r\n          if (forNode.type !== 'ForStatement') {\r\n            throw this.astErrorOutput('Invalid for statement', forNode);\r\n          }\r\n      \r\n          const initArr = [];\r\n          const testArr = [];\r\n          const updateArr = [];\r\n          const bodyArr = [];\r\n          let isSafe = null;\r\n      \r\n          if (forNode.init) {\r\n            const { declarations } = forNode.init;\r\n            if (declarations.length > 1) {\r\n              isSafe = false;\r\n            }\r\n            this.astGeneric(forNode.init, initArr);\r\n            for (let i = 0; i < declarations.length; i++) {\r\n              if (declarations[i].init && declarations[i].init.type !== 'Literal') {\r\n                isSafe = false;\r\n              }\r\n            }\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.test) {\r\n            this.astGeneric(forNode.test, testArr);\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.update) {\r\n            this.astGeneric(forNode.update, updateArr);\r\n          } else {\r\n            isSafe = false;\r\n          }\r\n      \r\n          if (forNode.body) {\r\n            this.pushState('loop-body');\r\n            this.astGeneric(forNode.body, bodyArr);\r\n            this.popState('loop-body');\r\n          }\r\n      \r\n          if (isSafe === null) {\r\n            isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);\r\n          }\r\n      \r\n          if (isSafe) {\r\n            const initString = initArr.join('');\r\n            const initNeedsSemiColon = initString[initString.length - 1] !== ';';\r\n            retArr.push(`for (${initString}${initNeedsSemiColon ? ';' : ''}${testArr.join('')};${updateArr.join('')}){\\n`);\r\n            retArr.push(bodyArr.join(''));\r\n            retArr.push('}\\n');\r\n          } else {\r\n            const iVariableName = this.getInternalVariableName('safeI');\r\n            if (initArr.length > 0) {\r\n              retArr.push(initArr.join(''), '\\n');\r\n            }\r\n            retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\n`);\r\n            if (testArr.length > 0) {\r\n              retArr.push(`if (!${testArr.join('')}) break;\\n`);\r\n            }\r\n            retArr.push(bodyArr.join(''));\r\n            retArr.push(`\\n${updateArr.join('')};`);\r\n            retArr.push('}\\n');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astWhileStatement(whileNode, retArr) {\r\n          if (whileNode.type !== 'WhileStatement') {\r\n            throw this.astErrorOutput('Invalid while statement', whileNode);\r\n          }\r\n      \r\n          const iVariableName = this.getInternalVariableName('safeI');\r\n          retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\n`);\r\n          retArr.push('if (!');\r\n          this.astGeneric(whileNode.test, retArr);\r\n          retArr.push(') break;\\n');\r\n          this.astGeneric(whileNode.body, retArr);\r\n          retArr.push('}\\n');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astDoWhileStatement(doWhileNode, retArr) {\r\n          if (doWhileNode.type !== 'DoWhileStatement') {\r\n            throw this.astErrorOutput('Invalid while statement', doWhileNode);\r\n          }\r\n      \r\n          const iVariableName = this.getInternalVariableName('safeI');\r\n          retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\n`);\r\n          this.astGeneric(doWhileNode.body, retArr);\r\n          retArr.push('if (!');\r\n          this.astGeneric(doWhileNode.test, retArr);\r\n          retArr.push(') break;\\n');\r\n          retArr.push('}\\n');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n      \r\n        astAssignmentExpression(assNode, retArr) {\r\n          if (assNode.operator === '%=') {\r\n            this.astGeneric(assNode.left, retArr);\r\n            retArr.push('=');\r\n            retArr.push('mod(');\r\n            this.astGeneric(assNode.left, retArr);\r\n            retArr.push(',');\r\n            this.astGeneric(assNode.right, retArr);\r\n            retArr.push(')');\r\n          } else if (assNode.operator === '**=') {\r\n            this.astGeneric(assNode.left, retArr);\r\n            retArr.push('=');\r\n            retArr.push('pow(');\r\n            this.astGeneric(assNode.left, retArr);\r\n            retArr.push(',');\r\n            this.astGeneric(assNode.right, retArr);\r\n            retArr.push(')');\r\n          } else {\r\n            const leftType = this.getType(assNode.left);\r\n            const rightType = this.getType(assNode.right);\r\n            this.astGeneric(assNode.left, retArr);\r\n            retArr.push(assNode.operator);\r\n            if (leftType !== 'Integer' && rightType === 'Integer') {\r\n              retArr.push('float(');\r\n              this.astGeneric(assNode.right, retArr);\r\n              retArr.push(')');\r\n            } else {\r\n              this.astGeneric(assNode.right, retArr);\r\n            }\r\n            return retArr;\r\n          }\r\n        }\r\n      \r\n        astBlockStatement(bNode, retArr) {\r\n          if (this.isState('loop-body')) {\r\n            this.pushState('block-body'); \r\n            for (let i = 0; i < bNode.body.length; i++) {\r\n              this.astGeneric(bNode.body[i], retArr);\r\n            }\r\n            this.popState('block-body');\r\n          } else {\r\n            retArr.push('{\\n');\r\n            for (let i = 0; i < bNode.body.length; i++) {\r\n              this.astGeneric(bNode.body[i], retArr);\r\n            }\r\n            retArr.push('}\\n');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astVariableDeclaration(varDecNode, retArr) {\r\n          const declarations = varDecNode.declarations;\r\n          if (!declarations || !declarations[0] || !declarations[0].init) {\r\n            throw this.astErrorOutput('Unexpected expression', varDecNode);\r\n          }\r\n          const result = [];\r\n          let lastType = null;\r\n          const declarationSets = [];\r\n          let declarationSet = [];\r\n          for (let i = 0; i < declarations.length; i++) {\r\n            const declaration = declarations[i];\r\n            const init = declaration.init;\r\n            const info = this.getDeclaration(declaration.id);\r\n            const actualType = this.getType(declaration.init);\r\n            let type = actualType;\r\n            if (type === 'LiteralInteger') {\r\n              if (info.suggestedType === 'Integer') {\r\n                type = 'Integer';\r\n              } else {\r\n                type = 'Number';\r\n              }\r\n            }\r\n            const markupType = typeMap[type];\r\n            if (!markupType) {\r\n              throw this.astErrorOutput(`Markup type ${ type } not handled`, varDecNode);\r\n            }\r\n            const declarationResult = [];\r\n            if (actualType === 'Integer' && type === 'Integer') {\r\n              info.valueType = 'Number';\r\n              if (i === 0 || lastType === null) {\r\n                declarationResult.push('float ');\r\n              } else if (type !== lastType) {\r\n                throw new Error('Unhandled declaration');\r\n              }\r\n              lastType = type;\r\n              declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);\r\n              declarationResult.push('float(');\r\n              this.astGeneric(init, declarationResult);\r\n              declarationResult.push(')');\r\n            } else {\r\n              info.valueType = type;\r\n              if (i === 0 || lastType === null) {\r\n                declarationResult.push(`${markupType} `);\r\n              } else if (type !== lastType) {\r\n                declarationSets.push(declarationSet.join(','));\r\n                declarationSet = [];\r\n                declarationResult.push(`${markupType} `);\r\n              }\r\n              lastType = type;\r\n              declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);\r\n              if (actualType === 'Number' && type === 'Integer') {\r\n                if (init.left && init.left.type === 'Literal') {\r\n                  this.astGeneric(init, declarationResult);\r\n                } else {\r\n                  declarationResult.push('int(');\r\n                  this.astGeneric(init, declarationResult);\r\n                  declarationResult.push(')');\r\n                }\r\n              } else if (actualType === 'LiteralInteger' && type === 'Integer') {\r\n                this.castLiteralToInteger(init, declarationResult);\r\n              } else {\r\n                this.astGeneric(init, declarationResult);\r\n              }\r\n            }\r\n            declarationSet.push(declarationResult.join(''));\r\n          }\r\n      \r\n          if (declarationSet.length > 0) {\r\n            declarationSets.push(declarationSet.join(','));\r\n          }\r\n      \r\n          result.push(declarationSets.join(';'));\r\n      \r\n          retArr.push(result.join(''));\r\n          retArr.push(';');\r\n          return retArr;\r\n        }\r\n      \r\n        astIfStatement(ifNode, retArr) {\r\n          retArr.push('if (');\r\n          this.astGeneric(ifNode.test, retArr);\r\n          retArr.push(')');\r\n          if (ifNode.consequent.type === 'BlockStatement') {\r\n            this.astGeneric(ifNode.consequent, retArr);\r\n          } else {\r\n            retArr.push(' {\\n');\r\n            this.astGeneric(ifNode.consequent, retArr);\r\n            retArr.push('\\n}\\n');\r\n          }\r\n      \r\n          if (ifNode.alternate) {\r\n            retArr.push('else ');\r\n            if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {\r\n              this.astGeneric(ifNode.alternate, retArr);\r\n            } else {\r\n              retArr.push(' {\\n');\r\n              this.astGeneric(ifNode.alternate, retArr);\r\n              retArr.push('\\n}\\n');\r\n            }\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astSwitchStatement(ast, retArr) {\r\n          if (ast.type !== 'SwitchStatement') {\r\n            throw this.astErrorOutput('Invalid switch statement', ast);\r\n          }\r\n          const { discriminant, cases } = ast;\r\n          const type = this.getType(discriminant);\r\n          const varName = `switchDiscriminant${this.astKey(ast, '_')}`;\r\n          switch (type) {\r\n            case 'Float':\r\n            case 'Number':\r\n              retArr.push(`float ${varName} = `);\r\n              this.astGeneric(discriminant, retArr);\r\n              retArr.push(';\\n');\r\n              break;\r\n            case 'Integer':\r\n              retArr.push(`int ${varName} = `);\r\n              this.astGeneric(discriminant, retArr);\r\n              retArr.push(';\\n');\r\n              break;\r\n          }\r\n          if (cases.length === 1 && !cases[0].test) {\r\n            this.astGeneric(cases[0].consequent, retArr);\r\n            return retArr;\r\n          }\r\n      \r\n          let fallingThrough = false;\r\n          let defaultResult = [];\r\n          let movingDefaultToEnd = false;\r\n          let pastFirstIf = false;\r\n          for (let i = 0; i < cases.length; i++) {\r\n            if (!cases[i].test) {\r\n              if (cases.length > i + 1) {\r\n                movingDefaultToEnd = true;\r\n                this.astGeneric(cases[i].consequent, defaultResult);\r\n                continue;\r\n              } else {\r\n                retArr.push(' else {\\n');\r\n              }\r\n            } else {\r\n              if (i === 0 || !pastFirstIf) {\r\n                pastFirstIf = true;\r\n                retArr.push(`if (${varName} == `);\r\n              } else {\r\n                if (fallingThrough) {\r\n                  retArr.push(`${varName} == `);\r\n                  fallingThrough = false;\r\n                } else {\r\n                  retArr.push(` else if (${varName} == `);\r\n                }\r\n              }\r\n              if (type === 'Integer') {\r\n                const testType = this.getType(cases[i].test);\r\n                switch (testType) {\r\n                  case 'Number':\r\n                  case 'Float':\r\n                    this.castValueToInteger(cases[i].test, retArr);\r\n                    break;\r\n                  case 'LiteralInteger':\r\n                    this.castLiteralToInteger(cases[i].test, retArr);\r\n                    break;\r\n                }\r\n              } else if (type === 'Float') {\r\n                const testType = this.getType(cases[i].test);\r\n                switch (testType) {\r\n                  case 'LiteralInteger':\r\n                    this.castLiteralToFloat(cases[i].test, retArr);\r\n                    break;\r\n                  case 'Integer':\r\n                    this.castValueToFloat(cases[i].test, retArr);\r\n                    break;\r\n                }\r\n              } else {\r\n                throw new Error('unhanlded');\r\n              }\r\n              if (!cases[i].consequent || cases[i].consequent.length === 0) {\r\n                fallingThrough = true;\r\n                retArr.push(' || ');\r\n                continue;\r\n              }\r\n              retArr.push(`) {\\n`);\r\n            }\r\n            this.astGeneric(cases[i].consequent, retArr);\r\n            retArr.push('\\n}');\r\n          }\r\n          if (movingDefaultToEnd) {\r\n            retArr.push(' else {');\r\n            retArr.push(defaultResult.join(''));\r\n            retArr.push('}');\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astThisExpression(tNode, retArr) {\r\n          retArr.push('this');\r\n          return retArr;\r\n        }\r\n      \r\n        astMemberExpression(mNode, retArr) {\r\n          const {\r\n            property,\r\n            name,\r\n            signature,\r\n            origin,\r\n            type,\r\n            xProperty,\r\n            yProperty,\r\n            zProperty\r\n          } = this.getMemberExpressionDetails(mNode);\r\n          switch (signature) {\r\n            case 'value.thread.value':\r\n            case 'this.thread.value':\r\n              if (name !== 'x' && name !== 'y' && name !== 'z') {\r\n                throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);\r\n              }\r\n              retArr.push(`threadId.${name}`);\r\n              return retArr;\r\n            case 'this.output.value':\r\n              if (this.dynamicOutput) {\r\n                switch (name) {\r\n                  case 'x':\r\n                    if (this.isState('casting-to-float')) {\r\n                      retArr.push('float(uOutputDim.x)');\r\n                    } else {\r\n                      retArr.push('uOutputDim.x');\r\n                    }\r\n                    break;\r\n                  case 'y':\r\n                    if (this.isState('casting-to-float')) {\r\n                      retArr.push('float(uOutputDim.y)');\r\n                    } else {\r\n                      retArr.push('uOutputDim.y');\r\n                    }\r\n                    break;\r\n                  case 'z':\r\n                    if (this.isState('casting-to-float')) {\r\n                      retArr.push('float(uOutputDim.z)');\r\n                    } else {\r\n                      retArr.push('uOutputDim.z');\r\n                    }\r\n                    break;\r\n                  default:\r\n                    throw this.astErrorOutput('Unexpected expression', mNode);\r\n                }\r\n              } else {\r\n                switch (name) {\r\n                  case 'x':\r\n                    if (this.isState('casting-to-integer')) {\r\n                      retArr.push(this.output[0]);\r\n                    } else {\r\n                      retArr.push(this.output[0], '.0');\r\n                    }\r\n                    break;\r\n                  case 'y':\r\n                    if (this.isState('casting-to-integer')) {\r\n                      retArr.push(this.output[1]);\r\n                    } else {\r\n                      retArr.push(this.output[1], '.0');\r\n                    }\r\n                    break;\r\n                  case 'z':\r\n                    if (this.isState('casting-to-integer')) {\r\n                      retArr.push(this.output[2]);\r\n                    } else {\r\n                      retArr.push(this.output[2], '.0');\r\n                    }\r\n                    break;\r\n                  default:\r\n                    throw this.astErrorOutput('Unexpected expression', mNode);\r\n                }\r\n              }\r\n              return retArr;\r\n            case 'value':\r\n              throw this.astErrorOutput('Unexpected expression', mNode);\r\n            case 'value[]':\r\n            case 'value[][]':\r\n            case 'value[][][]':\r\n            case 'value[][][][]':\r\n            case 'value.value':\r\n              if (origin === 'Math') {\r\n                retArr.push(Math[name]);\r\n                return retArr;\r\n              }\r\n              const cleanName = utils.sanitizeName(name);\r\n              switch (property) {\r\n                case 'r':\r\n                  retArr.push(`user_${ cleanName }.r`);\r\n                  return retArr;\r\n                case 'g':\r\n                  retArr.push(`user_${ cleanName }.g`);\r\n                  return retArr;\r\n                case 'b':\r\n                  retArr.push(`user_${ cleanName }.b`);\r\n                  return retArr;\r\n                case 'a':\r\n                  retArr.push(`user_${ cleanName }.a`);\r\n                  return retArr;\r\n              }\r\n              break;\r\n            case 'this.constants.value':\r\n              if (typeof xProperty === 'undefined') {\r\n                switch (type) {\r\n                  case 'Array(2)':\r\n                  case 'Array(3)':\r\n                  case 'Array(4)':\r\n                    retArr.push(`constants_${ utils.sanitizeName(name) }`);\r\n                    return retArr;\r\n                }\r\n              }\r\n              case 'this.constants.value[]':\r\n              case 'this.constants.value[][]':\r\n              case 'this.constants.value[][][]':\r\n              case 'this.constants.value[][][][]':\r\n                break;\r\n              case 'fn()[]':\r\n                this.astCallExpression(mNode.object, retArr);\r\n                retArr.push('[');\r\n                retArr.push(this.memberExpressionPropertyMarkup(property));\r\n                retArr.push(']');\r\n                return retArr;\r\n              case 'fn()[][]':\r\n                this.astCallExpression(mNode.object.object, retArr);\r\n                retArr.push('[');\r\n                retArr.push(this.memberExpressionPropertyMarkup(mNode.object.property));\r\n                retArr.push(']');\r\n                retArr.push('[');\r\n                retArr.push(this.memberExpressionPropertyMarkup(mNode.property));\r\n                retArr.push(']');\r\n                return retArr;\r\n              case '[][]':\r\n                this.astArrayExpression(mNode.object, retArr);\r\n                retArr.push('[');\r\n                retArr.push(this.memberExpressionPropertyMarkup(property));\r\n                retArr.push(']');\r\n                return retArr;\r\n              default:\r\n                throw this.astErrorOutput('Unexpected expression', mNode);\r\n          }\r\n      \r\n          if (mNode.computed === false) {\r\n            switch (type) {\r\n              case 'Number':\r\n              case 'Integer':\r\n              case 'Float':\r\n              case 'Boolean':\r\n                retArr.push(`${origin}_${utils.sanitizeName(name)}`);\r\n                return retArr;\r\n            }\r\n          }\r\n      \r\n          const markupName = `${origin}_${utils.sanitizeName(name)}`;\r\n      \r\n          switch (type) {\r\n            case 'Array(2)':\r\n            case 'Array(3)':\r\n            case 'Array(4)':\r\n              this.astGeneric(mNode.object, retArr);\r\n              retArr.push('[');\r\n              retArr.push(this.memberExpressionPropertyMarkup(xProperty));\r\n              retArr.push(']');\r\n              break;\r\n            case 'HTMLImageArray':\r\n              retArr.push(`getImage3D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'ArrayTexture(1)':\r\n              retArr.push(`getFloatFromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'Array1D(2)':\r\n            case 'Array2D(2)':\r\n            case 'Array3D(2)':\r\n              retArr.push(`getMemoryOptimizedVec2(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'ArrayTexture(2)':\r\n              retArr.push(`getVec2FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'Array1D(3)':\r\n            case 'Array2D(3)':\r\n            case 'Array3D(3)':\r\n              retArr.push(`getMemoryOptimizedVec3(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'ArrayTexture(3)':\r\n              retArr.push(`getVec3FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'Array1D(4)':\r\n            case 'Array2D(4)':\r\n            case 'Array3D(4)':\r\n              retArr.push(`getMemoryOptimizedVec4(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'ArrayTexture(4)':\r\n            case 'HTMLCanvas':\r\n            case 'HTMLImage':\r\n            case 'HTMLVideo':\r\n              retArr.push(`getVec4FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'NumberTexture':\r\n            case 'Array':\r\n            case 'Array2D':\r\n            case 'Array3D':\r\n            case 'Array4D':\r\n            case 'Input':\r\n            case 'Number':\r\n            case 'Float':\r\n            case 'Integer':\r\n              if (this.precision === 'single') {\r\n                retArr.push(`getMemoryOptimized32(${markupName}, ${markupName}Size, ${markupName}Dim, `);\r\n                this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n                retArr.push(')');\r\n              } else {\r\n                const bitRatio = (origin === 'user' ?\r\n                  this.lookupFunctionArgumentBitRatio(this.name, name) :\r\n                  this.constantBitRatios[name]\r\n                );\r\n                switch (bitRatio) {\r\n                  case 1:\r\n                    retArr.push(`get8(${markupName}, ${markupName}Size, ${markupName}Dim, `);\r\n                    break;\r\n                  case 2:\r\n                    retArr.push(`get16(${markupName}, ${markupName}Size, ${markupName}Dim, `);\r\n                    break;\r\n                  case 4:\r\n                  case 0:\r\n                    retArr.push(`get32(${markupName}, ${markupName}Size, ${markupName}Dim, `);\r\n                    break;\r\n                  default:\r\n                    throw new Error(`unhandled bit ratio of ${bitRatio}`);\r\n                }\r\n                this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n                retArr.push(')');\r\n              }\r\n              break;\r\n            case 'MemoryOptimizedNumberTexture':\r\n              retArr.push(`getMemoryOptimized32(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\r\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\r\n              retArr.push(')');\r\n              break;\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n              retArr.push(`${markupName}[${this.memberExpressionPropertyMarkup(yProperty)}]`);\r\n              if (yProperty) {\r\n                retArr.push(`[${this.memberExpressionPropertyMarkup(xProperty)}]`);\r\n              }\r\n              break;\r\n            default:\r\n              throw new Error(`unhandled member expression \"${ type }\"`);\r\n          }\r\n          return retArr;\r\n        }\r\n      \r\n        astCallExpression(ast, retArr) {\r\n          if (!ast.callee) {\r\n            throw this.astErrorOutput('Unknown CallExpression', ast);\r\n          }\r\n      \r\n          let functionName = null;\r\n          const isMathFunction = this.isAstMathFunction(ast);\r\n      \r\n          if (isMathFunction || (ast.callee.object && ast.callee.object.type === 'ThisExpression')) {\r\n            functionName = ast.callee.property.name;\r\n          }\r\n          else if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[0].type === 'Literal' && !isNaN(ast.callee.expressions[0].raw)) {\r\n            functionName = ast.callee.expressions[1].property.name;\r\n          } else {\r\n            functionName = ast.callee.name;\r\n          }\r\n      \r\n          if (!functionName) {\r\n            throw this.astErrorOutput(`Unhandled function, couldn't find name`, ast);\r\n          }\r\n      \r\n          switch (functionName) {\r\n            case 'pow':\r\n              functionName = '_pow';\r\n              break;\r\n            case 'round':\r\n              functionName = '_round';\r\n              break;\r\n          }\r\n      \r\n          if (this.calledFunctions.indexOf(functionName) < 0) {\r\n            this.calledFunctions.push(functionName);\r\n          }\r\n      \r\n          if (functionName === 'random' && this.plugins && this.plugins.length > 0) {\r\n            for (let i = 0; i < this.plugins.length; i++) {\r\n              const plugin = this.plugins[i];\r\n              if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {\r\n                retArr.push(plugin.functionReplace);\r\n                return retArr;\r\n              }\r\n            }\r\n          }\r\n      \r\n          if (this.onFunctionCall) {\r\n            this.onFunctionCall(this.name, functionName, ast.arguments);\r\n          }\r\n      \r\n          retArr.push(functionName);\r\n      \r\n          retArr.push('(');\r\n      \r\n          if (isMathFunction) {\r\n            for (let i = 0; i < ast.arguments.length; ++i) {\r\n              const argument = ast.arguments[i];\r\n              const argumentType = this.getType(argument);\r\n              if (i > 0) {\r\n                retArr.push(', ');\r\n              }\r\n      \r\n              switch (argumentType) {\r\n                case 'Integer':\r\n                  this.castValueToFloat(argument, retArr);\r\n                  break;\r\n                default:\r\n                  this.astGeneric(argument, retArr);\r\n                  break;\r\n              }\r\n            }\r\n          } else {\r\n            const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];\r\n            for (let i = 0; i < ast.arguments.length; ++i) {\r\n              const argument = ast.arguments[i];\r\n              let targetType = targetTypes[i];\r\n              if (i > 0) {\r\n                retArr.push(', ');\r\n              }\r\n              const argumentType = this.getType(argument);\r\n              if (!targetType) {\r\n                this.triggerImplyArgumentType(functionName, i, argumentType, this);\r\n                targetType = argumentType;\r\n              }\r\n              switch (argumentType) {\r\n                case 'Boolean':\r\n                  this.astGeneric(argument, retArr);\r\n                  continue;\r\n                case 'Number':\r\n                case 'Float':\r\n                  if (targetType === 'Integer') {\r\n                    retArr.push('int(');\r\n                    this.astGeneric(argument, retArr);\r\n                    retArr.push(')');\r\n                    continue;\r\n                  } else if (targetType === 'Number' || targetType === 'Float') {\r\n                    this.astGeneric(argument, retArr);\r\n                    continue;\r\n                  } else if (targetType === 'LiteralInteger') {\r\n                    this.castLiteralToFloat(argument, retArr);\r\n                    continue;\r\n                  }\r\n                  break;\r\n                case 'Integer':\r\n                  if (targetType === 'Number' || targetType === 'Float') {\r\n                    retArr.push('float(');\r\n                    this.astGeneric(argument, retArr);\r\n                    retArr.push(')');\r\n                    continue;\r\n                  } else if (targetType === 'Integer') {\r\n                    this.astGeneric(argument, retArr);\r\n                    continue;\r\n                  }\r\n                  break;\r\n                case 'LiteralInteger':\r\n                  if (targetType === 'Integer') {\r\n                    this.castLiteralToInteger(argument, retArr);\r\n                    continue;\r\n                  } else if (targetType === 'Number' || targetType === 'Float') {\r\n                    this.castLiteralToFloat(argument, retArr);\r\n                    continue;\r\n                  } else if (targetType === 'LiteralInteger') {\r\n                    this.astGeneric(argument, retArr);\r\n                    continue;\r\n                  }\r\n                  break;\r\n                case 'Array(2)':\r\n                case 'Array(3)':\r\n                case 'Array(4)':\r\n                  if (targetType === argumentType) {\r\n                    if (argument.type === 'Identifier') {\r\n                      retArr.push(`user_${utils.sanitizeName(argument.name)}`);\r\n                    } else if (argument.type === 'ArrayExpression' || argument.type === 'MemberExpression' || argument.type === 'CallExpression') {\r\n                      this.astGeneric(argument, retArr);\r\n                    } else {\r\n                      throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);\r\n                    }\r\n                    continue;\r\n                  }\r\n                  break;\r\n                case 'HTMLCanvas':\r\n                case 'HTMLImage':\r\n                case 'HTMLImageArray':\r\n                case 'HTMLVideo':\r\n                case 'ArrayTexture(1)':\r\n                case 'ArrayTexture(2)':\r\n                case 'ArrayTexture(3)':\r\n                case 'ArrayTexture(4)':\r\n                case 'Array':\r\n                case 'Input':\r\n                  if (targetType === argumentType) {\r\n                    if (argument.type !== 'Identifier') throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);\r\n                    this.triggerImplyArgumentBitRatio(this.name, argument.name, functionName, i);\r\n                    const name = utils.sanitizeName(argument.name);\r\n                    retArr.push(`user_${name},user_${name}Size,user_${name}Dim`);\r\n                    continue;\r\n                  }\r\n                  break;\r\n              }\r\n              throw this.astErrorOutput(`Unhandled argument combination of ${ argumentType } and ${ targetType } for argument named \"${ argument.name }\"`, ast);\r\n            }\r\n          }\r\n          retArr.push(')');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        astArrayExpression(arrNode, retArr) {\r\n          const returnType = this.getType(arrNode);\r\n      \r\n          const arrLen = arrNode.elements.length;\r\n      \r\n          switch (returnType) {\r\n            case 'Matrix(2)':\r\n            case 'Matrix(3)':\r\n            case 'Matrix(4)':\r\n              retArr.push(`mat${arrLen}(`);\r\n              break;\r\n            default:\r\n              retArr.push(`vec${arrLen}(`);\r\n          }\r\n          for (let i = 0; i < arrLen; ++i) {\r\n            if (i > 0) {\r\n              retArr.push(', ');\r\n            }\r\n            const subNode = arrNode.elements[i];\r\n            this.astGeneric(subNode, retArr)\r\n          }\r\n          retArr.push(')');\r\n      \r\n          return retArr;\r\n        }\r\n      \r\n        memberExpressionXYZ(x, y, z, retArr) {\r\n          if (z) {\r\n            retArr.push(this.memberExpressionPropertyMarkup(z), ', ');\r\n          } else {\r\n            retArr.push('0, ');\r\n          }\r\n          if (y) {\r\n            retArr.push(this.memberExpressionPropertyMarkup(y), ', ');\r\n          } else {\r\n            retArr.push('0, ');\r\n          }\r\n          retArr.push(this.memberExpressionPropertyMarkup(x));\r\n          return retArr;\r\n        }\r\n      \r\n        memberExpressionPropertyMarkup(property) {\r\n          if (!property) {\r\n            throw new Error('Property not set');\r\n          }\r\n          const type = this.getType(property);\r\n          const result = [];\r\n          switch (type) {\r\n            case 'Number':\r\n            case 'Float':\r\n              this.castValueToInteger(property, result);\r\n              break;\r\n            case 'LiteralInteger':\r\n              this.castLiteralToInteger(property, result);\r\n              break;\r\n            default:\r\n              this.astGeneric(property, result);\r\n          }\r\n          return result.join('');\r\n        }\r\n      }\r\n      \r\n      const typeMap = {\r\n        'Array': 'sampler2D',\r\n        'Array(2)': 'vec2',\r\n        'Array(3)': 'vec3',\r\n        'Array(4)': 'vec4',\r\n        'Matrix(2)': 'mat2',\r\n        'Matrix(3)': 'mat3',\r\n        'Matrix(4)': 'mat4',\r\n        'Array2D': 'sampler2D',\r\n        'Array3D': 'sampler2D',\r\n        'Boolean': 'bool',\r\n        'Float': 'float',\r\n        'Input': 'sampler2D',\r\n        'Integer': 'int',\r\n        'Number': 'float',\r\n        'LiteralInteger': 'float',\r\n        'NumberTexture': 'sampler2D',\r\n        'MemoryOptimizedNumberTexture': 'sampler2D',\r\n        'ArrayTexture(1)': 'sampler2D',\r\n        'ArrayTexture(2)': 'sampler2D',\r\n        'ArrayTexture(3)': 'sampler2D',\r\n        'ArrayTexture(4)': 'sampler2D',\r\n        'HTMLVideo': 'sampler2D',\r\n        'HTMLCanvas': 'sampler2D',\r\n        'HTMLImage': 'sampler2D',\r\n        'HTMLImageArray': 'sampler2DArray',\r\n      };\r\n      \r\n      const operatorMap = {\r\n        '===': '==',\r\n        '!==': '!='\r\n      };\r\n      \r\n      module.exports = {\r\n        WebGLFunctionNode\r\n      };\r\n      },{\"../../utils\":114,\"../function-node\":10}],39:[function(require,module,exports){\r\n      const { WebGLKernelValueBoolean } = require('./kernel-value/boolean');\r\n      const { WebGLKernelValueFloat } = require('./kernel-value/float');\r\n      const { WebGLKernelValueInteger } = require('./kernel-value/integer');\r\n      \r\n      const { WebGLKernelValueHTMLImage } = require('./kernel-value/html-image');\r\n      const { WebGLKernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');\r\n      \r\n      const { WebGLKernelValueHTMLVideo } = require('./kernel-value/html-video');\r\n      const { WebGLKernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');\r\n      \r\n      const { WebGLKernelValueSingleInput } = require('./kernel-value/single-input');\r\n      const { WebGLKernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');\r\n      \r\n      const { WebGLKernelValueUnsignedInput } = require('./kernel-value/unsigned-input');\r\n      const { WebGLKernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');\r\n      \r\n      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');\r\n      const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');\r\n      \r\n      const { WebGLKernelValueNumberTexture } = require('./kernel-value/number-texture');\r\n      const { WebGLKernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');\r\n      \r\n      const { WebGLKernelValueSingleArray } = require('./kernel-value/single-array');\r\n      const { WebGLKernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');\r\n      \r\n      const { WebGLKernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');\r\n      const { WebGLKernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');\r\n      \r\n      const { WebGLKernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');\r\n      const { WebGLKernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');\r\n      \r\n      const { WebGLKernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');\r\n      const { WebGLKernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');\r\n      \r\n      const { WebGLKernelValueSingleArray2 } = require('./kernel-value/single-array2');\r\n      const { WebGLKernelValueSingleArray3 } = require('./kernel-value/single-array3');\r\n      const { WebGLKernelValueSingleArray4 } = require('./kernel-value/single-array4');\r\n      \r\n      const { WebGLKernelValueUnsignedArray } = require('./kernel-value/unsigned-array');\r\n      const { WebGLKernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');\r\n      \r\n      const kernelValueMaps = {\r\n        unsigned: {\r\n          dynamic: {\r\n            'Boolean': WebGLKernelValueBoolean,\r\n            'Integer': WebGLKernelValueInteger,\r\n            'Float': WebGLKernelValueFloat,\r\n            'Array': WebGLKernelValueDynamicUnsignedArray,\r\n            'Array(2)': false,\r\n            'Array(3)': false,\r\n            'Array(4)': false,\r\n            'Array1D(2)': false,\r\n            'Array1D(3)': false,\r\n            'Array1D(4)': false,\r\n            'Array2D(2)': false,\r\n            'Array2D(3)': false,\r\n            'Array2D(4)': false,\r\n            'Array3D(2)': false,\r\n            'Array3D(3)': false,\r\n            'Array3D(4)': false,\r\n            'Input': WebGLKernelValueDynamicUnsignedInput,\r\n            'NumberTexture': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,\r\n            'HTMLImage': WebGLKernelValueDynamicHTMLImage,\r\n            'HTMLImageArray': false,\r\n            'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,\r\n          },\r\n          static: {\r\n            'Boolean': WebGLKernelValueBoolean,\r\n            'Float': WebGLKernelValueFloat,\r\n            'Integer': WebGLKernelValueInteger,\r\n            'Array': WebGLKernelValueUnsignedArray,\r\n            'Array(2)': false,\r\n            'Array(3)': false,\r\n            'Array(4)': false,\r\n            'Array1D(2)': false,\r\n            'Array1D(3)': false,\r\n            'Array1D(4)': false,\r\n            'Array2D(2)': false,\r\n            'Array2D(3)': false,\r\n            'Array2D(4)': false,\r\n            'Array3D(2)': false,\r\n            'Array3D(3)': false,\r\n            'Array3D(4)': false,\r\n            'Input': WebGLKernelValueUnsignedInput,\r\n            'NumberTexture': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(1)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(2)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(3)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(4)': WebGLKernelValueNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGLKernelValueHTMLImage,\r\n            'HTMLImage': WebGLKernelValueHTMLImage,\r\n            'HTMLImageArray': false,\r\n            'HTMLVideo': WebGLKernelValueHTMLVideo,\r\n          }\r\n        },\r\n        single: {\r\n          dynamic: {\r\n            'Boolean': WebGLKernelValueBoolean,\r\n            'Integer': WebGLKernelValueInteger,\r\n            'Float': WebGLKernelValueFloat,\r\n            'Array': WebGLKernelValueDynamicSingleArray,\r\n            'Array(2)': WebGLKernelValueSingleArray2,\r\n            'Array(3)': WebGLKernelValueSingleArray3,\r\n            'Array(4)': WebGLKernelValueSingleArray4,\r\n            'Array1D(2)': WebGLKernelValueDynamicSingleArray1DI,\r\n            'Array1D(3)': WebGLKernelValueDynamicSingleArray1DI,\r\n            'Array1D(4)': WebGLKernelValueDynamicSingleArray1DI,\r\n            'Array2D(2)': WebGLKernelValueDynamicSingleArray2DI,\r\n            'Array2D(3)': WebGLKernelValueDynamicSingleArray2DI,\r\n            'Array2D(4)': WebGLKernelValueDynamicSingleArray2DI,\r\n            'Array3D(2)': WebGLKernelValueDynamicSingleArray3DI,\r\n            'Array3D(3)': WebGLKernelValueDynamicSingleArray3DI,\r\n            'Array3D(4)': WebGLKernelValueDynamicSingleArray3DI,\r\n            'Input': WebGLKernelValueDynamicSingleInput,\r\n            'NumberTexture': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,\r\n            'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,\r\n            'HTMLImage': WebGLKernelValueDynamicHTMLImage,\r\n            'HTMLImageArray': false,\r\n            'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,\r\n          },\r\n          static: {\r\n            'Boolean': WebGLKernelValueBoolean,\r\n            'Float': WebGLKernelValueFloat,\r\n            'Integer': WebGLKernelValueInteger,\r\n            'Array': WebGLKernelValueSingleArray,\r\n            'Array(2)': WebGLKernelValueSingleArray2,\r\n            'Array(3)': WebGLKernelValueSingleArray3,\r\n            'Array(4)': WebGLKernelValueSingleArray4,\r\n            'Array1D(2)': WebGLKernelValueSingleArray1DI,\r\n            'Array1D(3)': WebGLKernelValueSingleArray1DI,\r\n            'Array1D(4)': WebGLKernelValueSingleArray1DI,\r\n            'Array2D(2)': WebGLKernelValueSingleArray2DI,\r\n            'Array2D(3)': WebGLKernelValueSingleArray2DI,\r\n            'Array2D(4)': WebGLKernelValueSingleArray2DI,\r\n            'Array3D(2)': WebGLKernelValueSingleArray3DI,\r\n            'Array3D(3)': WebGLKernelValueSingleArray3DI,\r\n            'Array3D(4)': WebGLKernelValueSingleArray3DI,\r\n            'Input': WebGLKernelValueSingleInput,\r\n            'NumberTexture': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(1)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(2)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(3)': WebGLKernelValueNumberTexture,\r\n            'ArrayTexture(4)': WebGLKernelValueNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGLKernelValueHTMLImage,\r\n            'HTMLImage': WebGLKernelValueHTMLImage,\r\n            'HTMLImageArray': false,\r\n            'HTMLVideo': WebGLKernelValueHTMLVideo,\r\n          }\r\n        },\r\n      };\r\n      \r\n      function lookupKernelValueType(type, dynamic, precision, value) {\r\n        if (!type) {\r\n          throw new Error('type missing');\r\n        }\r\n        if (!dynamic) {\r\n          throw new Error('dynamic missing');\r\n        }\r\n        if (!precision) {\r\n          throw new Error('precision missing');\r\n        }\r\n        if (value.type) {\r\n          type = value.type;\r\n        }\r\n        const types = kernelValueMaps[precision][dynamic];\r\n        if (types[type] === false) {\r\n          return null;\r\n        } else if (types[type] === undefined) {\r\n          throw new Error(`Could not find a KernelValue for ${ type }`);\r\n        }\r\n        return types[type];\r\n      }\r\n      \r\n      module.exports = {\r\n        lookupKernelValueType,\r\n        kernelValueMaps,\r\n      };\r\n      },{\"./kernel-value/boolean\":41,\"./kernel-value/dynamic-html-image\":42,\"./kernel-value/dynamic-html-video\":43,\"./kernel-value/dynamic-memory-optimized-number-texture\":44,\"./kernel-value/dynamic-number-texture\":45,\"./kernel-value/dynamic-single-array\":46,\"./kernel-value/dynamic-single-array1d-i\":47,\"./kernel-value/dynamic-single-array2d-i\":48,\"./kernel-value/dynamic-single-array3d-i\":49,\"./kernel-value/dynamic-single-input\":50,\"./kernel-value/dynamic-unsigned-array\":51,\"./kernel-value/dynamic-unsigned-input\":52,\"./kernel-value/float\":53,\"./kernel-value/html-image\":54,\"./kernel-value/html-video\":55,\"./kernel-value/integer\":57,\"./kernel-value/memory-optimized-number-texture\":58,\"./kernel-value/number-texture\":59,\"./kernel-value/single-array\":60,\"./kernel-value/single-array1d-i\":61,\"./kernel-value/single-array2\":62,\"./kernel-value/single-array2d-i\":63,\"./kernel-value/single-array3\":64,\"./kernel-value/single-array3d-i\":65,\"./kernel-value/single-array4\":66,\"./kernel-value/single-input\":67,\"./kernel-value/unsigned-array\":68,\"./kernel-value/unsigned-input\":69}],40:[function(require,module,exports){\r\n      const { WebGLKernelValue } = require('./index');\r\n      const { Input } = require('../../../input');\r\n      \r\n      class WebGLKernelArray extends WebGLKernelValue {\r\n        checkSize(width, height) {\r\n          if (!this.kernel.validate) return;\r\n          const { maxTextureSize } = this.kernel.constructor.features;\r\n          if (width > maxTextureSize || height > maxTextureSize) {\r\n            if (width > height) {\r\n              throw new Error(`Argument texture width of ${width} larger than maximum size of ${maxTextureSize} for your GPU`);\r\n            } else if (width < height) {\r\n              throw new Error(`Argument texture height of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);\r\n            } else {\r\n              throw new Error(`Argument texture height and width of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);\r\n            }\r\n          }\r\n        }\r\n      \r\n        setup() {\r\n          this.requestTexture();\r\n          this.setupTexture();\r\n          this.defineTexture();\r\n        }\r\n      \r\n        requestTexture() {\r\n          this.texture = this.onRequestTexture();\r\n        }\r\n      \r\n        defineTexture() {\r\n          const { context: gl } = this;\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        }\r\n      \r\n        setupTexture() {\r\n          this.contextHandle = this.onRequestContextHandle();\r\n          this.index = this.onRequestIndex();\r\n          this.dimensionsId = this.id + 'Dim';\r\n          this.sizeId = this.id + 'Size';\r\n        }\r\n      \r\n        getBitRatio(value) {\r\n          if (Array.isArray(value[0])) {\r\n            return this.getBitRatio(value[0]);\r\n          } else if (value.constructor === Input) {\r\n            return this.getBitRatio(value.value);\r\n          }\r\n          switch (value.constructor) {\r\n            case Uint8ClampedArray:\r\n            case Uint8Array:\r\n            case Int8Array:\r\n              return 1;\r\n            case Uint16Array:\r\n            case Int16Array:\r\n              return 2;\r\n            case Float32Array:\r\n            case Int32Array:\r\n            default:\r\n              return 4;\r\n          }\r\n        }\r\n      \r\n        destroy() {\r\n          if (this.prevArg) {\r\n            this.prevArg.delete();\r\n          }\r\n          this.context.deleteTexture(this.texture);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelArray\r\n      };\r\n      },{\"../../../input\":110,\"./index\":56}],41:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueBoolean extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            return `const bool ${this.id} = ${value};\\n`;\r\n          }\r\n          return `uniform bool ${this.id};\\n`;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform1i(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueBoolean\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],42:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueHTMLImage } = require('./html-image');\r\n      \r\n      class WebGLKernelValueDynamicHTMLImage extends WebGLKernelValueHTMLImage {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          const { width, height } = value;\r\n          this.checkSize(width, height);\r\n          this.dimensions = [width, height, 1];\r\n          this.textureSize = [width, height];\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicHTMLImage\r\n      };\r\n      },{\"../../../utils\":114,\"./html-image\":54}],43:[function(require,module,exports){\r\n      const { WebGLKernelValueDynamicHTMLImage } = require('./dynamic-html-image');\r\n      \r\n      class WebGLKernelValueDynamicHTMLVideo extends WebGLKernelValueDynamicHTMLImage {}\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicHTMLVideo\r\n      };\r\n      },{\"./dynamic-html-image\":42}],44:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./memory-optimized-number-texture');\r\n      \r\n      class WebGLKernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(inputTexture) {\r\n          this.dimensions = inputTexture.dimensions;\r\n          this.checkSize(inputTexture.size[0], inputTexture.size[1]);\r\n          this.textureSize = inputTexture.size;\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(inputTexture);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicMemoryOptimizedNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"./memory-optimized-number-texture\":58}],45:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueNumberTexture } = require('./number-texture');\r\n      \r\n      class WebGLKernelValueDynamicNumberTexture extends WebGLKernelValueNumberTexture {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.dimensions = value.dimensions;\r\n          this.checkSize(value.size[0], value.size[1]);\r\n          this.textureSize = value.size;\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"./number-texture\":59}],46:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray } = require('./single-array');\r\n      \r\n      class WebGLKernelValueDynamicSingleArray extends WebGLKernelValueSingleArray {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.dimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicSingleArray\r\n      };\r\n      },{\"../../../utils\":114,\"./single-array\":60}],47:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray1DI } = require('./single-array1d-i');\r\n      \r\n      class WebGLKernelValueDynamicSingleArray1DI extends WebGLKernelValueSingleArray1DI {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicSingleArray1DI\r\n      };\r\n      },{\"../../../utils\":114,\"./single-array1d-i\":61}],48:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray2DI } = require('./single-array2d-i');\r\n      \r\n      class WebGLKernelValueDynamicSingleArray2DI extends WebGLKernelValueSingleArray2DI {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicSingleArray2DI\r\n      };\r\n      },{\"../../../utils\":114,\"./single-array2d-i\":63}],49:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray3DI } = require('./single-array3d-i');\r\n      \r\n      class WebGLKernelValueDynamicSingleArray3DI extends WebGLKernelValueSingleArray3DI {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicSingleArray3DI\r\n      };\r\n      },{\"../../../utils\":114,\"./single-array3d-i\":65}],50:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleInput } = require('./single-input');\r\n      \r\n      class WebGLKernelValueDynamicSingleInput extends WebGLKernelValueSingleInput {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          let [w, h, d] = value.size;\r\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicSingleInput\r\n      };\r\n      },{\"../../../utils\":114,\"./single-input\":67}],51:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueUnsignedArray } = require('./unsigned-array');\r\n      \r\n      class WebGLKernelValueDynamicUnsignedArray extends WebGLKernelValueUnsignedArray {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.dimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          const Type = this.getTransferArrayType(value);\r\n          this.preUploadValue = new Type(this.uploadArrayLength);\r\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicUnsignedArray\r\n      };\r\n      },{\"../../../utils\":114,\"./unsigned-array\":68}],52:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueUnsignedInput } = require('./unsigned-input');\r\n      \r\n      class WebGLKernelValueDynamicUnsignedInput extends WebGLKernelValueUnsignedInput {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          let [w, h, d] = value.size;\r\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\r\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          const Type = this.getTransferArrayType(value.value);\r\n          this.preUploadValue = new Type(this.uploadArrayLength);\r\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueDynamicUnsignedInput\r\n      };\r\n      },{\"../../../utils\":114,\"./unsigned-input\":69}],53:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueFloat extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            if (Number.isInteger(value)) {\r\n              return `const float ${this.id} = ${value}.0;\\n`;\r\n            }\r\n            return `const float ${this.id} = ${value};\\n`;\r\n          }\r\n          return `uniform float ${this.id};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform1f(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueFloat\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],54:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueHTMLImage extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          const { width, height } = value;\r\n          this.checkSize(width, height);\r\n          this.dimensions = [width, height, 1];\r\n          this.textureSize = [width, height];\r\n          this.uploadValue = value;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(inputImage) {\r\n          if (inputImage.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(inputImage.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = inputImage);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueHTMLImage\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],55:[function(require,module,exports){\r\n      const { WebGLKernelValueHTMLImage } = require('./html-image');\r\n      \r\n      class WebGLKernelValueHTMLVideo extends WebGLKernelValueHTMLImage {}\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueHTMLVideo\r\n      };\r\n      },{\"./html-image\":54}],56:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { KernelValue } = require('../../kernel-value');\r\n      \r\n      class WebGLKernelValue extends KernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.dimensionsId = null;\r\n          this.sizeId = null;\r\n          this.initialValueConstructor = value.constructor;\r\n          this.onRequestTexture = settings.onRequestTexture;\r\n          this.onRequestIndex = settings.onRequestIndex;\r\n          this.uploadValue = null;\r\n          this.textureSize = null;\r\n          this.bitRatio = null;\r\n          this.prevArg = null;\r\n        }\r\n      \r\n        get id() {\r\n          return `${this.origin}_${utils.sanitizeName(this.name)}`;\r\n        }\r\n      \r\n        setup() {}\r\n      \r\n        getTransferArrayType(value) {\r\n          if (Array.isArray(value[0])) {\r\n            return this.getTransferArrayType(value[0]);\r\n          }\r\n          switch (value.constructor) {\r\n            case Array:\r\n            case Int32Array:\r\n            case Int16Array:\r\n            case Int8Array:\r\n              return Float32Array;\r\n            case Uint8ClampedArray:\r\n            case Uint8Array:\r\n            case Uint16Array:\r\n            case Uint32Array:\r\n            case Float32Array:\r\n            case Float64Array:\r\n              return value.constructor;\r\n          }\r\n          console.warn('Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros');\r\n          return value.constructor;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          throw new Error(`\"getStringValueHandler\" not implemented on ${this.constructor.name}`);\r\n        }\r\n      \r\n        getVariablePrecisionString() {\r\n          return this.kernel.getVariablePrecisionString(this.textureSize || undefined, this.tactic || undefined);\r\n        }\r\n      \r\n        destroy() {}\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValue\r\n      };\r\n      },{\"../../../utils\":114,\"../../kernel-value\":35}],57:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueInteger extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            return `const int ${this.id} = ${ parseInt(value) };\\n`;\r\n          }\r\n          return `uniform int ${this.id};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform1i(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueInteger\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],58:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      const sameError = `Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()`;\r\n      \r\n      class WebGLKernelValueMemoryOptimizedNumberTexture extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          const [width, height] = value.size;\r\n          this.checkSize(width, height);\r\n          this.dimensions = value.dimensions;\r\n          this.textureSize = value.size;\r\n          this.uploadValue = value.texture;\r\n          this.forceUploadEachRun = true;\r\n        }\r\n      \r\n        setup() {\r\n          this.setupTexture();\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName}.texture;\\n`;\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(inputTexture) {\r\n          if (inputTexture.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(inputTexture.constructor);\r\n            return;\r\n          }\r\n          if (this.checkContext && inputTexture.context !== this.context) {\r\n            throw new Error(`Value ${this.name} (${this.type}) must be from same context`);\r\n          }\r\n      \r\n          const { kernel, context: gl } = this;\r\n          if (kernel.pipeline) {\r\n            if (kernel.immutable) {\r\n              kernel.updateTextureArgumentRefs(this, inputTexture);\r\n            } else {\r\n              if (kernel.texture.texture === inputTexture.texture) {\r\n                throw new Error(sameError);\r\n              } else if (kernel.mappedTextures) {\r\n                const { mappedTextures } = kernel;\r\n                for (let i = 0; i < mappedTextures.length; i++) {\r\n                  if (mappedTextures[i].texture === inputTexture.texture) {\r\n                    throw new Error(sameError);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n      \r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueMemoryOptimizedNumberTexture,\r\n        sameError\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],59:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      const { sameError } = require('./memory-optimized-number-texture');\r\n      \r\n      class WebGLKernelValueNumberTexture extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          const [width, height] = value.size;\r\n          this.checkSize(width, height);\r\n          const { size: textureSize, dimensions } = value;\r\n          this.bitRatio = this.getBitRatio(value);\r\n          this.dimensions = dimensions;\r\n          this.textureSize = textureSize;\r\n          this.uploadValue = value.texture;\r\n          this.forceUploadEachRun = true;\r\n        }\r\n      \r\n        setup() {\r\n          this.setupTexture();\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName}.texture;\\n`;\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(inputTexture) {\r\n          if (inputTexture.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(inputTexture.constructor);\r\n            return;\r\n          }\r\n          if (this.checkContext && inputTexture.context !== this.context) {\r\n            throw new Error(`Value ${this.name} (${this.type}) must be from same context`);\r\n          }\r\n      \r\n          const { kernel, context: gl } = this;\r\n          if (kernel.pipeline) {\r\n            if (kernel.immutable) {\r\n              kernel.updateTextureArgumentRefs(this, inputTexture);\r\n            } else {\r\n              if (kernel.texture.texture === inputTexture.texture) {\r\n                throw new Error(sameError);\r\n              } else if (kernel.mappedTextures) {\r\n                const { mappedTextures } = kernel;\r\n                for (let i = 0; i < mappedTextures.length; i++) {\r\n                  if (mappedTextures[i].texture === inputTexture.texture) {\r\n                    throw new Error(sameError);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n      \r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40,\"./memory-optimized-number-texture\":58}],60:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueSingleArray extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = 4;\r\n          this.dimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\r\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],61:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueSingleArray1DI extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = 4;\r\n          this.setShape(value);\r\n        }\r\n      \r\n        setShape(value) {\r\n          const valueDimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);\r\n          this.dimensions = new Int32Array([valueDimensions[1], 1, 1]);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\r\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flatten2dArrayTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray1DI\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],62:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueSingleArray2 extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            return `const vec2 ${this.id} = vec2(${value[0]},${value[1]});\\n`;\r\n          }\r\n          return `uniform vec2 ${this.id};\\n`;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          if (this.origin === 'constants') return '';\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform2fv(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray2\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],63:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueSingleArray2DI extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = 4;\r\n          this.setShape(value);\r\n        }\r\n      \r\n        setShape(value) {\r\n          const valueDimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);\r\n          this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], 1]);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\r\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flatten3dArrayTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray2DI\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],64:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueSingleArray3 extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            return `const vec3 ${this.id} = vec3(${value[0]},${value[1]},${value[2]});\\n`;\r\n          }\r\n          return `uniform vec3 ${this.id};\\n`;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          if (this.origin === 'constants') return '';\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform3fv(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray3\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],65:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueSingleArray3DI extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = 4;\r\n          this.setShape(value);\r\n        }\r\n      \r\n        setShape(value) {\r\n          const valueDimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);\r\n          this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], valueDimensions[3]]);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\r\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flatten4dArrayTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray3DI\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],66:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValue } = require('./index');\r\n      \r\n      class WebGLKernelValueSingleArray4 extends WebGLKernelValue {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.uploadValue = value;\r\n        }\r\n        getSource(value) {\r\n          if (this.origin === 'constants') {\r\n            return `const vec4 ${this.id} = vec4(${value[0]},${value[1]},${value[2]},${value[3]});\\n`;\r\n          }\r\n          return `uniform vec4 ${this.id};\\n`;\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          if (this.origin === 'constants') return '';\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform4fv(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleArray4\r\n      };\r\n      },{\"../../../utils\":114,\"./index\":56}],67:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueSingleInput extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = 4;\r\n          let [w, h, d] = value.size;\r\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\r\n            `flattenTo(${this.varName}.value, uploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(input) {\r\n          if (input.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(input.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(input.value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueSingleInput\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],68:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueUnsignedArray extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = this.getBitRatio(value);\r\n          this.dimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.TranserArrayType = this.getTransferArrayType(value);\r\n          this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);\r\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,\r\n            `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,\r\n            `flattenTo(${this.varName}, preUploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.preUploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueUnsignedArray\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],69:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('./array');\r\n      \r\n      class WebGLKernelValueUnsignedInput extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.bitRatio = this.getBitRatio(value);\r\n          const [w, h, d] = value.size;\r\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\r\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.TranserArrayType = this.getTransferArrayType(value.value);\r\n          this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);\r\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return utils.linesToString([\r\n            `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,\r\n            `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,\r\n            `flattenTo(${this.varName}.value, preUploadValue_${this.name})`,\r\n          ]);\r\n        }\r\n      \r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(input) {\r\n          if (input.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(input.value, this.preUploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernelValueUnsignedInput\r\n      };\r\n      },{\"../../../utils\":114,\"./array\":40}],70:[function(require,module,exports){\r\n      const { GLKernel } = require('../gl/kernel');\r\n      const { FunctionBuilder } = require('../function-builder');\r\n      const { WebGLFunctionNode } = require('./function-node');\r\n      const { utils } = require('../../utils');\r\n      const mrud = require('../../plugins/math-random-uniformly-distributed');\r\n      const { fragmentShader } = require('./fragment-shader');\r\n      const { vertexShader } = require('./vertex-shader');\r\n      const { glKernelString } = require('../gl/kernel-string');\r\n      const { lookupKernelValueType } = require('./kernel-value-maps');\r\n      \r\n      let isSupported = null;\r\n      let testCanvas = null;\r\n      let testContext = null;\r\n      let testExtensions = null;\r\n      let features = null;\r\n      \r\n      const plugins = [mrud];\r\n      const canvases = [];\r\n      const maxTexSizes = {};\r\n      \r\n      \r\n      class WebGLKernel extends GLKernel {\r\n        static get isSupported() {\r\n          if (isSupported !== null) {\r\n            return isSupported;\r\n          }\r\n          this.setupFeatureChecks();\r\n          isSupported = this.isContextMatch(testContext);\r\n          return isSupported;\r\n        }\r\n      \r\n        static setupFeatureChecks() {\r\n          if (typeof document !== 'undefined') {\r\n            testCanvas = document.createElement('canvas');\r\n          } else if (typeof OffscreenCanvas !== 'undefined') {\r\n            testCanvas = new OffscreenCanvas(0, 0);\r\n          }\r\n          if (!testCanvas) return;\r\n          testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');\r\n          if (!testContext || !testContext.getExtension) return;\r\n          testExtensions = {\r\n            OES_texture_float: testContext.getExtension('OES_texture_float'),\r\n            OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),\r\n            OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),\r\n            WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),\r\n          };\r\n          features = this.getFeatures();\r\n        }\r\n      \r\n        static isContextMatch(context) {\r\n          if (typeof WebGLRenderingContext !== 'undefined') {\r\n            return context instanceof WebGLRenderingContext;\r\n          }\r\n          return false;\r\n        }\r\n      \r\n        static getIsTextureFloat() {\r\n          return Boolean(testExtensions.OES_texture_float);\r\n        }\r\n      \r\n        static getIsDrawBuffers() {\r\n          return Boolean(testExtensions.WEBGL_draw_buffers);\r\n        }\r\n      \r\n        static getChannelCount() {\r\n          return testExtensions.WEBGL_draw_buffers ?\r\n            testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :\r\n            1;\r\n        }\r\n      \r\n        static getMaxTextureSize() {\r\n          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);\r\n        }\r\n      \r\n        static lookupKernelValueType(type, dynamic, precision, value) {\r\n          return lookupKernelValueType(type, dynamic, precision, value);\r\n        }\r\n      \r\n        static get testCanvas() {\r\n          return testCanvas;\r\n        }\r\n      \r\n        static get testContext() {\r\n          return testContext;\r\n        }\r\n      \r\n        static get features() {\r\n          return features;\r\n        }\r\n      \r\n        static get fragmentShader() {\r\n          return fragmentShader;\r\n        }\r\n      \r\n        static get vertexShader() {\r\n          return vertexShader;\r\n        }\r\n      \r\n        constructor(source, settings) {\r\n          super(source, settings);\r\n          this.program = null;\r\n          this.pipeline = settings.pipeline;\r\n          this.endianness = utils.systemEndianness();\r\n          this.extensions = {};\r\n          this.argumentTextureCount = 0;\r\n          this.constantTextureCount = 0;\r\n          this.fragShader = null;\r\n          this.vertShader = null;\r\n          this.drawBuffersMap = null;\r\n      \r\n          this.maxTexSize = null;\r\n          this.onRequestSwitchKernel = null;\r\n      \r\n          this.texture = null;\r\n          this.mappedTextures = null;\r\n          this.mergeSettings(source.settings || settings);\r\n      \r\n          this.threadDim = null;\r\n          this.framebuffer = null;\r\n          this.buffer = null;\r\n      \r\n          this.textureCache = [];\r\n          this.programUniformLocationCache = {};\r\n          this.uniform1fCache = {};\r\n          this.uniform1iCache = {};\r\n          this.uniform2fCache = {};\r\n          this.uniform2fvCache = {};\r\n          this.uniform2ivCache = {};\r\n          this.uniform3fvCache = {};\r\n          this.uniform3ivCache = {};\r\n          this.uniform4fvCache = {};\r\n          this.uniform4ivCache = {};\r\n        }\r\n      \r\n        initCanvas() {\r\n          if (typeof document !== 'undefined') {\r\n            const canvas = document.createElement('canvas');\r\n            canvas.width = 2;\r\n            canvas.height = 2;\r\n            return canvas;\r\n          } else if (typeof OffscreenCanvas !== 'undefined') {\r\n            return new OffscreenCanvas(0, 0);\r\n          }\r\n        }\r\n      \r\n        initContext() {\r\n          const settings = {\r\n            alpha: false,\r\n            depth: false,\r\n            antialias: false\r\n          };\r\n          return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);\r\n        }\r\n      \r\n        initPlugins(settings) {\r\n          const pluginsToUse = [];\r\n          const { source } = this;\r\n          if (typeof source === 'string') {\r\n            for (let i = 0; i < plugins.length; i++) {\r\n              const plugin = plugins[i];\r\n              if (source.match(plugin.functionMatch)) {\r\n                pluginsToUse.push(plugin);\r\n              }\r\n            }\r\n          } else if (typeof source === 'object') {\r\n            if (settings.pluginNames) { \r\n              for (let i = 0; i < plugins.length; i++) {\r\n                const plugin = plugins[i];\r\n                const usePlugin = settings.pluginNames.some(pluginName => pluginName === plugin.name);\r\n                if (usePlugin) {\r\n                  pluginsToUse.push(plugin);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          return pluginsToUse;\r\n        }\r\n      \r\n        initExtensions() {\r\n          this.extensions = {\r\n            OES_texture_float: this.context.getExtension('OES_texture_float'),\r\n            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),\r\n            OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),\r\n            WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),\r\n            WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float'),\r\n          };\r\n        }\r\n      \r\n        validateSettings(args) {\r\n          if (!this.validate) {\r\n            this.texSize = utils.getKernelTextureSize({\r\n              optimizeFloatMemory: this.optimizeFloatMemory,\r\n              precision: this.precision,\r\n            }, this.output);\r\n            return;\r\n          }\r\n      \r\n          const { features } = this.constructor;\r\n      \r\n          if (this.optimizeFloatMemory === true && !features.isTextureFloat) {\r\n            throw new Error('Float textures are not supported');\r\n          } else if (this.precision === 'single' && !features.isFloatRead) {\r\n            throw new Error('Single precision not supported');\r\n          } else if (!this.graphical && this.precision === null && features.isTextureFloat) {\r\n            this.precision = features.isFloatRead ? 'single' : 'unsigned';\r\n          }\r\n      \r\n          if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {\r\n            throw new Error('could not instantiate draw buffers extension');\r\n          }\r\n      \r\n          if (this.fixIntegerDivisionAccuracy === null) {\r\n            this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;\r\n          } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {\r\n            this.fixIntegerDivisionAccuracy = false;\r\n          }\r\n      \r\n          this.checkOutput();\r\n      \r\n          if (!this.output || this.output.length === 0) {\r\n            if (args.length !== 1) {\r\n              throw new Error('Auto output only supported for kernels with only one input');\r\n            }\r\n      \r\n            const argType = utils.getVariableType(args[0], this.strictIntegers);\r\n            switch (argType) {\r\n              case 'Array':\r\n                this.output = utils.getDimensions(argType);\r\n                break;\r\n              case 'NumberTexture':\r\n              case 'MemoryOptimizedNumberTexture':\r\n              case 'ArrayTexture(1)':\r\n              case 'ArrayTexture(2)':\r\n              case 'ArrayTexture(3)':\r\n              case 'ArrayTexture(4)':\r\n                this.output = args[0].output;\r\n                break;\r\n              default:\r\n                throw new Error('Auto output not supported for input type: ' + argType);\r\n            }\r\n          }\r\n      \r\n          if (this.graphical) {\r\n            if (this.output.length !== 2) {\r\n              throw new Error('Output must have 2 dimensions on graphical mode');\r\n            }\r\n      \r\n            if (this.precision === 'precision') {\r\n              this.precision = 'unsigned';\r\n              console.warn('Cannot use graphical mode and single precision at the same time');\r\n            }\r\n      \r\n            this.texSize = utils.clone(this.output);\r\n            return;\r\n          } else if (this.precision === null && features.isTextureFloat) {\r\n            this.precision = 'single';\r\n          }\r\n      \r\n          this.texSize = utils.getKernelTextureSize({\r\n            optimizeFloatMemory: this.optimizeFloatMemory,\r\n            precision: this.precision,\r\n          }, this.output);\r\n      \r\n          this.checkTextureSize();\r\n        }\r\n      \r\n        updateMaxTexSize() {\r\n          const { texSize, canvas } = this;\r\n          if (this.maxTexSize === null) {\r\n            let canvasIndex = canvases.indexOf(canvas);\r\n            if (canvasIndex === -1) {\r\n              canvasIndex = canvases.length;\r\n              canvases.push(canvas);\r\n              maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];\r\n            }\r\n            this.maxTexSize = maxTexSizes[canvasIndex];\r\n          }\r\n          if (this.maxTexSize[0] < texSize[0]) {\r\n            this.maxTexSize[0] = texSize[0];\r\n          }\r\n          if (this.maxTexSize[1] < texSize[1]) {\r\n            this.maxTexSize[1] = texSize[1];\r\n          }\r\n        }\r\n      \r\n        setupArguments(args) {\r\n          this.kernelArguments = [];\r\n          this.argumentTextureCount = 0;\r\n          const needsArgumentTypes = this.argumentTypes === null;\r\n          if (needsArgumentTypes) {\r\n            this.argumentTypes = [];\r\n          }\r\n          this.argumentSizes = [];\r\n          this.argumentBitRatios = [];\r\n      \r\n          if (args.length < this.argumentNames.length) {\r\n            throw new Error('not enough arguments for kernel');\r\n          } else if (args.length > this.argumentNames.length) {\r\n            throw new Error('too many arguments for kernel');\r\n          }\r\n      \r\n          const { context: gl } = this;\r\n          let textureIndexes = 0;\r\n      \r\n          const onRequestTexture = () => {\r\n            return this.createTexture();\r\n          };\r\n          const onRequestIndex = () => {\r\n            return this.constantTextureCount + textureIndexes++;\r\n          };\r\n          const onUpdateValueMismatch = (constructor) => {\r\n            this.switchKernels({\r\n              type: 'argumentMismatch',\r\n              needed: constructor\r\n            });\r\n          };\r\n          const onRequestContextHandle = () => {\r\n            return gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;\r\n          };\r\n      \r\n          for (let index = 0; index < args.length; index++) {\r\n            const value = args[index];\r\n            const name = this.argumentNames[index];\r\n            let type;\r\n            if (needsArgumentTypes) {\r\n              type = utils.getVariableType(value, this.strictIntegers);\r\n              this.argumentTypes.push(type);\r\n            } else {\r\n              type = this.argumentTypes[index];\r\n            }\r\n            const KernelValue = this.constructor.lookupKernelValueType(type, this.dynamicArguments ? 'dynamic' : 'static', this.precision, args[index]);\r\n            if (KernelValue === null) {\r\n              return this.requestFallback(args);\r\n            }\r\n            const kernelArgument = new KernelValue(value, {\r\n              name,\r\n              type,\r\n              tactic: this.tactic,\r\n              origin: 'user',\r\n              context: gl,\r\n              checkContext: this.checkContext,\r\n              kernel: this,\r\n              strictIntegers: this.strictIntegers,\r\n              onRequestTexture,\r\n              onRequestIndex,\r\n              onUpdateValueMismatch,\r\n              onRequestContextHandle,\r\n            });\r\n            this.kernelArguments.push(kernelArgument);\r\n            kernelArgument.setup();\r\n            this.argumentSizes.push(kernelArgument.textureSize);\r\n            this.argumentBitRatios[index] = kernelArgument.bitRatio;\r\n          }\r\n        }\r\n      \r\n        createTexture() {\r\n          const texture = this.context.createTexture();\r\n          this.textureCache.push(texture);\r\n          return texture;\r\n        }\r\n      \r\n        setupConstants(args) {\r\n          const { context: gl } = this;\r\n          this.kernelConstants = [];\r\n          this.forceUploadKernelConstants = [];\r\n          let needsConstantTypes = this.constantTypes === null;\r\n          if (needsConstantTypes) {\r\n            this.constantTypes = {};\r\n          }\r\n          this.constantBitRatios = {};\r\n          let textureIndexes = 0;\r\n          for (const name in this.constants) {\r\n            const value = this.constants[name];\r\n            let type;\r\n            if (needsConstantTypes) {\r\n              type = utils.getVariableType(value, this.strictIntegers);\r\n              this.constantTypes[name] = type;\r\n            } else {\r\n              type = this.constantTypes[name];\r\n            }\r\n            const KernelValue = this.constructor.lookupKernelValueType(type, 'static', this.precision, value);\r\n            if (KernelValue === null) {\r\n              return this.requestFallback(args);\r\n            }\r\n            const kernelValue = new KernelValue(value, {\r\n              name,\r\n              type,\r\n              tactic: this.tactic,\r\n              origin: 'constants',\r\n              context: this.context,\r\n              checkContext: this.checkContext,\r\n              kernel: this,\r\n              strictIntegers: this.strictIntegers,\r\n              onRequestTexture: () => {\r\n                return this.createTexture();\r\n              },\r\n              onRequestIndex: () => {\r\n                return textureIndexes++;\r\n              },\r\n              onRequestContextHandle: () => {\r\n                return gl.TEXTURE0 + this.constantTextureCount++;\r\n              }\r\n            });\r\n            this.constantBitRatios[name] = kernelValue.bitRatio;\r\n            this.kernelConstants.push(kernelValue);\r\n            kernelValue.setup();\r\n            if (kernelValue.forceUploadEachRun) {\r\n              this.forceUploadKernelConstants.push(kernelValue);\r\n            }\r\n          }\r\n        }\r\n      \r\n        build() {\r\n          if (this.built) return;\r\n          this.initExtensions();\r\n          this.validateSettings(arguments);\r\n          this.setupConstants(arguments);\r\n          if (this.fallbackRequested) return;\r\n          this.setupArguments(arguments);\r\n          if (this.fallbackRequested) return;\r\n          this.updateMaxTexSize();\r\n          this.translateSource();\r\n          const failureResult = this.pickRenderStrategy(arguments);\r\n          if (failureResult) {\r\n            return failureResult;\r\n          }\r\n          const { texSize, context: gl, canvas } = this;\r\n          gl.enable(gl.SCISSOR_TEST);\r\n          if (this.pipeline && this.precision === 'single') {\r\n            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);\r\n            canvas.width = this.maxTexSize[0];\r\n            canvas.height = this.maxTexSize[1];\r\n          } else {\r\n            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);\r\n            canvas.width = this.maxTexSize[0];\r\n            canvas.height = this.maxTexSize[1];\r\n          }\r\n          const threadDim = this.threadDim = Array.from(this.output);\r\n          while (threadDim.length < 3) {\r\n            threadDim.push(1);\r\n          }\r\n      \r\n          const compiledVertexShader = this.getVertexShader(arguments);\r\n          const vertShader = gl.createShader(gl.VERTEX_SHADER);\r\n          gl.shaderSource(vertShader, compiledVertexShader);\r\n          gl.compileShader(vertShader);\r\n          this.vertShader = vertShader;\r\n      \r\n          const compiledFragmentShader = this.getFragmentShader(arguments);\r\n          const fragShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n          gl.shaderSource(fragShader, compiledFragmentShader);\r\n          gl.compileShader(fragShader);\r\n          this.fragShader = fragShader;\r\n      \r\n          if (this.debug) {\r\n            console.log('GLSL Shader Output:');\r\n            console.log(compiledFragmentShader);\r\n          }\r\n      \r\n          if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {\r\n            throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));\r\n          }\r\n          if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {\r\n            throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));\r\n          }\r\n      \r\n          const program = this.program = gl.createProgram();\r\n          gl.attachShader(program, vertShader);\r\n          gl.attachShader(program, fragShader);\r\n          gl.linkProgram(program);\r\n          this.framebuffer = gl.createFramebuffer();\r\n          this.framebuffer.width = texSize[0];\r\n          this.framebuffer.height = texSize[1];\r\n          this.rawValueFramebuffers = {};\r\n      \r\n          const vertices = new Float32Array([-1, -1,\r\n            1, -1, -1, 1,\r\n            1, 1\r\n          ]);\r\n          const texCoords = new Float32Array([\r\n            0, 0,\r\n            1, 0,\r\n            0, 1,\r\n            1, 1\r\n          ]);\r\n      \r\n          const texCoordOffset = vertices.byteLength;\r\n      \r\n          let buffer = this.buffer;\r\n          if (!buffer) {\r\n            buffer = this.buffer = gl.createBuffer();\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n            gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);\r\n          } else {\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n          }\r\n      \r\n          gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);\r\n          gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);\r\n      \r\n          const aPosLoc = gl.getAttribLocation(this.program, 'aPos');\r\n          gl.enableVertexAttribArray(aPosLoc);\r\n          gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);\r\n          const aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');\r\n          gl.enableVertexAttribArray(aTexCoordLoc);\r\n          gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\r\n      \r\n          let i = 0;\r\n          gl.useProgram(this.program);\r\n          for (let p in this.constants) {\r\n            this.kernelConstants[i++].updateValue(this.constants[p]);\r\n          }\r\n      \r\n          this._setupOutputTexture();\r\n          if (\r\n            this.subKernels !== null &&\r\n            this.subKernels.length > 0\r\n          ) {\r\n            this._mappedTextureSwitched = {};\r\n            this._setupSubOutputTextures();\r\n          }\r\n          this.buildSignature(arguments);\r\n          this.built = true;\r\n        }\r\n      \r\n        translateSource() {\r\n          const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {\r\n            fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy\r\n          });\r\n          this.translatedSource = functionBuilder.getPrototypeString('kernel');\r\n          this.setupReturnTypes(functionBuilder);\r\n        }\r\n      \r\n        setupReturnTypes(functionBuilder) {\r\n          if (!this.graphical && !this.returnType) {\r\n            this.returnType = functionBuilder.getKernelResultType();\r\n          }\r\n      \r\n          if (this.subKernels && this.subKernels.length > 0) {\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              const subKernel = this.subKernels[i];\r\n              if (!subKernel.returnType) {\r\n                subKernel.returnType = functionBuilder.getSubKernelResultType(i);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      \r\n        run() {\r\n          const { kernelArguments, texSize, forceUploadKernelConstants, context: gl } = this;\r\n      \r\n          gl.useProgram(this.program);\r\n          gl.scissor(0, 0, texSize[0], texSize[1]);\r\n          if (this.dynamicOutput) {\r\n            this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));\r\n            this.setUniform2iv('uTexSize', texSize);\r\n          }\r\n      \r\n          this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);\r\n      \r\n          for (let i = 0; i < forceUploadKernelConstants.length; i++) {\r\n            const constant = forceUploadKernelConstants[i];\r\n            constant.updateValue(this.constants[constant.name]);\r\n            if (this.switchingKernels) return;\r\n          }\r\n          for (let i = 0; i < kernelArguments.length; i++) {\r\n            kernelArguments[i].updateValue(arguments[i]);\r\n            if (this.switchingKernels) return;\r\n          }\r\n      \r\n          if (this.plugins) {\r\n            for (let i = 0; i < this.plugins.length; i++) {\r\n              const plugin = this.plugins[i];\r\n              if (plugin.onBeforeRun) {\r\n                plugin.onBeforeRun(this);\r\n              }\r\n            }\r\n          }\r\n      \r\n          if (this.graphical) {\r\n            if (this.pipeline) {\r\n              gl.bindRenderbuffer(gl.RENDERBUFFER, null);\r\n              gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\r\n              if (this.immutable) {\r\n                this._replaceOutputTexture();\r\n              }\r\n              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n              return this.immutable ? this.texture.clone() : this.texture;\r\n            }\r\n            gl.bindRenderbuffer(gl.RENDERBUFFER, null);\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n            return;\r\n          }\r\n      \r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\r\n          if (this.immutable) {\r\n            this._replaceOutputTexture();\r\n          }\r\n      \r\n          if (this.subKernels !== null) {\r\n            if (this.immutable) {\r\n              this._replaceSubOutputTextures();\r\n            }\r\n            this.drawBuffers();\r\n          }\r\n      \r\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n        }\r\n      \r\n        drawBuffers() {\r\n          this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);\r\n        }\r\n      \r\n        getInternalFormat() {\r\n          return this.context.RGBA;\r\n        }\r\n        getTextureFormat() {\r\n          const { context: gl } = this;\r\n          switch (this.getInternalFormat()) {\r\n            case gl.RGBA:\r\n              return gl.RGBA;\r\n            default:\r\n              throw new Error('Unknown internal format');\r\n          }\r\n        }\r\n      \r\n        _replaceOutputTexture() {\r\n          if (this.texture.beforeMutate() || this._textureSwitched) {\r\n            const gl = this.context;\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);\r\n            this._textureSwitched = false;\r\n          }\r\n        }\r\n      \r\n        _setupOutputTexture() {\r\n          const gl = this.context;\r\n          const texSize = this.texSize;\r\n          if (this.texture) {\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);\r\n            return;\r\n          }\r\n          const texture = this.createTexture();\r\n          gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);\r\n          gl.bindTexture(gl.TEXTURE_2D, texture);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n          const format = this.getInternalFormat();\r\n          if (this.precision === 'single') {\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);\r\n          } else {\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);\r\n          }\r\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n          this.texture = new this.TextureConstructor({\r\n            texture,\r\n            size: texSize,\r\n            dimensions: this.threadDim,\r\n            output: this.output,\r\n            context: this.context,\r\n            internalFormat: this.getInternalFormat(),\r\n            textureFormat: this.getTextureFormat(),\r\n            kernel: this,\r\n          });\r\n        }\r\n      \r\n        _replaceSubOutputTextures() {\r\n          const gl = this.context;\r\n          for (let i = 0; i < this.mappedTextures.length; i++) {\r\n            const mappedTexture = this.mappedTextures[i];\r\n            if (mappedTexture.beforeMutate() || this._mappedTextureSwitched[i]) {\r\n              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, mappedTexture.texture, 0);\r\n              this._mappedTextureSwitched[i] = false;\r\n            }\r\n          }\r\n        }\r\n      \r\n        _setupSubOutputTextures() {\r\n          const gl = this.context;\r\n          if (this.mappedTextures) {\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);\r\n            }\r\n            return;\r\n          }\r\n          const texSize = this.texSize;\r\n          this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];\r\n          this.mappedTextures = [];\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const texture = this.createTexture();\r\n            this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);\r\n            gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n            if (this.precision === 'single') {\r\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);\r\n            } else {\r\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n            }\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);\r\n      \r\n            this.mappedTextures.push(new this.TextureConstructor({\r\n              texture,\r\n              size: texSize,\r\n              dimensions: this.threadDim,\r\n              output: this.output,\r\n              context: this.context,\r\n              internalFormat: this.getInternalFormat(),\r\n              textureFormat: this.getTextureFormat(),\r\n              kernel: this,\r\n            }));\r\n          }\r\n        }\r\n      \r\n        setUniform1f(name, value) {\r\n          if (this.uniform1fCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform1fCache[name];\r\n            if (value === cache) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform1fCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform1f(loc, value);\r\n        }\r\n      \r\n        setUniform1i(name, value) {\r\n          if (this.uniform1iCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform1iCache[name];\r\n            if (value === cache) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform1iCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform1i(loc, value);\r\n        }\r\n      \r\n        setUniform2f(name, value1, value2) {\r\n          if (this.uniform2fCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform2fCache[name];\r\n            if (\r\n              value1 === cache[0] &&\r\n              value2 === cache[1]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform2fCache[name] = [value1, value2];\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform2f(loc, value1, value2);\r\n        }\r\n      \r\n        setUniform2fv(name, value) {\r\n          if (this.uniform2fvCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform2fvCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform2fvCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform2fv(loc, value);\r\n        }\r\n      \r\n        setUniform2iv(name, value) {\r\n          if (this.uniform2ivCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform2ivCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform2ivCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform2iv(loc, value);\r\n        }\r\n      \r\n        setUniform3fv(name, value) {\r\n          if (this.uniform3fvCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform3fvCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1] &&\r\n              value[2] === cache[2]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform3fvCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform3fv(loc, value);\r\n        }\r\n      \r\n        setUniform3iv(name, value) {\r\n          if (this.uniform3ivCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform3ivCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1] &&\r\n              value[2] === cache[2]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform3ivCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform3iv(loc, value);\r\n        }\r\n      \r\n        setUniform4fv(name, value) {\r\n          if (this.uniform4fvCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform4fvCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1] &&\r\n              value[2] === cache[2] &&\r\n              value[3] === cache[3]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform4fvCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform4fv(loc, value);\r\n        }\r\n      \r\n        setUniform4iv(name, value) {\r\n          if (this.uniform4ivCache.hasOwnProperty(name)) {\r\n            const cache = this.uniform4ivCache[name];\r\n            if (\r\n              value[0] === cache[0] &&\r\n              value[1] === cache[1] &&\r\n              value[2] === cache[2] &&\r\n              value[3] === cache[3]\r\n            ) {\r\n              return;\r\n            }\r\n          }\r\n          this.uniform4ivCache[name] = value;\r\n          const loc = this.getUniformLocation(name);\r\n          this.context.uniform4iv(loc, value);\r\n        }\r\n      \r\n        getUniformLocation(name) {\r\n          if (this.programUniformLocationCache.hasOwnProperty(name)) {\r\n            return this.programUniformLocationCache[name];\r\n          }\r\n          return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);\r\n        }\r\n      \r\n        _getFragShaderArtifactMap(args) {\r\n          return {\r\n            HEADER: this._getHeaderString(),\r\n            LOOP_MAX: this._getLoopMaxString(),\r\n            PLUGINS: this._getPluginsString(),\r\n            CONSTANTS: this._getConstantsString(),\r\n            DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),\r\n            ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),\r\n            DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),\r\n            INJECTED_NATIVE: this._getInjectedNative(),\r\n            MAIN_CONSTANTS: this._getMainConstantsString(),\r\n            MAIN_ARGUMENTS: this._getMainArgumentsString(args),\r\n            KERNEL: this.getKernelString(),\r\n            MAIN_RESULT: this.getMainResultString(),\r\n            FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),\r\n            INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),\r\n            SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),\r\n            SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),\r\n          };\r\n        }\r\n      \r\n        _getVertShaderArtifactMap(args) {\r\n          return {\r\n            FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),\r\n            INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),\r\n            SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),\r\n            SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),\r\n          };\r\n        }\r\n      \r\n        _getHeaderString() {\r\n          return (\r\n            this.subKernels !== null ?\r\n            '#extension GL_EXT_draw_buffers : require\\n' :\r\n            ''\r\n          );\r\n        }\r\n      \r\n        _getLoopMaxString() {\r\n          return (\r\n            this.loopMaxIterations ?\r\n            ` ${parseInt(this.loopMaxIterations)};\\n` :\r\n            ' 1000;\\n'\r\n          );\r\n        }\r\n      \r\n        _getPluginsString() {\r\n          if (!this.plugins) return '\\n';\r\n          return this.plugins.map(plugin => plugin.source && this.source.match(plugin.functionMatch) ? plugin.source : '').join('\\n');\r\n        }\r\n      \r\n        _getConstantsString() {\r\n          const result = [];\r\n          const { threadDim, texSize } = this;\r\n          if (this.dynamicOutput) {\r\n            result.push(\r\n              'uniform ivec3 uOutputDim',\r\n              'uniform ivec2 uTexSize'\r\n            );\r\n          } else {\r\n            result.push(\r\n              `ivec3 uOutputDim = ivec3(${threadDim[0]}, ${threadDim[1]}, ${threadDim[2]})`,\r\n              `ivec2 uTexSize = ivec2(${texSize[0]}, ${texSize[1]})`\r\n            );\r\n          }\r\n          return utils.linesToString(result);\r\n        }\r\n      \r\n        _getTextureCoordinate() {\r\n          const subKernels = this.subKernels;\r\n          if (subKernels === null || subKernels.length < 1) {\r\n            return 'varying vec2 vTexCoord;\\n';\r\n          } else {\r\n            return 'out vec2 vTexCoord;\\n';\r\n          }\r\n        }\r\n      \r\n        _getDecode32EndiannessString() {\r\n          return (\r\n            this.endianness === 'LE' ?\r\n            '' :\r\n            '  texel.rgba = texel.abgr;\\n'\r\n          );\r\n        }\r\n      \r\n        _getEncode32EndiannessString() {\r\n          return (\r\n            this.endianness === 'LE' ?\r\n            '' :\r\n            '  texel.rgba = texel.abgr;\\n'\r\n          );\r\n        }\r\n      \r\n        _getDivideWithIntegerCheckString() {\r\n          return this.fixIntegerDivisionAccuracy ?\r\n            `float divWithIntCheck(float x, float y) {\r\n        if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {\r\n          return float(int(x) / int(y));\r\n        }\r\n        return x / y;\r\n      }\r\n      \r\n      float integerCorrectionModulo(float number, float divisor) {\r\n        if (number < 0.0) {\r\n          number = abs(number);\r\n          if (divisor < 0.0) {\r\n            divisor = abs(divisor);\r\n          }\r\n          return -(number - (divisor * floor(divWithIntCheck(number, divisor))));\r\n        }\r\n        if (divisor < 0.0) {\r\n          divisor = abs(divisor);\r\n        }\r\n        return number - (divisor * floor(divWithIntCheck(number, divisor)));\r\n      }` :\r\n            '';\r\n        }\r\n      \r\n        _getMainArgumentsString(args) {\r\n          const results = [];\r\n          const { argumentNames } = this;\r\n          for (let i = 0; i < argumentNames.length; i++) {\r\n            results.push(this.kernelArguments[i].getSource(args[i]));\r\n          }\r\n          return results.join('');\r\n        }\r\n      \r\n        _getInjectedNative() {\r\n          return this.injectedNative || '';\r\n        }\r\n      \r\n        _getMainConstantsString() {\r\n          const result = [];\r\n          const { constants } = this;\r\n          if (constants) {\r\n            let i = 0;\r\n            for (const name in constants) {\r\n              if (!this.constants.hasOwnProperty(name)) continue;\r\n              result.push(this.kernelConstants[i++].getSource(this.constants[name]));\r\n            }\r\n          }\r\n          return result.join('');\r\n        }\r\n      \r\n        getRawValueFramebuffer(width, height) {\r\n          if (!this.rawValueFramebuffers[width]) {\r\n            this.rawValueFramebuffers[width] = {};\r\n          }\r\n          if (!this.rawValueFramebuffers[width][height]) {\r\n            const framebuffer = this.context.createFramebuffer();\r\n            framebuffer.width = width;\r\n            framebuffer.height = height;\r\n            this.rawValueFramebuffers[width][height] = framebuffer;\r\n          }\r\n          return this.rawValueFramebuffers[width][height];\r\n        }\r\n      \r\n        getKernelResultDeclaration() {\r\n          switch (this.returnType) {\r\n            case 'Array(2)':\r\n              return 'vec2 kernelResult';\r\n            case 'Array(3)':\r\n              return 'vec3 kernelResult';\r\n            case 'Array(4)':\r\n              return 'vec4 kernelResult';\r\n            case 'LiteralInteger':\r\n            case 'Float':\r\n            case 'Number':\r\n            case 'Integer':\r\n              return 'float kernelResult';\r\n            default:\r\n              if (this.graphical) {\r\n                return 'float kernelResult';\r\n              } else {\r\n                throw new Error(`unrecognized output type \"${ this.returnType }\"`);\r\n              }\r\n          }\r\n        }\r\n        getKernelString() {\r\n          const result = [this.getKernelResultDeclaration()];\r\n          const { subKernels } = this;\r\n          if (subKernels !== null) {\r\n            switch (this.returnType) {\r\n              case 'Number':\r\n              case 'Float':\r\n              case 'Integer':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  const subKernel = subKernels[i];\r\n                  result.push(\r\n                    subKernel.returnType === 'Integer' ?\r\n                    `int subKernelResult_${ subKernel.name } = 0` :\r\n                    `float subKernelResult_${ subKernel.name } = 0.0`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(2)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec2 subKernelResult_${ subKernels[i].name }`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(3)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec3 subKernelResult_${ subKernels[i].name }`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(4)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec4 subKernelResult_${ subKernels[i].name }`\r\n                  );\r\n                }\r\n                break;\r\n            }\r\n          }\r\n      \r\n          return utils.linesToString(result) + this.translatedSource;\r\n        }\r\n      \r\n        getMainResultGraphical() {\r\n          return utils.linesToString([\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  gl_FragColor = actualColor',\r\n          ]);\r\n        }\r\n      \r\n        getMainResultPackedPixels() {\r\n          switch (this.returnType) {\r\n            case 'LiteralInteger':\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n              return this.getMainResultKernelPackedPixels() +\r\n                this.getMainResultSubKernelPackedPixels();\r\n            default:\r\n              throw new Error(`packed output only usable with Numbers, \"${this.returnType}\" specified`);\r\n          }\r\n        }\r\n      \r\n        getMainResultKernelPackedPixels() {\r\n          return utils.linesToString([\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            `  gl_FragData[0] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`\r\n          ]);\r\n        }\r\n      \r\n        getMainResultSubKernelPackedPixels() {\r\n          const result = [];\r\n          if (!this.subKernels) return '';\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`\r\n              );\r\n            }\r\n          }\r\n          return utils.linesToString(result);\r\n        }\r\n      \r\n        getMainResultMemoryOptimizedFloats() {\r\n          const result = [\r\n            '  index *= 4',\r\n          ];\r\n      \r\n          switch (this.returnType) {\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n              const channels = ['r', 'g', 'b', 'a'];\r\n              for (let i = 0; i < channels.length; i++) {\r\n                const channel = channels[i];\r\n                this.getMainResultKernelMemoryOptimizedFloats(result, channel);\r\n                this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);\r\n                if (i + 1 < channels.length) {\r\n                  result.push('  index += 1');\r\n                }\r\n              }\r\n              break;\r\n            default:\r\n              throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);\r\n          }\r\n      \r\n          return utils.linesToString(result);\r\n        }\r\n      \r\n        getMainResultKernelMemoryOptimizedFloats(result, channel) {\r\n          result.push(\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            `  gl_FragData[0].${channel} = kernelResult`\r\n          );\r\n        }\r\n      \r\n        getMainResultSubKernelMemoryOptimizedFloats(result, channel) {\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}].${channel} = float(subKernelResult_${this.subKernels[i].name})`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}].${channel} = subKernelResult_${this.subKernels[i].name}`\r\n              );\r\n            }\r\n          }\r\n        }\r\n      \r\n        getMainResultKernelNumberTexture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  gl_FragData[0][0] = kernelResult',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelNumberTexture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}][0] = float(subKernelResult_${subKernel.name})`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  gl_FragData[${i + 1}][0] = subKernelResult_${subKernel.name}`\r\n              );\r\n            }\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray2Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  gl_FragData[0][0] = kernelResult[0]',\r\n            '  gl_FragData[0][1] = kernelResult[1]',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray2Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            result.push(\r\n              `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\r\n              `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`\r\n            );\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray3Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  gl_FragData[0][0] = kernelResult[0]',\r\n            '  gl_FragData[0][1] = kernelResult[1]',\r\n            '  gl_FragData[0][2] = kernelResult[2]',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray3Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            result.push(\r\n              `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\r\n              `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,\r\n              `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`\r\n            );\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray4Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  gl_FragData[0] = kernelResult',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray4Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          switch (this.returnType) {\r\n            case 'Number':\r\n            case 'Float':\r\n            case 'Integer':\r\n              for (let i = 0; i < this.subKernels.length; ++i) {\r\n                const subKernel = this.subKernels[i];\r\n                if (subKernel.returnType === 'Integer') {\r\n                  result.push(\r\n                    `  gl_FragData[${i + 1}] = float(subKernelResult_${this.subKernels[i].name})`\r\n                  );\r\n                } else {\r\n                  result.push(\r\n                    `  gl_FragData[${i + 1}] = subKernelResult_${this.subKernels[i].name}`\r\n                  );\r\n                }\r\n              }\r\n              break;\r\n            case 'Array(2)':\r\n              for (let i = 0; i < this.subKernels.length; ++i) {\r\n                result.push(\r\n                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\r\n                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`\r\n                );\r\n              }\r\n              break;\r\n            case 'Array(3)':\r\n              for (let i = 0; i < this.subKernels.length; ++i) {\r\n                result.push(\r\n                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\r\n                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,\r\n                  `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`\r\n                );\r\n              }\r\n              break;\r\n            case 'Array(4)':\r\n              for (let i = 0; i < this.subKernels.length; ++i) {\r\n                result.push(\r\n                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\r\n                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,\r\n                  `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,\r\n                  `  gl_FragData[${i + 1}][3] = subKernelResult_${this.subKernels[i].name}[3]`\r\n                );\r\n              }\r\n              break;\r\n          }\r\n      \r\n          return result;\r\n        }\r\n      \r\n        replaceArtifacts(src, map) {\r\n          return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\\n/g, (match, artifact) => {\r\n            if (map.hasOwnProperty(artifact)) {\r\n              return map[artifact];\r\n            }\r\n            throw `unhandled artifact ${artifact}`;\r\n          });\r\n        }\r\n      \r\n        getFragmentShader(args) {\r\n          if (this.compiledFragmentShader !== null) {\r\n            return this.compiledFragmentShader;\r\n          }\r\n          return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));\r\n        }\r\n      \r\n        getVertexShader(args) {\r\n          if (this.compiledVertexShader !== null) {\r\n            return this.compiledVertexShader;\r\n          }\r\n          return this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(args));\r\n        }\r\n      \r\n        toString() {\r\n          const setupContextString = utils.linesToString([\r\n            `const gl = context`,\r\n          ]);\r\n          return glKernelString(this.constructor, arguments, this, setupContextString);\r\n        }\r\n      \r\n        destroy(removeCanvasReferences) {\r\n          if (!this.context) return;\r\n          if (this.buffer) {\r\n            this.context.deleteBuffer(this.buffer);\r\n          }\r\n          if (this.framebuffer) {\r\n            this.context.deleteFramebuffer(this.framebuffer);\r\n          }\r\n          for (const width in this.rawValueFramebuffers) {\r\n            for (const height in this.rawValueFramebuffers[width]) {\r\n              this.context.deleteFramebuffer(this.rawValueFramebuffers[width][height]);\r\n              delete this.rawValueFramebuffers[width][height];\r\n            }\r\n            delete this.rawValueFramebuffers[width];\r\n          }\r\n          if (this.vertShader) {\r\n            this.context.deleteShader(this.vertShader);\r\n          }\r\n          if (this.fragShader) {\r\n            this.context.deleteShader(this.fragShader);\r\n          }\r\n          if (this.program) {\r\n            this.context.deleteProgram(this.program);\r\n          }\r\n          if (this.texture) {\r\n            this.texture.delete();\r\n            const textureCacheIndex = this.textureCache.indexOf(this.texture.texture);\r\n            if (textureCacheIndex > -1) {\r\n              this.textureCache.splice(textureCacheIndex, 1);\r\n            }\r\n            this.texture = null;\r\n          }\r\n          if (this.mappedTextures && this.mappedTextures.length) {\r\n            for (let i = 0; i < this.mappedTextures.length; i++) {\r\n              const mappedTexture = this.mappedTextures[i];\r\n              mappedTexture.delete();\r\n              const textureCacheIndex = this.textureCache.indexOf(mappedTexture.texture);\r\n              if (textureCacheIndex > -1) {\r\n                this.textureCache.splice(textureCacheIndex, 1);\r\n              }\r\n            }\r\n            this.mappedTextures = null;\r\n          }\r\n          if (this.kernelArguments) {\r\n            for (let i = 0; i < this.kernelArguments.length; i++) {\r\n              this.kernelArguments[i].destroy();\r\n            }\r\n          }\r\n          if (this.kernelConstants) {\r\n            for (let i = 0; i < this.kernelConstants.length; i++) {\r\n              this.kernelConstants[i].destroy();\r\n            }\r\n          }\r\n          while (this.textureCache.length > 0) {\r\n            const texture = this.textureCache.pop();\r\n            this.context.deleteTexture(texture);\r\n          }\r\n          if (removeCanvasReferences) {\r\n            const idx = canvases.indexOf(this.canvas);\r\n            if (idx >= 0) {\r\n              canvases[idx] = null;\r\n              maxTexSizes[idx] = null;\r\n            }\r\n          }\r\n          this.destroyExtensions();\r\n          delete this.context;\r\n          delete this.canvas;\r\n          if (!this.gpu) return;\r\n          const i = this.gpu.kernels.indexOf(this);\r\n          if (i === -1) return;\r\n          this.gpu.kernels.splice(i, 1);\r\n        }\r\n      \r\n        destroyExtensions() {\r\n          this.extensions.OES_texture_float = null;\r\n          this.extensions.OES_texture_float_linear = null;\r\n          this.extensions.OES_element_index_uint = null;\r\n          this.extensions.WEBGL_draw_buffers = null;\r\n        }\r\n      \r\n        static destroyContext(context) {\r\n          const extension = context.getExtension('WEBGL_lose_context');\r\n          if (extension) {\r\n            extension.loseContext();\r\n          }\r\n        }\r\n      \r\n        toJSON() {\r\n          const json = super.toJSON();\r\n          json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();\r\n          json.settings.threadDim = this.threadDim;\r\n          return json;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGLKernel\r\n      };\r\n      },{\"../../plugins/math-random-uniformly-distributed\":112,\"../../utils\":114,\"../function-builder\":9,\"../gl/kernel\":13,\"../gl/kernel-string\":12,\"./fragment-shader\":37,\"./function-node\":38,\"./kernel-value-maps\":39,\"./vertex-shader\":71}],71:[function(require,module,exports){\r\n      const vertexShader = `__FLOAT_TACTIC_DECLARATION__;\r\n      __INT_TACTIC_DECLARATION__;\r\n      __SAMPLER_2D_TACTIC_DECLARATION__;\r\n      \r\n      attribute vec2 aPos;\r\n      attribute vec2 aTexCoord;\r\n      \r\n      varying vec2 vTexCoord;\r\n      uniform vec2 ratio;\r\n      \r\n      void main(void) {\r\n        gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\r\n        vTexCoord = aTexCoord;\r\n      }`;\r\n      \r\n      module.exports = {\r\n        vertexShader\r\n      };\r\n      },{}],72:[function(require,module,exports){\r\n      const fragmentShader = `#version 300 es\r\n      __HEADER__;\r\n      __FLOAT_TACTIC_DECLARATION__;\r\n      __INT_TACTIC_DECLARATION__;\r\n      __SAMPLER_2D_TACTIC_DECLARATION__;\r\n      __SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;\r\n      \r\n      const int LOOP_MAX = __LOOP_MAX__;\r\n      \r\n      __PLUGINS__;\r\n      __CONSTANTS__;\r\n      \r\n      in vec2 vTexCoord;\r\n      \r\n      float atan2(float v1, float v2) {\r\n        if (v1 == 0.0 || v2 == 0.0) return 0.0;\r\n        return atan(v1 / v2);\r\n      }\r\n      \r\n      float cbrt(float x) {\r\n        if (x >= 0.0) {\r\n          return pow(x, 1.0 / 3.0);\r\n        } else {\r\n          return -pow(x, 1.0 / 3.0);\r\n        }\r\n      }\r\n      \r\n      float expm1(float x) {\r\n        return pow(${Math.E}, x) - 1.0; \r\n      }\r\n      \r\n      float fround(highp float x) {\r\n        return x;\r\n      }\r\n      \r\n      float imul(float v1, float v2) {\r\n        return float(int(v1) * int(v2));\r\n      }\r\n      \r\n      float log10(float x) {\r\n        return log2(x) * (1.0 / log2(10.0));\r\n      }\r\n      \r\n      float log1p(float x) {\r\n        return log(1.0 + x);\r\n      }\r\n      \r\n      float _pow(float v1, float v2) {\r\n        if (v2 == 0.0) return 1.0;\r\n        return pow(v1, v2);\r\n      }\r\n      \r\n      float _round(float x) {\r\n        return floor(x + 0.5);\r\n      }\r\n      \r\n      \r\n      const int BIT_COUNT = 32;\r\n      int modi(int x, int y) {\r\n        return x - y * (x / y);\r\n      }\r\n      \r\n      int bitwiseOr(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 || b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseXOR(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 || b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseAnd(int a, int b) {\r\n        int result = 0;\r\n        int n = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\r\n            result += n;\r\n          }\r\n          a = a / 2;\r\n          b = b / 2;\r\n          n = n * 2;\r\n          if(!(a > 0 && b > 0)) {\r\n            break;\r\n          }\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseNot(int a) {\r\n        int result = 0;\r\n        int n = 1;\r\n        \r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (modi(a, 2) == 0) {\r\n            result += n;    \r\n          }\r\n          a = a / 2;\r\n          n = n * 2;\r\n        }\r\n        return result;\r\n      }\r\n      int bitwiseZeroFillLeftShift(int n, int shift) {\r\n        int maxBytes = BIT_COUNT;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (maxBytes >= n) {\r\n            break;\r\n          }\r\n          maxBytes *= 2;\r\n        }\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= shift) {\r\n            break;\r\n          }\r\n          n *= 2;\r\n        }\r\n      \r\n        int result = 0;\r\n        int byteVal = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= maxBytes) break;\r\n          if (modi(n, 2) > 0) { result += byteVal; }\r\n          n = int(n / 2);\r\n          byteVal *= 2;\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      int bitwiseSignedRightShift(int num, int shifts) {\r\n        return int(floor(float(num) / pow(2.0, float(shifts))));\r\n      }\r\n      \r\n      int bitwiseZeroFillRightShift(int n, int shift) {\r\n        int maxBytes = BIT_COUNT;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (maxBytes >= n) {\r\n            break;\r\n          }\r\n          maxBytes *= 2;\r\n        }\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= shift) {\r\n            break;\r\n          }\r\n          n /= 2;\r\n        }\r\n        int result = 0;\r\n        int byteVal = 1;\r\n        for (int i = 0; i < BIT_COUNT; i++) {\r\n          if (i >= maxBytes) break;\r\n          if (modi(n, 2) > 0) { result += byteVal; }\r\n          n = int(n / 2);\r\n          byteVal *= 2;\r\n        }\r\n        return result;\r\n      }\r\n      \r\n      vec2 integerMod(vec2 x, float y) {\r\n        vec2 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      vec3 integerMod(vec3 x, float y) {\r\n        vec3 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      vec4 integerMod(vec4 x, vec4 y) {\r\n        vec4 res = floor(mod(x, y));\r\n        return res * step(1.0 - floor(y), -res);\r\n      }\r\n      \r\n      float integerMod(float x, float y) {\r\n        float res = floor(mod(x, y));\r\n        return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\r\n      }\r\n      \r\n      int integerMod(int x, int y) {\r\n        return x - (y * int(x/y));\r\n      }\r\n      \r\n      __DIVIDE_WITH_INTEGER_CHECK__;\r\n      \r\n      // Here be dragons!\r\n      // DO NOT OPTIMIZE THIS CODE\r\n      // YOU WILL BREAK SOMETHING ON SOMEBODY\\'S MACHINE\r\n      // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\r\n      const vec2 MAGIC_VEC = vec2(1.0, -256.0);\r\n      const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\r\n      const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\r\n      float decode32(vec4 texel) {\r\n        __DECODE32_ENDIANNESS__;\r\n        texel *= 255.0;\r\n        vec2 gte128;\r\n        gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;\r\n        gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\r\n        float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\r\n        float res = exp2(round(exponent));\r\n        texel.b = texel.b - 128.0 * gte128.x;\r\n        res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;\r\n        res *= gte128.y * -2.0 + 1.0;\r\n        return res;\r\n      }\r\n      \r\n      float decode16(vec4 texel, int index) {\r\n        int channel = integerMod(index, 2);\r\n        return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;\r\n      }\r\n      \r\n      float decode8(vec4 texel, int index) {\r\n        int channel = integerMod(index, 4);\r\n        return texel[channel] * 255.0;\r\n      }\r\n      \r\n      vec4 legacyEncode32(float f) {\r\n        float F = abs(f);\r\n        float sign = f < 0.0 ? 1.0 : 0.0;\r\n        float exponent = floor(log2(F));\r\n        float mantissa = (exp2(-exponent) * F);\r\n        // exponent += floor(log2(mantissa));\r\n        vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\r\n        texel.rg = integerMod(texel.rg, 256.0);\r\n        texel.b = integerMod(texel.b, 128.0);\r\n        texel.a = exponent*0.5 + 63.5;\r\n        texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\r\n        texel = floor(texel);\r\n        texel *= 0.003921569; // 1/255\r\n        __ENCODE32_ENDIANNESS__;\r\n        return texel;\r\n      }\r\n      \r\n      // https://github.com/gpujs/gpu.js/wiki/Encoder-details\r\n      vec4 encode32(float value) {\r\n        if (value == 0.0) return vec4(0, 0, 0, 0);\r\n      \r\n        float exponent;\r\n        float mantissa;\r\n        vec4  result;\r\n        float sgn;\r\n      \r\n        sgn = step(0.0, -value);\r\n        value = abs(value);\r\n      \r\n        exponent = floor(log2(value));\r\n      \r\n        mantissa = value*pow(2.0, -exponent)-1.0;\r\n        exponent = exponent+127.0;\r\n        result   = vec4(0,0,0,0);\r\n      \r\n        result.a = floor(exponent/2.0);\r\n        exponent = exponent - result.a*2.0;\r\n        result.a = result.a + 128.0*sgn;\r\n      \r\n        result.b = floor(mantissa * 128.0);\r\n        mantissa = mantissa - result.b / 128.0;\r\n        result.b = result.b + exponent*128.0;\r\n      \r\n        result.g = floor(mantissa*32768.0);\r\n        mantissa = mantissa - result.g/32768.0;\r\n      \r\n        result.r = floor(mantissa*8388608.0);\r\n        return result/255.0;\r\n      }\r\n      // Dragons end here\r\n      \r\n      int index;\r\n      ivec3 threadId;\r\n      \r\n      ivec3 indexTo3D(int idx, ivec3 texDim) {\r\n        int z = int(idx / (texDim.x * texDim.y));\r\n        idx -= z * int(texDim.x * texDim.y);\r\n        int y = int(idx / texDim.x);\r\n        int x = int(integerMod(idx, texDim.x));\r\n        return ivec3(x, y, z);\r\n      }\r\n      \r\n      float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture(tex, st / vec2(texSize));\r\n        return decode32(texel);\r\n      }\r\n      \r\n      float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + (texDim.x * (y + (texDim.y * z)));\r\n        int w = texSize.x * 2;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));\r\n        return decode16(texel, index);\r\n      }\r\n      \r\n      float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + (texDim.x * (y + (texDim.y * z)));\r\n        int w = texSize.x * 4;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));\r\n        return decode8(texel, index);\r\n      }\r\n      \r\n      float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + (texDim.x * (y + (texDim.y * z)));\r\n        int channel = integerMod(index, 4);\r\n        index = index / 4;\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        index = index / 4;\r\n        vec4 texel = texture(tex, st / vec2(texSize));\r\n        return texel[channel];\r\n      }\r\n      \r\n      vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        return texture(tex, st / vec2(texSize));\r\n      }\r\n      \r\n      vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        return texture(tex, vec3(st / vec2(texSize), z));\r\n      }\r\n      \r\n      float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return result[0];\r\n      }\r\n      \r\n      vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return vec2(result[0], result[1]);\r\n      }\r\n      \r\n      vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int channel = integerMod(index, 2);\r\n        index = index / 2;\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture(tex, st / vec2(texSize));\r\n        if (channel == 0) return vec2(texel.r, texel.g);\r\n        if (channel == 1) return vec2(texel.b, texel.a);\r\n        return vec2(0.0, 0.0);\r\n      }\r\n      \r\n      vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\r\n        return vec3(result[0], result[1], result[2]);\r\n      }\r\n      \r\n      vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));\r\n        int vectorIndex = fieldIndex / 4;\r\n        int vectorOffset = fieldIndex - vectorIndex * 4;\r\n        int readY = vectorIndex / texSize.x;\r\n        int readX = vectorIndex - readY * texSize.x;\r\n        vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));\r\n      \r\n        if (vectorOffset == 0) {\r\n          return tex1.xyz;\r\n        } else if (vectorOffset == 1) {\r\n          return tex1.yzw;\r\n        } else {\r\n          readX++;\r\n          if (readX >= texSize.x) {\r\n            readX = 0;\r\n            readY++;\r\n          }\r\n          vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));\r\n          if (vectorOffset == 2) {\r\n            return vec3(tex1.z, tex1.w, tex2.x);\r\n          } else {\r\n            return vec3(tex1.w, tex2.x, tex2.y);\r\n          }\r\n        }\r\n      }\r\n      \r\n      vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        return getImage2D(tex, texSize, texDim, z, y, x);\r\n      }\r\n      \r\n      vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\r\n        int index = x + texDim.x * (y + texDim.y * z);\r\n        int channel = integerMod(index, 2);\r\n        int w = texSize.x;\r\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\r\n        vec4 texel = texture(tex, st / vec2(texSize));\r\n        return vec4(texel.r, texel.g, texel.b, texel.a);\r\n      }\r\n      \r\n      vec4 actualColor;\r\n      void color(float r, float g, float b, float a) {\r\n        actualColor = vec4(r,g,b,a);\r\n      }\r\n      \r\n      void color(float r, float g, float b) {\r\n        color(r,g,b,1.0);\r\n      }\r\n      \r\n      float modulo(float number, float divisor) {\r\n        if (number < 0.0) {\r\n          number = abs(number);\r\n          if (divisor < 0.0) {\r\n            divisor = abs(divisor);\r\n          }\r\n          return -mod(number, divisor);\r\n        }\r\n        if (divisor < 0.0) {\r\n          divisor = abs(divisor);\r\n        }\r\n        return mod(number, divisor);\r\n      }\r\n      \r\n      __INJECTED_NATIVE__;\r\n      __MAIN_CONSTANTS__;\r\n      __MAIN_ARGUMENTS__;\r\n      __KERNEL__;\r\n      \r\n      void main(void) {\r\n        index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\r\n        __MAIN_RESULT__;\r\n      }`;\r\n      \r\n      module.exports = {\r\n        fragmentShader\r\n      };\r\n      },{}],73:[function(require,module,exports){\r\n      const { utils } = require('../../utils');\r\n      const { WebGLFunctionNode } = require('../web-gl/function-node');\r\n      \r\n      class WebGL2FunctionNode extends WebGLFunctionNode {\r\n      \r\n        astIdentifierExpression(idtNode, retArr) {\r\n          if (idtNode.type !== 'Identifier') {\r\n            throw this.astErrorOutput(\r\n              'IdentifierExpression - not an Identifier',\r\n              idtNode\r\n            );\r\n          }\r\n      \r\n          const type = this.getType(idtNode);\r\n      \r\n          const name = utils.sanitizeName(idtNode.name);\r\n          if (idtNode.name === 'Infinity') {\r\n            retArr.push('intBitsToFloat(2139095039)');\r\n          } else if (type === 'Boolean') {\r\n            if (this.argumentNames.indexOf(name) > -1) {\r\n              retArr.push(`bool(user_${name})`);\r\n            } else {\r\n              retArr.push(`user_${name}`);\r\n            }\r\n          } else {\r\n            retArr.push(`user_${name}`);\r\n          }\r\n      \r\n          return retArr;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2FunctionNode\r\n      };\r\n      },{\"../../utils\":114,\"../web-gl/function-node\":38}],74:[function(require,module,exports){\r\n      const { WebGL2KernelValueBoolean } = require('./kernel-value/boolean');\r\n      const { WebGL2KernelValueFloat } = require('./kernel-value/float');\r\n      const { WebGL2KernelValueInteger } = require('./kernel-value/integer');\r\n      \r\n      const { WebGL2KernelValueHTMLImage } = require('./kernel-value/html-image');\r\n      const { WebGL2KernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');\r\n      \r\n      const { WebGL2KernelValueHTMLImageArray } = require('./kernel-value/html-image-array');\r\n      const { WebGL2KernelValueDynamicHTMLImageArray } = require('./kernel-value/dynamic-html-image-array');\r\n      \r\n      const { WebGL2KernelValueHTMLVideo } = require('./kernel-value/html-video');\r\n      const { WebGL2KernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');\r\n      \r\n      const { WebGL2KernelValueSingleInput } = require('./kernel-value/single-input');\r\n      const { WebGL2KernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');\r\n      \r\n      const { WebGL2KernelValueUnsignedInput } = require('./kernel-value/unsigned-input');\r\n      const { WebGL2KernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');\r\n      \r\n      const { WebGL2KernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');\r\n      const { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');\r\n      \r\n      const { WebGL2KernelValueNumberTexture } = require('./kernel-value/number-texture');\r\n      const { WebGL2KernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');\r\n      \r\n      const { WebGL2KernelValueSingleArray } = require('./kernel-value/single-array');\r\n      const { WebGL2KernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');\r\n      \r\n      const { WebGL2KernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');\r\n      const { WebGL2KernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');\r\n      \r\n      const { WebGL2KernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');\r\n      const { WebGL2KernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');\r\n      \r\n      const { WebGL2KernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');\r\n      const { WebGL2KernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');\r\n      \r\n      const { WebGL2KernelValueSingleArray2 } = require('./kernel-value/single-array2');\r\n      const { WebGL2KernelValueSingleArray3 } = require('./kernel-value/single-array3');\r\n      const { WebGL2KernelValueSingleArray4 } = require('./kernel-value/single-array4');\r\n      \r\n      const { WebGL2KernelValueUnsignedArray } = require('./kernel-value/unsigned-array');\r\n      const { WebGL2KernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');\r\n      \r\n      const kernelValueMaps = {\r\n        unsigned: {\r\n          dynamic: {\r\n            'Boolean': WebGL2KernelValueBoolean,\r\n            'Integer': WebGL2KernelValueInteger,\r\n            'Float': WebGL2KernelValueFloat,\r\n            'Array': WebGL2KernelValueDynamicUnsignedArray,\r\n            'Array(2)': false,\r\n            'Array(3)': false,\r\n            'Array(4)': false,\r\n            'Array1D(2)': false,\r\n            'Array1D(3)': false,\r\n            'Array1D(4)': false,\r\n            'Array2D(2)': false,\r\n            'Array2D(3)': false,\r\n            'Array2D(4)': false,\r\n            'Array3D(2)': false,\r\n            'Array3D(3)': false,\r\n            'Array3D(4)': false,\r\n            'Input': WebGL2KernelValueDynamicUnsignedInput,\r\n            'NumberTexture': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,\r\n            'HTMLImage': WebGL2KernelValueDynamicHTMLImage,\r\n            'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,\r\n            'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,\r\n          },\r\n          static: {\r\n            'Boolean': WebGL2KernelValueBoolean,\r\n            'Float': WebGL2KernelValueFloat,\r\n            'Integer': WebGL2KernelValueInteger,\r\n            'Array': WebGL2KernelValueUnsignedArray,\r\n            'Array(2)': false,\r\n            'Array(3)': false,\r\n            'Array(4)': false,\r\n            'Array1D(2)': false,\r\n            'Array1D(3)': false,\r\n            'Array1D(4)': false,\r\n            'Array2D(2)': false,\r\n            'Array2D(3)': false,\r\n            'Array2D(4)': false,\r\n            'Array3D(2)': false,\r\n            'Array3D(3)': false,\r\n            'Array3D(4)': false,\r\n            'Input': WebGL2KernelValueUnsignedInput,\r\n            'NumberTexture': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(1)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(2)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(3)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(4)': WebGL2KernelValueNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGL2KernelValueHTMLImage,\r\n            'HTMLImage': WebGL2KernelValueHTMLImage,\r\n            'HTMLImageArray': WebGL2KernelValueHTMLImageArray,\r\n            'HTMLVideo': WebGL2KernelValueHTMLVideo,\r\n          }\r\n        },\r\n        single: {\r\n          dynamic: {\r\n            'Boolean': WebGL2KernelValueBoolean,\r\n            'Integer': WebGL2KernelValueInteger,\r\n            'Float': WebGL2KernelValueFloat,\r\n            'Array': WebGL2KernelValueDynamicSingleArray,\r\n            'Array(2)': WebGL2KernelValueSingleArray2,\r\n            'Array(3)': WebGL2KernelValueSingleArray3,\r\n            'Array(4)': WebGL2KernelValueSingleArray4,\r\n            'Array1D(2)': WebGL2KernelValueDynamicSingleArray1DI,\r\n            'Array1D(3)': WebGL2KernelValueDynamicSingleArray1DI,\r\n            'Array1D(4)': WebGL2KernelValueDynamicSingleArray1DI,\r\n            'Array2D(2)': WebGL2KernelValueDynamicSingleArray2DI,\r\n            'Array2D(3)': WebGL2KernelValueDynamicSingleArray2DI,\r\n            'Array2D(4)': WebGL2KernelValueDynamicSingleArray2DI,\r\n            'Array3D(2)': WebGL2KernelValueDynamicSingleArray3DI,\r\n            'Array3D(3)': WebGL2KernelValueDynamicSingleArray3DI,\r\n            'Array3D(4)': WebGL2KernelValueDynamicSingleArray3DI,\r\n            'Input': WebGL2KernelValueDynamicSingleInput,\r\n            'NumberTexture': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,\r\n            'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,\r\n            'HTMLImage': WebGL2KernelValueDynamicHTMLImage,\r\n            'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,\r\n            'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,\r\n          },\r\n          static: {\r\n            'Boolean': WebGL2KernelValueBoolean,\r\n            'Float': WebGL2KernelValueFloat,\r\n            'Integer': WebGL2KernelValueInteger,\r\n            'Array': WebGL2KernelValueSingleArray,\r\n            'Array(2)': WebGL2KernelValueSingleArray2,\r\n            'Array(3)': WebGL2KernelValueSingleArray3,\r\n            'Array(4)': WebGL2KernelValueSingleArray4,\r\n            'Array1D(2)': WebGL2KernelValueSingleArray1DI,\r\n            'Array1D(3)': WebGL2KernelValueSingleArray1DI,\r\n            'Array1D(4)': WebGL2KernelValueSingleArray1DI,\r\n            'Array2D(2)': WebGL2KernelValueSingleArray2DI,\r\n            'Array2D(3)': WebGL2KernelValueSingleArray2DI,\r\n            'Array2D(4)': WebGL2KernelValueSingleArray2DI,\r\n            'Array3D(2)': WebGL2KernelValueSingleArray3DI,\r\n            'Array3D(3)': WebGL2KernelValueSingleArray3DI,\r\n            'Array3D(4)': WebGL2KernelValueSingleArray3DI,\r\n            'Input': WebGL2KernelValueSingleInput,\r\n            'NumberTexture': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(1)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(2)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(3)': WebGL2KernelValueNumberTexture,\r\n            'ArrayTexture(4)': WebGL2KernelValueNumberTexture,\r\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueMemoryOptimizedNumberTexture,\r\n            'HTMLCanvas': WebGL2KernelValueHTMLImage,\r\n            'HTMLImage': WebGL2KernelValueHTMLImage,\r\n            'HTMLImageArray': WebGL2KernelValueHTMLImageArray,\r\n            'HTMLVideo': WebGL2KernelValueHTMLVideo,\r\n          }\r\n        },\r\n      };\r\n      \r\n      function lookupKernelValueType(type, dynamic, precision, value) {\r\n        if (!type) {\r\n          throw new Error('type missing');\r\n        }\r\n        if (!dynamic) {\r\n          throw new Error('dynamic missing');\r\n        }\r\n        if (!precision) {\r\n          throw new Error('precision missing');\r\n        }\r\n        if (value.type) {\r\n          type = value.type;\r\n        }\r\n        const types = kernelValueMaps[precision][dynamic];\r\n        if (types[type] === false) {\r\n          return null;\r\n        } else if (types[type] === undefined) {\r\n          throw new Error(`Could not find a KernelValue for ${ type }`);\r\n        }\r\n        return types[type];\r\n      }\r\n      \r\n      module.exports = {\r\n        kernelValueMaps,\r\n        lookupKernelValueType\r\n      };\r\n      },{\"./kernel-value/boolean\":75,\"./kernel-value/dynamic-html-image\":77,\"./kernel-value/dynamic-html-image-array\":76,\"./kernel-value/dynamic-html-video\":78,\"./kernel-value/dynamic-memory-optimized-number-texture\":79,\"./kernel-value/dynamic-number-texture\":80,\"./kernel-value/dynamic-single-array\":81,\"./kernel-value/dynamic-single-array1d-i\":82,\"./kernel-value/dynamic-single-array2d-i\":83,\"./kernel-value/dynamic-single-array3d-i\":84,\"./kernel-value/dynamic-single-input\":85,\"./kernel-value/dynamic-unsigned-array\":86,\"./kernel-value/dynamic-unsigned-input\":87,\"./kernel-value/float\":88,\"./kernel-value/html-image\":90,\"./kernel-value/html-image-array\":89,\"./kernel-value/html-video\":91,\"./kernel-value/integer\":92,\"./kernel-value/memory-optimized-number-texture\":93,\"./kernel-value/number-texture\":94,\"./kernel-value/single-array\":95,\"./kernel-value/single-array1d-i\":96,\"./kernel-value/single-array2\":97,\"./kernel-value/single-array2d-i\":98,\"./kernel-value/single-array3\":99,\"./kernel-value/single-array3d-i\":100,\"./kernel-value/single-array4\":101,\"./kernel-value/single-input\":102,\"./kernel-value/unsigned-array\":103,\"./kernel-value/unsigned-input\":104}],75:[function(require,module,exports){\r\n      const { WebGLKernelValueBoolean } = require('../../web-gl/kernel-value/boolean');\r\n      \r\n      class WebGL2KernelValueBoolean extends WebGLKernelValueBoolean {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueBoolean\r\n      };\r\n      },{\"../../web-gl/kernel-value/boolean\":41}],76:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueHTMLImageArray } = require('./html-image-array');\r\n      \r\n      class WebGL2KernelValueDynamicHTMLImageArray extends WebGL2KernelValueHTMLImageArray {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2DArray ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(images) {\r\n          const { width, height } = images[0];\r\n          this.checkSize(width, height);\r\n          this.dimensions = [width, height, images.length];\r\n          this.textureSize = [width, height];\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(images);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicHTMLImageArray\r\n      };\r\n      },{\"../../../utils\":114,\"./html-image-array\":89}],77:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueDynamicHTMLImage } = require('../../web-gl/kernel-value/dynamic-html-image');\r\n      \r\n      class WebGL2KernelValueDynamicHTMLImage extends WebGLKernelValueDynamicHTMLImage {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicHTMLImage\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/dynamic-html-image\":42}],78:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueDynamicHTMLImage } = require('./dynamic-html-image');\r\n      \r\n      class WebGL2KernelValueDynamicHTMLVideo extends WebGL2KernelValueDynamicHTMLImage {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicHTMLVideo\r\n      };\r\n      },{\"../../../utils\":114,\"./dynamic-html-image\":77}],79:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/dynamic-memory-optimized-number-texture');\r\n      \r\n      class WebGL2KernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueDynamicMemoryOptimizedNumberTexture {\r\n        getSource() {\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${this.id}`,\r\n            `uniform ivec2 ${this.sizeId}`,\r\n            `uniform ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicMemoryOptimizedNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture\":44}],80:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueDynamicNumberTexture } = require('../../web-gl/kernel-value/dynamic-number-texture');\r\n      \r\n      class WebGL2KernelValueDynamicNumberTexture extends WebGLKernelValueDynamicNumberTexture {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/dynamic-number-texture\":45}],81:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueSingleArray } = require('../../web-gl2/kernel-value/single-array');\r\n      \r\n      class WebGL2KernelValueDynamicSingleArray extends WebGL2KernelValueSingleArray {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.dimensions = utils.getDimensions(value, true);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicSingleArray\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl2/kernel-value/single-array\":95}],82:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueSingleArray1DI } = require('../../web-gl2/kernel-value/single-array1d-i');\r\n      \r\n      class WebGL2KernelValueDynamicSingleArray1DI extends WebGL2KernelValueSingleArray1DI {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicSingleArray1DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl2/kernel-value/single-array1d-i\":96}],83:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueSingleArray2DI } = require('../../web-gl2/kernel-value/single-array2d-i');\r\n      \r\n      class WebGL2KernelValueDynamicSingleArray2DI extends WebGL2KernelValueSingleArray2DI {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicSingleArray2DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl2/kernel-value/single-array2d-i\":98}],84:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueSingleArray3DI } = require('../../web-gl2/kernel-value/single-array3d-i');\r\n      \r\n      class WebGL2KernelValueDynamicSingleArray3DI extends WebGL2KernelValueSingleArray3DI {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          this.setShape(value);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicSingleArray3DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl2/kernel-value/single-array3d-i\":100}],85:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueSingleInput } = require('../../web-gl2/kernel-value/single-input');\r\n      \r\n      class WebGL2KernelValueDynamicSingleInput extends WebGL2KernelValueSingleInput {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          let [w, h, d] = value.size;\r\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\r\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\r\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\r\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\r\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\r\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\r\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\r\n          super.updateValue(value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicSingleInput\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl2/kernel-value/single-input\":102}],86:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueDynamicUnsignedArray } = require('../../web-gl/kernel-value/dynamic-unsigned-array');\r\n      \r\n      class WebGL2KernelValueDynamicUnsignedArray extends WebGLKernelValueDynamicUnsignedArray {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicUnsignedArray\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/dynamic-unsigned-array\":51}],87:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueDynamicUnsignedInput } = require('../../web-gl/kernel-value/dynamic-unsigned-input');\r\n      \r\n      class WebGL2KernelValueDynamicUnsignedInput extends WebGLKernelValueDynamicUnsignedInput {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\r\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueDynamicUnsignedInput\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/dynamic-unsigned-input\":52}],88:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueFloat } = require('../../web-gl/kernel-value/float');\r\n      \r\n      class WebGL2KernelValueFloat extends WebGLKernelValueFloat {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueFloat\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/float\":53}],89:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelArray } = require('../../web-gl/kernel-value/array');\r\n      \r\n      class WebGL2KernelValueHTMLImageArray extends WebGLKernelArray {\r\n        constructor(value, settings) {\r\n          super(value, settings);\r\n          this.checkSize(value[0].width, value[0].height);\r\n          this.dimensions = [value[0].width, value[0].height, value.length];\r\n          this.textureSize = [value[0].width, value[0].height];\r\n        }\r\n        defineTexture() {\r\n          const { context: gl } = this;\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);\r\n          gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n          gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        }\r\n      \r\n        getStringValueHandler() {\r\n          return `const uploadValue_${this.name} = ${this.varName};\\n`;\r\n        }\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2DArray ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(images) {\r\n          const { context: gl } = this;\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\r\n          gl.texImage3D(\r\n            gl.TEXTURE_2D_ARRAY,\r\n            0,\r\n            gl.RGBA,\r\n            images[0].width,\r\n            images[0].height,\r\n            images.length,\r\n            0,\r\n            gl.RGBA,\r\n            gl.UNSIGNED_BYTE,\r\n            null\r\n          );\r\n          for (let i = 0; i < images.length; i++) {\r\n            const xOffset = 0;\r\n            const yOffset = 0;\r\n            const imageDepth = 1;\r\n            gl.texSubImage3D(\r\n              gl.TEXTURE_2D_ARRAY,\r\n              0,\r\n              xOffset,\r\n              yOffset,\r\n              i,\r\n              images[i].width,\r\n              images[i].height,\r\n              imageDepth,\r\n              gl.RGBA,\r\n              gl.UNSIGNED_BYTE,\r\n              this.uploadValue = images[i]\r\n            );\r\n          }\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueHTMLImageArray\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/array\":40}],90:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueHTMLImage } = require('../../web-gl/kernel-value/html-image');\r\n      \r\n      class WebGL2KernelValueHTMLImage extends WebGLKernelValueHTMLImage {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueHTMLImage\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/html-image\":54}],91:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGL2KernelValueHTMLImage } = require('./html-image');\r\n      \r\n      class WebGL2KernelValueHTMLVideo extends WebGL2KernelValueHTMLImage {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueHTMLVideo\r\n      };\r\n      },{\"../../../utils\":114,\"./html-image\":90}],92:[function(require,module,exports){\r\n      const { WebGLKernelValueInteger } = require('../../web-gl/kernel-value/integer');\r\n      \r\n      class WebGL2KernelValueInteger extends WebGLKernelValueInteger {\r\n        getSource(value) {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          if (this.origin === 'constants') {\r\n            return `const ${ variablePrecision } int ${this.id} = ${ parseInt(value) };\\n`;\r\n          }\r\n          return `uniform ${ variablePrecision } int ${this.id};\\n`;\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (this.origin === 'constants') return;\r\n          this.kernel.setUniform1i(this.id, this.uploadValue = value);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueInteger\r\n      };\r\n      },{\"../../web-gl/kernel-value/integer\":57}],93:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/memory-optimized-number-texture');\r\n      \r\n      class WebGL2KernelValueMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {\r\n        getSource() {\r\n          const { id, sizeId, textureSize, dimensionsId, dimensions } = this;\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform sampler2D ${id}`,\r\n            `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueMemoryOptimizedNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/memory-optimized-number-texture\":58}],94:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueNumberTexture } = require('../../web-gl/kernel-value/number-texture');\r\n      \r\n      class WebGL2KernelValueNumberTexture extends WebGLKernelValueNumberTexture {\r\n        getSource() {\r\n          const { id, sizeId, textureSize, dimensionsId, dimensions } = this;\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${id}`,\r\n            `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueNumberTexture\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/number-texture\":59}],95:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray } = require('../../web-gl/kernel-value/single-array');\r\n      \r\n      class WebGL2KernelValueSingleArray extends WebGLKernelValueSingleArray {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/single-array\":60}],96:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray1DI } = require('../../web-gl/kernel-value/single-array1d-i');\r\n      \r\n      class WebGL2KernelValueSingleArray1DI extends WebGLKernelValueSingleArray1DI {\r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray1DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/single-array1d-i\":61}],97:[function(require,module,exports){\r\n      const { WebGLKernelValueSingleArray2 } = require('../../web-gl/kernel-value/single-array2');\r\n      \r\n      class WebGL2KernelValueSingleArray2 extends WebGLKernelValueSingleArray2 {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray2\r\n      };\r\n      },{\"../../web-gl/kernel-value/single-array2\":62}],98:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray2DI } = require('../../web-gl/kernel-value/single-array2d-i');\r\n      \r\n      class WebGL2KernelValueSingleArray2DI extends WebGLKernelValueSingleArray2DI {\r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray2DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/single-array2d-i\":63}],99:[function(require,module,exports){\r\n      const { WebGLKernelValueSingleArray3 } = require('../../web-gl/kernel-value/single-array3');\r\n      \r\n      class WebGL2KernelValueSingleArray3 extends WebGLKernelValueSingleArray3 {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray3\r\n      };\r\n      },{\"../../web-gl/kernel-value/single-array3\":64}],100:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleArray3DI } = require('../../web-gl/kernel-value/single-array3d-i');\r\n      \r\n      class WebGL2KernelValueSingleArray3DI extends WebGLKernelValueSingleArray3DI {\r\n        updateValue(value) {\r\n          if (value.constructor !== this.initialValueConstructor) {\r\n            this.onUpdateValueMismatch(value.constructor);\r\n            return;\r\n          }\r\n          const { context: gl } = this;\r\n          utils.flattenTo(value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray3DI\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/single-array3d-i\":65}],101:[function(require,module,exports){\r\n      const { WebGLKernelValueSingleArray4 } = require('../../web-gl/kernel-value/single-array4');\r\n      \r\n      class WebGL2KernelValueSingleArray4 extends WebGLKernelValueSingleArray4 {}\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleArray4\r\n      };\r\n      },{\"../../web-gl/kernel-value/single-array4\":66}],102:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueSingleInput } = require('../../web-gl/kernel-value/single-input');\r\n      \r\n      class WebGL2KernelValueSingleInput extends WebGLKernelValueSingleInput {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      \r\n        updateValue(input) {\r\n          const { context: gl } = this;\r\n          utils.flattenTo(input.value, this.uploadValue);\r\n          gl.activeTexture(this.contextHandle);\r\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\r\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\r\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\r\n          this.kernel.setUniform1i(this.id, this.index);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueSingleInput\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/single-input\":67}],103:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueUnsignedArray } = require('../../web-gl/kernel-value/unsigned-array');\r\n      \r\n      class WebGL2KernelValueUnsignedArray extends WebGLKernelValueUnsignedArray {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueUnsignedArray\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/unsigned-array\":68}],104:[function(require,module,exports){\r\n      const { utils } = require('../../../utils');\r\n      const { WebGLKernelValueUnsignedInput } = require('../../web-gl/kernel-value/unsigned-input');\r\n      \r\n      class WebGL2KernelValueUnsignedInput extends WebGLKernelValueUnsignedInput {\r\n        getSource() {\r\n          const variablePrecision = this.getVariablePrecisionString();\r\n          return utils.linesToString([\r\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\r\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\r\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\r\n          ]);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2KernelValueUnsignedInput\r\n      };\r\n      },{\"../../../utils\":114,\"../../web-gl/kernel-value/unsigned-input\":69}],105:[function(require,module,exports){\r\n      const { WebGLKernel } = require('../web-gl/kernel');\r\n      const { WebGL2FunctionNode } = require('./function-node');\r\n      const { FunctionBuilder } = require('../function-builder');\r\n      const { utils } = require('../../utils');\r\n      const { fragmentShader } = require('./fragment-shader');\r\n      const { vertexShader } = require('./vertex-shader');\r\n      const { lookupKernelValueType } = require('./kernel-value-maps');\r\n      \r\n      let isSupported = null;\r\n      let testCanvas = null;\r\n      let testContext = null;\r\n      let testExtensions = null;\r\n      \r\n      let features = null;\r\n      \r\n      class WebGL2Kernel extends WebGLKernel {\r\n        static get isSupported() {\r\n          if (isSupported !== null) {\r\n            return isSupported;\r\n          }\r\n          this.setupFeatureChecks();\r\n          isSupported = this.isContextMatch(testContext);\r\n          return isSupported;\r\n        }\r\n      \r\n        static setupFeatureChecks() {\r\n          if (typeof document !== 'undefined') {\r\n            testCanvas = document.createElement('canvas');\r\n          } else if (typeof OffscreenCanvas !== 'undefined') {\r\n            testCanvas = new OffscreenCanvas(0, 0);\r\n          }\r\n          if (!testCanvas) return;\r\n          testContext = testCanvas.getContext('webgl2');\r\n          if (!testContext || !testContext.getExtension) return;\r\n          testExtensions = {\r\n            EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),\r\n            OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),\r\n          };\r\n          features = this.getFeatures();\r\n        }\r\n      \r\n        static isContextMatch(context) {\r\n          if (typeof WebGL2RenderingContext !== 'undefined') {\r\n            return context instanceof WebGL2RenderingContext;\r\n          }\r\n          return false;\r\n        }\r\n      \r\n        static getFeatures() {\r\n          const gl = this.testContext;\r\n          return Object.freeze({\r\n            isFloatRead: this.getIsFloatRead(),\r\n            isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),\r\n            isSpeedTacticSupported: this.getIsSpeedTacticSupported(),\r\n            kernelMap: true,\r\n            isTextureFloat: true,\r\n            isDrawBuffers: true,\r\n            channelCount: this.getChannelCount(),\r\n            maxTextureSize: this.getMaxTextureSize(),\r\n            lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),\r\n            lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),\r\n            mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),\r\n            mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),\r\n            highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),\r\n            highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),\r\n          });\r\n        }\r\n      \r\n        static getIsTextureFloat() {\r\n          return true;\r\n        }\r\n      \r\n        static getChannelCount() {\r\n          return testContext.getParameter(testContext.MAX_DRAW_BUFFERS);\r\n        }\r\n      \r\n        static getMaxTextureSize() {\r\n          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);\r\n        }\r\n      \r\n        static lookupKernelValueType(type, dynamic, precision, value) {\r\n          return lookupKernelValueType(type, dynamic, precision, value);\r\n        }\r\n      \r\n        static get testCanvas() {\r\n          return testCanvas;\r\n        }\r\n      \r\n        static get testContext() {\r\n          return testContext;\r\n        }\r\n      \r\n        static get features() {\r\n          return features;\r\n        }\r\n      \r\n        static get fragmentShader() {\r\n          return fragmentShader;\r\n        }\r\n        static get vertexShader() {\r\n          return vertexShader;\r\n        }\r\n      \r\n        initContext() {\r\n          const settings = {\r\n            alpha: false,\r\n            depth: false,\r\n            antialias: false\r\n          };\r\n          return this.canvas.getContext('webgl2', settings);\r\n        }\r\n      \r\n        initExtensions() {\r\n          this.extensions = {\r\n            EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),\r\n            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),\r\n          };\r\n        }\r\n      \r\n        validateSettings(args) {\r\n          if (!this.validate) {\r\n            this.texSize = utils.getKernelTextureSize({\r\n              optimizeFloatMemory: this.optimizeFloatMemory,\r\n              precision: this.precision,\r\n            }, this.output);\r\n            return;\r\n          }\r\n      \r\n          const { features } = this.constructor;\r\n          if (this.precision === 'single' && !features.isFloatRead) {\r\n            throw new Error('Float texture outputs are not supported');\r\n          } else if (!this.graphical && this.precision === null) {\r\n            this.precision = features.isFloatRead ? 'single' : 'unsigned';\r\n          }\r\n      \r\n          if (this.fixIntegerDivisionAccuracy === null) {\r\n            this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;\r\n          } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {\r\n            this.fixIntegerDivisionAccuracy = false;\r\n          }\r\n      \r\n          this.checkOutput();\r\n      \r\n          if (!this.output || this.output.length === 0) {\r\n            if (args.length !== 1) {\r\n              throw new Error('Auto output only supported for kernels with only one input');\r\n            }\r\n      \r\n            const argType = utils.getVariableType(args[0], this.strictIntegers);\r\n            switch (argType) {\r\n              case 'Array':\r\n                this.output = utils.getDimensions(argType);\r\n                break;\r\n              case 'NumberTexture':\r\n              case 'MemoryOptimizedNumberTexture':\r\n              case 'ArrayTexture(1)':\r\n              case 'ArrayTexture(2)':\r\n              case 'ArrayTexture(3)':\r\n              case 'ArrayTexture(4)':\r\n                this.output = args[0].output;\r\n                break;\r\n              default:\r\n                throw new Error('Auto output not supported for input type: ' + argType);\r\n            }\r\n          }\r\n      \r\n          if (this.graphical) {\r\n            if (this.output.length !== 2) {\r\n              throw new Error('Output must have 2 dimensions on graphical mode');\r\n            }\r\n      \r\n            if (this.precision === 'single') {\r\n              console.warn('Cannot use graphical mode and single precision at the same time');\r\n              this.precision = 'unsigned';\r\n            }\r\n      \r\n            this.texSize = utils.clone(this.output);\r\n            return;\r\n          } else if (!this.graphical && this.precision === null && features.isTextureFloat) {\r\n            this.precision = 'single';\r\n          }\r\n      \r\n          this.texSize = utils.getKernelTextureSize({\r\n            optimizeFloatMemory: this.optimizeFloatMemory,\r\n            precision: this.precision,\r\n          }, this.output);\r\n      \r\n          this.checkTextureSize();\r\n        }\r\n      \r\n        translateSource() {\r\n          const functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {\r\n            fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy\r\n          });\r\n          this.translatedSource = functionBuilder.getPrototypeString('kernel');\r\n          this.setupReturnTypes(functionBuilder);\r\n        }\r\n      \r\n        drawBuffers() {\r\n          this.context.drawBuffers(this.drawBuffersMap);\r\n        }\r\n      \r\n        getTextureFormat() {\r\n          const { context: gl } = this;\r\n          switch (this.getInternalFormat()) {\r\n            case gl.R32F:\r\n              return gl.RED;\r\n            case gl.RG32F:\r\n              return gl.RG;\r\n            case gl.RGBA32F:\r\n              return gl.RGBA;\r\n            case gl.RGBA:\r\n              return gl.RGBA;\r\n            default:\r\n              throw new Error('Unknown internal format');\r\n          }\r\n        }\r\n        getInternalFormat() {\r\n          const { context: gl } = this;\r\n      \r\n          if (this.precision === 'single') {\r\n            if (this.pipeline) {\r\n              switch (this.returnType) {\r\n                case 'Number':\r\n                case 'Float':\r\n                case 'Integer':\r\n                  if (this.optimizeFloatMemory) {\r\n                    return gl.RGBA32F;\r\n                  } else {\r\n                    return gl.R32F;\r\n                  }\r\n                  case 'Array(2)':\r\n                    return gl.RG32F;\r\n                  case 'Array(3)': \r\n                  case 'Array(4)':\r\n                    return gl.RGBA32F;\r\n                  default:\r\n                    throw new Error('Unhandled return type');\r\n              }\r\n            }\r\n            return gl.RGBA32F;\r\n          }\r\n          return gl.RGBA;\r\n        }\r\n      \r\n        _setupOutputTexture() {\r\n          const gl = this.context;\r\n          if (this.texture) {\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);\r\n            return;\r\n          }\r\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\r\n          const texture = gl.createTexture();\r\n          const texSize = this.texSize;\r\n          gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);\r\n          gl.bindTexture(gl.TEXTURE_2D, texture);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n          const format = this.getInternalFormat();\r\n          if (this.precision === 'single') {\r\n            gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);\r\n          } else {\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);\r\n          }\r\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\r\n          this.texture = new this.TextureConstructor({\r\n            texture,\r\n            size: texSize,\r\n            dimensions: this.threadDim,\r\n            output: this.output,\r\n            context: this.context,\r\n            internalFormat: this.getInternalFormat(),\r\n            textureFormat: this.getTextureFormat(),\r\n            kernel: this,\r\n          });\r\n        }\r\n      \r\n        _setupSubOutputTextures() {\r\n          const gl = this.context;\r\n          if (this.mappedTextures) {\r\n            for (let i = 0; i < this.subKernels.length; i++) {\r\n              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);\r\n            }\r\n            return;\r\n          }\r\n          const texSize = this.texSize;\r\n          this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];\r\n          this.mappedTextures = [];\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const texture = this.createTexture();\r\n            this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);\r\n            gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n            const format = this.getInternalFormat();\r\n            if (this.precision === 'single') {\r\n              gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);\r\n            } else {\r\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\r\n            }\r\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);\r\n      \r\n            this.mappedTextures.push(new this.TextureConstructor({\r\n              texture,\r\n              size: texSize,\r\n              dimensions: this.threadDim,\r\n              output: this.output,\r\n              context: this.context,\r\n              internalFormat: this.getInternalFormat(),\r\n              textureFormat: this.getTextureFormat(),\r\n              kernel: this,\r\n            }));\r\n          }\r\n        }\r\n      \r\n        _getHeaderString() {\r\n          return '';\r\n        }\r\n      \r\n        _getTextureCoordinate() {\r\n          const subKernels = this.subKernels;\r\n          const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);\r\n          if (subKernels === null || subKernels.length < 1) {\r\n            return `in ${ variablePrecision } vec2 vTexCoord;\\n`;\r\n          } else {\r\n            return `out ${ variablePrecision } vec2 vTexCoord;\\n`;\r\n          }\r\n        }\r\n      \r\n        _getMainArgumentsString(args) {\r\n          const result = [];\r\n          const argumentNames = this.argumentNames;\r\n          for (let i = 0; i < argumentNames.length; i++) {\r\n            result.push(this.kernelArguments[i].getSource(args[i]));\r\n          }\r\n          return result.join('');\r\n        }\r\n      \r\n        getKernelString() {\r\n          const result = [this.getKernelResultDeclaration()];\r\n          const subKernels = this.subKernels;\r\n          if (subKernels !== null) {\r\n            result.push(\r\n              'layout(location = 0) out vec4 data0'\r\n            );\r\n            switch (this.returnType) {\r\n              case 'Number':\r\n              case 'Float':\r\n              case 'Integer':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  const subKernel = subKernels[i];\r\n                  result.push(\r\n                    subKernel.returnType === 'Integer' ?\r\n                    `int subKernelResult_${ subKernel.name } = 0` :\r\n                    `float subKernelResult_${ subKernel.name } = 0.0`,\r\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(2)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec2 subKernelResult_${ subKernels[i].name }`,\r\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(3)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec3 subKernelResult_${ subKernels[i].name }`,\r\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\r\n                  );\r\n                }\r\n                break;\r\n              case 'Array(4)':\r\n                for (let i = 0; i < subKernels.length; i++) {\r\n                  result.push(\r\n                    `vec4 subKernelResult_${ subKernels[i].name }`,\r\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\r\n                  );\r\n                }\r\n                break;\r\n            }\r\n          } else {\r\n            result.push(\r\n              'out vec4 data0'\r\n            );\r\n          }\r\n      \r\n          return utils.linesToString(result) + this.translatedSource;\r\n        }\r\n      \r\n        getMainResultGraphical() {\r\n          return utils.linesToString([\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  data0 = actualColor',\r\n          ]);\r\n        }\r\n      \r\n        getMainResultPackedPixels() {\r\n          switch (this.returnType) {\r\n            case 'LiteralInteger':\r\n            case 'Number':\r\n            case 'Integer':\r\n            case 'Float':\r\n              return this.getMainResultKernelPackedPixels() +\r\n                this.getMainResultSubKernelPackedPixels();\r\n            default:\r\n              throw new Error(`packed output only usable with Numbers, \"${this.returnType}\" specified`);\r\n          }\r\n        }\r\n      \r\n        getMainResultKernelPackedPixels() {\r\n          return utils.linesToString([\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            `  data0 = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`\r\n          ]);\r\n        }\r\n      \r\n        getMainResultSubKernelPackedPixels() {\r\n          const result = [];\r\n          if (!this.subKernels) return '';\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`\r\n              );\r\n            }\r\n          }\r\n          return utils.linesToString(result);\r\n        }\r\n      \r\n        getMainResultKernelMemoryOptimizedFloats(result, channel) {\r\n          result.push(\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            `  data0.${channel} = kernelResult`\r\n          );\r\n        }\r\n      \r\n        getMainResultSubKernelMemoryOptimizedFloats(result, channel) {\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; i++) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  data${i + 1}.${channel} = float(subKernelResult_${subKernel.name})`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  data${i + 1}.${channel} = subKernelResult_${subKernel.name}`\r\n              );\r\n            }\r\n          }\r\n        }\r\n      \r\n        getMainResultKernelNumberTexture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  data0[0] = kernelResult',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelNumberTexture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            const subKernel = this.subKernels[i];\r\n            if (subKernel.returnType === 'Integer') {\r\n              result.push(\r\n                `  data${i + 1}[0] = float(subKernelResult_${subKernel.name})`\r\n              );\r\n            } else {\r\n              result.push(\r\n                `  data${i + 1}[0] = subKernelResult_${subKernel.name}`\r\n              );\r\n            }\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray2Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  data0[0] = kernelResult[0]',\r\n            '  data0[1] = kernelResult[1]',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray2Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            const subKernel = this.subKernels[i];\r\n            result.push(\r\n              `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,\r\n              `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`\r\n            );\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray3Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  data0[0] = kernelResult[0]',\r\n            '  data0[1] = kernelResult[1]',\r\n            '  data0[2] = kernelResult[2]',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray3Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            const subKernel = this.subKernels[i];\r\n            result.push(\r\n              `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,\r\n              `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,\r\n              `  data${i + 1}[2] = subKernelResult_${subKernel.name}[2]`\r\n            );\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        getMainResultKernelArray4Texture() {\r\n          return [\r\n            '  threadId = indexTo3D(index, uOutputDim)',\r\n            '  kernel()',\r\n            '  data0 = kernelResult',\r\n          ];\r\n        }\r\n      \r\n        getMainResultSubKernelArray4Texture() {\r\n          const result = [];\r\n          if (!this.subKernels) return result;\r\n          for (let i = 0; i < this.subKernels.length; ++i) {\r\n            result.push(\r\n              `  data${i + 1} = subKernelResult_${this.subKernels[i].name}`\r\n            );\r\n          }\r\n          return result;\r\n        }\r\n      \r\n        destroyExtensions() {\r\n          this.extensions.EXT_color_buffer_float = null;\r\n          this.extensions.OES_texture_float_linear = null;\r\n        }\r\n      \r\n        toJSON() {\r\n          const json = super.toJSON();\r\n          json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();\r\n          json.settings.threadDim = this.threadDim;\r\n          return json;\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        WebGL2Kernel\r\n      };\r\n      },{\"../../utils\":114,\"../function-builder\":9,\"../web-gl/kernel\":70,\"./fragment-shader\":72,\"./function-node\":73,\"./kernel-value-maps\":74,\"./vertex-shader\":106}],106:[function(require,module,exports){\r\n      const vertexShader = `#version 300 es\r\n      __FLOAT_TACTIC_DECLARATION__;\r\n      __INT_TACTIC_DECLARATION__;\r\n      __SAMPLER_2D_TACTIC_DECLARATION__;\r\n      \r\n      in vec2 aPos;\r\n      in vec2 aTexCoord;\r\n      \r\n      out vec2 vTexCoord;\r\n      uniform vec2 ratio;\r\n      \r\n      void main(void) {\r\n        gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\r\n        vTexCoord = aTexCoord;\r\n      }`;\r\n      \r\n      module.exports = {\r\n        vertexShader\r\n      };\r\n      },{}],107:[function(require,module,exports){\r\n      const lib = require('./index');\r\n      const GPU = lib.GPU;\r\n      for (const p in lib) {\r\n        if (!lib.hasOwnProperty(p)) continue;\r\n        if (p === 'GPU') continue; \r\n        GPU[p] = lib[p];\r\n      }\r\n      \r\n      if (typeof window !== 'undefined') {\r\n        bindTo(window);\r\n      }\r\n      if (typeof self !== 'undefined') {\r\n        bindTo(self);\r\n      }\r\n      \r\n      function bindTo(target) {\r\n        if (target.GPU) return;\r\n        Object.defineProperty(target, 'GPU', {\r\n          get() {\r\n            return GPU;\r\n          }\r\n        });\r\n      }\r\n      \r\n      module.exports = lib;\r\n      },{\"./index\":109}],108:[function(require,module,exports){\r\n      const { gpuMock } = require('gpu-mock.js');\r\n      const { utils } = require('./utils');\r\n      const { Kernel } = require('./backend/kernel');\r\n      const { CPUKernel } = require('./backend/cpu/kernel');\r\n      const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');\r\n      const { WebGL2Kernel } = require('./backend/web-gl2/kernel');\r\n      const { WebGLKernel } = require('./backend/web-gl/kernel');\r\n      const { kernelRunShortcut } = require('./kernel-run-shortcut');\r\n      \r\n      \r\n      const kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];\r\n      \r\n      const kernelTypes = ['gpu', 'cpu'];\r\n      \r\n      const internalKernels = {\r\n        'headlessgl': HeadlessGLKernel,\r\n        'webgl2': WebGL2Kernel,\r\n        'webgl': WebGLKernel,\r\n      };\r\n      \r\n      let validate = true;\r\n      \r\n      class GPU {\r\n        static disableValidation() {\r\n          validate = false;\r\n        }\r\n      \r\n        static enableValidation() {\r\n          validate = true;\r\n        }\r\n      \r\n        static get isGPUSupported() {\r\n          return kernelOrder.some(Kernel => Kernel.isSupported);\r\n        }\r\n      \r\n        static get isKernelMapSupported() {\r\n          return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.kernelMap);\r\n        }\r\n      \r\n        static get isOffscreenCanvasSupported() {\r\n          return (typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined') || typeof importScripts !== 'undefined';\r\n        }\r\n      \r\n        static get isWebGLSupported() {\r\n          return WebGLKernel.isSupported;\r\n        }\r\n      \r\n        static get isWebGL2Supported() {\r\n          return WebGL2Kernel.isSupported;\r\n        }\r\n      \r\n        static get isHeadlessGLSupported() {\r\n          return HeadlessGLKernel.isSupported;\r\n        }\r\n      \r\n        static get isCanvasSupported() {\r\n          return typeof HTMLCanvasElement !== 'undefined';\r\n        }\r\n      \r\n        static get isGPUHTMLImageArraySupported() {\r\n          return WebGL2Kernel.isSupported;\r\n        }\r\n      \r\n        static get isSinglePrecisionSupported() {\r\n          return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat);\r\n        }\r\n      \r\n        constructor(settings) {\r\n          settings = settings || {};\r\n          this.canvas = settings.canvas || null;\r\n          this.context = settings.context || null;\r\n          this.mode = settings.mode;\r\n          this.Kernel = null;\r\n          this.kernels = [];\r\n          this.functions = [];\r\n          this.nativeFunctions = [];\r\n          this.injectedNative = null;\r\n          if (this.mode === 'dev') return;\r\n          this.chooseKernel();\r\n          if (settings.functions) {\r\n            for (let i = 0; i < settings.functions.length; i++) {\r\n              this.addFunction(settings.functions[i]);\r\n            }\r\n          }\r\n      \r\n          if (settings.nativeFunctions) {\r\n            for (const p in settings.nativeFunctions) {\r\n              if (!settings.nativeFunctions.hasOwnProperty(p)) continue;\r\n              const s = settings.nativeFunctions[p];\r\n              const { name, source } = s;\r\n              this.addNativeFunction(name, source, s);\r\n            }\r\n          }\r\n        }\r\n      \r\n        chooseKernel() {\r\n          if (this.Kernel) return;\r\n      \r\n          let Kernel = null;\r\n      \r\n          if (this.context) {\r\n            for (let i = 0; i < kernelOrder.length; i++) {\r\n              const ExternalKernel = kernelOrder[i];\r\n              if (ExternalKernel.isContextMatch(this.context)) {\r\n                if (!ExternalKernel.isSupported) {\r\n                  throw new Error(`Kernel type ${ExternalKernel.name} not supported`);\r\n                }\r\n                Kernel = ExternalKernel;\r\n                break;\r\n              }\r\n            }\r\n            if (Kernel === null) {\r\n              throw new Error('unknown Context');\r\n            }\r\n          } else if (this.mode) {\r\n            if (this.mode in internalKernels) {\r\n              if (!validate || internalKernels[this.mode].isSupported) {\r\n                Kernel = internalKernels[this.mode];\r\n              }\r\n            } else if (this.mode === 'gpu') {\r\n              for (let i = 0; i < kernelOrder.length; i++) {\r\n                if (kernelOrder[i].isSupported) {\r\n                  Kernel = kernelOrder[i];\r\n                  break;\r\n                }\r\n              }\r\n            } else if (this.mode === 'cpu') {\r\n              Kernel = CPUKernel;\r\n            }\r\n            if (!Kernel) {\r\n              throw new Error(`A requested mode of \"${this.mode}\" and is not supported`);\r\n            }\r\n          } else {\r\n            for (let i = 0; i < kernelOrder.length; i++) {\r\n              if (kernelOrder[i].isSupported) {\r\n                Kernel = kernelOrder[i];\r\n                break;\r\n              }\r\n            }\r\n            if (!Kernel) {\r\n              Kernel = CPUKernel;\r\n            }\r\n          }\r\n      \r\n          if (!this.mode) {\r\n            this.mode = Kernel.mode;\r\n          }\r\n          this.Kernel = Kernel;\r\n        }\r\n      \r\n        createKernel(source, settings) {\r\n          if (typeof source === 'undefined') {\r\n            throw new Error('Missing source parameter');\r\n          }\r\n          if (typeof source !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {\r\n            throw new Error('source parameter not a function');\r\n          }\r\n      \r\n          const kernels = this.kernels;\r\n          if (this.mode === 'dev') {\r\n            const devKernel = gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));\r\n            kernels.push(devKernel);\r\n            return devKernel;\r\n          }\r\n      \r\n          source = typeof source === 'function' ? source.toString() : source;\r\n          const switchableKernels = {};\r\n          const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings) || {};\r\n          if (settings && typeof settings.argumentTypes === 'object') {\r\n            settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);\r\n          }\r\n      \r\n          function onRequestFallback(args) {\r\n            console.warn('Falling back to CPU');\r\n            const fallbackKernel = new CPUKernel(source, {\r\n              argumentTypes: kernelRun.argumentTypes,\r\n              constantTypes: kernelRun.constantTypes,\r\n              graphical: kernelRun.graphical,\r\n              loopMaxIterations: kernelRun.loopMaxIterations,\r\n              constants: kernelRun.constants,\r\n              dynamicOutput: kernelRun.dynamicOutput,\r\n              dynamicArgument: kernelRun.dynamicArguments,\r\n              output: kernelRun.output,\r\n              precision: kernelRun.precision,\r\n              pipeline: kernelRun.pipeline,\r\n              immutable: kernelRun.immutable,\r\n              optimizeFloatMemory: kernelRun.optimizeFloatMemory,\r\n              fixIntegerDivisionAccuracy: kernelRun.fixIntegerDivisionAccuracy,\r\n              functions: kernelRun.functions,\r\n              nativeFunctions: kernelRun.nativeFunctions,\r\n              injectedNative: kernelRun.injectedNative,\r\n              subKernels: kernelRun.subKernels,\r\n              strictIntegers: kernelRun.strictIntegers,\r\n              debug: kernelRun.debug,\r\n            });\r\n            fallbackKernel.build.apply(fallbackKernel, args);\r\n            const result = fallbackKernel.run.apply(fallbackKernel, args);\r\n            kernelRun.replaceKernel(fallbackKernel);\r\n            return result;\r\n          }\r\n      \r\n          function onRequestSwitchKernel(reasons, args, _kernel) {\r\n            if (_kernel.debug) {\r\n              console.warn('Switching kernels');\r\n            }\r\n            let newOutput = null;\r\n            if (_kernel.signature && !switchableKernels[_kernel.signature]) {\r\n              switchableKernels[_kernel.signature] = _kernel;\r\n            }\r\n            if (_kernel.dynamicOutput) {\r\n              for (let i = reasons.length - 1; i >= 0; i--) {\r\n                const reason = reasons[i];\r\n                if (reason.type === 'outputPrecisionMismatch') {\r\n                  newOutput = reason.needed;\r\n                }\r\n              }\r\n            }\r\n      \r\n            const Constructor = _kernel.constructor;\r\n            const argumentTypes = Constructor.getArgumentTypes(_kernel, args);\r\n            const signature = Constructor.getSignature(_kernel, argumentTypes);\r\n            const existingKernel = switchableKernels[signature];\r\n            if (existingKernel) {\r\n              existingKernel.onActivate(_kernel);\r\n              return existingKernel;\r\n            }\r\n      \r\n            const newKernel = switchableKernels[signature] = new Constructor(source, {\r\n              argumentTypes,\r\n              constantTypes: _kernel.constantTypes,\r\n              graphical: _kernel.graphical,\r\n              loopMaxIterations: _kernel.loopMaxIterations,\r\n              constants: _kernel.constants,\r\n              dynamicOutput: _kernel.dynamicOutput,\r\n              dynamicArgument: _kernel.dynamicArguments,\r\n              context: _kernel.context,\r\n              canvas: _kernel.canvas,\r\n              output: newOutput || _kernel.output,\r\n              precision: _kernel.precision,\r\n              pipeline: _kernel.pipeline,\r\n              immutable: _kernel.immutable,\r\n              optimizeFloatMemory: _kernel.optimizeFloatMemory,\r\n              fixIntegerDivisionAccuracy: _kernel.fixIntegerDivisionAccuracy,\r\n              functions: _kernel.functions,\r\n              nativeFunctions: _kernel.nativeFunctions,\r\n              injectedNative: _kernel.injectedNative,\r\n              subKernels: _kernel.subKernels,\r\n              strictIntegers: _kernel.strictIntegers,\r\n              debug: _kernel.debug,\r\n              gpu: _kernel.gpu,\r\n              validate,\r\n              returnType: _kernel.returnType,\r\n              tactic: _kernel.tactic,\r\n              onRequestFallback,\r\n              onRequestSwitchKernel,\r\n              texture: _kernel.texture,\r\n              mappedTextures: _kernel.mappedTextures,\r\n              drawBuffersMap: _kernel.drawBuffersMap,\r\n            });\r\n            newKernel.build.apply(newKernel, args);\r\n            kernelRun.replaceKernel(newKernel);\r\n            kernels.push(newKernel);\r\n            return newKernel;\r\n          }\r\n          const mergedSettings = Object.assign({\r\n            context: this.context,\r\n            canvas: this.canvas,\r\n            functions: this.functions,\r\n            nativeFunctions: this.nativeFunctions,\r\n            injectedNative: this.injectedNative,\r\n            gpu: this,\r\n            validate,\r\n            onRequestFallback,\r\n            onRequestSwitchKernel\r\n          }, settingsCopy);\r\n      \r\n          const kernel = new this.Kernel(source, mergedSettings);\r\n          const kernelRun = kernelRunShortcut(kernel);\r\n      \r\n          if (!this.canvas) {\r\n            this.canvas = kernel.canvas;\r\n          }\r\n      \r\n          if (!this.context) {\r\n            this.context = kernel.context;\r\n          }\r\n      \r\n          kernels.push(kernel);\r\n      \r\n          return kernelRun;\r\n        }\r\n      \r\n        createKernelMap() {\r\n          let fn;\r\n          let settings;\r\n          const argument2Type = typeof arguments[arguments.length - 2];\r\n          if (argument2Type === 'function' || argument2Type === 'string') {\r\n            fn = arguments[arguments.length - 2];\r\n            settings = arguments[arguments.length - 1];\r\n          } else {\r\n            fn = arguments[arguments.length - 1];\r\n          }\r\n      \r\n          if (this.mode !== 'dev') {\r\n            if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {\r\n              if (this.mode && kernelTypes.indexOf(this.mode) < 0) {\r\n                throw new Error(`kernelMap not supported on ${this.Kernel.name}`);\r\n              }\r\n            }\r\n          }\r\n      \r\n          const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings);\r\n          if (settings && typeof settings.argumentTypes === 'object') {\r\n            settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);\r\n          }\r\n      \r\n          if (Array.isArray(arguments[0])) {\r\n            settingsCopy.subKernels = [];\r\n            const functions = arguments[0];\r\n            for (let i = 0; i < functions.length; i++) {\r\n              const source = functions[i].toString();\r\n              const name = utils.getFunctionNameFromString(source);\r\n              settingsCopy.subKernels.push({\r\n                name,\r\n                source,\r\n                property: i,\r\n              });\r\n            }\r\n          } else {\r\n            settingsCopy.subKernels = [];\r\n            const functions = arguments[0];\r\n            for (let p in functions) {\r\n              if (!functions.hasOwnProperty(p)) continue;\r\n              const source = functions[p].toString();\r\n              const name = utils.getFunctionNameFromString(source);\r\n              settingsCopy.subKernels.push({\r\n                name: name || p,\r\n                source,\r\n                property: p,\r\n              });\r\n            }\r\n          }\r\n          return this.createKernel(fn, settingsCopy);\r\n        }\r\n      \r\n        combineKernels() {\r\n          const firstKernel = arguments[0];\r\n          const combinedKernel = arguments[arguments.length - 1];\r\n          if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;\r\n          const canvas = arguments[0].canvas;\r\n          const context = arguments[0].context;\r\n          const max = arguments.length - 1;\r\n          for (let i = 0; i < max; i++) {\r\n            arguments[i]\r\n              .setCanvas(canvas)\r\n              .setContext(context)\r\n              .setPipeline(true);\r\n          }\r\n      \r\n          return function() {\r\n            const texture = combinedKernel.apply(this, arguments);\r\n            if (texture.toArray) {\r\n              return texture.toArray();\r\n            }\r\n            return texture;\r\n          };\r\n        }\r\n      \r\n        setFunctions(functions) {\r\n          this.functions = functions;\r\n          return this;\r\n        }\r\n      \r\n        setNativeFunctions(nativeFunctions) {\r\n          this.nativeFunctions = nativeFunctions;\r\n          return this;\r\n        }\r\n      \r\n        addFunction(source, settings) {\r\n          this.functions.push({ source, settings });\r\n          return this;\r\n        }\r\n      \r\n        addNativeFunction(name, source, settings) {\r\n          if (this.kernels.length > 0) {\r\n            throw new Error('Cannot call \"addNativeFunction\" after \"createKernels\" has been called.');\r\n          }\r\n          this.nativeFunctions.push(Object.assign({ name, source }, settings));\r\n          return this;\r\n        }\r\n      \r\n        injectNative(source) {\r\n          this.injectedNative = source;\r\n          return this;\r\n        }\r\n      \r\n        destroy() {\r\n          return new Promise((resolve, reject) => {\r\n            if (!this.kernels) {\r\n              resolve();\r\n            }\r\n            setTimeout(() => {\r\n              try {\r\n                for (let i = 0; i < this.kernels.length; i++) {\r\n                  this.kernels[i].destroy(true); \r\n                }\r\n                let firstKernel = this.kernels[0];\r\n                if (firstKernel) {\r\n                  if (firstKernel.kernel) {\r\n                    firstKernel = firstKernel.kernel;\r\n                  }\r\n                  if (firstKernel.constructor.destroyContext) {\r\n                    firstKernel.constructor.destroyContext(this.context);\r\n                  }\r\n                }\r\n              } catch (e) {\r\n                reject(e);\r\n              }\r\n              resolve();\r\n            }, 0);\r\n          });\r\n        }\r\n      }\r\n      \r\n      \r\n      function upgradeDeprecatedCreateKernelSettings(settings) {\r\n        if (!settings) {\r\n          return {};\r\n        }\r\n        const upgradedSettings = Object.assign({}, settings);\r\n      \r\n        if (settings.hasOwnProperty('floatOutput')) {\r\n          utils.warnDeprecated('setting', 'floatOutput', 'precision');\r\n          upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';\r\n        }\r\n        if (settings.hasOwnProperty('outputToTexture')) {\r\n          utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');\r\n          upgradedSettings.pipeline = Boolean(settings.outputToTexture);\r\n        }\r\n        if (settings.hasOwnProperty('outputImmutable')) {\r\n          utils.warnDeprecated('setting', 'outputImmutable', 'immutable');\r\n          upgradedSettings.immutable = Boolean(settings.outputImmutable);\r\n        }\r\n        if (settings.hasOwnProperty('floatTextures')) {\r\n          utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');\r\n          upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);\r\n        }\r\n        return upgradedSettings;\r\n      }\r\n      \r\n      module.exports = {\r\n        GPU,\r\n        kernelOrder,\r\n        kernelTypes\r\n      };\r\n      },{\"./backend/cpu/kernel\":8,\"./backend/headless-gl/kernel\":34,\"./backend/kernel\":36,\"./backend/web-gl/kernel\":70,\"./backend/web-gl2/kernel\":105,\"./kernel-run-shortcut\":111,\"./utils\":114,\"gpu-mock.js\":4}],109:[function(require,module,exports){\r\n      const { GPU } = require('./gpu');\r\n      const { alias } = require('./alias');\r\n      const { utils } = require('./utils');\r\n      const { Input, input } = require('./input');\r\n      const { Texture } = require('./texture');\r\n      const { FunctionBuilder } = require('./backend/function-builder');\r\n      const { FunctionNode } = require('./backend/function-node');\r\n      const { CPUFunctionNode } = require('./backend/cpu/function-node');\r\n      const { CPUKernel } = require('./backend/cpu/kernel');\r\n      \r\n      const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');\r\n      \r\n      const { WebGLFunctionNode } = require('./backend/web-gl/function-node');\r\n      const { WebGLKernel } = require('./backend/web-gl/kernel');\r\n      const { kernelValueMaps: webGLKernelValueMaps } = require('./backend/web-gl/kernel-value-maps');\r\n      \r\n      const { WebGL2FunctionNode } = require('./backend/web-gl2/function-node');\r\n      const { WebGL2Kernel } = require('./backend/web-gl2/kernel');\r\n      const { kernelValueMaps: webGL2KernelValueMaps } = require('./backend/web-gl2/kernel-value-maps');\r\n      \r\n      const { GLKernel } = require('./backend/gl/kernel');\r\n      \r\n      const { Kernel } = require('./backend/kernel');\r\n      \r\n      const { FunctionTracer } = require('./backend/function-tracer');\r\n      \r\n      const mathRandom = require('./plugins/math-random-uniformly-distributed');\r\n      \r\n      module.exports = {\r\n        alias,\r\n        CPUFunctionNode,\r\n        CPUKernel,\r\n        GPU,\r\n        FunctionBuilder,\r\n        FunctionNode,\r\n        HeadlessGLKernel,\r\n        Input,\r\n        input,\r\n        Texture,\r\n        utils,\r\n      \r\n        WebGL2FunctionNode,\r\n        WebGL2Kernel,\r\n        webGL2KernelValueMaps,\r\n      \r\n        WebGLFunctionNode,\r\n        WebGLKernel,\r\n        webGLKernelValueMaps,\r\n      \r\n        GLKernel,\r\n        Kernel,\r\n        FunctionTracer,\r\n      \r\n        plugins: {\r\n          mathRandom\r\n        }\r\n      };\r\n      },{\"./alias\":5,\"./backend/cpu/function-node\":6,\"./backend/cpu/kernel\":8,\"./backend/function-builder\":9,\"./backend/function-node\":10,\"./backend/function-tracer\":11,\"./backend/gl/kernel\":13,\"./backend/headless-gl/kernel\":34,\"./backend/kernel\":36,\"./backend/web-gl/function-node\":38,\"./backend/web-gl/kernel\":70,\"./backend/web-gl/kernel-value-maps\":39,\"./backend/web-gl2/function-node\":73,\"./backend/web-gl2/kernel\":105,\"./backend/web-gl2/kernel-value-maps\":74,\"./gpu\":108,\"./input\":110,\"./plugins/math-random-uniformly-distributed\":112,\"./texture\":113,\"./utils\":114}],110:[function(require,module,exports){\r\n      class Input {\r\n        constructor(value, size) {\r\n          this.value = value;\r\n          if (Array.isArray(size)) {\r\n            this.size = size;\r\n          } else {\r\n            this.size = new Int32Array(3);\r\n            if (size.z) {\r\n              this.size = new Int32Array([size.x, size.y, size.z]);\r\n            } else if (size.y) {\r\n              this.size = new Int32Array([size.x, size.y]);\r\n            } else {\r\n              this.size = new Int32Array([size.x]);\r\n            }\r\n          }\r\n      \r\n          const [w, h, d] = this.size;\r\n          if (d) {\r\n            if (this.value.length !== (w * h * d)) {\r\n              throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} * ${d} = ${(h * w * d)}`);\r\n            }\r\n          } else if (h) {\r\n            if (this.value.length !== (w * h)) {\r\n              throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} = ${(h * w)}`);\r\n            }\r\n          } else {\r\n            if (this.value.length !== w) {\r\n              throw new Error(`Input size ${this.value.length} does not match ${w}`);\r\n            }\r\n          }\r\n      \r\n        }\r\n      \r\n        toArray() {\r\n          const { utils } = require('./utils');\r\n          const [w, h, d] = this.size;\r\n          if (d) {\r\n            return utils.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h, d);\r\n          } else if (h) {\r\n            return utils.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h);\r\n          } else {\r\n            return this.value;\r\n          }\r\n        }\r\n      }\r\n      \r\n      function input(value, size) {\r\n        return new Input(value, size);\r\n      }\r\n      \r\n      module.exports = {\r\n        Input,\r\n        input\r\n      };\r\n      },{\"./utils\":114}],111:[function(require,module,exports){\r\n      const { utils } = require('./utils');\r\n      \r\n      function kernelRunShortcut(kernel) {\r\n        let run = function() {\r\n          kernel.build.apply(kernel, arguments);\r\n          run = function() {\r\n            let result = kernel.run.apply(kernel, arguments);\r\n            if (kernel.switchingKernels) {\r\n              const reasons = kernel.resetSwitchingKernels();\r\n              const newKernel = kernel.onRequestSwitchKernel(reasons, arguments, kernel);\r\n              shortcut.kernel = kernel = newKernel;\r\n              result = newKernel.run.apply(newKernel, arguments);\r\n            }\r\n            if (kernel.renderKernels) {\r\n              return kernel.renderKernels();\r\n            } else if (kernel.renderOutput) {\r\n              return kernel.renderOutput();\r\n            } else {\r\n              return result;\r\n            }\r\n          };\r\n          return run.apply(kernel, arguments);\r\n        };\r\n        const shortcut = function() {\r\n          return run.apply(kernel, arguments);\r\n        };\r\n        shortcut.exec = function() {\r\n          return new Promise((accept, reject) => {\r\n            try {\r\n              accept(run.apply(this, arguments));\r\n            } catch (e) {\r\n              reject(e);\r\n            }\r\n          });\r\n        };\r\n        shortcut.replaceKernel = function(replacementKernel) {\r\n          kernel = replacementKernel;\r\n          bindKernelToShortcut(kernel, shortcut);\r\n        };\r\n      \r\n        bindKernelToShortcut(kernel, shortcut);\r\n        return shortcut;\r\n      }\r\n      \r\n      function bindKernelToShortcut(kernel, shortcut) {\r\n        if (shortcut.kernel) {\r\n          shortcut.kernel = kernel;\r\n          return;\r\n        }\r\n        const properties = utils.allPropertiesOf(kernel);\r\n        for (let i = 0; i < properties.length; i++) {\r\n          const property = properties[i];\r\n          if (property[0] === '_' && property[1] === '_') continue;\r\n          if (typeof kernel[property] === 'function') {\r\n            if (property.substring(0, 3) === 'add' || property.substring(0, 3) === 'set') {\r\n              shortcut[property] = function() {\r\n                shortcut.kernel[property].apply(shortcut.kernel, arguments);\r\n                return shortcut;\r\n              };\r\n            } else {\r\n              shortcut[property] = function() {\r\n                return shortcut.kernel[property].apply(shortcut.kernel, arguments);\r\n              };\r\n            }\r\n          } else {\r\n            shortcut.__defineGetter__(property, () => shortcut.kernel[property]);\r\n            shortcut.__defineSetter__(property, (value) => {\r\n              shortcut.kernel[property] = value;\r\n            });\r\n          }\r\n        }\r\n        shortcut.kernel = kernel;\r\n      }\r\n      module.exports = {\r\n        kernelRunShortcut\r\n      };\r\n      },{\"./utils\":114}],112:[function(require,module,exports){\r\n      const source = `// https://www.shadertoy.com/view/4t2SDh\r\n      //note: uniformly distributed, normalized rand, [0,1]\r\n      highp float randomSeedShift = 1.0;\r\n      highp float slide = 1.0;\r\n      uniform highp float randomSeed1;\r\n      uniform highp float randomSeed2;\r\n      \r\n      highp float nrand(highp vec2 n) {\r\n        highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);\r\n        randomSeedShift = result;\r\n        if (randomSeedShift > 0.5) {\r\n          slide += 0.00009; \r\n        } else {\r\n          slide += 0.0009;\r\n        }\r\n        return result;\r\n      }`;\r\n      \r\n      const name = 'math-random-uniformly-distributed';\r\n      \r\n      const functionMatch = `Math.random()`;\r\n      \r\n      const functionReplace = `nrand(vTexCoord)`;\r\n      \r\n      const functionReturnType = 'Number';\r\n      const onBeforeRun = (kernel) => {\r\n        kernel.setUniform1f('randomSeed1', Math.random());\r\n        kernel.setUniform1f('randomSeed2', Math.random());\r\n      };\r\n      \r\n      const plugin = {\r\n        name,\r\n        onBeforeRun,\r\n        functionMatch,\r\n        functionReplace,\r\n        functionReturnType,\r\n        source\r\n      };\r\n      \r\n      module.exports = plugin;\r\n      },{}],113:[function(require,module,exports){\r\n      class Texture {\r\n        constructor(settings) {\r\n          const {\r\n            texture,\r\n            size,\r\n            dimensions,\r\n            output,\r\n            context,\r\n            type = 'NumberTexture',\r\n            kernel,\r\n            internalFormat,\r\n            textureFormat\r\n          } = settings;\r\n          if (!output) throw new Error('settings property \"output\" required.');\r\n          if (!context) throw new Error('settings property \"context\" required.');\r\n          if (!texture) throw new Error('settings property \"texture\" required.');\r\n          if (!kernel) throw new Error('settings property \"kernel\" required.');\r\n          this.texture = texture;\r\n          if (texture._refs) {\r\n            texture._refs++;\r\n          } else {\r\n            texture._refs = 1;\r\n          }\r\n          this.size = size;\r\n          this.dimensions = dimensions;\r\n          this.output = output;\r\n          this.context = context;\r\n          this.kernel = kernel;\r\n          this.type = type;\r\n          this._deleted = false;\r\n          this.internalFormat = internalFormat;\r\n          this.textureFormat = textureFormat;\r\n        }\r\n      \r\n        toArray() {\r\n          throw new Error(`Not implemented on ${this.constructor.name}`);\r\n        }\r\n      \r\n        clone() {\r\n          throw new Error(`Not implemented on ${this.constructor.name}`);\r\n        }\r\n      \r\n        delete() {\r\n          throw new Error(`Not implemented on ${this.constructor.name}`);\r\n        }\r\n      \r\n        clear() {\r\n          throw new Error(`Not implemented on ${this.constructor.name}`);\r\n        }\r\n      }\r\n      \r\n      module.exports = {\r\n        Texture\r\n      };\r\n      },{}],114:[function(require,module,exports){\r\n      const acorn = require('acorn');\r\n      const { Input } = require('./input');\r\n      const { Texture } = require('./texture');\r\n      \r\n      const FUNCTION_NAME = /function ([^(]*)/;\r\n      const STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\r\n      const ARGUMENT_NAMES = /([^\\s,]+)/g;\r\n      \r\n      const utils = {\r\n        systemEndianness() {\r\n          return _systemEndianness;\r\n        },\r\n        getSystemEndianness() {\r\n          const b = new ArrayBuffer(4);\r\n          const a = new Uint32Array(b);\r\n          const c = new Uint8Array(b);\r\n          a[0] = 0xdeadbeef;\r\n          if (c[0] === 0xef) return 'LE';\r\n          if (c[0] === 0xde) return 'BE';\r\n          throw new Error('unknown endianness');\r\n        },\r\n      \r\n        isFunction(funcObj) {\r\n          return typeof(funcObj) === 'function';\r\n        },\r\n      \r\n        isFunctionString(fn) {\r\n          if (typeof fn === 'string') {\r\n            return (fn\r\n              .slice(0, 'function'.length)\r\n              .toLowerCase() === 'function');\r\n          }\r\n          return false;\r\n        },\r\n      \r\n        getFunctionNameFromString(funcStr) {\r\n          const result = FUNCTION_NAME.exec(funcStr);\r\n          if (!result || result.length === 0) return null;\r\n          return result[1].trim();\r\n        },\r\n      \r\n        getFunctionBodyFromString(funcStr) {\r\n          return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));\r\n        },\r\n      \r\n        getArgumentNamesFromString(fn) {\r\n          const fnStr = fn.replace(STRIP_COMMENTS, '');\r\n          let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\r\n          if (result === null) {\r\n            result = [];\r\n          }\r\n          return result;\r\n        },\r\n      \r\n        clone(obj) {\r\n          if (obj === null || typeof obj !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;\r\n      \r\n          const temp = obj.constructor(); \r\n      \r\n          for (let key in obj) {\r\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n              obj.isActiveClone = null;\r\n              temp[key] = utils.clone(obj[key]);\r\n              delete obj.isActiveClone;\r\n            }\r\n          }\r\n      \r\n          return temp;\r\n        },\r\n      \r\n        isArray(array) {\r\n          return !isNaN(array.length);\r\n        },\r\n      \r\n        getVariableType(value, strictIntegers) {\r\n          if (utils.isArray(value)) {\r\n            if (value.length > 0 && value[0].nodeName === 'IMG') {\r\n              return 'HTMLImageArray';\r\n            }\r\n            return 'Array';\r\n          }\r\n      \r\n          switch (value.constructor) {\r\n            case Boolean:\r\n              return 'Boolean';\r\n            case Number:\r\n              if (strictIntegers && Number.isInteger(value)) {\r\n                return 'Integer';\r\n              }\r\n              return 'Float';\r\n            case Texture:\r\n              return value.type;\r\n            case Input:\r\n              return 'Input';\r\n          }\r\n          switch (value.nodeName) {\r\n            case 'IMG':\r\n              return 'HTMLImage';\r\n            case 'CANVAS':\r\n              return 'HTMLImage';\r\n            case 'VIDEO':\r\n              return 'HTMLVideo';\r\n          }\r\n          if (value.hasOwnProperty('type')) {\r\n            return value.type;\r\n          }\r\n          return 'Unknown';\r\n        },\r\n      \r\n        getKernelTextureSize(settings, dimensions) {\r\n          let [w, h, d] = dimensions;\r\n          let texelCount = (w || 1) * (h || 1) * (d || 1);\r\n      \r\n          if (settings.optimizeFloatMemory && settings.precision === 'single') {\r\n            w = texelCount = Math.ceil(texelCount / 4);\r\n          }\r\n          if (h > 1 && w * h === texelCount) {\r\n            return new Int32Array([w, h]);\r\n          }\r\n          return utils.closestSquareDimensions(texelCount);\r\n        },\r\n      \r\n        closestSquareDimensions(length) {\r\n          const sqrt = Math.sqrt(length);\r\n          let high = Math.ceil(sqrt);\r\n          let low = Math.floor(sqrt);\r\n          while (high * low < length) {\r\n            high--;\r\n            low = Math.ceil(length / high);\r\n          }\r\n          return new Int32Array([low, Math.ceil(length / low)]);\r\n        },\r\n      \r\n        getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {\r\n          const totalArea = utils.roundTo((dimensions[0] || 1) * (dimensions[1] || 1) * (dimensions[2] || 1) * (dimensions[3] || 1), 4);\r\n          const texelCount = totalArea / bitRatio;\r\n          return utils.closestSquareDimensions(texelCount);\r\n        },\r\n      \r\n        getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {\r\n          const [w, h, d] = dimensions;\r\n          const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);\r\n          const texelCount = totalArea / (4 / bitRatio);\r\n          return utils.closestSquareDimensions(texelCount);\r\n        },\r\n      \r\n        roundTo(n, d) {\r\n          return Math.floor((n + d - 1) / d) * d;\r\n        },\r\n        getDimensions(x, pad) {\r\n          let ret;\r\n          if (utils.isArray(x)) {\r\n            const dim = [];\r\n            let temp = x;\r\n            while (utils.isArray(temp)) {\r\n              dim.push(temp.length);\r\n              temp = temp[0];\r\n            }\r\n            ret = dim.reverse();\r\n          } else if (x instanceof Texture) {\r\n            ret = x.output;\r\n          } else if (x instanceof Input) {\r\n            ret = x.size;\r\n          } else {\r\n            throw new Error(`Unknown dimensions of ${x}`);\r\n          }\r\n      \r\n          if (pad) {\r\n            ret = Array.from(ret);\r\n            while (ret.length < 3) {\r\n              ret.push(1);\r\n            }\r\n          }\r\n      \r\n          return new Int32Array(ret);\r\n        },\r\n      \r\n        flatten2dArrayTo(array, target) {\r\n          let offset = 0;\r\n          for (let y = 0; y < array.length; y++) {\r\n            target.set(array[y], offset);\r\n            offset += array[y].length;\r\n          }\r\n        },\r\n      \r\n        flatten3dArrayTo(array, target) {\r\n          let offset = 0;\r\n          for (let z = 0; z < array.length; z++) {\r\n            for (let y = 0; y < array[z].length; y++) {\r\n              target.set(array[z][y], offset);\r\n              offset += array[z][y].length;\r\n            }\r\n          }\r\n        },\r\n      \r\n        flatten4dArrayTo(array, target) {\r\n          let offset = 0;\r\n          for (let l = 0; l < array.length; l++) {\r\n            for (let z = 0; z < array[l].length; z++) {\r\n              for (let y = 0; y < array[l][z].length; y++) {\r\n                target.set(array[l][z][y], offset);\r\n                offset += array[l][z][y].length;\r\n              }\r\n            }\r\n          }\r\n        },\r\n      \r\n        flattenTo(array, target) {\r\n          if (utils.isArray(array[0])) {\r\n            if (utils.isArray(array[0][0])) {\r\n              if (utils.isArray(array[0][0][0])) {\r\n                utils.flatten4dArrayTo(array, target);\r\n              } else {\r\n                utils.flatten3dArrayTo(array, target);\r\n              }\r\n            } else {\r\n              utils.flatten2dArrayTo(array, target);\r\n            }\r\n          } else {\r\n            target.set(array);\r\n          }\r\n        },\r\n      \r\n        splitArray(array, part) {\r\n          const result = [];\r\n          for (let i = 0; i < array.length; i += part) {\r\n            result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));\r\n          }\r\n          return result;\r\n        },\r\n      \r\n        getAstString(source, ast) {\r\n          const lines = Array.isArray(source) ? source : source.split(/\\r?\\n/g);\r\n          const start = ast.loc.start;\r\n          const end = ast.loc.end;\r\n          const result = [];\r\n          if (start.line === end.line) {\r\n            result.push(lines[start.line - 1].substring(start.column, end.column));\r\n          } else {\r\n            result.push(lines[start.line - 1].slice(start.column));\r\n            for (let i = start.line; i < end.line; i++) {\r\n              result.push(lines[i]);\r\n            }\r\n            result.push(lines[end.line - 1].slice(0, end.column));\r\n          }\r\n          return result.join('\\n');\r\n        },\r\n      \r\n        allPropertiesOf(obj) {\r\n          const props = [];\r\n      \r\n          do {\r\n            props.push.apply(props, Object.getOwnPropertyNames(obj));\r\n          } while (obj = Object.getPrototypeOf(obj));\r\n      \r\n          return props;\r\n        },\r\n      \r\n        linesToString(lines) {\r\n          if (lines.length > 0) {\r\n            return lines.join(';\\n') + ';\\n';\r\n          } else {\r\n            return '\\n';\r\n          }\r\n        },\r\n        warnDeprecated(type, oldName, newName) {\r\n          if (newName) {\r\n            console.warn(`You are using a deprecated ${ type } \"${ oldName }\". It has been replaced with \"${ newName }\". Fixing, but please upgrade as it will soon be removed.`);\r\n          } else {\r\n            console.warn(`You are using a deprecated ${ type } \"${ oldName }\". It has been removed. Fixing, but please upgrade as it will soon be removed.`);\r\n          }\r\n        },\r\n        flipPixels: (pixels, width, height) => {\r\n          const halfHeight = height / 2 | 0; \r\n          const bytesPerRow = width * 4;\r\n          const temp = new Uint8ClampedArray(width * 4);\r\n          const result = pixels.slice(0);\r\n          for (let y = 0; y < halfHeight; ++y) {\r\n            const topOffset = y * bytesPerRow;\r\n            const bottomOffset = (height - y - 1) * bytesPerRow;\r\n      \r\n            temp.set(result.subarray(topOffset, topOffset + bytesPerRow));\r\n      \r\n            result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);\r\n      \r\n            result.set(temp, bottomOffset);\r\n          }\r\n          return result;\r\n        },\r\n        erectPackedFloat: (array, width) => {\r\n          return array.subarray(0, width);\r\n        },\r\n        erect2DPackedFloat: (array, width, height) => {\r\n          const yResults = new Array(height);\r\n          for (let y = 0; y < height; y++) {\r\n            const xStart = y * width;\r\n            const xEnd = xStart + width;\r\n            yResults[y] = array.subarray(xStart, xEnd);\r\n          }\r\n          return yResults;\r\n        },\r\n        erect3DPackedFloat: (array, width, height, depth) => {\r\n          const zResults = new Array(depth);\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const xStart = (z * height * width) + y * width;\r\n              const xEnd = xStart + width;\r\n              yResults[y] = array.subarray(xStart, xEnd);\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n        erectMemoryOptimizedFloat: (array, width) => {\r\n          return array.subarray(0, width);\r\n        },\r\n        erectMemoryOptimized2DFloat: (array, width, height) => {\r\n          const yResults = new Array(height);\r\n          for (let y = 0; y < height; y++) {\r\n            const offset = y * width;\r\n            yResults[y] = array.subarray(offset, offset + width);\r\n          }\r\n          return yResults;\r\n        },\r\n        erectMemoryOptimized3DFloat: (array, width, height, depth) => {\r\n          const zResults = new Array(depth);\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const offset = (z * height * width) + (y * width);\r\n              yResults[y] = array.subarray(offset, offset + width);\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n        erectFloat: (array, width) => {\r\n          const xResults = new Float32Array(width);\r\n          let i = 0;\r\n          for (let x = 0; x < width; x++) {\r\n            xResults[x] = array[i];\r\n            i += 4;\r\n          }\r\n          return xResults;\r\n        },\r\n        erect2DFloat: (array, width, height) => {\r\n          const yResults = new Array(height);\r\n          let i = 0;\r\n          for (let y = 0; y < height; y++) {\r\n            const xResults = new Float32Array(width);\r\n            for (let x = 0; x < width; x++) {\r\n              xResults[x] = array[i];\r\n              i += 4;\r\n            }\r\n            yResults[y] = xResults;\r\n          }\r\n          return yResults;\r\n        },\r\n        erect3DFloat: (array, width, height, depth) => {\r\n          const zResults = new Array(depth);\r\n          let i = 0;\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const xResults = new Float32Array(width);\r\n              for (let x = 0; x < width; x++) {\r\n                xResults[x] = array[i];\r\n                i += 4;\r\n              }\r\n              yResults[y] = xResults;\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n        erectArray2: (array, width) => {\r\n          const xResults = new Array(width);\r\n          const xResultsMax = width * 4;\r\n          let i = 0;\r\n          for (let x = 0; x < xResultsMax; x += 4) {\r\n            xResults[i++] = array.subarray(x, x + 2);\r\n          }\r\n          return xResults;\r\n        },\r\n        erect2DArray2: (array, width, height) => {\r\n          const yResults = new Array(height);\r\n          const XResultsMax = width * 4;\r\n          for (let y = 0; y < height; y++) {\r\n            const xResults = new Array(width);\r\n            const offset = y * XResultsMax;\r\n            let i = 0;\r\n            for (let x = 0; x < XResultsMax; x += 4) {\r\n              xResults[i++] = array.subarray(x + offset, x + offset + 2);\r\n            }\r\n            yResults[y] = xResults;\r\n          }\r\n          return yResults;\r\n        },\r\n        erect3DArray2: (array, width, height, depth) => {\r\n          const xResultsMax = width * 4;\r\n          const zResults = new Array(depth);\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const xResults = new Array(width);\r\n              const offset = (z * xResultsMax * height) + (y * xResultsMax);\r\n              let i = 0;\r\n              for (let x = 0; x < xResultsMax; x += 4) {\r\n                xResults[i++] = array.subarray(x + offset, x + offset + 2);\r\n              }\r\n              yResults[y] = xResults;\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n        erectArray3: (array, width) => {\r\n          const xResults = new Array(width);\r\n          const xResultsMax = width * 4;\r\n          let i = 0;\r\n          for (let x = 0; x < xResultsMax; x += 4) {\r\n            xResults[i++] = array.subarray(x, x + 3);\r\n          }\r\n          return xResults;\r\n        },\r\n        erect2DArray3: (array, width, height) => {\r\n          const xResultsMax = width * 4;\r\n          const yResults = new Array(height);\r\n          for (let y = 0; y < height; y++) {\r\n            const xResults = new Array(width);\r\n            const offset = y * xResultsMax;\r\n            let i = 0;\r\n            for (let x = 0; x < xResultsMax; x += 4) {\r\n              xResults[i++] = array.subarray(x + offset, x + offset + 3);\r\n            }\r\n            yResults[y] = xResults;\r\n          }\r\n          return yResults;\r\n        },\r\n        erect3DArray3: (array, width, height, depth) => {\r\n          const xResultsMax = width * 4;\r\n          const zResults = new Array(depth);\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const xResults = new Array(width);\r\n              const offset = (z * xResultsMax * height) + (y * xResultsMax);\r\n              let i = 0;\r\n              for (let x = 0; x < xResultsMax; x += 4) {\r\n                xResults[i++] = array.subarray(x + offset, x + offset + 3);\r\n              }\r\n              yResults[y] = xResults;\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n        erectArray4: (array, width) => {\r\n          const xResults = new Array(array);\r\n          const xResultsMax = width * 4;\r\n          let i = 0;\r\n          for (let x = 0; x < xResultsMax; x += 4) {\r\n            xResults[i++] = array.subarray(x, x + 4);\r\n          }\r\n          return xResults;\r\n        },\r\n        erect2DArray4: (array, width, height) => {\r\n          const xResultsMax = width * 4;\r\n          const yResults = new Array(height);\r\n          for (let y = 0; y < height; y++) {\r\n            const xResults = new Array(width);\r\n            const offset = y * xResultsMax;\r\n            let i = 0;\r\n            for (let x = 0; x < xResultsMax; x += 4) {\r\n              xResults[i++] = array.subarray(x + offset, x + offset + 4);\r\n            }\r\n            yResults[y] = xResults;\r\n          }\r\n          return yResults;\r\n        },\r\n        erect3DArray4: (array, width, height, depth) => {\r\n          const xResultsMax = width * 4;\r\n          const zResults = new Array(depth);\r\n          for (let z = 0; z < depth; z++) {\r\n            const yResults = new Array(height);\r\n            for (let y = 0; y < height; y++) {\r\n              const xResults = new Array(width);\r\n              const offset = (z * xResultsMax * height) + (y * xResultsMax);\r\n              let i = 0;\r\n              for (let x = 0; x < xResultsMax; x += 4) {\r\n                xResults[i++] = array.subarray(x + offset, x + offset + 4);\r\n              }\r\n              yResults[y] = xResults;\r\n            }\r\n            zResults[z] = yResults;\r\n          }\r\n          return zResults;\r\n        },\r\n      \r\n        flattenFunctionToString: (source, settings) => {\r\n          const { findDependency, thisLookup, doNotDefine } = settings;\r\n          let flattened = settings.flattened;\r\n          if (!flattened) {\r\n            flattened = settings.flattened = {};\r\n          }\r\n          const ast = acorn.parse(source);\r\n          const functionDependencies = [];\r\n          let indent = 0;\r\n      \r\n          function flatten(ast) {\r\n            if (Array.isArray(ast)) {\r\n              const results = [];\r\n              for (let i = 0; i < ast.length; i++) {\r\n                results.push(flatten(ast[i]));\r\n              }\r\n              return results.join('');\r\n            }\r\n            switch (ast.type) {\r\n              case 'Program':\r\n                return flatten(ast.body) + (ast.body[0].type === 'VariableDeclaration' ? ';' : '');\r\n              case 'FunctionDeclaration':\r\n                return `function ${ast.id.name}(${ast.params.map(flatten).join(', ')}) ${ flatten(ast.body) }`;\r\n              case 'BlockStatement': {\r\n                const result = [];\r\n                indent += 2;\r\n                for (let i = 0; i < ast.body.length; i++) {\r\n                  const flat = flatten(ast.body[i]);\r\n                  if (flat) {\r\n                    result.push(' '.repeat(indent) + flat, ';\\n');\r\n                  }\r\n                }\r\n                indent -= 2;\r\n                return `{\\n${result.join('')}}`;\r\n              }\r\n              case 'VariableDeclaration':\r\n                const declarations = utils.normalizeDeclarations(ast)\r\n                  .map(flatten)\r\n                  .filter(r => r !== null);\r\n                if (declarations.length < 1) {\r\n                  return '';\r\n                } else {\r\n                  return `${ast.kind} ${declarations.join(',')}`;\r\n                }\r\n                case 'VariableDeclarator':\r\n                  if (ast.init.object && ast.init.object.type === 'ThisExpression') {\r\n                    const lookup = thisLookup(ast.init.property.name, true);\r\n                    if (lookup) {\r\n                      return `${ast.id.name} = ${flatten(ast.init)}`;\r\n                    } else {\r\n                      return null;\r\n                    }\r\n                  } else {\r\n                    return `${ast.id.name} = ${flatten(ast.init)}`;\r\n                  }\r\n                  case 'CallExpression': {\r\n                    if (ast.callee.property.name === 'subarray') {\r\n                      return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                    }\r\n                    if (ast.callee.object.name === 'gl' || ast.callee.object.name === 'context') {\r\n                      return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                    }\r\n                    if (ast.callee.object.type === 'ThisExpression') {\r\n                      functionDependencies.push(findDependency('this', ast.callee.property.name));\r\n                      return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                    } else if (ast.callee.object.name) {\r\n                      const foundSource = findDependency(ast.callee.object.name, ast.callee.property.name);\r\n                      if (foundSource === null) {\r\n                        return `${ast.callee.object.name}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                      } else {\r\n                        functionDependencies.push(foundSource);\r\n                        return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                      }\r\n                    } else if (ast.callee.object.type === 'MemberExpression') {\r\n                      return `${flatten(ast.callee.object)}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                    } else {\r\n                      throw new Error('unknown ast.callee');\r\n                    }\r\n                  }\r\n                  case 'ReturnStatement':\r\n                    return `return ${flatten(ast.argument)}`;\r\n                  case 'BinaryExpression':\r\n                    return `(${flatten(ast.left)}${ast.operator}${flatten(ast.right)})`;\r\n                  case 'UnaryExpression':\r\n                    if (ast.prefix) {\r\n                      return `${ast.operator} ${flatten(ast.argument)}`;\r\n                    } else {\r\n                      return `${flatten(ast.argument)} ${ast.operator}`;\r\n                    }\r\n                    case 'ExpressionStatement':\r\n                      return `${flatten(ast.expression)}`;\r\n                    case 'SequenceExpression':\r\n                      return `(${flatten(ast.expressions)})`;\r\n                    case 'ArrowFunctionExpression':\r\n                      return `(${ast.params.map(flatten).join(', ')}) => ${flatten(ast.body)}`;\r\n                    case 'Literal':\r\n                      return ast.raw;\r\n                    case 'Identifier':\r\n                      return ast.name;\r\n                    case 'MemberExpression':\r\n                      if (ast.object.type === 'ThisExpression') {\r\n                        return thisLookup(ast.property.name);\r\n                      }\r\n                      if (ast.computed) {\r\n                        return `${flatten(ast.object)}[${flatten(ast.property)}]`;\r\n                      }\r\n                      return flatten(ast.object) + '.' + flatten(ast.property);\r\n                    case 'ThisExpression':\r\n                      return 'this';\r\n                    case 'NewExpression':\r\n                      return `new ${flatten(ast.callee)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\r\n                    case 'ForStatement':\r\n                      return `for (${flatten(ast.init)};${flatten(ast.test)};${flatten(ast.update)}) ${flatten(ast.body)}`;\r\n                    case 'AssignmentExpression':\r\n                      return `${flatten(ast.left)}${ast.operator}${flatten(ast.right)}`;\r\n                    case 'UpdateExpression':\r\n                      return `${flatten(ast.argument)}${ast.operator}`;\r\n                    case 'IfStatement':\r\n                      return `if (${flatten(ast.test)}) ${flatten(ast.consequent)}`;\r\n                    case 'ThrowStatement':\r\n                      return `throw ${flatten(ast.argument)}`;\r\n                    case 'ObjectPattern':\r\n                      return ast.properties.map(flatten).join(', ');\r\n                    case 'ArrayPattern':\r\n                      return ast.elements.map(flatten).join(', ');\r\n                    case 'DebuggerStatement':\r\n                      return 'debugger;';\r\n                    case 'ConditionalExpression':\r\n                      return `${flatten(ast.test)}?${flatten(ast.consequent)}:${flatten(ast.alternate)}`;\r\n                    case 'Property':\r\n                      if (ast.kind === 'init') {\r\n                        return flatten(ast.key);\r\n                      }\r\n            }\r\n            throw new Error(`unhandled ast.type of ${ ast.type }`);\r\n          }\r\n          const result = flatten(ast);\r\n          if (functionDependencies.length > 0) {\r\n            const flattenedFunctionDependencies = [];\r\n            for (let i = 0; i < functionDependencies.length; i++) {\r\n              const functionDependency = functionDependencies[i];\r\n              if (!flattened[functionDependency]) {\r\n                flattened[functionDependency] = true;\r\n              }\r\n              functionDependency ? flattenedFunctionDependencies.push(utils.flattenFunctionToString(functionDependency, settings) + '\\n') : '';\r\n            }\r\n            return flattenedFunctionDependencies.join('') + result;\r\n          }\r\n          return result;\r\n        },\r\n      \r\n        normalizeDeclarations: (ast) => {\r\n          if (ast.type !== 'VariableDeclaration') throw new Error('Ast is not of type \"VariableDeclaration\"');\r\n          const normalizedDeclarations = [];\r\n          for (let declarationIndex = 0; declarationIndex < ast.declarations.length; declarationIndex++) {\r\n            const declaration = ast.declarations[declarationIndex];\r\n            if (declaration.id && declaration.id.type === 'ObjectPattern' && declaration.id.properties) {\r\n              const { properties } = declaration.id;\r\n              for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {\r\n                const property = properties[propertyIndex];\r\n                if (property.value.type === 'ObjectPattern' && property.value.properties) {\r\n                  for (let subPropertyIndex = 0; subPropertyIndex < property.value.properties.length; subPropertyIndex++) {\r\n                    const subProperty = property.value.properties[subPropertyIndex];\r\n                    if (subProperty.type === 'Property') {\r\n                      normalizedDeclarations.push({\r\n                        type: 'VariableDeclarator',\r\n                        id: {\r\n                          type: 'Identifier',\r\n                          name: subProperty.key.name\r\n                        },\r\n                        init: {\r\n                          type: 'MemberExpression',\r\n                          object: {\r\n                            type: 'MemberExpression',\r\n                            object: declaration.init,\r\n                            property: {\r\n                              type: 'Identifier',\r\n                              name: property.key.name\r\n                            },\r\n                            computed: false\r\n                          },\r\n                          property: {\r\n                            type: 'Identifier',\r\n                            name: subProperty.key.name\r\n                          },\r\n                          computed: false\r\n                        }\r\n                      });\r\n                    } else {\r\n                      throw new Error('unexpected state');\r\n                    }\r\n                  }\r\n                } else if (property.value.type === 'Identifier') {\r\n                  normalizedDeclarations.push({\r\n                    type: 'VariableDeclarator',\r\n                    id: {\r\n                      type: 'Identifier',\r\n                      name: property.value && property.value.name ? property.value.name : property.key.name\r\n                    },\r\n                    init: {\r\n                      type: 'MemberExpression',\r\n                      object: declaration.init,\r\n                      property: {\r\n                        type: 'Identifier',\r\n                        name: property.key.name\r\n                      },\r\n                      computed: false\r\n                    }\r\n                  });\r\n                } else {\r\n                  throw new Error('unexpected state');\r\n                }\r\n              }\r\n            } else if (declaration.id && declaration.id.type === 'ArrayPattern' && declaration.id.elements) {\r\n              const { elements } = declaration.id;\r\n              for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {\r\n                const element = elements[elementIndex];\r\n                if (element.type === 'Identifier') {\r\n                  normalizedDeclarations.push({\r\n                    type: 'VariableDeclarator',\r\n                    id: {\r\n                      type: 'Identifier',\r\n                      name: element.name\r\n                    },\r\n                    init: {\r\n                      type: 'MemberExpression',\r\n                      object: declaration.init,\r\n                      property: {\r\n                        type: 'Literal',\r\n                        value: elementIndex,\r\n                        raw: elementIndex.toString(),\r\n                        start: element.start,\r\n                        end: element.end\r\n                      },\r\n                      computed: true\r\n                    }\r\n                  });\r\n                } else {\r\n                  throw new Error('unexpected state');\r\n                }\r\n              }\r\n            } else {\r\n              normalizedDeclarations.push(declaration);\r\n            }\r\n          }\r\n          return normalizedDeclarations;\r\n        },\r\n      \r\n        splitHTMLImageToRGB: (gpu, image) => {\r\n          const rKernel = gpu.createKernel(function(a) {\r\n            const pixel = a[this.thread.y][this.thread.x];\r\n            return pixel.r * 255;\r\n          }, {\r\n            output: [image.width, image.height],\r\n            precision: 'unsigned',\r\n            argumentTypes: { a: 'HTMLImage' },\r\n          });\r\n          const gKernel = gpu.createKernel(function(a) {\r\n            const pixel = a[this.thread.y][this.thread.x];\r\n            return pixel.g * 255;\r\n          }, {\r\n            output: [image.width, image.height],\r\n            precision: 'unsigned',\r\n            argumentTypes: { a: 'HTMLImage' },\r\n          });\r\n          const bKernel = gpu.createKernel(function(a) {\r\n            const pixel = a[this.thread.y][this.thread.x];\r\n            return pixel.b * 255;\r\n          }, {\r\n            output: [image.width, image.height],\r\n            precision: 'unsigned',\r\n            argumentTypes: { a: 'HTMLImage' },\r\n          });\r\n          const aKernel = gpu.createKernel(function(a) {\r\n            const pixel = a[this.thread.y][this.thread.x];\r\n            return pixel.a * 255;\r\n          }, {\r\n            output: [image.width, image.height],\r\n            precision: 'unsigned',\r\n            argumentTypes: { a: 'HTMLImage' },\r\n          });\r\n          const result = [\r\n            rKernel(image),\r\n            gKernel(image),\r\n            bKernel(image),\r\n            aKernel(image),\r\n          ];\r\n          result.rKernel = rKernel;\r\n          result.gKernel = gKernel;\r\n          result.bKernel = bKernel;\r\n          result.aKernel = aKernel;\r\n          result.gpu = gpu;\r\n          return result;\r\n        },\r\n      \r\n        splitRGBAToCanvases: (gpu, rgba, width, height) => {\r\n          const visualKernelR = gpu.createKernel(function(v) {\r\n            const pixel = v[this.thread.y][this.thread.x];\r\n            this.color(pixel.r / 255, 0, 0, 255);\r\n          }, {\r\n            output: [width, height],\r\n            graphical: true,\r\n            argumentTypes: { v: 'Array2D(4)' }\r\n          });\r\n          visualKernelR(rgba);\r\n      \r\n          const visualKernelG = gpu.createKernel(function(v) {\r\n            const pixel = v[this.thread.y][this.thread.x];\r\n            this.color(0, pixel.g / 255, 0, 255);\r\n          }, {\r\n            output: [width, height],\r\n            graphical: true,\r\n            argumentTypes: { v: 'Array2D(4)' }\r\n          });\r\n          visualKernelG(rgba);\r\n      \r\n          const visualKernelB = gpu.createKernel(function(v) {\r\n            const pixel = v[this.thread.y][this.thread.x];\r\n            this.color(0, 0, pixel.b / 255, 255);\r\n          }, {\r\n            output: [width, height],\r\n            graphical: true,\r\n            argumentTypes: { v: 'Array2D(4)' }\r\n          });\r\n          visualKernelB(rgba);\r\n      \r\n          const visualKernelA = gpu.createKernel(function(v) {\r\n            const pixel = v[this.thread.y][this.thread.x];\r\n            this.color(255, 255, 255, pixel.a / 255);\r\n          }, {\r\n            output: [width, height],\r\n            graphical: true,\r\n            argumentTypes: { v: 'Array2D(4)' }\r\n          });\r\n          visualKernelA(rgba);\r\n          return [\r\n            visualKernelR.canvas,\r\n            visualKernelG.canvas,\r\n            visualKernelB.canvas,\r\n            visualKernelA.canvas,\r\n          ];\r\n        },\r\n      \r\n        getMinifySafeName: (fn) => {\r\n          try {\r\n            const ast = acorn.parse(`const value = ${fn.toString()}`);\r\n            const { init } = ast.body[0].declarations[0];\r\n            return init.body.name || init.body.body[0].argument.name;\r\n          } catch (e) {\r\n            throw new Error('Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }');\r\n          }\r\n        },\r\n        sanitizeName: function(name) {\r\n          if (dollarSign.test(name)) {\r\n            name = name.replace(dollarSign, 'S_S');\r\n          }\r\n          if (doubleUnderscore.test(name)) {\r\n            name = name.replace(doubleUnderscore, 'U_U');\r\n          } else if (singleUnderscore.test(name)) {\r\n            name = name.replace(singleUnderscore, 'u_u');\r\n          }\r\n          return name;\r\n        }\r\n      };\r\n      \r\n      const dollarSign = /\\$/;\r\n      const doubleUnderscore = /__/;\r\n      const singleUnderscore = /_/;\r\n      \r\n      const _systemEndianness = utils.getSystemEndianness();\r\n      \r\n      module.exports = {\r\n        utils\r\n      };\r\n      },{\"./input\":110,\"./texture\":113,\"acorn\":1}]},{},[107])(107)\r\n      });","//By Joshua Brewster, Dovydas Stirpeika (AGPL v3.0 License)\r\n//------------------------------------\r\n//---------GPU Utility Funcs---------- (gpu.addFunction())\r\n//------------------------------------\r\n\r\n\r\nfunction add(a, b) { return a + b; }\r\nfunction sub(a, b) { return a - b; }\r\nfunction mul(a, b) { return a * b; }\r\nfunction div(a, b) { return a / b; }\r\n\r\nfunction cadd(a_real, a_imag, b_real, b_imag) {\r\n    return [a_real + b_real, a_imag + b_imag];\r\n}\r\n\r\nfunction csub(a_real, a_imag, b_real, b_imag) {\r\n    return [a_real - b_real, a_imag - b_imag];\r\n}\r\n\r\nfunction cmul(a_real, a_imag, b_real, b_imag) {\r\n    return [a_real*b_real - a_imag*b_imag, a_real*b_imag + a_imag*b_real];\r\n}\r\n\r\nfunction cexp(a_real, a_imag) {\r\n    const er = Math.exp(a_real);\r\n    return [er * Math.cos(a_imag), er * Math.sin(a_imag)];\r\n}\r\n\r\nfunction mag(a, b) { // Returns magnitude\r\n    return Math.sqrt(a*a + b*b);\r\n}\r\n\r\nfunction conj(imag) { //Complex conjugate of x + iy is x - iy\r\n    return 0 - imag;\r\n}\r\n\r\nfunction lof(n) { //Lowest odd factor\r\n    const sqrt_n = Math.sqrt(n);\r\n    var factor = 3;\r\n\r\n    while(factor <= sqrt_n) {\r\n        if (n % factor === 0) return factor;\r\n        factor += 2;\r\n    }\r\n}\r\n\r\nfunction mean(arr, len) {\r\n    var mean = 0;\r\n    for (var i = 0; i < len; i++) {\r\n        mean += arr[i];\r\n    }\r\n    return mean/len;\r\n}\r\n\r\nfunction est(arr, mean, len) {\r\n    var est = 0;\r\n    for (var i=0; i<len;i++){\r\n        est += (arr[i]-mean)*(arr[i]-mean);\r\n    }\r\n    return Math.sqrt(est);\r\n}\r\n\r\nfunction mse(arr, mean, len) { //mean squared error\r\n    var est = 0;\r\n    var vari = 0;\r\n    for (var i = 0; i < len; i++) {\r\n        vari = arr[i]-mean;\r\n        est += vari*vari;\r\n    }\r\n    return est/len;\r\n}\r\n\r\nfunction rms(arr, mean, len) { //root mean square error\r\n    var est = 0;\r\n    var vari = 0;\r\n    for (var i = 0; i < len; i++) {\r\n        vari = arr[i]-mean;\r\n        est += vari*vari;\r\n    }\r\n    return Math.sqrt(est/len);\r\n}\r\n\r\nfunction xcor(arr1, arr1mean, arr1Est, arr2, arr2mean, arr2Est, len, delay) { //performs a single pass of a cross correlation equation, see correlogramsKern\r\n    var correlation = 0;\r\n    for (var i = 0; i < len; i++)  {\r\n        var j = i+delay;\r\n        var k = 0;\r\n        if(j < len) { k = arr2[j]; }\r\n        correlation += (arr1[i]-arr1mean)*(k-arr2mean);\r\n    }\r\n    return correlation/(arr1Est*arr2Est);\r\n}\r\n\r\nfunction softmax(array, len, i) { // Returns a single array value for a 1d softmax function.\r\n    var esum = 0;\r\n    for(var j = 0; j < len; j++){\r\n        esum+= Math.exp(array[j]);\r\n    }\r\n    return Math.exp(array[i])/esum;\r\n}\r\n\r\nfunction DFT(signal, len, freq){ //Extract a particular frequency\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    for(var i = 0; i<len; i++){\r\n      var sharedi = shared*i; //this.thread.x is the target frequency\r\n      real = real+signal[i]*Math.cos(sharedi);\r\n      imag = imag-signal[i]*Math.sin(sharedi);\r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real*_len,imag*_len]; //mag(real,imag)\r\n}\r\n\r\nfunction DFTlist(signals, len, freq, n) { //Extract a particular frequency\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n    for(var i = 0; i<len; i++){\r\n      var sharedi = shared*i; //this.thread.x is the target frequency\r\n      real = real+signals[i+(len-1)*n]*Math.cos(sharedi);\r\n      imag = imag-signals[i+(len-1)*n]*Math.sin(sharedi);  \r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real*_len,imag*_len]; //mag(real,imag)\r\n}\r\n\r\n//FFT, simply implements a nyquist frequency based index skip for frequencies <= sampleRate*.25.\r\n//Other optimization: could do 4 loops per thread and return a vec4, this is what you see in some other ultrafast libs\r\nfunction FFT(signal, len, freq, sr){ //Extract a particular frequency\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    var skip = 1;\r\n    var N = 0;\r\n    var factor = sr*.25;\r\n    if(freq <= factor){\r\n        while(freq <= factor){\r\n            factor=factor*.5;\r\n            skip+=1;\r\n        }\r\n    }\r\n\r\n    for(var i = 0; i<len; i+=skip){\r\n      var j = i;\r\n      if(j > len) { j = len; }\r\n      var sharedi = shared*j; //this.thread.x is the target frequency\r\n      real = real+signal[j]*Math.cos(sharedi);\r\n      imag = imag-signal[j]*Math.sin(sharedi);\r\n      N += 1;\r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real/N,imag/N]; //mag(real,imag)\r\n}\r\n\r\nfunction FFTlist(signals, len, freq, n, sr) { //Extract a particular frequency from a 1D list of equal sized signal arrays. Uses less samples for lower frequencies closer to nyquist threshold\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    var skip = 1;\r\n    var N = 0;\r\n    var factor = sr*.25;\r\n    if(freq <= factor){\r\n        while(freq <= factor){\r\n            factor=factor*.5;\r\n            skip+=1;\r\n        }\r\n    }\r\n\r\n    for(var i = 0; i<len; i+=skip){\r\n        var j = i;\r\n      if(j > len) { j = len; }\r\n      var sharedi = shared*j; //this.thread.x is the target frequency\r\n      real = real+signals[j+(len-1)*n]*Math.cos(sharedi);\r\n      imag = imag-signals[j+(len-1)*n]*Math.sin(sharedi);\r\n      N += 1;  \r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real/N,imag/N]; //mag(real,imag)\r\n}\r\n\r\n//Conjugated real and imaginary parts for iDFT (need to test still)\r\nfunction iDFT(fft, len, freq){ //inverse DFT to return time domain\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    for(var i = 0; i<len; i++){\r\n      var sharedi = shared*i; //this.thread.x is the target frequency\r\n      real = real+fft[i]*Math.cos(sharedi);\r\n      imag = fft[i]*Math.sin(sharedi)-imag;  \r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real*_len,imag*_len]; //mag(real,imag)\r\n}\r\n\r\nfunction iDFTlist(fft,len,freq,n){ //inverse DFT to return time domain \r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len\r\n    for (var i = 0; i<len; i++) {\r\n      var sharedi = shared*i; //this.thread.x is the target frequency\r\n      real = real+fft[i+(len-1)*n]*Math.cos(sharedi);\r\n      imag = fft[i+(len-1)*n]*Math.sin(sharedi)-imag;  \r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real*_len,imag*_len]; //mag(real,imag)\r\n}\r\n\r\nfunction iFFT(fft, len, freq, sr){ //inverse FFT to return time domain\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    var skip = 1;\r\n    var N = 0;\r\n    var factor = sr*.25;\r\n    if(freq <= factor){\r\n        while(freq <= factor){\r\n            factor=factor*.5;\r\n            skip+=1;\r\n        }\r\n    }\r\n\r\n    for(var i = 0; i<len; i+=skip){\r\n      var j = i;\r\n      if(j > len) { j = len; }\r\n      var sharedi = shared*j; //this.thread.x is the target frequency\r\n      real = real+fft[j]*Math.cos(sharedi);\r\n      imag = fft[j]*Math.sin(sharedi)-imag;  \r\n      N += 1;\r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real/N,imag/N]; //mag(real,imag)\r\n}\r\n\r\nfunction iFFTlist(signals, len, freq, n, sr) { //Extract a particular frequency from a 1D list of equal sized signal arrays. Uses less samples for lower frequencies closer to nyquist threshold\r\n    var real = 0;\r\n    var imag = 0;\r\n    var _len = 1/len;\r\n    var shared = 6.28318530718*freq*_len;\r\n\r\n    var skip = 1;\r\n    var N = 0;\r\n    var factor = sr*.25;\r\n    if(freq <= factor){\r\n        while(freq <= factor){\r\n            factor=factor*.5;\r\n            skip+=1;\r\n        }\r\n    }\r\n\r\n    for(var i = 0; i<len; i+=skip){\r\n        var j = i;\r\n      if(j > len) { j = len; }\r\n      var sharedi = shared*j; //this.thread.x is the target frequency\r\n      real = real+signals[j+(len-1)*n]*Math.cos(sharedi);\r\n      imag = signals[j+(len-1)*n]*Math.sin(sharedi)-imag;\r\n      N += 1;  \r\n    }\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return [real/N,imag/N]; //mag(real,imag)\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//------------------------------------\r\n//---------Kernel functions----------- (gpu.createKernel(func))\r\n//------------------------------------\r\n\r\n\r\nfunction correlogramsKern(arrays, len) { //Computes cross correlations of each pair of arrays given to the function. so xcor[0,1],xcor[2,3],etc\r\n\r\n    var k = Math.floor(this.thread.x/len)*2;\r\n    var delay = this.thread.x - Math.floor(this.thread.x/len)*len;\r\n    var arr1mean = mean(arrays[k],len);\r\n    var arr2mean = mean(arrays[k+1],len);\r\n    var arr1Est = est(arrays[k],arr1mean,len);\r\n    var arr2Est = est(arrays[k+1],arr2mean,len);\r\n\r\n    var y_x = xcor(arrays[k],arr1mean,arr1Est,arrays[k+1],arr2mean,arr2Est,len,delay);\r\n\r\n    return y_x;\r\n}\r\n\r\n//Computes cross correlations of each pair of arrays given to the function. so xcor[0,1],xcor[2,3],etc\r\n//Takes precomputed averages and estimators for each array for efficiency\r\nfunction correlogramsPCKern(arrays, len, means, estimators) { \r\n    var k = Math.floor(this.thread.x/len)*2;\r\n    var delay = this.thread.x - Math.floor(this.thread.x/len)*len;\r\n    var arr1mean = means[k];\r\n    var arr2mean = means[k+1];\r\n    var arr1Est = estimators[k];\r\n    var arr2Est = estimators[k+1];\r\n\r\n    var y_x = xcor(arrays[k],arr1mean,arr1Est,arrays[k+1],arr2mean,arr2Est,len,delay);\r\n\r\n    return y_x;\r\n}\r\n\r\n\r\n//Return frequency domain based on DFT\r\nfunction dftKern(signal, len, scalar) {\r\n    var result = DFT(signal,len, this.thread.x);\r\n    return mag(result[0], result[1])*scalar;\r\n}\r\n\r\nfunction idftKern(amplitudes, len, scalar) {\r\n    var result = iDFT(amplitudes, len, this.thread.x);\r\n    return mag(result[0], result[1])*scalar;\r\n}\r\n\r\nfunction fftKern(signal, len, scalar, sampleRate) {\r\n    var result = FFT(signal,len, this.thread.x, sampleRate);\r\n    return mag(result[0], result[1])*scalar;\r\n}\r\n\r\nfunction ifftKern(amplitudes, len, scalar, sampleRate) {\r\n    var result = iFFT(amplitudes, len, this.thread.x, sampleRate);\r\n    return mag(result[0], result[1])*scalar;\r\n}\r\n\r\n// Takes a 2D array input [signal1[],signal2[],signal3[]]; does not work atm\r\nfunction listdft2DKern(signals, scalar) {\r\n    var len = this.output.x;\r\n    var result = DFT(signals[this.thread.y],len,this.thread.x);\r\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\r\n    return mag(result[0],result[1])*scalar; //mag(real,imag)\r\n}\r\n\r\n// [[signals1][signals2]]\r\n\r\n// More like a vertex buffer list to chunk through lists of signals\r\nfunction listdft1DKern(signals, len, scalar) {\r\n    var result = [0, 0];\r\n    if (this.thread.x <= len) {\r\n      result = DFT(signals,len,this.thread.x);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/len);\r\n      result = DFTlist(signals,len,this.thread.x-n*len,n);\r\n    }\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n} // [signals1,signasl2]\r\n\r\n// More like a vertex buffer list to chunk through lists of signals\r\nfunction listfft1DKern(signals, len, scalar, sps) {\r\n    var result = [0, 0];\r\n    if (this.thread.x <= len) {\r\n      result = FFT(signals,len,this.thread.x,sps);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/len);\r\n      result = FFTlist(signals,len,this.thread.x-n*len,n,sps);\r\n    }\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n} // [signals1,signasl2]\r\n\r\nfunction dft_windowedKern(signal, sampleRate, freqStart, freqEnd, scalar) {\r\n    var result = [0,0];\r\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n    result = DFT(signal,sampleRate,freq);\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n} \r\n\r\n\r\n//windowed functions should use a 1 second window for these hacky DFTs/FFTs to work right.\r\n\r\nfunction fft_windowedKern(signal, sampleRate, freqStart, freqEnd, scalar) {\r\n    var result = [0,0];\r\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n    result = FFT(signal,sampleRate,freq);\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n}\r\n\r\nfunction idft_windowedKern(amplitudes, sampleRate, freqStart, freqEnd, scalar) {\r\n    var result = [0,0];\r\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n    result = iDFT(amplitudes,sampleRate,freq);\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n}\r\n\r\nfunction ifft_windowedKern(amplitudes, sampleRate, freqStart, freqEnd, scalar) {\r\n    var result = [0,0];\r\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n    result = iFFT(amplitudes,sampleRate,freq);\r\n\r\n    return mag(result[0],result[1])*scalar;\r\n}\r\n\r\nfunction listdft1D_windowedKern(signals, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\r\n    var result = [0, 0];\r\n    if (this.thread.x < sampleRate) {\r\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = DFT(signals,sampleRate,freq);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/sampleRate);\r\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = DFTlist(signals,sampleRate,freq-n*sampleRate,n);\r\n    }\r\n    //var mags = mag(result[0],result[1]);\r\n\r\n    return mag(result[0],result[1])*scalar; \r\n}\r\n\r\nfunction listfft1D_windowedKern(signals, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\r\n    var result = [0, 0];\r\n    if (this.thread.x < sampleRate) {\r\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = FFT(signals,sampleRate,freq,sampleRate);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/sampleRate);\r\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = FFTlist(signals,sampleRate,freq-n*sampleRate,n,sampleRate);\r\n    }\r\n    //var mags = mag(result[0],result[1]);\r\n\r\n    return mag(result[0],result[1])*scalar; \r\n}\r\n\r\nfunction listidft1D_windowedKern(ffts, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\r\n    var result = [0, 0];\r\n    if (this.thread.x < sampleRate) {\r\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = iDFT(ffts,sampleRate,freq);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/sampleRate);\r\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = iDFTlist(ffts,sampleRate,freq-n*sampleRate,n);\r\n    }\r\n    //var mags = mag(result[0],result[1]);\r\n\r\n    return mag(result[0]*2,result[1]*2)*scalar; //Multiply result by 2 since we are only getting the positive results and want to estimate the actual amplitudes (positive = half power, reflected in the negative axis)\r\n}\r\n\r\nfunction listifft1D_windowedKern(ffts, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\r\n    var result = [0, 0];\r\n    if (this.thread.x < sampleRate) {\r\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = iFFT(ffts,sampleRate,freq);\r\n    } else {\r\n      var n = Math.floor(this.thread.x/sampleRate);\r\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\r\n      result = iFFTlist(ffts,sampleRate,freq-n*sampleRate,n);\r\n    }\r\n    //var mags = mag(result[0],result[1]);\r\n\r\n    return mag(result[0]*2,result[1]*2)*scalar; //Multiply result by 2 since we are only getting the positive results and want to estimate the actual amplitudes (positive = half power, reflected in the negative axis)\r\n}\r\n\r\n//e.g. arrays = [[arr1],[arr2],[arr3],[arr4],[arr5],[arr6]], len = 10, n = 2, scalar=1... return results of [arr1*arr2], [arr3*arr4], [arr5*arr6] as one long array that needs to be split\r\nfunction bulkArrayMulKern(arrays, len, n, scalar) {\r\n    var i = n*Math.floor(this.thread.x/len); //Jump forward in array buffer\r\n    var product = arrays[i][this.thread.x];\r\n    for (var j = 0; j < n; j++) {\r\n      product *= arrays[j][this.thread.x];\r\n    }\r\n    return product*scalar;\r\n}\r\n\r\nfunction ImgConv2DKern(img, width, height, kernel, kernelLength) {\r\n    let kernelRadius = (Math.sqrt(kernelLength) - 1) / 2;\r\n    const kSize = 2 * kernelRadius + 1;\r\n    let r = 0, g = 0, b = 0;\r\n\r\n    let i = -kernelRadius;\r\n    let kernelOffset = 0;\r\n    while (i <= kernelRadius) {\r\n        if (this.thread.x + i < 0 || this.thread.x + i >= width) {\r\n            i++;\r\n            continue;\r\n        }\r\n\r\n        let j = -kernelRadius;\r\n        while (j <= kernelRadius) {\r\n            if (this.thread.y + j < 0 || this.thread.y + j >= height) {\r\n                j++;\r\n                continue;\r\n            }\r\n\r\n            kernelOffset = (j + kernelRadius) * kSize + i + kernelRadius;\r\n            const weights = kernel[kernelOffset];\r\n            const pixel = img[this.thread.y + i][this.thread.x + j];\r\n            r += pixel.r * weights;\r\n            g += pixel.g * weights;\r\n            b += pixel.b * weights;\r\n            j++;\r\n        }\r\n        i++;\r\n    }\r\n\r\n    this.color(r, g, b);\r\n}\r\n\r\nfunction multiImgConv2DKern(img, width, height, kernels, kernelLengths, nKernels) {\r\n    \r\n    let r = 0, g = 0, b = 0;\r\n    for(var i = 0; i < nKernels; i++){\r\n\r\n        let kernelLength = kernelLengths[i];            \r\n        let kernelRadius = (Math.sqrt(kernelLength) - 1) / 2;\r\n        //(src, width, height, kernel, kernelRadius)\r\n        const kSize = 2 * kernelRadius + 1;\r\n        \r\n        let k = -kernelRadius;\r\n        let kernelOffset = 0;\r\n        while (k <= kernelRadius) {\r\n            if (this.thread.x + k < 0 || this.thread.x + k >= width) {\r\n                k++;\r\n                continue;\r\n            }\r\n\r\n            let j = -kernelRadius;\r\n            while (j <= kernelRadius) {\r\n                if (this.thread.y + j < 0 || this.thread.y + j >= height) {\r\n                j++;\r\n                continue;\r\n                }\r\n\r\n                kernelOffset = (j + kernelRadius) * kSize + k + kernelRadius;\r\n                const weights = kernels[i][kernelOffset];\r\n                const pixel = img[this.thread.y + k][this.thread.x + j];\r\n    \r\n                r += pixel.r * weights;\r\n                g += pixel.g * weights;\r\n                b += pixel.b * weights;\r\n            \r\n                //img[this.thread.y + k][this.thread.x + j] = pixel;      \r\n                    \r\n                j++;\r\n            }\r\n            k++;\r\n        }\r\n    }\r\n    this.color(r,g,b);\r\n}\r\n\r\nfunction transpose2DKern(mat2) { //Transpose a 2D matrix, meant to be combined\r\n    return mat2[this.thread.y][this.thread.x];\r\n}\r\n\r\n\r\n//function deferredPass(vPos, vNorm, vAlbedo, vDepth, vSpec) {  } //project geometry, light geometry\r\n\r\n/*\r\nScene drawing:\r\n(With depth testing enabled)\r\n1. Project object local spaces to world space based on geometry and world coordinates\r\n1.5 do some occlusion culling for which texture data to send to the gpu, requires last camera matrix\r\n2. Now send to lighting pass, with coloring properties defined by different texture maps. \r\n3. Project result to camera space based on camera position and aperture.\r\n4. Draw result\r\n*/\r\n\r\n\r\n//Note on pixel operations in gpujs: create kernel with setGraphical(true), render() to offscreencanvas, get render.getPixels() on each frame for pixel values which can be stored math operations\r\n\r\n\r\n//Exports\r\n\r\nexport const createGpuKernels = {\r\n    correlogramsKern, correlogramsPCKern, dftKern, idftKern, fftKern, ifftKern,\r\n    dft_windowedKern, idft_windowedKern, fft_windowedKern, ifft_windowedKern, \r\n    listdft2DKern, listdft1DKern, listfft1DKern, listfft1D_windowedKern, listdft1D_windowedKern, listidft1D_windowedKern, listifft1D_windowedKern,\r\n    bulkArrayMulKern, fftKern, ifftKern, multiImgConv2DKern,\r\n    ImgConv2DKern\r\n}\r\n\r\nexport const addGpuFunctions = [\r\n    add, sub, mul, div, cadd, csub,\r\n    cmul, cexp, mag, conj, lof, mean, est,\r\n    mse, rms, xcor, softmax, DFT, DFTlist,\r\n    iDFT, iDFTlist, FFT, iFFT, iFFTlist\r\n];","import './gpu-browser.min.js' // becomes a window variable\r\nimport { addGpuFunctions, createGpuKernels as krnl } from './gpuUtils-functs';\r\n\r\n//By Joshua Brewster, Dovydas Stirpeika (AGPL v3.0 License)\r\n\r\nexport function makeKrnl(gpu, f, opts = {\r\n  setDynamicOutput: true,\r\n  setDynamicArguments: true,\r\n  setPipeline: true,\r\n  setImmutable: true,\r\n  setGraphical: false\r\n}) {\r\n\r\n  const k = gpu.createKernel(f);\r\n\r\n  if (opts.setDynamicOutput)    k.setDynamicOutput(true);\r\n  if (opts.output)              k.setOutput(opts.output);\r\n  if (opts.setDynamicArguments) k.setDynamicArguments(true);\r\n  if (opts.setPipeline)         k.setPipeline(true);\r\n  if (opts.setImmutable)        k.setImmutable(true);\r\n  if (opts.setGraphical)        k.setGraphical(true);\r\n\r\n  //.setOutput([signal.length]) //Call before running the kernel\r\n  //.setLoopMaxIterations(signal.length);\r\n\r\n  return k;\r\n}\r\n\r\nexport function makeCanvasKrnl(toAppend, gpu, f, opts = {\r\n  output: [300,300],\r\n  setDynamicArguments: true,\r\n  setDynamicOutput: true,\r\n  setPipeline: false,\r\n  setImmutable: true,\r\n  setGraphical: true\r\n}) {\r\n\r\n  const k = makeKrnl(gpu,f,opts);\r\n\r\n  //k();\r\n\r\n  const canvas = k.canvas; \r\n\r\n  if (typeof toAppend === 'string') document.getElementById(toAppend).appendChild(canvas);\r\n  else toAppend.appendChild(canvas);\r\n\r\n  return k; //run k() with the input arguments in an animation loop, get graphical output.\r\n}\r\n\r\nexport class gpuUtils {\r\n  \r\n  constructor(gpu = new GPU()) {\r\n    this.gpu = gpu;\r\n    this.kernels = []; // {name:\"\",f:foo(){}}\r\n\r\n    this.kernel;\r\n    this.PI = 3.141592653589793;\r\n    this.SQRT1_2 = 0.7071067811865476\r\n\r\n    this.addFunctions();\r\n\r\n    this.imgkernels = {\r\n      edgeDetection: [\r\n        -1, -1, -1,\r\n        -1,  8, -1,\r\n        -1, -1, -1\r\n      ], boxBlur: [\r\n        1/9, 1/9, 1/9,\r\n        1/9, 1/9, 1/9,\r\n        1/9, 1/9, 1/9\r\n      ], sobelLeft: [\r\n        1,  0, -1,\r\n        2,  0, -2,\r\n        1,  0, -1\r\n      ], sobelRight: [\r\n        -1, 0, 1,\r\n        -2, 0, 2,\r\n        -1, 0, 1\r\n      ], sobelTop: [\r\n        1,  2,  1,\r\n        0,  0,  0,\r\n        -1, -2, -1  \r\n      ], sobelBottom: [\r\n        -1, 2, 1,\r\n        0, 0, 0,\r\n        1, 2, 1\r\n      ], identity: [\r\n        0, 0, 0, \r\n        0, 1, 0, \r\n        0, 0, 0\r\n      ], gaussian3x3: [\r\n        1,  2,  1, \r\n        2,  4,  2, \r\n        1,  2,  1\r\n      ], guassian7x7: [\r\n        0, 0,  0,   5,   0,   0,  0,\r\n        0, 5,  18,  32,  18,  5,  0,\r\n        0, 18, 64,  100, 64,  18, 0,\r\n        5, 32, 100, 100, 100, 32, 5,\r\n        0, 18, 64,  100, 64,  18, 0,\r\n        0, 5,  18,  32,  18,  5,  0,\r\n        0, 0,  0,   5,   0,   0,  0,\r\n      ], emboss: [\r\n        -2, -1,  0, \r\n        -1,  1,  1, \r\n        0,  1,  2\r\n      ], sharpen: [\r\n        0, -1,  0,\r\n        -1,  5, -1,\r\n        0, -1,  0\r\n      ]\r\n    };\r\n  }\r\n\r\n  //adds math functions to use per-thread\r\n  addFunction(func = function f(){}) {\r\n    this.gpu.addFunction(func);\r\n  }\r\n\r\n  //add kernels to run based on input data. Input/Output sizes are dynamically allocated, functions are saved on the gpu to improve runtimes\r\n  addKernel(name=\"\", krnl=function foo(){}) {\r\n    let found = this.kernels.find((o)=> {\r\n      if(o.name === name) {\r\n        return true;\r\n      }\r\n    });\r\n    if(!found) {\r\n      this.kernels.push({name:name, krnl:makeKrnl(this.gpu,krnl)});\r\n      return true;\r\n    } else { \r\n      console.error('Kernel already exists'); \r\n      return false;\r\n    }\r\n    \r\n  }\r\n\r\n  addCanvasKernel(name, f, toAppend, opts) {\r\n    let found = this.kernels.find((o)=> {\r\n      if(o.name === name) {\r\n        return true;\r\n      }\r\n    });\r\n    if(!found) {\r\n      let krnl = makeCanvasKrnl(toAppend,this.gpu,f, opts)\r\n      this.kernels.push({name,krnl});\r\n      return krnl;\r\n    } else { \r\n      console.error('Kernel already exists'); \r\n      return false;\r\n    }\r\n    \r\n  }\r\n\r\n  //combine two or more kernels into a single function, this lets you run multiple kernels on the GPU (with appropriately varying inputs/output sizes) before returning to the CPU.\r\n  //Discount compute shaders\r\n  combineKernels(name, fs=[], ckrnl=function foo() {}) {\r\n    let found = this.kernels.find((o)=> {\r\n      if(o.name === name) {\r\n        return true;\r\n      }\r\n    });\r\n    if(!found) {\r\n      fs.forEach((f,i)=>{\r\n        if(typeof f === 'string') {\r\n          let found2 = this.krnl.find((o)=> {\r\n            if(o.name === name) {\r\n              return true;\r\n            }\r\n          });\r\n          if(found2) fs[i] = found2.kernel;\r\n          else return false;\r\n        } else if (typeof f === 'function') {\r\n          if(this[f.name]) {\r\n            //cool\r\n          } else {\r\n            this.addKernel(f.name, f);\r\n          }\r\n        }\r\n      });\r\n      this.kernels.push({name:name, krnl:this.gpu.combineKernels(...fs,ckrnl)});\r\n      return true;\r\n    } else { \r\n      console.error('Kernel already exists'); \r\n      return false;\r\n    }\r\n  }\r\n\r\n  callKernel(name=\"\",args=[]) {\r\n    let result;\r\n    let found = this.kernels.find((o)=> {\r\n      if(o.name === name) {\r\n        //console.log(o.krnl,args)\r\n        result = o.krnl(...args);\r\n        return true;\r\n      }\r\n    });\r\n    if(!found) {\r\n      console.error('Kernel not found');\r\n      return false;\r\n    } else return result;\r\n  }\r\n\r\n  callCanvasKernel(name=\"\",args=[],outputDims=[]) {\r\n    let result;\r\n    let found = this.kernels.find((o)=> {\r\n      if(o.name === name) {\r\n        //console.log(o.krnl,args)\r\n        if (outputDims.length === 2) o.krnl.setOutput(outputDims);\r\n        result = o.krnl(...args);\r\n        return true;\r\n      }\r\n    });\r\n    if(!found) {\r\n      console.error('Kernel not found');\r\n      return false;\r\n    } else return result;\r\n  }\r\n\r\n  hasKernel(name=\"\") {\r\n    let found = this.kernels.find((o)=> {\r\n      if(o.name === name) {\r\n        return true;\r\n      }\r\n    });\r\n    if(!found) {\r\n      return false;\r\n    } else return true;\r\n  }\r\n\r\n  addFunctions() { \r\n    addGpuFunctions.forEach(f => this.gpu.addFunction(f));\r\n\r\n    this.correlograms = makeKrnl(this.gpu, krnl.correlogramsKern);\r\n    this.correlogramsPC = makeKrnl(this.gpu, krnl.correlogramsKern);\r\n    this.dft = makeKrnl(this.gpu, krnl.dftKern);\r\n    this.idft = makeKrnl(this.gpu, krnl.idftKern);\r\n    this.dft_windowed = makeKrnl(this.gpu, krnl.dft_windowedKern);\r\n    this.idft_windowed = makeKrnl(this.gpu, krnl.idft_windowedKern);\r\n    this.fft = makeKrnl(this.gpu, krnl.fftKern);\r\n    this.ifft = makeKrnl(this.gpu, krnl.ifftKern);\r\n    this.fft_windowed = makeKrnl(this.gpu, krnl.fft_windowedKern);\r\n    this.ifft_windowed = makeKrnl(this.gpu, krnl.ifft_windowedKern);\r\n    this.listdft2D = makeKrnl(this.gpu, krnl.listdft2DKern);\r\n    this.listdft1D = makeKrnl(this.gpu, krnl.listdft1DKern);\r\n    this.listdft1D_windowed = makeKrnl(this.gpu, krnl.listdft1D_windowedKern);\r\n    this.listfft1D = makeKrnl(this.gpu, krnl.listfft1DKern);\r\n    this.listfft1D_windowed = makeKrnl(this.gpu, krnl.listfft1D_windowedKern);\r\n    this.listidft1D_windowed = makeKrnl(this.gpu, krnl.listidft1D_windowedKern);\r\n    this.listifft1D_windowed = makeKrnl(this.gpu, krnl.listifft1D_windowedKern);\r\n    this.bulkArrayMul = makeKrnl(this.gpu, krnl.bulkArrayMulKern);\r\n\r\n    this.kernels.push(\r\n      {name:\"correlograms\", krnl:this.correlograms},\r\n      {name:\"correlogramsPC\", krnl: this.correlogramsPC},\r\n      {name:\"dft\", krnl:this.dft},\r\n      {name:\"idft\", krnl:this.idft},\r\n      {name:\"dft_windowed\", krnl:this.idft_windowed},\r\n      {name:\"fft\", krnl:this.fft},\r\n      {name:\"ifft\", krnl:this.ifft},\r\n      {name:\"fft_windowed\", krnl:this.fft_windowed},\r\n      {name:\"ifft_windowed\", krnl:this.ifft_windowed},\r\n      {name:\"listdft2D\", krnl:this.listdft2D},\r\n      {name:\"listdft1D\", krnl:this.listdft1D},\r\n      {name:\"listdft1D_windowed\", krnl:this.listdft1D_windowed},\r\n      {name:\"listfft1D\", krnl:this.listfft1D},\r\n      {name:\"listfft1D_windowed\", krnl:this.listfft1D_windowed},\r\n      {name:\"listidft1D_windowed\", krnl:this.listidft1D_windowed},\r\n      {name:\"listifft1D_windowed\", krnl:this.listifft1D_windowed},\r\n      {name:\"bulkArrayMul\", krnl:this.bulkArrayMul}\r\n      );\r\n    \r\n    //----------------------------------- Easy gpu pipelining\r\n    //------------Combine Kernels-------- gpu.combineKernels(f1,f2,function(a,b,c) { f1(f2(a,b),c); });\r\n    //----------------------------------- TODO: Make this actually work (weird error)\r\n\r\n    //Bandpass FFT+iFFT to return a cleaned up waveform\r\n    const signalBandpass = (signal, sampleRate, freqStart, freqEnd, scalar) => { //Returns the signal wave with the bandpass filter applied\r\n      var dft = this.fft_windowed(signal, sampleRate, freqStart, freqEnd, scalar, 0);\r\n      var filtered_signal = this.ifft_windowed(dft, sampleRate, freqStart, freqEnd, scalar); \r\n      return filtered_signal;\r\n    }\r\n\r\n    //this.signalBandpass = this.gpu.combineKernels(this.dft_windowedKern,this.idft_windowedKern, signalBandpass);\r\n    \r\n    const signalBandpassMulti = (signals, sampleRate, freqStart, freqEnd, scalar) => {\r\n      var dfts = this.listdft1D_windowed(signals,sampleRate,freqStart,freqEnd,scalar, new Array(Math.ceil(signals/sampleRate)).fill(0));\r\n      var filtered_signals = this.listifft1D_windowed(dfts,sampleRate,freqStart,freqEnd,scalar);\r\n      return filtered_signals;\r\n    }\r\n\r\n    //this.signalBandpassMulti = this.gpu.combineKernels(this.listdft1D_windowed,this.listidft1D_windowed, signalBandpassMulti);\r\n\r\n    //TODO: automatic auto/cross correlation and ordering.\r\n    //Input signals like this : [signal1,signal2,autocor1,autocor2,crosscor,...repeat for desired coherence calculations] or any order of that.\r\n    this.gpuCoherence = (signals, sampleRate, freqStart, freqEnd, scalar) => { //Take FFTs of the signals, their autocorrelations, and cross correlation (5 FFTs per coherence), then multiply.\r\n      var xcors = this.correlograms(signals);\r\n      var dfts = this.listfft1D_windowed(xcors, sampleRate, freqStart, freqEnd, scalar, new Array(Math.ceil(signals/sampleRate)).fill(0) );\r\n      var products = this.bulkArrayMul(dfts, sampleRate, 5, 1);\r\n      return products;\r\n    }\r\n\r\n    //Need to get this working to be MUCH faster, the above method returns to the CPU each call, the below does not.\r\n    //this.gpuCoherence = this.gpu.combineKernels(this.listdft1D_windowedKern, this.bulkArrayMulKern, this.correlogramsKern, function gpuCoherence(signals,sampleRate,freqStart,freqEnd,scalar) {\r\n    //  var xcors = this.correlograms(signals);\r\n    //  var dfts = this.listdft1D_windowed(xcors, sampleRate, freqStart, freqEnd, scalar, new Array(Math.ceil(signals/sampleRate)).fill(0) );\r\n    //  var products = this.bulkArrayMul(dfts, sampleRate, 5, 1);\r\n    //  return products;\r\n    //});\r\n\r\n  }\r\n\r\n  gpuXCors(arrays, precompute=false, texOut = false) { //gpu implementation for bulk cross/auto correlations, outputs [[0:0],[0:1],...,[1:1],...[n:n]]\r\n \r\n    var outputTex;\r\n   \r\n    if(precompute === true) { //Precompute the means and estimators rather than in every single thread\r\n      var means = [];\r\n      var ests = [];\r\n      arrays.forEach((arr,i) => {\r\n        means.push(arr.reduce((prev,curr)=> curr += prev)/arr.length);\r\n        ests.push(Math.sqrt(means[i].reduce((sum,item) => sum += Math.pow(item-mean1,2))));\r\n      });\r\n\r\n      var meansbuf = [];\r\n      var estsbuf = [];\r\n      var buffer = [];\r\n      for(var i = 0; i < arrays.length; i++) {\r\n        for(var j = i; j < arrays.length; j++){\r\n          buffer.push(...arrays[i],...arrays[j]);\r\n          meansbuf.push(means[i],means[j]);\r\n          estsbuf.push(ests[i],ests[j]);\r\n        }\r\n      }\r\n\r\n      this.correlogramsPC.setOutput([buffer.length]);\r\n      this.correlogramsPC.setLoopMaxIterations(arrays[0].length*2);\r\n      outputTex = this.correlogramsPC(buffer, arrays[0].length, meansbuf, estsbuf)\r\n    }\r\n    else{\r\n      var buffer = [];\r\n      for(var i = 0; i < arrays.length; i++) {\r\n        for(var j = i; j < arrays.length; j++){\r\n          buffer.push(...arrays[i],...arrays[j]);\r\n        }\r\n      }\r\n\r\n      this.correlograms.setOutput([buffer.length]);\r\n      this.correlograms.setLoopMaxIterations(arrays[0].length*2);\r\n\r\n      outputTex = this.correlograms(buffer, arrays[0].length);\r\n    }\r\n\r\n    if(texOut === true) { return outputTex; }\r\n    var outputbuf = outputTex.toArray();\r\n    outputTex.delete();\r\n    var outputarrs = [];\r\n\r\n    for(var i = 0; i < arrays.length; i++){\r\n      outputarrs.push(outputbuf.splice(0, arrays[0].length));\r\n    }\r\n\r\n    return outputarrs;\r\n\r\n  } \r\n\r\n  //Input array buffer and the number of seconds of data\r\n  gpuDFT(signalBuffer, nSeconds, scalar=1, texOut = false){\r\n\r\n    var nSamples = signalBuffer.length;\r\n    var sampleRate = nSamples/nSeconds;\r\n\r\n    this.dft.setOutput([signalBuffer.length]);\r\n    this.dft.setLoopMaxIterations(nSamples);\r\n\r\n    var outputTex = this.dft(signalBuffer, nSamples, scalar);\r\n    var output = null;\r\n    if(texOut === false){\r\n      var freqDist = this.makeFrequencyDistribution(nSamples, sampleRate);\r\n      var signalBufferProcessed = outputTex.toArray();\r\n      //console.log(signalBufferProcessed);\r\n      outputTex.delete();\r\n      return [freqDist,this.orderMagnitudes(signalBufferProcessed)]; //Returns x (frequencies) and y axis (magnitudes)\r\n    }\r\n    else {\r\n      var tex = outputTex; \r\n      outputTex.delete(); \r\n      return tex;\r\n    }\r\n  }\r\n\r\n  //Input array of array buffers of the same length and the number of seconds recorded\r\n  MultiChannelDFT(signalBuffer, nSeconds, scalar=1, texOut=false) {\r\n    \r\n    var signalBufferProcessed = [];\r\n      \r\n    signalBuffer.forEach((row) => {\r\n      signalBufferProcessed.push(...row);\r\n    });\r\n    //console.log(signalBufferProcessed);\r\n  \r\n    var nSamplesPerChannel = signalBuffer[0].length;\r\n    var sampleRate = nSamplesPerChannel/nSeconds\r\n\r\n    this.listdft1D.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\r\n    this.listdft1D.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\r\n        \r\n    var outputTex = this.listdft1D(signalBufferProcessed,nSamplesPerChannel, scalar);\r\n    if(texOut === false){\r\n      var orderedMagsList = [];\r\n\r\n      var freqDist = this.makeFrequencyDistribution(nSamplesPerChannel, sampleRate);\r\n      signalBufferProcessed = outputTex.toArray();\r\n      //console.log(signalBufferProcessed);\r\n\r\n      for(var i = 0; i < signalBufferProcessed.length; i+=nSamplesPerChannel){\r\n        orderedMagsList.push(this.orderMagnitudes([...signalBufferProcessed.slice(i,i+nSamplesPerChannel)]));\r\n      }\r\n      //Now slice up the big buffer into individual arrays for each signal\r\n\r\n      outputTex.delete();\r\n      return [freqDist,orderedMagsList]; //Returns x (frequencies) and y axis (magnitudes)\r\n    }\r\n    else {\r\n      var tex = outputTex; \r\n      outputTex.delete(); \r\n      return tex;\r\n    }\r\n  }\r\n\r\n      \r\n  //Input buffer of signals [[channel 0],[channel 1],...,[channel n]] with the same number of samples for each signal. Returns arrays of the positive DFT results in the given window.\r\n  MultiChannelDFT_Bandpass(signalBuffer=[],nSeconds,freqStart,freqEnd, scalar=1, texOut = false) {\r\n\r\n    var signalBufferProcessed = [];\r\n      \r\n    signalBuffer.forEach((row) => {\r\n      signalBufferProcessed.push(...row);\r\n    });\r\n    //console.log(signalBufferProcessed);\r\n\r\n    var freqEnd_nyquist = freqEnd*2;\r\n    var nSamplesPerChannel = signalBuffer[0].length;\r\n    var sampleRate = nSamplesPerChannel/nSeconds;\r\n    \r\n    this.listdft1D_windowed.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\r\n    this.listdft1D_windowed.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\r\n        \r\n    var outputTex = this.listdft1D_windowed(signalBufferProcessed,sampleRate,freqStart,freqEnd_nyquist, scalar);\r\n    if(texOut === true) { return outputTex; }\r\n    \r\n    signalBufferProcessed = outputTex.toArray();\r\n    outputTex.delete();\r\n\r\n    //console.log(signalBufferProcessed)\r\n    //TODO: Optimize for SPEEEEEEED.. or just pass it str8 to a shader\r\n    var freqDist = this.bandPassWindow(freqStart,freqEnd,sampleRate);\r\n    return [freqDist, this.orderBPMagnitudes(signalBufferProcessed,nSeconds,sampleRate,nSamplesPerChannel)]; //Returns x (frequencies) and y axis (magnitudes)\r\n  \r\n  }\r\n\r\n  \r\n  //Input array buffer and the number of seconds of data\r\n  gpuFFT(signalBuffer, nSeconds, scalar=1, sampleRate, texOut = false){\r\n\r\n    var nSamples = signalBuffer.length;\r\n    var sampleRate = nSamples/nSeconds;\r\n\r\n    this.fft.setOutput([signalBuffer.length]);\r\n    this.fft.setLoopMaxIterations(nSamples);\r\n\r\n    var outputTex = this.fft(signalBuffer, nSamples, scalar, sampleRate);\r\n    var output = null;\r\n    if(texOut === false){\r\n      var freqDist = this.makeFrequencyDistribution(nSamples, sampleRate);\r\n      var signalBufferProcessed = outputTex.toArray();\r\n      //console.log(signalBufferProcessed);\r\n      outputTex.delete();\r\n      return [freqDist,this.orderMagnitudes(signalBufferProcessed)]; //Returns x (frequencies) and y axis (magnitudes)\r\n    }\r\n    else {\r\n      var tex = outputTex; \r\n      outputTex.delete(); \r\n      return tex;\r\n    }\r\n  }\r\n\r\n  //Input array of array buffers of the same length and the number of seconds recorded\r\n  MultiChannelFFT(signalBuffer, nSeconds, scalar=1, texOut=false) {\r\n    \r\n    var signalBufferProcessed = [];\r\n      \r\n    signalBuffer.forEach((row) => {\r\n      signalBufferProcessed.push(...row);\r\n    });\r\n    //console.log(signalBufferProcessed);\r\n  \r\n    var nSamplesPerChannel = signalBuffer[0].length;\r\n    var sampleRate = nSamplesPerChannel/nSeconds\r\n\r\n    this.listfft1D.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\r\n    this.listfft1D.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\r\n        \r\n    var outputTex = this.listfft1D(signalBufferProcessed,nSamplesPerChannel, scalar, sampleRate);\r\n    if(texOut === false){\r\n      var orderedMagsList = [];\r\n\r\n      var freqDist = this.makeFrequencyDistribution(nSamplesPerChannel, sampleRate);\r\n      signalBufferProcessed = outputTex.toArray();\r\n      //console.log(signalBufferProcessed);\r\n\r\n      for(var i = 0; i < signalBufferProcessed.length; i+=nSamplesPerChannel){\r\n        orderedMagsList.push(this.orderMagnitudes([...signalBufferProcessed.slice(i,i+nSamplesPerChannel)]));\r\n      }\r\n      //Now slice up the big buffer into individual arrays for each signal\r\n\r\n      outputTex.delete();\r\n      return [freqDist,orderedMagsList]; //Returns x (frequencies) and y axis (magnitudes)\r\n    }\r\n    else {\r\n      var tex = outputTex; \r\n      outputTex.delete(); \r\n      return tex;\r\n    }\r\n  }\r\n\r\n      \r\n  //Input buffer of signals [[channel 0],[channel 1],...,[channel n]] with the same number of samples for each signal. Returns arrays of the positive DFT results in the given window.\r\n  MultiChannelFFT_Bandpass(signalBuffer=[],nSeconds,freqStart,freqEnd, scalar=1, texOut = false) {\r\n\r\n    var signalBufferProcessed = [];\r\n      \r\n    signalBuffer.forEach((row) => {\r\n      signalBufferProcessed.push(...row);\r\n    });\r\n    //console.log(signalBufferProcessed);\r\n\r\n    var freqEnd_nyquist = freqEnd*2;\r\n    var nSamplesPerChannel = signalBuffer[0].length;\r\n    var sampleRate = nSamplesPerChannel/nSeconds;\r\n    \r\n    this.listfft1D_windowed.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\r\n    this.listfft1D_windowed.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\r\n        \r\n    var outputTex = this.listfft1D_windowed(signalBufferProcessed,sampleRate,freqStart,freqEnd_nyquist, scalar);\r\n    if(texOut === true) { return outputTex; }\r\n    \r\n    signalBufferProcessed = outputTex.toArray();\r\n    outputTex.delete();\r\n\r\n    //console.log(signalBufferProcessed)\r\n    //TODO: Optimize for SPEEEEEEED.. or just pass it str8 to a shader\r\n    var freqDist = this.bandPassWindow(freqStart,freqEnd,sampleRate);\r\n    return [freqDist, this.orderBPMagnitudes(signalBufferProcessed,nSeconds,sampleRate,nSamplesPerChannel)]; //Returns x (frequencies) and y axis (magnitudes)\r\n  \r\n  }\r\n\r\n  orderMagnitudes(unorderedMags){\r\n    return [...unorderedMags.slice(Math.ceil(unorderedMags.length*.5),unorderedMags.length),...unorderedMags.slice(0,Math.ceil(unorderedMags.length*.5))];  \r\n  }\r\n\r\n  makeFrequencyDistribution(FFTlength, sampleRate) {\r\n    var N = FFTlength; // FFT size\r\n    var df = sampleRate/N; // frequency resolution\r\n    \r\n    var freqDist = [];\r\n    for(var i=(-N/2); i<(N/2); i++) {\r\n      var freq = i*df;\r\n      freqDist.push(freq);\r\n    }\r\n    return freqDist;\r\n  }\r\n\r\n  //Order and sum positive magnitudes from bandpass DFT\r\n  orderBPMagnitudes(signalBufferProcessed,nSeconds,sampleRate,nSamplesPerChannel) {\r\n    var magList = [];\r\n\r\n      for(var i = 0; i < signalBufferProcessed.length; i+=nSamplesPerChannel){\r\n        magList.push([...signalBufferProcessed.slice(i,Math.ceil(nSamplesPerChannel*.5+i))]);\r\n      }\r\n\r\n\r\n    var summedMags = [];\r\n    var _sampleRate = 1/sampleRate;\r\n    if(nSeconds > 1) { //Need to sum results when sample time > 1 sec\r\n      magList.forEach((row, k) => {\r\n        summedMags.push([]);\r\n        var _max = 1/Math.max(...row); //uhh\r\n        for(var i = 0; i < row.length; i++ ){\r\n          if(i == 0){\r\n              summedMags[k]=row.slice(i,Math.floor(sampleRate));\r\n              i = Math.floor(sampleRate);\r\n          }\r\n          else {\r\n              var j = i-Math.floor(Math.floor(i*_sampleRate)*sampleRate)-1; //console.log(j);\r\n              summedMags[k][j] = summedMags[k][j] * row[i-1]*_max; \r\n          }\r\n        }\r\n        summedMags[k] = [...summedMags[k].slice(0,Math.ceil(summedMags[k].length*0.5))]\r\n\r\n      });\r\n      //console.log(summedMags);\r\n      return summedMags;  \r\n    }\r\n    \r\n    else {return magList;}\r\n  }\r\n\r\n  //Returns the x axis (frequencies) for the bandpass filter amplitudes. The window gets stretched or squeezed between the chosen frequencies based on the sample rate in my implementation.\r\n  bandPassWindow(freqStart,freqEnd,nSteps,posOnly=true) {\r\n \r\n    var freqEnd_nyquist = freqEnd*2;\r\n    let increment = (freqEnd_nyquist - freqStart)/nSteps;\r\n\r\n    var fftwindow = [];\r\n    if(posOnly === true){\r\n      for (var i = 0; i < Math.ceil(0.5*nSteps); i+=increment){\r\n          fftwindow.push(freqStart + (freqEnd_nyquist-freqStart)*i/(nSteps));\r\n      }\r\n    }\r\n    else{\r\n      for (var i = -Math.ceil(0.5*nSteps); i < Math.ceil(0.5*nSteps); i+=increment){\r\n        fftwindow.push(freqStart + (freqEnd_nyquist-freqStart)*i/(nSteps));\r\n      }\r\n    }\r\n    return fftwindow;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nvar mandebrotFrag = \r\n`\r\nuniform sampler1D tex;\r\nuniform vec2 center;\r\nuniform float scale;\r\nuniform int iter;\r\n\r\nvoid main() {\r\n    vec2 z, c;\r\n\r\n    c.x = 1.3333 * (gl_TexCoord[0].x - 0.5) * scale - center.x;\r\n    c.y = (gl_TexCoord[0].y - 0.5) * scale - center.y;\r\n\r\n    int i;\r\n    z = c;\r\n    for(i=0; i<iter; i++) {\r\n        float x = (z.x * z.x - z.y * z.y) + c.x;\r\n        float y = (z.y * z.x + z.x * z.y) + c.y;\r\n\r\n        if((x * x + y * y) > 4.0) break;\r\n        z.x = x;\r\n        z.y = y;\r\n    }\r\n\r\n    gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);\r\n}\r\n`;\r\n\r\nvar juliaSetFrag =\r\n`\r\nuniform sampler1D tex;\r\nuniform vec2 c;\r\nuniform int iter;\r\n\r\nvoid main() {\r\n    vec2 z;\r\n    z.x = 3.0 * (gl_TexCoord[0].x - 0.5);\r\n    z.y = 2.0 * (gl_TexCoord[0].y - 0.5);\r\n\r\n    int i;\r\n    for(i=0; i<iter; i++) {\r\n        float x = (z.x * z.x - z.y * z.y) + c.x;\r\n        float y = (z.y * z.x + z.x * z.y) + c.y;\r\n\r\n        if((x * x + y * y) > 4.0) break;\r\n        z.x = x;\r\n        z.y = y;\r\n    }\r\n\r\n    gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);\r\n}\r\n`;\r\n","\"use strict\";\n\n/* eslint-env browser */\n\n/* eslint-disable no-undef, no-use-before-define, new-cap */\nmodule.exports = function (content, workerConstructor, workerOptions, url) {\n  var globalScope = self || window;\n\n  try {\n    try {\n      var blob;\n\n      try {\n        // New API\n        blob = new globalScope.Blob([content]);\n      } catch (e) {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = globalScope.BlobBuilder || globalScope.WebKitBlobBuilder || globalScope.MozBlobBuilder || globalScope.MSBlobBuilder;\n        blob = new BlobBuilder();\n        blob.append(content);\n        blob = blob.getBlob();\n      }\n\n      var URL = globalScope.URL || globalScope.webkitURL;\n      var objectURL = URL.createObjectURL(blob);\n      var worker = new globalScope[workerConstructor](objectURL, workerOptions);\n      URL.revokeObjectURL(objectURL);\n      return worker;\n    } catch (e) {\n      return new globalScope[workerConstructor](\"data:application/javascript,\".concat(encodeURIComponent(content)), workerOptions);\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error(\"Inline worker is not supported\");\n    }\n\n    return new globalScope[workerConstructor](url, workerOptions);\n  }\n};","function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(() => {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = () => ([]);\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = 776;\nmodule.exports = webpackEmptyAsyncContext;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"\";","\nimport worker from \"!!../node_modules/worker-loader/dist/runtime/inline.js\";\n\nexport default function Worker_fn() {\n  return worker(\"/******/ (() => { // webpackBootstrap\\n/******/ \\tvar __webpack_modules__ = ({\\n\\n/***/ 228:\\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\\n\\n\\\"use strict\\\";\\n\\n// EXPORTS\\n__webpack_require__.d(__webpack_exports__, {\\n  \\\"z\\\": () => (/* binding */ Events)\\n});\\n\\n;// CONCATENATED MODULE: ./node_modules/objectlisteners/ObjectListener.js\\n\\r\\n/*\\r\\n//Example:\\r\\nlet events = new ObjectListener();\\r\\nlet x = { y: 1, z: { w: 2 }}\\r\\n\\r\\n\\r\\nevents.addListener(\\\"y\\\",x,\\\"y\\\");\\r\\nevents.addListener(\\\"z\\\",x,\\\"z\\\");\\r\\n\\r\\nx.z.w = 3;\\r\\nx.y = 2;\\r\\n//See console\\r\\n\\r\\n*/\\r\\n\\r\\n//By Joshua Brewster (AGPL v3.0 License)\\r\\n\\r\\n//Create instance and then call instance.addListener(listenerName,objectToListenTo,propToListenTo,onchange,interval).\\r\\n//name, propToListenTo, onchange, and interval are optional (leave or set as undefined). Onchange is a custom callback just like for other event listeners. Set a name to make it easier to start and stop or edit each listener.\\r\\nclass ObjectListener {\\r\\n    constructor(debug=false, synchronous=false) {\\r\\n        this.debug = debug;\\r\\n        this.listeners = [];\\r\\n        this.synchronous = synchronous;//check all listeners simulatenously instead of on individual loops. use startSync() to trigger\\r\\n        this.syncInterval = 'FRAMERATE'; //interval\\r\\n        this.syncAnim = undefined;\\r\\n        if(synchronous === true) this.startSync();\\r\\n    }\\r\\n\\r\\n    //add a new object listener with specified props (or none to watch the whole object), and onchange functions, with optional interval\\r\\n    addListener(listenerKey=null,objectToListenTo,propToListenTo=undefined,onchange=undefined,interval=undefined,debug=this.debug,startRunning=true) {\\r\\n        if(objectToListenTo === undefined) {\\r\\n            console.error(\\\"You must assign an object\\\");\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        var key = listenerKey;\\r\\n        if(key == null) {\\r\\n            key = Math.floor(Math.random()*100000);\\r\\n        }\\r\\n        if(this.synchronous === true) startRunning = false; //negate this in case of synchronous runtime\\r\\n        var listener = {key:key, listener: new ObjectListenerInstance(objectToListenTo,propToListenTo,onchange,interval,debug,startRunning)};\\r\\n        this.listeners.push(listener);\\r\\n    }\\r\\n\\r\\n    getListener(key) {\\r\\n        let found = this.listeners.find((item,i) =>{\\r\\n            if(item.key === key) return true;\\r\\n        });\\r\\n        return found;\\r\\n    }\\r\\n\\r\\n    hasKey(key) {\\r\\n        var found = false;\\r\\n        this.listeners.forEach((item,i) =>{\\r\\n            if(item.key === key) {found = true; return true;}\\r\\n        });\\r\\n        return found;\\r\\n    }\\r\\n\\r\\n    getKeyIndices(key) {\\r\\n        var indices = [];\\r\\n        this.listeners.find((o,i) => {\\r\\n            if(o.key === key) {\\r\\n                indices.push(i);\\r\\n            }\\r\\n        });\\r\\n        return indices;\\r\\n    }\\r\\n\\r\\n    onchange(key=null,newCallback=null){\\r\\n        if(key == null) {\\r\\n            this.listeners.forEach((obj,i) => {\\r\\n                obj.listener.onchange = newCallback;\\r\\n            });\\r\\n        }\\r\\n        else {\\r\\n            var found = this.listeners.find((o,i) => {\\r\\n                if(o.name === key) {\\r\\n                    o.listener.onchange = newCallback;\\r\\n                }\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Add extra onchange functions\\r\\n    addFunc = (key=null,newCallback=null, start=true) => {\\r\\n        var callbackIdx = null;\\r\\n        if(newCallback !== null){\\r\\n            if(key == null) {\\r\\n                this.listeners.forEach((obj,i) => {\\r\\n                    callbackIdx = obj.listener.addFunc(newCallback);\\r\\n                    if(obj.listener.running == false && start == true)\\r\\n                        obj.listener.start();\\r\\n                });\\r\\n            }\\r\\n            else {\\r\\n                var found = this.listeners.find((obj,i) => {\\r\\n                    if(obj.key === key) {\\r\\n                        callbackIdx = obj.listener.addFunc(newCallback);\\r\\n                        if(obj.listener.running == false && start == true)\\r\\n                            obj.listener.start();\\r\\n                    }\\r\\n                });\\r\\n            }\\r\\n        }\\r\\n        return callbackIdx;\\r\\n    }\\r\\n\\r\\n    //get the array of secondary onchange functions\\r\\n    getFuncs = (key=undefined) => {\\r\\n        if(key) {\\r\\n            var found = this.listeners.find((o,i) => {\\r\\n                if(o.key === key) {\\r\\n                    return true;\\r\\n                }\\r\\n            });\\r\\n            return found.onchangeFuncs;\\r\\n        } else return undefined;\\r\\n    }\\r\\n\\r\\n    //Remove extra onchange functions\\r\\n    removeFuncs = (key = null, idx = null, stop=false) => {\\r\\n        if(key == null) {\\r\\n            this.listeners.forEach((obj,i) => {\\r\\n                obj.listener.removeFuncs(idx);\\r\\n            });\\r\\n        }\\r\\n        else {\\r\\n            var found = this.listeners.find((o,i) => {\\r\\n                if(o.key === key) {\\r\\n                    o.listener.removeFuncs(idx);\\r\\n                    if(o.listener.onchangeFuncs.length === 0 || stop === true) {\\r\\n                        o.listener.stop()\\r\\n                    }\\r\\n                }\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Stop all or named listeners\\r\\n    stop(key=null) {\\r\\n        if(this.synchronous) this.stopSync();\\r\\n        if(key == null) {\\r\\n            this.listeners.forEach((obj,i) => {\\r\\n                obj.listener.stop();\\r\\n            });\\r\\n        }\\r\\n        else {\\r\\n            var found = this.listeners.find((o,i) => {\\r\\n                if(o.name === key) {\\r\\n                    o.listener.stop();\\r\\n                }\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Restart all or named listeners\\r\\n    start(key=null) {\\r\\n        if(this.synchronous) this.stopSync();\\r\\n        if(key == null) {\\r\\n            this.listeners.forEach((obj,i) => {\\r\\n                obj.listener.start();\\r\\n            });\\r\\n        }\\r\\n        else {\\r\\n            var found = this.listeners.find((o,i) => {\\r\\n                if(o.name === key) {\\r\\n                    o.listener.start();\\r\\n                }\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //run listeners synchronously instead of on their own individual loops\\r\\n    startSync() {\\r\\n        if(this.synchronous === false) {\\r\\n            this.synchronous = true;\\r\\n            this.stop(); //stop the async calls\\r\\n            let runChecks = () => {\\r\\n                if(this.synchronous === true) {\\r\\n                    this.listeners.forEach((l)=>{\\r\\n                        l.listener.check();\\r\\n                    });\\r\\n                    if(this.syncInterval === 'FRAMERATE') {\\r\\n                        this.syncAnim = requestAnimationFrame(runChecks);\\r\\n                    } else if (typeof this.syncInterval === 'number') {\\r\\n                        setTimeout(runChecks, this.syncInterval);\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n            runChecks();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //stop the synchronous checking\\r\\n    stopSync() {\\r\\n        this.synchronous = false;\\r\\n        if(this.syncAnim) cancelAnimationFrame(this.syncAnim);\\r\\n    }   \\r\\n\\r\\n    remove(key=null){\\r\\n        if(key == null) {\\r\\n            this.listeners.forEach((o) => {\\r\\n                o.listener.stop();\\r\\n            });\\r\\n            this.listeners.splice(0,this.listeners.length);\\r\\n        }\\r\\n        else {\\r\\n            var indices = [];\\r\\n            var found = this.listeners.forEach((o,i) => {\\r\\n                if(o.key === key) {\\r\\n                    indices.push(i);\\r\\n                }\\r\\n            });\\r\\n            indices.reverse().forEach((idx) => {\\r\\n                this.listeners[idx].listener.stop();\\r\\n                this.listeners.splice(idx,1);\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n//Instance of an object listener. This will subscribe to object properties (or whole objects) and run attached functions when a change is detected.\\r\\nclass ObjectListenerInstance {\\r\\n    constructor(object,propName=\\\"__ANY__\\\",onchange=this.onchange,interval=\\\"FRAMERATE\\\",debug=false,startRunning=true) {\\r\\n        this.debug=debug;\\r\\n\\r\\n        this.onchange = onchange; //Main onchange function\\r\\n        this.onchangeFuncs = []; //Execute extra functions pushed to this array\\r\\n\\r\\n        this.object = object; //Objects are always passed by reference\\r\\n        this.propName = propName;\\r\\n        this.propOld = undefined;\\r\\n        this.setListenerRef(propName);\\r\\n\\r\\n        this.running = startRunning;\\r\\n        this.funcs = 0;\\r\\n\\r\\n        this.interval;\\r\\n        if(interval < 10) {\\r\\n            this.interval = 10; console.log(\\\"Min recommended interval set: 10ms\\\");}\\r\\n        else {\\r\\n            this.interval = interval;\\r\\n        }\\r\\n\\r\\n        if(startRunning === true) {\\r\\n            if (typeof window === 'undefined') {\\r\\n                setTimeout(()=>{this.check();}, 60)\\r\\n            } else {\\r\\n                this.checker = requestAnimationFrame(this.check);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Main onchange execution\\r\\n    onchange = (newData) => {\\r\\n        console.log(this.propName,\\\" changed from: \\\", this.propOld,\\\" to: \\\", this.object[this.propName]);\\r\\n    }\\r\\n\\r\\n    //Add extra onchange functions for execution\\r\\n    addFunc = (onchange=null) => {\\r\\n        let sub = 0;\\r\\n        if(onchange !== null){\\r\\n            this.onchangeFuncs.push({idx:this.funcs, onchange:onchange});\\r\\n            sub=this.funcs;\\r\\n            this.funcs++;\\r\\n        }\\r\\n        return sub;\\r\\n    }\\r\\n\\r\\n    //Remove extra onchange functions\\r\\n    removeFuncs(idx = null) {\\r\\n        let i = 0;\\r\\n        if(idx === null) {\\r\\n            this.onchangeFuncs = [];\\r\\n        }\\r\\n        else if(this.onchangeFuncs.find((o,j)=>{if(o.idx===idx){ i=j; return true;}}) !== undefined) {\\r\\n            this.onchangeFuncs.splice(i,1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Execute extra onchange functions\\r\\n    onchangeMulti = (newData) => {\\r\\n        let onChangeCache = [...this.onchangeFuncs]\\r\\n        onChangeCache.forEach((func,i) => {\\r\\n            if(this.debug === true) { console.log(func.onchange); }\\r\\n            func.onchange(newData);\\r\\n        });\\r\\n    }\\r\\n\\r\\n    //Update listener reference copy.\\r\\n    setListenerRef = (propName) => {\\r\\n        if(propName === \\\"__ANY__\\\" || propName === null || propName === undefined) {\\r\\n            this.propOld = JSON.stringifyFast(this.object);\\r\\n        }\\r\\n        else if(Array.isArray(this.object[propName])) {\\r\\n            this.propOld = JSON.stringifyFast(this.object[propName].slice(this.object[propName].length-20));\\r\\n        }\\r\\n        else if(typeof this.object[propName] === \\\"object\\\"){\\r\\n            this.propOld = JSON.stringifyFast(this.object[propName]);\\r\\n        }\\r\\n        else if(typeof this.object[propName] === \\\"function\\\"){\\r\\n            this.propOld = this.object[propName].toString();\\r\\n        }\\r\\n        else{\\r\\n            this.propOld = this.object[propName]; //usually a number, bool, or string;\\r\\n        }\\r\\n        \\r\\n        if(this.debug === true) { console.log(\\\"propname\\\", propName, \\\", new assignment: \\\", this.propOld); }\\r\\n    }\\r\\n\\r\\n    check = () => {\\r\\n        let changed = false;\\r\\n        if(this.propName === \\\"__ANY__\\\" || this.propName === null || this.propName === undefined){\\r\\n            if(this.propOld !== JSON.stringifyFast(this.object)){\\r\\n                if(this.debug === true) { console.log(\\\"onchange: \\\", this.onchange); }\\r\\n                this.onchange(this.object);\\r\\n                if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object); }\\r\\n                this.setListenerRef(this.propName);\\r\\n                changed = true;\\r\\n            }\\r\\n        }\\r\\n        else if(Array.isArray(this.object[this.propName])) { //cut arrays down for speed\\r\\n            if(this.propOld !== JSON.stringifyFast(this.object[this.propName].slice(this.object[this.propName].length-20))){\\r\\n                if(this.debug === true) { console.log(\\\"onchange: \\\", this.onchange); }\\r\\n                this.onchange(this.object[this.propName]);\\r\\n                if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object[this.propName]); }\\r\\n                this.setListenerRef(this.propName);\\r\\n                changed = true;\\r\\n            }\\r\\n        }\\r\\n        else if(typeof this.object[this.propName] === \\\"object\\\") {\\r\\n            let string = JSON.stringifyFast(this.object[this.propName]);\\r\\n            if(this.propOld !== string){\\r\\n                if(this.debug === true) { console.log(\\\"onchange: \\\", this.onchange); }\\r\\n                this.onchange(this.object[this.propName]);\\r\\n                if(this.onchangeFuncs.length > 0) { \\r\\n                    this.onchangeMulti(this.object[this.propName]); \\r\\n                }\\r\\n                this.setListenerRef(this.propName);\\r\\n                changed = true;\\r\\n            }\\r\\n        }\\r\\n        else if(typeof this.object[this.propName] === \\\"function\\\") {\\r\\n            if(this.propOld !== this.object[this.propName].toString()){\\r\\n                if(this.debug === true) { console.log(\\\"onchange: \\\", this.onchange); }\\r\\n                this.onchange(this.object[this.propName].toString());\\r\\n                if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object[this.propName].toString()); }\\r\\n                this.setListenerRef(this.propName);\\r\\n                changed = true;\\r\\n            }\\r\\n        }\\r\\n        else if(this.object[this.propName] !== this.propOld) {\\r\\n            if(this.debug === true) { console.log(\\\"onchange: \\\", this.onchange); }\\r\\n            this.onchange(this.object[this.propName]);\\r\\n            if(this.onchangeFuncs.length > 0) { this.onchangeMulti(this.object[this.propName]); }\\r\\n            this.setListenerRef(this.propName);\\r\\n            changed = true;\\r\\n        }\\r\\n        \\r\\n        if(this.running === true) {\\r\\n            if(this.debug === true) {console.log(\\\"checking\\\", this.object, this.propName);}\\r\\n            if(this.interval === \\\"FRAMERATE\\\"){\\r\\n                if (typeof window === 'undefined') {\\r\\n                    setTimeout(()=>{this.check();}, 16)\\r\\n                } else {\\r\\n                    this.checker = requestAnimationFrame(this.check);\\r\\n                }\\r\\n            }\\r\\n            else {\\r\\n                setTimeout(()=>{this.check();},this.interval);\\r\\n            }\\r\\n        };\\r\\n\\r\\n        return changed;\\r\\n    }\\r\\n\\r\\n    start() {\\r\\n        this.running = true;\\r\\n        if (typeof window === 'undefined') {\\r\\n            setTimeout(()=>{this.check();}, 16);\\r\\n        } else {\\r\\n            this.checker = requestAnimationFrame(this.check);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    stop() {\\r\\n        this.running = false;\\r\\n        cancelAnimationFrame(this.checker);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n//This only really matters in Chrome and one other browser\\r\\nfunction sortObjectByValue(object) { //Sorts number and string objects by numeric value. Strings have charcodes summed for comparison. Objects and functions are stringified.\\r\\n    var sortable = [];\\r\\n    for(var prop in object) {\\r\\n        sortable.push([prop, object[prop]]);\\r\\n    }\\r\\n\\r\\n    sortable.sort(function(a,b) {\\r\\n        var prop1 = a;\\r\\n        var prop2 = b;\\r\\n        if(typeof prop1[1] === \\\"function\\\"){\\r\\n            prop1[1] = prop1[1].toString();\\r\\n        }\\r\\n        else if(typeof prop1[1] === \\\"object\\\"){\\r\\n            prop1[1] = JSON.stringifyFast(prop1[1]);\\r\\n        }\\r\\n        if(typeof prop2[1] === \\\"function\\\"){\\r\\n            prop2[1] = prop2[1].toString();\\r\\n        }\\r\\n        else if(typeof prop2[1] === \\\"object\\\"){\\r\\n            prop2[1] = JSON.stringifyFast(prop2[1]);\\r\\n        }\\r\\n        \\r\\n        if(typeof prop1[1] === \\\"string\\\") {\\r\\n            var temp = 0;\\r\\n            prop1.forEach((char,i) => {\\r\\n                temp += prop1.charCodeAt(i);\\r\\n            });\\r\\n            prop1 = temp;\\r\\n        }\\r\\n        if(typeof prop2[1] === \\\"string\\\") {\\r\\n            var temp = 0;\\r\\n            prop2.forEach((char,i) => {\\r\\n                temp += prop2.charCodeAt(i);\\r\\n            });\\r\\n            prop2 = temp;\\r\\n        }\\r\\n        return prop1[1]-prop2[1];\\r\\n    });\\r\\n\\r\\n    var sorted = {};\\r\\n\\r\\n    sortable.forEach((item) => {\\r\\n       sorted[item[0]]=item[1];\\r\\n    });\\r\\n\\r\\n    return sorted;\\r\\n\\r\\n}\\r\\n\\r\\nfunction sortObjectByPropName(object) {\\r\\n\\r\\n    var sortable = [];\\r\\n\\r\\n    for(var prop in object) {\\r\\n        sortable.push([prop, object[prop]]);\\r\\n    }\\r\\n\\r\\n    sortable.sort(function(a,b) {\\r\\n        return a[0] > b[0];\\r\\n    });\\r\\n\\r\\n    var sorted = {};\\r\\n\\r\\n    sortable.forEach((item) => {\\r\\n        sorted[item[0]]=item[1];\\r\\n    });\\r\\n\\r\\n    return sorted;\\r\\n\\r\\n}\\r\\n\\r\\n//modified to also cut down the size arrays for faster looping\\r\\nif(JSON.stringifyFast === undefined) {\\r\\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\\r\\n    JSON.stringifyFast = (function() {\\r\\n        const refs = new Map();\\r\\n        const parents = [];\\r\\n        const path = [\\\"this\\\"];\\r\\n\\r\\n        function clear() {\\r\\n            refs.clear();\\r\\n            parents.length = 0;\\r\\n            path.length = 1;\\r\\n        }\\r\\n\\r\\n        function updateParents(key, value) {\\r\\n            var idx = parents.length - 1;\\r\\n            if(parents[idx]){\\r\\n                var prev = parents[idx];\\r\\n                if (prev[key] === value || idx === 0) {\\r\\n                    path.push(key);\\r\\n                    parents.push(value.pushed);\\r\\n                } else {\\r\\n                    while (idx-- >= 0) {\\r\\n                    prev = parents[idx];\\r\\n                    if (prev[key] === value) {\\r\\n                        idx += 2;\\r\\n                        parents.length = idx;\\r\\n                        path.length = idx;\\r\\n                        --idx;\\r\\n                        parents[idx] = value;\\r\\n                        path[idx] = key;\\r\\n                        break;\\r\\n                    }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        function checkValues(key, value) {\\r\\n            let val;\\r\\n            if (value != null) {\\r\\n                if (typeof value === \\\"object\\\") {\\r\\n                    //if (key) { updateParents(key, value); }\\r\\n                    let c = value.constructor.name;\\r\\n                    if (key && c === 'Object') {updateParents(key, value); }\\r\\n\\r\\n                    let other = refs.get(value);\\r\\n                    if (other) {\\r\\n                        return '[Circular Reference]' + other;\\r\\n                    } else {\\r\\n                        refs.set(value, path.join('.'));\\r\\n                    }\\r\\n                    if(c === \\\"Array\\\") { //Cut arrays down to 100 samples for referencing\\r\\n                        if(value.length > 20) {\\r\\n                            val = value.slice(value.length-20);\\r\\n                        } else val = value;\\r\\n                       // refs.set(val, path.join('.'));\\r\\n                    }  \\r\\n                    else if (c.includes(\\\"Set\\\")) {\\r\\n                        val = Array.from(value)\\r\\n                    }  \\r\\n                    else if (c !== \\\"Object\\\" && c !== \\\"Number\\\" && c !== \\\"String\\\" && c !== \\\"Boolean\\\") { //simplify classes, objects, and functions, point to nested objects for the state manager to monitor those properly\\r\\n                        val = \\\"instanceof_\\\"+c;\\r\\n                    }\\r\\n                    else if (c === 'Object') {\\r\\n                        let obj = {};\\r\\n                        for(const prop in value) {\\r\\n                            if (value[prop] == null){\\r\\n                                obj[prop] = value[prop]; \\r\\n                            }\\r\\n                            else if(Array.isArray(value[prop])) { \\r\\n                                if(value[prop].length>20)\\r\\n                                    obj[prop] = value[prop].slice(value[prop].length-20); \\r\\n                                else obj[prop] = value[prop];\\r\\n                            } //deal with arrays in nested objects (e.g. means, slices)\\r\\n                            else if (value[prop].constructor.name === 'Object') { //additional layer of recursion for 3 object-deep array checks\\r\\n                                obj[prop] = {};\\r\\n                                for(const p in value[prop]) {\\r\\n                                    if(Array.isArray(value[prop][p])) {\\r\\n                                        if(value[prop][p].length>20)\\r\\n                                            obj[prop][p] = value[prop][p].slice(value[prop][p].length-20); \\r\\n                                        else obj[prop][p] = value[prop][p];\\r\\n                                    }\\r\\n                                    else { \\r\\n                                        if (value[prop][p] != null){\\r\\n                                            let con = value[prop][p].constructor.name;\\r\\n                                            if (con.includes(\\\"Set\\\")) {\\r\\n                                                obj[prop][p] = Array.from(value[prop][p])\\r\\n                                            } else if(con !== \\\"Number\\\" && con !== \\\"String\\\" && con !== \\\"Boolean\\\") {\\r\\n                                                obj[prop][p] = \\\"instanceof_\\\"+con; //3-deep nested objects are cut off\\r\\n                                            }  else {\\r\\n                                                obj[prop][p] = value[prop][p]; \\r\\n                                            }\\r\\n                                        } else {\\r\\n                                            obj[prop][p] = value[prop][p]; \\r\\n                                        }\\r\\n                                    }\\r\\n                                }\\r\\n                            }\\r\\n                            else { \\r\\n                                let con = value[prop].constructor.name;\\r\\n                                if (con.includes(\\\"Set\\\")) {\\r\\n                                    obj[prop] = Array.from(value[prop])\\r\\n                                } else if(con !== \\\"Number\\\" && con !== \\\"String\\\" && con !== \\\"Boolean\\\") {\\r\\n                                    obj[prop] = \\\"instanceof_\\\"+con;\\r\\n                                } else {\\r\\n                                    obj[prop] = value[prop]; \\r\\n                                }\\r\\n                            }\\r\\n                        }\\r\\n                        //console.log(obj, value)\\r\\n                        val = obj;\\r\\n                        //refs.set(val, path.join('.'));\\r\\n                    }\\r\\n                    else {\\r\\n                        val = value;\\r\\n                    }\\r\\n                } else {\\r\\n                    val = value;\\r\\n                }\\r\\n            }\\r\\n            //console.log(value, val)\\r\\n            return val;\\r\\n        }\\r\\n\\r\\n        return function stringifyFast(obj, space) {\\r\\n            try {\\r\\n                parents.push(obj);\\r\\n                return JSON.stringify(obj, checkValues, space);\\r\\n            } catch(er) {\\r\\n                console.error(obj, er);\\r\\n            } finally {\\r\\n                clear();\\r\\n            } \\r\\n        }\\r\\n    })();\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nif(JSON.stringifyWithCircularRefs === undefined) {\\r\\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\\r\\n    JSON.stringifyWithCircularRefs = (function() {\\r\\n        const refs = new Map();\\r\\n        const parents = [];\\r\\n        const path = [\\\"this\\\"];\\r\\n\\r\\n        function clear() {\\r\\n        refs.clear();\\r\\n        parents.length = 0;\\r\\n        path.length = 1;\\r\\n        }\\r\\n\\r\\n        function updateParents(key, value) {\\r\\n        var idx = parents.length - 1;\\r\\n        var prev = parents[idx];\\r\\n        if (prev[key] === value || idx === 0) {\\r\\n            path.push(key);\\r\\n            parents.push(value);\\r\\n        } else {\\r\\n            while (idx-- >= 0) {\\r\\n            prev = parents[idx];\\r\\n            if (prev[key] === value) {\\r\\n                idx += 2;\\r\\n                parents.length = idx;\\r\\n                path.length = idx;\\r\\n                --idx;\\r\\n                parents[idx] = value;\\r\\n                path[idx] = key;\\r\\n                break;\\r\\n            }\\r\\n            }\\r\\n        }\\r\\n        }\\r\\n\\r\\n        function checkCircular(key, value) {\\r\\n        if (value != null) {\\r\\n            if (typeof value === \\\"object\\\") {\\r\\n            if (key) { updateParents(key, value); }\\r\\n\\r\\n            let other = refs.get(value);\\r\\n            if (other) {\\r\\n                return '[Circular Reference]' + other;\\r\\n            } else {\\r\\n                refs.set(value, path.join('.'));\\r\\n            }\\r\\n            }\\r\\n        }\\r\\n        return value;\\r\\n        }\\r\\n\\r\\n        return function stringifyWithCircularRefs(obj, space) {\\r\\n        try {\\r\\n            parents.push(obj);\\r\\n            return JSON.stringify(obj, checkCircular, space);\\r\\n        } finally {\\r\\n            clear();\\r\\n        }\\r\\n        }\\r\\n    })();\\r\\n}\\r\\n\\r\\n/* harmony default export */ const objectlisteners_ObjectListener = (ObjectListener);\\n;// CONCATENATED MODULE: ./node_modules/anotherstatemanager/StateManager.js\\n\\r\\n\\r\\n//By Joshua Brewster (MIT License)\\r\\n//Simple state manager.\\r\\n//Set key responses to have functions fire when keyed values change\\r\\n//add variables to state with addToState(key, value, keyonchange (optional))\\r\\nclass StateManager {\\r\\n    constructor(init = {}, interval=\\\"FRAMERATE\\\", defaultKeyEventLoop=true) { //Default interval is at the browser framerate\\r\\n        this.data = init;\\r\\n        this.interval = interval;\\r\\n        this.pushToState={};\\r\\n        this.pushRecord={pushed:[]}; //all setStates between frames\\r\\n        this.pushCallbacks = {};\\r\\n        this.triggers = {};\\r\\n\\r\\n        this.listener = new objectlisteners_ObjectListener();\\r\\n        this.defaultStartListenerEventLoop = defaultKeyEventLoop;\\r\\n\\r\\n        /*\\r\\n        this.prev = Object.assign({},this.data);\\r\\n         \\r\\n        const onStateChanged = () => {\\r\\n            this.prev = Object.assign({},this.data);\\r\\n            //this.prev=JSON.parse(JSON.stringifyFast(this.data));\\r\\n        }\\r\\n\\r\\n        //Causes app to be stuck on startup\\r\\n        this.listener.addListener(\\r\\n            \\\"state\\\",\\r\\n            this.data,\\r\\n            \\\"__ANY__\\\",\\r\\n            onStateChanged,\\r\\n            interval,\\r\\n        );\\r\\n        */\\r\\n    }\\r\\n\\r\\n    setInterval(interval=\\\"FRAMERATE\\\") {\\r\\n        this.interval = interval;\\r\\n        this.listener.listeners.forEach((obj,i) => {\\r\\n            obj.interval = this.interval;\\r\\n        });\\r\\n    }\\r\\n\\r\\n\\r\\n    // Managed State Updates. Must Still Clean Event Listeners\\r\\n    updateState(key, value){\\r\\n        if (this.data[key] == null){\\r\\n            this.addToState(key,value)\\r\\n        } else {\\r\\n            this.data[key] = value\\r\\n        }    \\r\\n    }\\r\\n\\r\\n    //Removes all references to a state key i.e. subscriptions and data\\r\\n    removeState(key, sequential=false){\\r\\n            if (sequential) this.unsubscribeAllSequential(key);\\r\\n            else this.unsubscribeAll(key);\\r\\n            delete this.data[key]\\r\\n\\r\\n            // Log Update\\r\\n            this.setSequentialState({stateRemoved: key})\\r\\n    }\\r\\n\\r\\n    setupSynchronousUpdates = () => {\\r\\n        if(!this.listener.hasKey('pushToState')) {\\r\\n            //we won't add this listener unless we use this function\\r\\n            const pushToStateResponse = () => {\\r\\n                if(Object.keys(this.pushToState).length > 0) {\\r\\n                    //Object.assign(this.prev,this.data);//Temp fix until the global state listener function works as expected\\r\\n                    Object.assign(this.data,this.pushToState);\\r\\n\\r\\n                    //console.log(\\\"new state: \\\", this.data); console.log(\\\"props set: \\\", this.pushToState);\\r\\n                    for (const prop of Object.getOwnPropertyNames(this.pushToState)) {\\r\\n                        delete this.pushToState[prop];\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n    \\r\\n            this.listener.addListener(\\r\\n                \\\"pushToState\\\",\\r\\n                this.pushToState,\\r\\n                \\\"__ANY__\\\",\\r\\n                pushToStateResponse,\\r\\n                this.interval\\r\\n            );\\r\\n\\r\\n            this.addToState('pushRecord',this.pushRecord,(record)=>{\\r\\n\\r\\n                let l = record.pushed.length;\\r\\n                for (let i = 0; i < l; i++){\\r\\n                    let updateObj = record.pushed[i];\\r\\n                    for(const prop in updateObj) {\\r\\n                        if(this.pushCallbacks[prop]) {\\r\\n                            this.pushCallbacks[prop].forEach((o) =>{\\r\\n                                o.onchange(updateObj[prop]);\\r\\n                            });\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n                this.pushRecord.pushed.splice(0,l);\\r\\n            });\\r\\n\\r\\n            this.data.pushCallbacks = this.pushCallbacks;\\r\\n\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Alternatively just add to the state by doing this.state[key] = value with the state manager instance\\r\\n    addToState(key, value, onchange=null, startRunning=this.defaultStartListenerEventLoop, debug=false) {\\r\\n        if(!this.listener.hasKey('pushToState') && this.defaultStartListenerEventLoop) {\\r\\n            this.setupSynchronousUpdates();\\r\\n        }\\r\\n\\r\\n        this.data[key] = value;\\r\\n\\r\\n        // Log Update\\r\\n        this.setSequentialState({stateAdded: key})\\r\\n\\r\\n        if(onchange !== null){\\r\\n            return this.addSecondaryKeyResponse(key,onchange,debug,startRunning);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    getState() { //Return a hard copy of the latest state with reduced values. Otherwise just use this.state.data\\r\\n        return JSON.parse(JSON.stringifyFast(this.data));\\r\\n    }\\r\\n\\r\\n    //Synchronous set-state, only updates main state on interval. Can set to trigger now instead of waiting on interval. Also can append arrays in state instead of replacing them\\r\\n    setState(updateObj={}, appendArrs=false){ //Pass object with keys in. Undefined keys in state will be added automatically. State only notifies of change based on update interval\\r\\n        //console.log(\\\"setting state\\\");\\r\\n        if(!this.listener.hasKey('pushToState') && this.defaultStartListenerEventLoop) {\\r\\n            this.setupSynchronousUpdates();\\r\\n            this.pushRecord.pushed.push(JSON.parse(JSON.stringifyWithCircularRefs(updateObj)));\\r\\n        }\\r\\n\\r\\n        updateObj.stateUpdateTimeStamp = Date.now();\\r\\n        \\r\\n        if(appendArrs) {\\r\\n            for(const prop in updateObj) { //3 object-deep array checks to buffer values instead of overwriting\\r\\n                if(this.pushToState[prop]) {\\r\\n                    if(Array.isArray(this.pushToState[prop]) && Array.isArray(updateObj[prop])) {\\r\\n                        updateObj[prop] = this.pushToState[prop].push(...updateObj[prop]);\\r\\n                    } else if (typeof this.pushToState[prop] === 'object' && typeof updateObj[prop] === 'object') {\\r\\n                        for(const p in updateObj[prop]) {\\r\\n                            if(this.pushToState[prop][p]) {\\r\\n                                if(Array.isArray(this.pushToState[prop][p]) && Array.isArray(updateObj[prop][p])) {\\r\\n                                    updateObj[prop][p] = this.pushToState[prop][p].push(...updateObj[prop][p]);\\r\\n                                }\\r\\n                                else if (typeof this.pushToState[prop][p] === 'object' && typeof updateObj[prop][p] === 'object') {\\r\\n                                    for(const p2 in updateObj[prop][p]) {\\r\\n                                        if(this.pushToState[prop][p][p2]) {\\r\\n                                            if(Array.isArray(this.pushToState[prop][p][p2]) && Array.isArray(updateObj[prop][p][p2])) {\\r\\n                                                updateObj[prop][p][p2] = this.pushToState[prop][p][p2].push(...updateObj[prop][p][p2]);\\r\\n                                            }\\r\\n                                        }\\r\\n                                        else if (typeof this.pushToState[prop][p][p2] === 'object' && typeof updateObj[prop][p][p2] === 'object') {\\r\\n                                            for(const p3 in updateObj[prop][p][p2]) {\\r\\n                                                if(this.pushToState[prop][p][p2][p3]) {\\r\\n                                                    if(Array.isArray(this.pushToState[prop][p][p2][p3]) && Array.isArray(updateObj[prop][p][p2][p3])) {\\r\\n                                                        updateObj[prop][p][p2][p3] = this.pushToState[prop][p][p2][p3].push(...updateObj[prop][p][p2][p3]);\\r\\n                                                    }\\r\\n                                                }\\r\\n                                            }\\r\\n                                        }\\r\\n                                    }\\r\\n                                }\\r\\n                            }\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        Object.assign(this.pushToState,updateObj);\\r\\n        \\r\\n        if(Object.keys(this.triggers).length > 0) {\\r\\n            // Object.assign(this.data,this.pushToState);\\r\\n            for (const prop of Object.getOwnPropertyNames(this.triggers)) {\\r\\n                if(this.pushToState[prop]) {\\r\\n                    this.data[prop] = this.pushToState[prop]\\r\\n                    delete this.pushToState[prop];\\r\\n                    this.triggers[prop].forEach((obj)=>{\\r\\n                        obj.onchange(this.data[prop]);\\r\\n                    });\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return this.pushToState;\\r\\n    }\\r\\n\\r\\n    //Trigger-only functions on otherwise looping listeners\\r\\n    subscribeTrigger(key=undefined,onchange=(value)=>{}) {\\r\\n\\r\\n        // console.error('SUBSCRIBING')\\r\\n        if(key) {\\r\\n            if(!this.triggers[key]) {\\r\\n                this.triggers[key] = [];\\r\\n            }\\r\\n            let l = this.triggers[key].length;\\r\\n            this.triggers[key].push({idx:l, onchange:onchange});\\r\\n            return this.triggers[key].length-1;\\r\\n        } else return undefined;\\r\\n    }\\r\\n\\r\\n    //will remove the trigger after firing once\\r\\n    subscribeTriggerOnce(key=undefined,onchange=(value)=>{}) {\\r\\n        let sub;\\r\\n        let changed = (value) => {\\r\\n            onchange(value);\\r\\n            this.unsubscribeTrigger(key,sub);\\r\\n        }\\r\\n\\r\\n        sub = this.subscribeTrigger(key,changed);\\r\\n    }\\r\\n\\r\\n    //Delete specific trigger functions for a key\\r\\n    unsubscribeTrigger(key=undefined,sub=0) {\\r\\n        let idx = undefined;\\r\\n        let triggers = this.triggers[key]\\r\\n        if (triggers){\\r\\n            let obj = triggers.find((o)=>{\\r\\n                if(o.idx===sub) {return true;}\\r\\n            });\\r\\n            if(obj) triggers.splice(idx,1);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Remove all triggers for a key\\r\\n    unsubscribeAllTriggers(key) {\\r\\n        if(key && this.triggers[key]) {\\r\\n            delete this.triggers[key];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //only push to an object that keeps the sequences of updates instead of synchronously updating the whole state.\\r\\n    setSequentialState(updateObj={}) {\\r\\n        //console.log(\\\"setting state\\\");\\r\\n        if(!this.listener.hasKey('pushToState')) {\\r\\n            this.setupSynchronousUpdates();\\r\\n        }\\r\\n        updateObj.stateUpdateTimeStamp = Date.now();\\r\\n        this.pushRecord.pushed.push(JSON.parse(JSON.stringify(updateObj)));\\r\\n    }\\r\\n\\r\\n    subscribeSequential(key=undefined,onchange=undefined) {\\r\\n        // console.error('SUBSCRIBING')\\r\\n\\r\\n        if(key) {\\r\\n            \\r\\n            if(this.data[key] === undefined) {this.addToState(key,null,undefined);}\\r\\n\\r\\n            if(!this.pushCallbacks[key])\\r\\n                this.pushCallbacks[key] = [];\\r\\n\\r\\n            if(onchange) {\\r\\n                let idx = this.pushCallbacks[key].length;\\r\\n                this.pushCallbacks[key].push({idx:idx, onchange:onchange});\\r\\n                return this.pushCallbacks[key].length-1; //get key sub index for unsubscribing\\r\\n            } \\r\\n            else return undefined;\\r\\n        } else return undefined;\\r\\n    }\\r\\n    \\r\\n    //will remove the sequence after firing once (e.g. between frames)\\r\\n    subscribeSequentialOnce(key=undefined,onchange=(value)=>{}) {\\r\\n        let sub;\\r\\n        let changed = (value) => {\\r\\n            onchange(value);\\r\\n            this.unsubscribeSequential(key,sub);\\r\\n        }\\r\\n\\r\\n        sub = this.subscribeSequential(key,changed);\\r\\n    }\\r\\n\\r\\n    unsubscribeSequential(key=undefined,sub=0) {\\r\\n        if(key){\\r\\n            if(this.pushCallbacks[key]) {\\r\\n                if(this.pushCallbacks[key].find((o,j)=>{\\r\\n                    if(o.idx === sub) {\\r\\n                        this.pushCallbacks[key].splice(j,1);\\r\\n                        return true;\\r\\n                    }\\r\\n                })) {\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    unsubscribeAllSequential(key) {\\r\\n        if(key) {\\r\\n            if(this.pushCallbacks[key]) {\\r\\n                if(this.pushCallbacks[key]) {\\r\\n                    delete this.pushCallbacks[key];\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Set main onchange response for the property-specific object listener. Don't touch the state\\r\\n    setPrimaryKeyResponse(key=null, onchange=null, debug=false, startRunning=this.defaultStartListenerEventLoop) {\\r\\n        if(onchange !== null){\\r\\n            if(this.listener.hasKey(key)){\\r\\n                this.listener.onchange(key, onchange);\\r\\n            }\\r\\n            else if(key !== null){\\r\\n                this.listener.addListener(key, this.data, key, onchange, this.data[\\\"stateUpdateInterval\\\"], debug, startRunning);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Add extra onchange responses to the object listener for a set property. Use state key for state-wide change responses\\r\\n    addSecondaryKeyResponse(key=null, onchange=null, debug=false, startRunning=this.defaultStartListenerEventLoop) {\\r\\n        if(onchange !== null){\\r\\n            if(this.listener.hasKey(key)){\\r\\n                return this.listener.addFunc(key, onchange);\\r\\n            }\\r\\n            else if(key !== null){\\r\\n                this.listener.addListener(key, this.data,key,()=>{},this.data[\\\"stateUpdateInterval\\\"], debug, startRunning);\\r\\n                return this.listener.addFunc(key, onchange);\\r\\n            }\\r\\n            else { return this.listener.addFunc(\\\"state\\\", onchange);}\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //removes all secondary responses if idx left null. use \\\"state\\\" key for state-wide change responses\\r\\n    removeSecondaryKeyResponse(key=null,responseIdx=null, stopIfEmpty=true) {\\r\\n        if(key !== null) {\\r\\n            if(this.listener.hasKey(key)){\\r\\n                this.listener.removeFuncs(key, responseIdx, stopIfEmpty);\\r\\n            } else {\\r\\n                console.error(\\\"key does not exist\\\")\\r\\n            }\\r\\n        }\\r\\n        else{console.error(\\\"provide key\\\")}\\r\\n    }\\r\\n\\r\\n    //Remove any extra object listeners for a key. Entering \\\"state\\\" will break the state manager's primary response\\r\\n    clearAllKeyResponses(key=null) {\\r\\n        if(key === null) this.listener.remove(null);\\r\\n        else if(this.listener.hasKey(key)) this.listener.remove(key);\\r\\n    }\\r\\n\\r\\n    //Get all of the onchange functions added via subscribe/addSecondaryKeyResponse\\r\\n    getKeySubCallbacks(key) {\\r\\n        let callbacks = this.listener.getFuncs(key);\\r\\n        return callbacks;\\r\\n    }\\r\\n\\r\\n    //Save the return value to provide as the responseIdx in unsubscribe\\r\\n    subscribe(key, onchange, startRunning=true) {\\r\\n        // console.error('SUBSCRIBING')\\r\\n\\r\\n        if(this.data[key] === undefined) {this.addToState(key,null,onchange,startRunning);}\\r\\n        else {return this.addSecondaryKeyResponse(key,onchange);}\\r\\n    }\\r\\n \\r\\n    //will remove the subscription after firing once\\r\\n    subscribeOnce(key=undefined,onchange=(value)=>{}) {\\r\\n        let sub;\\r\\n        let changed = (value) => {\\r\\n            onchange(value);\\r\\n            this.unsubscribe(key,sub);\\r\\n        }\\r\\n\\r\\n        sub = this.subscribe(key,changed);\\r\\n    }\\r\\n    \\r\\n    //Unsubscribe from the given key using the index of the response saved from the subscribe() function\\r\\n    unsubscribe(key, responseIdx=null) {\\r\\n        if(responseIdx !== null) this.removeSecondaryKeyResponse(key, responseIdx, true);\\r\\n        else console.error(\\\"Specify a subcription function index\\\");\\r\\n    }\\r\\n\\r\\n    unsubscribeAll(key) { // Removes the listener for the key (including the animation loop)\\r\\n        this.clearAllKeyResponses(key);\\r\\n        if(this.data[key]) delete this.data[key];\\r\\n    }\\r\\n\\r\\n    //runs only one animation frame to check all state keys\\r\\n    runSynchronousListeners() {\\r\\n        this.defaultStartListenerEventLoop = false;\\r\\n        this.listener.startSync();\\r\\n    }\\r\\n\\r\\n    //stops the listener event loops without clearing the keys.\\r\\n    stop(key=null) {\\r\\n        this.listener.stop(key);\\r\\n    }\\r\\n\\r\\n}\\r\\n\\r\\n\\r\\n//modified to also cut down the size arrays for faster looping\\r\\nif(JSON.stringifyFast === undefined) {\\r\\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\\r\\n    JSON.stringifyFast = (function() {\\r\\n        const refs = new Map();\\r\\n        const parents = [];\\r\\n        const path = [\\\"this\\\"];\\r\\n\\r\\n        function clear() {\\r\\n            refs.clear();\\r\\n            parents.length = 0;\\r\\n            path.length = 1;\\r\\n        }\\r\\n\\r\\n        function updateParents(key, value) {\\r\\n            var idx = parents.length - 1;\\r\\n            //console.log(idx, parents[idx])\\r\\n            if(parents[idx]){\\r\\n                var prev = parents[idx];\\r\\n                //console.log(value); \\r\\n                if (prev[key] === value || idx === 0) {\\r\\n                    path.push(key);\\r\\n                    parents.push(value.pushed);\\r\\n                } else {\\r\\n                    while (idx-- >= 0) {\\r\\n                    prev = parents[idx];\\r\\n                    if (prev[key] === value) {\\r\\n                        idx += 2;\\r\\n                        parents.length = idx;\\r\\n                        path.length = idx;\\r\\n                        --idx;\\r\\n                        parents[idx] = value;\\r\\n                        path[idx] = key;\\r\\n                        break;\\r\\n                    }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        function checkValues(key, value) {\\r\\n            let val;\\r\\n            if (value != null) {\\r\\n                if (typeof value === \\\"object\\\") {\\r\\n                    //if (key) { updateParents(key, value); }\\r\\n                    let c = value.constructor.name;\\r\\n                    if (key && c === 'Object') {updateParents(key, value); }\\r\\n\\r\\n                    let other = refs.get(value);\\r\\n                    if (other) {\\r\\n                        return '[Circular Reference]' + other;\\r\\n                    } else {\\r\\n                        refs.set(value, path.join('.'));\\r\\n                    }\\r\\n                    if(c === \\\"Array\\\") { //Cut arrays down to 100 samples for referencing\\r\\n                        if(value.length > 20) {\\r\\n                            val = value.slice(value.length-20);\\r\\n                        } else val = value;\\r\\n                       // refs.set(val, path.join('.'));\\r\\n                    }  \\r\\n                    else if (c.includes(\\\"Set\\\")) {\\r\\n                        val = Array.from(value)\\r\\n                    }  \\r\\n                    else if (c !== \\\"Object\\\" && c !== \\\"Number\\\" && c !== \\\"String\\\" && c !== \\\"Boolean\\\") { //simplify classes, objects, and functions, point to nested objects for the state manager to monitor those properly\\r\\n                        val = \\\"instanceof_\\\"+c;\\r\\n                    }\\r\\n                    else if (c === 'Object') {\\r\\n                        let obj = {};\\r\\n                        for(const prop in value) {\\r\\n                            if (value[prop] == null){\\r\\n                                obj[prop] = value[prop]; \\r\\n                            }\\r\\n                            else if(Array.isArray(value[prop])) { \\r\\n                                if(value[prop].length>20)\\r\\n                                    obj[prop] = value[prop].slice(value[prop].length-20); \\r\\n                                else obj[prop] = value[prop];\\r\\n                            } //deal with arrays in nested objects (e.g. means, slices)\\r\\n                            else if (value[prop].constructor.name === 'Object') { //additional layer of recursion for 3 object-deep array checks\\r\\n                                obj[prop] = {};\\r\\n                                for(const p in value[prop]) {\\r\\n                                    if(Array.isArray(value[prop][p])) {\\r\\n                                        if(value[prop][p].length>20)\\r\\n                                            obj[prop][p] = value[prop][p].slice(value[prop][p].length-20); \\r\\n                                        else obj[prop][p] = value[prop][p];\\r\\n                                    }\\r\\n                                    else { \\r\\n                                        if (value[prop][p] != null){\\r\\n                                            let con = value[prop][p].constructor.name;\\r\\n                                            if (con.includes(\\\"Set\\\")) {\\r\\n                                                obj[prop][p] = Array.from(value[prop][p])\\r\\n                                            } else if(con !== \\\"Number\\\" && con !== \\\"String\\\" && con !== \\\"Boolean\\\") {\\r\\n                                                obj[prop][p] = \\\"instanceof_\\\"+con; //3-deep nested objects are cut off\\r\\n                                            }  else {\\r\\n                                                obj[prop][p] = value[prop][p]; \\r\\n                                            }\\r\\n                                        } else {\\r\\n                                            obj[prop][p] = value[prop][p]; \\r\\n                                        }\\r\\n                                    }\\r\\n                                }\\r\\n                            }\\r\\n                            else { \\r\\n                                let con = value[prop].constructor.name;\\r\\n                                if (con.includes(\\\"Set\\\")) {\\r\\n                                    obj[prop] = Array.from(value[prop])\\r\\n                                } else if(con !== \\\"Number\\\" && con !== \\\"String\\\" && con !== \\\"Boolean\\\") {\\r\\n                                    obj[prop] = \\\"instanceof_\\\"+con;\\r\\n                                } else {\\r\\n                                    obj[prop] = value[prop]; \\r\\n                                }\\r\\n                            }\\r\\n                        }\\r\\n                        //console.log(obj, value)\\r\\n                        val = obj;\\r\\n                        //refs.set(val, path.join('.'));\\r\\n                    }\\r\\n                    else {\\r\\n                        val = value;\\r\\n                    }\\r\\n                } else {\\r\\n                    val = value;\\r\\n                }\\r\\n            }\\r\\n            //console.log(value, val)\\r\\n            return val;\\r\\n        }\\r\\n\\r\\n        return function stringifyFast(obj, space) {\\r\\n            try {\\r\\n                parents.push(obj);\\r\\n                return JSON.stringify(obj, checkValues, space);\\r\\n            } catch(er) {\\r\\n                console.error(obj, er);\\r\\n            } finally {\\r\\n                clear();\\r\\n            } \\r\\n        }\\r\\n    })();\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\nif(JSON.stringifyWithCircularRefs === undefined) {\\r\\n    //Workaround for objects containing DOM nodes, which can't be stringified with JSON. From: https://stackoverflow.com/questions/4816099/chrome-sendrequest-error-typeerror-converting-circular-structure-to-json\\r\\n    JSON.stringifyWithCircularRefs = (function() {\\r\\n        const refs = new Map();\\r\\n        const parents = [];\\r\\n        const path = [\\\"this\\\"];\\r\\n\\r\\n        function clear() {\\r\\n        refs.clear();\\r\\n        parents.length = 0;\\r\\n        path.length = 1;\\r\\n        }\\r\\n\\r\\n        function updateParents(key, value) {\\r\\n        var idx = parents.length - 1;\\r\\n        var prev = parents[idx];\\r\\n        if (prev[key] === value || idx === 0) {\\r\\n            path.push(key);\\r\\n            parents.push(value);\\r\\n        } else {\\r\\n            while (idx-- >= 0) {\\r\\n            prev = parents[idx];\\r\\n            if (prev[key] === value) {\\r\\n                idx += 2;\\r\\n                parents.length = idx;\\r\\n                path.length = idx;\\r\\n                --idx;\\r\\n                parents[idx] = value;\\r\\n                path[idx] = key;\\r\\n                break;\\r\\n            }\\r\\n            }\\r\\n        }\\r\\n        }\\r\\n\\r\\n        function checkCircular(key, value) {\\r\\n        if (value != null) {\\r\\n            if (typeof value === \\\"object\\\") {\\r\\n            if (key) { updateParents(key, value); }\\r\\n\\r\\n            let other = refs.get(value);\\r\\n            if (other) {\\r\\n                return '[Circular Reference]' + other;\\r\\n            } else {\\r\\n                refs.set(value, path.join('.'));\\r\\n            }\\r\\n            }\\r\\n        }\\r\\n        return value;\\r\\n        }\\r\\n\\r\\n        return function stringifyWithCircularRefs(obj, space) {\\r\\n        try {\\r\\n            parents.push(obj);\\r\\n            return JSON.stringify(obj, checkCircular, space);\\r\\n        } finally {\\r\\n            clear();\\r\\n        }\\r\\n        }\\r\\n    })();\\r\\n}\\r\\n\\r\\n/* harmony default export */ const anotherstatemanager_StateManager = ((/* unused pure expression or super */ null && (StateManager)));\\n;// CONCATENATED MODULE: ./src/lib/Event.js\\n//multithreaded event manager, spawn one per thread and import a single instance elsewhere.\\n\\n/**\\r\\n * This is both a simple wrapper for a trigger-only state manager as well \\r\\n * as an interface for multithreaded events for simpler, more dynamic threading pipelines\\r\\n * \\r\\n * From any thread:\\r\\n * emit -> tx\\r\\n * rx -> run trigger \\r\\n * \\r\\n */\\n\\nclass Events {\\n  constructor(manager = undefined) {\\n    this.state = new StateManager({}, undefined, false); //trigger only state (no overhead)\\n\\n    this.manager = manager;\\n\\n    if (manager !== undefined) {\\n      //only in window\\n      let found = manager.responses.find(foo => {\\n        if (foo.name === 'eventmanager') return true;\\n      });\\n\\n      if (!found) {\\n        manager.addCallback('eventmanager', this.callback);\\n      }\\n    }\\n  } //subscribe a to an event, default is the port reponse \\n\\n\\n  subEvent(eventName, response = output => {\\n    console.log(eventName, output);\\n  }) {\\n    return this.state.subscribeTrigger(eventName, response);\\n  }\\n\\n  unsubEvent(eventName, sub) {\\n    return this.state.unsubscribeTrigger(eventName, sub);\\n  } //add an event name, can optionally add them to any threads too from the main thread\\n\\n\\n  async addEvent(eventName, workerId = undefined, functionName = undefined, origin = undefined) {\\n    this.state.setState({\\n      [eventName]: undefined\\n    });\\n\\n    if (this.manager !== undefined) {\\n      if (origin !== undefined || functionName !== undefined) {\\n        if (workerId !== undefined) {\\n          return await this.manager.post({\\n            origin: origin,\\n            foo: 'addevent',\\n            input: [eventName, functionName]\\n          }, workerId);\\n        } else {\\n          this.manager.workers.forEach(w => {\\n            this.manager.post({\\n              origin: origin,\\n              foo: 'addevent',\\n              input: [eventName, functionName]\\n            }, w.id); //add it to all of them since we're assuming we're rotating threads\\n          });\\n          return true;\\n        }\\n      }\\n    }\\n  } //remove an event\\n\\n\\n  removeEmitter(eventName) {\\n    this.state.unsubscribeAllTriggers(eventName);\\n  } //use this to set values by event name, will post messages on threads too\\n\\n\\n  emit = (eventName, input, workerId = undefined, transfer = undefined, port = undefined) => {\\n    let output = {\\n      eventName: eventName,\\n      output: input\\n    };\\n    if (!input || !eventName) return;\\n\\n    if (this.manager !== undefined) {\\n      //when emitting values for workers, input should be an object like {input:0, foo'abc', origin:'here'} for correct worker callback usage\\n      if (workerId !== undefined) this.manager.post(output, workerId, transfer);else {\\n        this.manager.workers.forEach(w => {\\n          this.manager.post(output, w.id, transfer);\\n        });\\n      }\\n    } else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\\n      // run this in global scope of window or worker. since window.self = window, we're ok\\n      //if(port) console.log(port,output);\\n      if (port) port.postMessage(output, undefined, transfer);else self.postMessage(output, undefined, transfer); //thread event \\n    }\\n\\n    this.state.setState({\\n      [eventName]: input\\n    }); //local event \\n  };\\n  callback = msg => {\\n    if (typeof msg === 'object') {\\n      if (msg.eventName !== undefined && msg.output !== undefined) {\\n        this.state.setState({\\n          [msg.eventName]: msg.output\\n        });\\n      }\\n    }\\n  };\\n  export = () => {\\n    return this;\\n  };\\n}\\n\\n/***/ }),\\n\\n/***/ 343:\\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\\n\\n\\\"use strict\\\";\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"d\\\": () => (/* binding */ Math2)\\n/* harmony export */ });\\n//By Joshua Brewster (AGPL)\\n\\n/**\\r\\n * Math2 Contains All Static Methods\\r\\n * We'll add more useful static things like filter kernels etc. as we get to making them.\\r\\n * \\r\\n * //Just type these and the variable inputs that pop up should be easy to follow. Everything is commented otherwise till we document it\\r\\n * genSineWave() //generate a sine wave\\r\\n * getSineAmplitude() //get amplitude of a sine at time t\\r\\n * mean() //array mean\\r\\n * mode() //array mode\\r\\n * std() //standard dev\\r\\n * relError() //relative error\\r\\n * informationEntropy() //trying to build a maxent distribution off of this stuff\\r\\n * zscore() //array z score\\r\\n * variance() //variance\\r\\n * dot() //dot product\\r\\n * cross3D() //3d cross product\\r\\n * magnitude() //vector magnitude\\r\\n * distance() //distance function p1-p2\\r\\n * normalize() //array normalization\\r\\n * newtonsMethod() //root approximation\\r\\n * integral() //1d integral\\r\\n * dintegral() //2d integral\\r\\n * tintegral() //3d integral\\r\\n * pintegral() //2d path integral\\r\\n * makeVec() \\r\\n * transpose(mat) //2d mat transpose\\r\\n * matmul(a,b) \\r\\n * matscale(mat,scalar)\\r\\n * matadd(a,b)\\r\\n * matsub(a,b)\\r\\n * normalDistribution(samples=[], normalize=true) //create a norall (gaussian) distribution\\r\\n * expectedValue(samples=[],probabilities=this.normalDistribution(samples)) //get expected value of an array\\r\\n * originMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) //statistical moment about origin\\r\\n * centralMoment(samples=[],probabilities=this.normalDistribution(samples),order=1) //statistical moment about mean\\r\\n * linearDiscriminantAnalysis(samples=[], classifier=[]) //LDA\\r\\n * conv1D(arr=[],kern=[],pad=0) //1d convolution //1d convolution\\r\\n * conv2D(mat=[[],[],[]],kern=[[],[],[]],pad=0) //2d convolution\\r\\n * cov2d(mat) //2d covariance\\r\\n * cov1d(arr1=[],arr2=[]) //1d covariance\\r\\n * cov3d(x=[],y=[],z=[]) //3d covariance\\r\\n * covNd(dimensionalData=[]) //nd covariance\\r\\n * eigens2x2(mat=[[1,2],[3,4]]) //fast 2x2 eigenvalue \\r\\n * eigenvectors2x2(mat=[[1,2],[3,4]], eigens=[1,2]) //fast 2x2 eigenvector \\r\\n * fastpca2d(xarr,yarr) //fast 2d pca\\r\\n * crosscorrelation(arr1,arr2) //crosscor\\r\\n * autocorrelation(arr1) //autocor\\r\\n * correlograms(dat=[[],[]]) //return cross correlations of many signals\\r\\n * sma(arr=[], window) //simple moving average \\r\\n * sum(arr=[]) //array sum\\r\\n * reduceArrByFactor(arr,factor=2) //reduce array sizes\\r\\n * makeArr(startValue, stopValue, nSteps) //linspace\\r\\n * interpolateArray(data, fitCount, scalar=1) \\r\\n * isExtrema(arr,critical='peak') //peak or valley\\r\\n * isCriticalPoint(arr,critical='peak') //peak, valley\\r\\n * peakDetect = (smoothedArray,type='peak',window=49) //wider window to find less peaks\\r\\n * getPeakThreshold(arr, peakIndices, thresholdVar)\\r\\n * \\r\\n * eigens(M=[[],[]], tolerance=0.0001, max_iterations=1000)\\r\\n * pca(mat=[[],[]],tolerance = 0.00001) //power iteration method PCA\\r\\n * eigenvalue_of_vector(mat, eigenvector)\\r\\n * power_iteration(mat, tolerance=0.00001, max_iterations=1000)\\r\\n * squared_difference(v1, v2)\\r\\n * flatten_vector(v) //column to row\\r\\n * column(mat, x) //row to column\\r\\n * \\r\\n */\\nclass Math2 {\\n  constructor() {} //----------------------------------------------------------------\\n  //-------------------- Static Variables---------------------------\\n  //----------------------------------------------------------------\\n  //Throwing a bunch in here for the hell of it\\n\\n\\n  static TWO_PI = Math.PI * 2; //2PI\\n\\n  static C = 299792458; //speed of light m/s\\n\\n  static G = 6.67430e-11; //Newton's gravitation constant N*m^2 / kg^2\\n\\n  static h = 6.62607015e-34; //Planck constant J*s\\n\\n  static R = 8.31432e3; //Universal gas constant J / kg*mol*K\\n\\n  static Ra = 287; //Air gas constant J / kg*K\\n\\n  static H = 69.3; //Hubble constant km/s/Mpc \\n\\n  static kbar = 1.054571817e-34; //Dirac constant J*s\\n\\n  static kB = 1.380649e-23; //Boltzmann constant J/K\\n\\n  static ke = 8.9875517923e9; //Coulomb constant kg * m^3 * s^-2 * C^-2\\n\\n  static me = 9.1093837015e-31; //electron mass kg\\n\\n  static mp = 1.67262192369e-27; //proton mass kg\\n\\n  static mn = 1.67492749804e-27; //neutron mass kg\\n\\n  static P0 = 1.01325e5; //Sea level pressure N/m^2\\n\\n  static T0 = 288.15; //Sea level room temperature K\\n\\n  static p0 = 1.225; //Sea level air density kg/m^3\\n\\n  static Na = 6.0220978e23; //Avogadro's number 1 / kg*mol\\n\\n  static y = 1.405; //Adiabatic constant\\n\\n  static M0 = 28.96643; //Sea level molecular weight\\n\\n  static g0 = 9.80665; //Sea level gravity m/s^2\\n\\n  static Re = 6.3781e6; //Earth radius m\\n\\n  static B = 1.458e-6; //Thermal constant Kg / m*s*sqrt(kg)\\n\\n  static S = 110.4; //Sutherland's constant K\\n\\n  static Sigma = 3.65e-10; //Collision diameter of air m\\n\\n  static imgkernels = {\\n    edgeDetection: [[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]],\\n    boxBlur: [[1 / 9, 1 / 9, 1 / 9], [1 / 9, 1 / 9, 1 / 9], [1 / 9, 1 / 9, 1 / 9]],\\n    sobelLeft: [[1, 0, -1], [2, 0, -2], [1, 0, -1]],\\n    sobelRight: [[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]],\\n    sobelTop: [[1, 2, 1], [0, 0, 0], [-1, -2, -1]],\\n    sobelBottom: [[-1, 2, 1], [0, 0, 0], [1, 2, 1]],\\n    identity: [[0, 0, 0], [0, 1, 0], [0, 0, 0]],\\n    gaussian3x3: [[1, 2, 1], [2, 4, 2], [1, 2, 1]],\\n    guassian7x7: [[0, 0, 0, 5, 0, 0, 0], [0, 5, 18, 32, 18, 5, 0], [0, 18, 64, 100, 64, 18, 0], [5, 32, 100, 100, 100, 32, 5], [0, 18, 64, 100, 64, 18, 0], [0, 5, 18, 32, 18, 5, 0], [0, 0, 0, 5, 0, 0, 0]],\\n    emboss: [[-2, -1, 0], [-1, 1, 1], [0, 1, 2]],\\n    sharpen: [[0, -1, 0], [-1, 5, -1], [0, -1, 0]]\\n  }; //----------------------------------------------------------------\\n  //-------------------- Static Functions --------------------------\\n  //----------------------------------------------------------------\\n  //Generate sinewave, you can add a noise frequency in too. Array length will be Math.ceil(fs*nSec)\\n\\n  static genSineWave(freq = 20, peakAmp = 1, nSec = 1, fs = 512, freq2 = 0, peakAmp2 = 1) {\\n    var sineWave = [];\\n    var t = [];\\n    var increment = 1 / fs; //x-axis time increment based on sample rate\\n\\n    for (var ti = 0; ti < nSec; ti += increment) {\\n      var amplitude = Math.sin(2 * Math.PI * freq * ti) * peakAmp;\\n      amplitude += Math.sin(2 * Math.PI * freq2 * ti) * peakAmp2; //Add interference\\n\\n      sineWave.push(amplitude);\\n      t.push(ti);\\n    }\\n\\n    return [t, sineWave]; // [[times],[amplitudes]]\\n  } //get the sine amplitude at a particular time (seconds)\\n\\n\\n  static getSineAmplitude(frequency = 20, peakAmplitude = 1, ti = 0, tOffset = 0) {\\n    return Math.sin(this.TWO_PI * frequency * ti + tOffset) * peakAmplitude;\\n  } //average value of array\\n\\n\\n  static mean(arr) {\\n    var sum = arr.reduce((prev, curr) => curr += prev);\\n    return sum / arr.length;\\n  } //array mode (most commonly occurring number)\\n\\n\\n  static mode(arr) {\\n    return arr.sort((a, b) => arr.filter(v => v === a).length - arr.filter(v => v === b).length).pop();\\n  } //standard deviation\\n\\n\\n  static std(arr, mean = undefined) {\\n    let avg = mean;\\n    if (!mean) avg = this.mean(arr);\\n    let summed = 0;\\n\\n    for (let i = 0; i < arr.length; i++) {\\n      let subbed = arr[i] - avg;\\n      summed += subbed * subbed;\\n    }\\n\\n    return Math.sqrt(summed / arr.length);\\n  } //find the relative error of predicted results\\n\\n\\n  static relError(actual = [], forecast = [], abs = true) {\\n    if (actual.length !== forecast.length) throw new Error('Input arrays of same length!');\\n    let i = actual.length;\\n    let d = []; //relative errors\\n\\n    for (let j = 0; j < i; j++) {\\n      let dd = (actual[j] - forecast[j]) / actual[j];\\n      if (abs) dd = Math.abs(dd);\\n      d.push(dd);\\n    }\\n\\n    return d;\\n  } //returns information entropy in natural units (base e)\\n\\n\\n  static informationEntropy(probabilities = []) {\\n    let entropy = [];\\n    let len = probabilities.length;\\n\\n    for (let i = 0; i < len; i++) {\\n      let ent = probabilities[i] * Math.log(probabilities[i]);\\n      if (isNaN(ent)) ent = 0;\\n      entropy.push(ent);\\n    }\\n\\n    return entropy;\\n  } //array zscore (probabilities)\\n\\n\\n  static zscore(arr) {\\n    let mean = this.mean(arr);\\n    let std = this.std(arr, mean);\\n    let z = [];\\n\\n    for (let i = 0; i < arr.length; i++) {\\n      z.push((arr[i] - mean) / std);\\n    }\\n\\n    return z;\\n  }\\n\\n  static variance(arr) {\\n    //Variance of 1D input arrays of length n\\n    var mean = this.mean(arr);\\n    return arr.reduce((a, b) => a + (b - mean) ** 2, 0) / arr.length;\\n  }\\n\\n  static dot(vec1, vec2) {\\n    //nDimensional vector dot product\\n    var dot = 0;\\n\\n    for (var i = 0; i < vec1.length; i++) {\\n      dot += vec1[i] * vec2[i];\\n    }\\n\\n    return dot;\\n  }\\n\\n  static cross3D(vec1, vec2) {\\n    //3D vector cross product\\n    return [vec1[1] * vec2[2] - vec1[2] * vec2[1], //x\\n    vec1[2] * vec2[0] - vec1[0] * vec2[2], //y\\n    vec1[0] * vec2[1] - vec1[1] * vec2[0] //z\\n    ];\\n  }\\n\\n  static magnitude(vec) {\\n    //nDimensional magnitude\\n    var sqrd = 0;\\n    vec.forEach(c => {\\n      sqrd += c * c;\\n    });\\n    return Math.sqrt(sqrd);\\n  }\\n\\n  static distance(point1, point2) {\\n    //nDimensional vector distance function\\n    var dsqrd = 0;\\n    point1.forEach((c, i) => {\\n      dsqrd += (point2[i] - c) * (point2[i] - c);\\n    });\\n    return Math.sqrt(dsqrd);\\n  }\\n\\n  static normalize(vec) {\\n    //nDimensional vector normalization\\n    var norm = 0;\\n    norm = this.magnitude(vec);\\n    var vecn = [];\\n    vec.forEach((c, i) => {\\n      vecn.push(c * norm);\\n    });\\n    return vecn;\\n  } //return the quadratic roots based on your input ax^2 + bx + c = 0\\n\\n\\n  static quadraticFormula(a, b, c) {\\n    let bbmac4 = Math.sqrt(b * b - 4 * a * c);\\n    if (!isNaN(bbmac4)) return ['complex', 'complex'];\\n\\n    let _a2 = 1 / (2 * a);\\n\\n    if (bbmac4 === 0) return [b * _a2];\\n    let nb = -b;\\n    return [(nb + bbmac4) * _a2, (nb - bbmac4) * _a2];\\n  } //approximation of function roots. Provide a function (1d), window, and precision and it will return approximate roots along that window\\n\\n\\n  static newtonsMethod(foo = x => {\\n    return Math.pow(x, 5) + x * x - x - 0.2;\\n  }, start = 0, end = 1, precision = 0.01, attempts = 10) {\\n    let roots = [];\\n\\n    for (let i = 0; i < attempts; i++) {\\n      let seedx = Math.random() * (end - start);\\n      let guess = foo(seedx);\\n      let guess2 = foo(seedx + precision);\\n      let slope = (guess2 - guess) / precision;\\n      let xn = seedx + precision;\\n\\n      while (Math.abs(slope) > precision) {\\n        let step = -guess / slope;\\n        let xn1 = xn + step;\\n        guess = guess2;\\n        guess2 = foo(xn1);\\n        let slope = (guess2 - guess) / (xn1 - xn);\\n      }\\n\\n      let idx;\\n      let f = roots.find((root, i) => {\\n        if (Math.abs(xn1 - root) < precision) {\\n          idx = i;\\n          return true;\\n        }\\n      });\\n      if (f) roots[idx] = (xn1 + f) * 0.5;else roots.push(xn1);\\n    }\\n\\n    return roots;\\n  } //2D integral approximation using rectangular area under the curve. If you need absolute values be sure to return that.\\n\\n\\n  static integral = (func = x => {\\n    let y = x;\\n    return y;\\n  }, range = [], stepx = 0.01) => {\\n    let area = 0;\\n\\n    for (let i = range[0]; i < range[1]; i += stepx) {\\n      let y = func(i);\\n      area += y * stepx;\\n    }\\n\\n    return area;\\n  }; //3D double integral approximation\\n\\n  static dintegral = (func = (x, y) => {\\n    let z = x + y;\\n    return z;\\n  }, range = [[], []], stepx = 0.01, stepy = stepx) => {\\n    let volume = 0;\\n\\n    for (let i = range[0][0] + stepx; i < range[0][1]; i += stepx) {\\n      for (let j = range[1][0] + stepy; j < range[1][1]; j += stepy) {\\n        let z = func(i, j);\\n        volume += z * stepx * stepy;\\n      }\\n    }\\n\\n    return volume;\\n  }; //4D triple integral approximation\\n\\n  static tintegral = (func = (x, y, z) => {\\n    let w = x + y + z;\\n    return w;\\n  }, range = [[], [], []], stepx = 0.01, stepy = stepx, stepz = stepx) => {\\n    let volume = 0;\\n\\n    for (let i = range[0][0] + stepx; i < range[0][1]; i += stepx) {\\n      for (let j = range[1][0] + stepy; j < range[1][1]; j += stepy) {\\n        for (let k = range[2][0] + stepz; k < range[2][1]; k += stepz) {\\n          let w = func(i, j, k);\\n          volume += w * stepx * stepy * stepz;\\n        }\\n      }\\n    }\\n\\n    return volume;\\n  }; //2D path integral approximation (the length of a curve)\\n\\n  static pintegral = (func = x => {\\n    let y = x;\\n    return y;\\n  }, range = [], stepx = 0.01) => {\\n    let length = 0;\\n    let y0 = undefined;\\n    let yi = undefined;\\n\\n    for (let i = range[0]; i < range[1]; i += stepx) {\\n      y0 = yi;\\n      yi = func(i);\\n      if (y0) length += this.distance([0, y0], [stepx, yi]);\\n    }\\n\\n    return length;\\n  };\\n\\n  static makeVec(point1, point2) {\\n    //Make vector from two nDimensional points (arrays)\\n    var vec = [];\\n    point1.forEach((c, i) => {\\n      vec.push(point2[i] - c);\\n    });\\n    return vec;\\n  }\\n\\n  static transpose(mat) {\\n    return mat[0].map((_, colIndex) => mat.map(row => row[colIndex]));\\n  } //2D Matrix multiplication from: https://stackoverflow.com/questions/27205018/multiply-2-matrices-in-javascript\\n\\n\\n  static matmul(a, b) {\\n    var aNumRows = a.length,\\n        aNumCols = a[0].length,\\n        bNumRows = b.length,\\n        bNumCols = b[0].length,\\n        m = new Array(aNumRows); // initialize array of rows\\n\\n    for (var r = 0; r < aNumRows; ++r) {\\n      m[r] = new Array(bNumCols); // initialize the current row\\n\\n      for (var c = 0; c < bNumCols; ++c) {\\n        m[r][c] = 0; // initialize the current cell\\n\\n        for (var i = 0; i < aNumCols; ++i) {\\n          m[r][c] += a[r][i] * b[i][c];\\n        }\\n      }\\n    }\\n\\n    return m;\\n  } //Apply scalar to 2D matrix \\n\\n\\n  static matscale(mat, scalar) {\\n    let m = [];\\n\\n    for (var i = 0; i < mat.length; i++) {\\n      m[i] = [];\\n\\n      for (let j = 0; j < mat[0].length; j++) {\\n        m[i][j] = mat[i][j] * scalar;\\n      }\\n    }\\n\\n    return m;\\n  } //2d matrix addition\\n\\n\\n  static matadd(a, b) {\\n    let m = [];\\n\\n    for (let i = 0; i < a.length; i++) {\\n      m[i] = [];\\n\\n      for (var j = 0; j < a[0].length; j++) {\\n        m[i][j] = a[i][j] + b[i][j];\\n      }\\n    }\\n\\n    return m;\\n  } //2d matrix subtraction\\n\\n\\n  static matsub(a, b) {\\n    let m = [];\\n\\n    for (let i = 0; i < a.length; i++) {\\n      m[i] = [];\\n\\n      for (var j = 0; j < a[0].length; j++) {\\n        m[i][j] = a[i][j] - b[i][j];\\n      }\\n    }\\n\\n    return m;\\n  } //return a histogram of the array, use nBins to override binSize\\n\\n\\n  static histogram(arr = [], binSize = 1, nBins = undefined) {\\n    let copy = [...arr];\\n    copy.sort(function (a, b) {\\n      return a - b;\\n    }); //ascending sort\\n\\n    let binStart = Math.min(...copy);\\n\\n    if (typeof nBins === 'number') {\\n      let binEnd = Math.max(...copy);\\n      binSize = Math.abs((binEnd - binStart) / (nBins - 1));\\n    }\\n\\n    let j = binStart;\\n    let binx = [];\\n    let biny = [];\\n\\n    for (let i = 0; i < copy.length; i++) {\\n      let binidx = binSize * j;\\n\\n      if (copy[i] > binStart + binidx) {\\n        j++;\\n        binidx += binSize;\\n        let binmin = binStart + binidx;\\n        let binmid = binmin + binidx * 0.5;\\n        binx.push(binmid);\\n        biny.push(0);\\n      }\\n\\n      biny[biny.length - 1]++;\\n    }\\n\\n    return [binx, biny];\\n  } //Get probability densities for the samples, set a cutoff to avoid obscenely small numbers\\n\\n\\n  static normalDistribution(samples = [], normalize = true, cutoff = 0.0001) {\\n    let m = this.mean(samples);\\n    let vari = this.variance(samples);\\n    let nSamples = samples.length;\\n    let probabilities = [];\\n    let denom = 1 / (this.TWO_PI * vari);\\n\\n    let _variance = 1 / vari;\\n\\n    let sum = 0; //for normalization\\n\\n    for (let i = 0; i < nSamples; i++) {\\n      let px = Math.exp(-0.5 * Math.pow((samples[i] - m) * _variance, 2)) * denom;\\n      if (px < cutoff) px = 0;\\n      probabilities.push(px);\\n      sum += px;\\n    }\\n\\n    if (normalize) {\\n      let _sum = 1 / sum;\\n\\n      probabilities = probabilities.map(x => x * _sum);\\n    }\\n\\n    return probabilities;\\n  }\\n\\n  static expectedValue(samples = [], probabilities = this.normalDistribution(samples)) {\\n    return samples.reduce((sum, item, idx) => sum + item * probabilities[idx]);\\n  } //moment about the origin (statistics)\\n\\n\\n  static originMoment(samples = [], probabilities = this.normalDistribution(samples), order = 1) {\\n    return samples.reduce((sum, item, idx) => sum + Math.pow(item, order) * probabilities[idx]);\\n  } //moment about the population mean (statistics)\\n\\n\\n  static centralMoment(samples = [], probabilities = this.normalDistribution(samples), order = 1) {\\n    let m = this.mean(samples);\\n    return samples.reduce((sum, item, idx) => sum + Math.pow(item - m, order) * probabilities[idx] / samples.length);\\n  }\\n\\n  static linearDiscriminantAnalysis(samples = [], classifier = []) {\\n    let mean = this.mean(samples);\\n    let meank = this.mean(classifier);\\n    let covariance = this.cov1d(samples, classifier);\\n    let probs = this.normalDistribution(samples);\\n    let dk = [];\\n\\n    for (let i = 0; i < samples.length; i++) {\\n      dk.push(x[i] * covariance * meank - .5 * mean * covariance * meank + Math.log10(probs[i]));\\n    }\\n\\n    return dk;\\n  } //1D convolution (filtering)\\n\\n\\n  static conv1D(arr = [], kern = [1 / 3, 1 / 3, 1 / 3], pad = Math.floor(kern.length * 0.5)) {\\n    let result = [];\\n\\n    let _n = 1 / kern.length;\\n\\n    if (pad > 0) {\\n      let pads = new Array(pad).fill(0);\\n      arr = [...pads, ...arr, ...pads];\\n    }\\n\\n    let start = Math.floor(kern.length * 0.5); //offset since kernel will reduce size of array\\n\\n    let end = arr.length - kern.length + start; //end index\\n\\n    for (let i = start; i < end; i++) {\\n      let acc = 0;\\n\\n      for (let j = 0; j < kern.length; j++) {\\n        acc += arr[i - start] * kern[j];\\n      }\\n\\n      result.push(acc * _n);\\n    }\\n\\n    return result;\\n  } //2D convolution (filtering), input 2d mat and 2d kernel \\n\\n\\n  static conv2D(mat = [[], [], []], kern = [[], [], []], pad = 0) {\\n    let result = new Array(mat.length - Math.ceil(kern.length * 0.5)).fill([]);\\n    let mat_t;\\n    let kern_t = Math2.transpose(kern_t);\\n\\n    if (pad > 0) {\\n      let pads = new Array(pad).fill(0); //transpose to col/row\\n\\n      mat_t = Math2.transpose(mat); //hard copy\\n\\n      for (let i = 0; i < mat_t.length; i++) {\\n        mat_t[i] = [...pads, ...mat_t[i], ...pads];\\n      } //transpose back\\n\\n\\n      mat = Math2.transpose(mat_t);\\n\\n      for (let j = 0; j < mat.length; j++) {\\n        mat[j] = [...pads, ...mat[j], ...pads];\\n      }\\n    }\\n\\n    let startr = Math.floor(kern[0].length * 0.5); //offset since kernel will reduce size of array\\n\\n    let startl = Math.floor(kern_t[0].length * 0.5); //offset since kernel will reduce size of array\\n\\n    let endr = mat[0].length - kern[0].length + startr; //row end\\n\\n    let endl = mat_t[0].length - kern_t[0].length + startl; //column end\\n\\n    let _n = 1 / (kern[0].length * kern_t[0].length);\\n\\n    let iters = endr * endl; //number of convolutions to perform\\n\\n    let i = startr;\\n    let x;\\n    let y = startl;\\n\\n    while (i < iters) {\\n      let acc = 0;\\n      x = i % mat[0].length;\\n\\n      if (x === 0) {\\n        y++;\\n      }\\n\\n      for (let j = 0; j < kern[0].length; j++) {\\n        for (let k = 0; k < kern_t[0].length; j++) {\\n          acc += mat[y - startl + k][x - startr + j] * kern[k][j];\\n        }\\n\\n        result[y].push(acc * _n);\\n      }\\n\\n      i++;\\n    }\\n\\n    return result;\\n  } //2D matrix covariance (e.g. for lists of signals). Pretty fast!!!\\n\\n\\n  static cov2d(mat) {\\n    //[[x,y,z,w],[x,y,z,w],...] input list of vectors of the same length\\n    //Get variance of rows and columns\\n    //console.time(\\\"cov2d\\\");\\n    var mattransposed = this.transpose(mat); //console.log(mattransposed)\\n\\n    var matproducts = [];\\n    var rowmeans = [];\\n    var colmeans = [];\\n    mat.forEach((row, idx) => {\\n      rowmeans.push(this.mean(row));\\n    });\\n    mattransposed.forEach((col, idx) => {\\n      colmeans.push(this.mean(col));\\n    });\\n    mat.forEach((row, idx) => {\\n      matproducts.push([]);\\n\\n      for (var col = 0; col < row.length; col++) {\\n        matproducts[idx].push((mat[idx][col] - rowmeans[idx]) * (mat[idx][col] - colmeans[col]) / (row.length - 1));\\n      }\\n    });\\n    /*\\r\\n    \\tmat[y][x] = (x - rowAvg)*(x - colAvg) / (mat[y].length - 1);\\r\\n    */\\n    //console.log(matproducts);\\n    //Transpose matrix\\n\\n    var matproductstransposed = this.transpose(matproducts); //Matrix multiplication, stolen from: https://stackoverflow.com/questions/27205018/multiply-2-matrices-in-javascript\\n\\n    var aNumRows = matproducts.length,\\n        aNumCols = matproducts[0].length,\\n        bNumRows = matproductstransposed.length,\\n        bNumCols = matproductstransposed[0].length,\\n        m = new Array(aNumRows); // initialize array of rows\\n\\n    for (var r = 0; r < aNumRows; ++r) {\\n      m[r] = new Array(bNumCols); // initialize the current row\\n\\n      for (var c = 0; c < bNumCols; ++c) {\\n        m[r][c] = 0; // initialize the current cell\\n\\n        for (var i = 0; i < aNumCols; ++i) {\\n          m[r][c] += matproducts[r][i] * matproductstransposed[i][c] / (mat[0].length - 1); //divide by row length - 1\\n        }\\n      }\\n    } //console.timeEnd(\\\"cov2d\\\");\\n\\n\\n    return m; //Covariance matrix\\n  } //Covariance between two 1D arrays\\n\\n\\n  static cov1d(arr1 = [], arr2 = []) {\\n    return this.cov2d([arr1, arr2]);\\n  } //3d covariance\\n\\n\\n  static cov3d(x = [], y = [], z = []) {\\n    return [[this.cov1d(x, x), this.cov1d(x, y), this.cov1d(x, z)], [this.cov1d(y, x), this.cov1d(y, y), this.cov1d(y, z)], [this.cov1d(z, x), this.cov1d(z, y), this.cov1d(z, z)]];\\n  } //n-dimensional covariance matrix\\n\\n\\n  static covNd(dimensionalData = []) {\\n    let covariance = [];\\n    dimensionalData.forEach((arr, i) => {\\n      covariance.push([]);\\n      dimensionalData.forEach((arr2, j) => {\\n        covariance[i].push(this.cov1d(arr, arr2));\\n      });\\n    });\\n  } //fast 2x2 eigenvalue calculator: https://www.youtube.com/watch?v=e50Bj7jn9IQ\\n\\n\\n  static eigens2x2(mat = [[1, 2], [3, 4]]) {\\n    let det = mat[0][0] * mat[1][1] - mat[0][1] * mat[1][0];\\n    let mean = (mat[0][0] + mat[1][1]) * .5;\\n    let sqrt = Math.sqrt(mean * mean - det);\\n    let eig1 = mean + sqrt;\\n    let eig2 = mean - sqrt;\\n    return [eig1, eig2];\\n  } //http://math.colgate.edu/~wweckesser/math312Spring06/handouts/IMM_2x2linalg.pdf\\n\\n\\n  static eigenvectors2x2(mat = [[1, 2], [3, 4]], eigens = [1, 2]) {\\n    let v1 = [-mat[0][1], mat[0][0] - eigens[0]];\\n\\n    if (v1[0] === 0 && v1[1] === 0) {\\n      v1[0] = mat[1][1] - eigens[0];\\n      v1[1] = -mat[1][0];\\n    }\\n\\n    let v2 = [-mat[0][1], mat[0][0] - eigens[1]];\\n\\n    if (v2[0] === 0 && v2[1] === 0) {\\n      v2[0] = mat[1][1] - eigens[1];\\n      v2[1] = -mat[1][0];\\n    }\\n\\n    return [v1, v2];\\n  } //Fast PCA for 2D datasets https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c\\n\\n\\n  static fastpca2d(xarr, yarr) {\\n    let cov1d = this.cov1d(xarr, yarr); //yields a 2x2 matrix\\n\\n    let eigs = this.eigens2x2(cov1d);\\n    if (eigs[1] > eigs[0]) eigs.reverse();\\n    let evs = this.eigenvectors2x2(cov1d, eigs);\\n    console.log(eigs, evs);\\n    return [eigs, evs];\\n  } //Simple cross correlation.\\n\\n\\n  static crosscorrelation(arr1, arr2) {\\n    //console.time(\\\"crosscorrelation\\\");\\n    var arr2buf = [...arr2, ...Array(arr2.length).fill(0)];\\n    var mean1 = this.mean(arr1);\\n    var mean2 = this.mean(arr2); //Estimators\\n\\n    var arr1Est = arr1.reduce((sum, item) => sum += Math.pow(item - mean1, 2));\\n    arr1Est = Math.sqrt(arr1Est);\\n    var arr2Est = arr2.reduce((sum, item) => sum += Math.pow(item - mean1, 2));\\n    arr2Est = Math.sqrt(arr2Est);\\n\\n    var _arrEstsMul = 1 / (arr1Est * arr2Est);\\n\\n    var correlations = new Array(arr1.length).fill(0);\\n\\n    for (var delay = 0; delay < arr1.length; delay++) {\\n      var r = arr1.reduce((sum, item, i) => sum += (item - mean1) * (arr2buf[delay + i] - mean2));\\n      correlations[delay] = r * _arrEstsMul;\\n    } //console.timeEnd(\\\"crosscorrelation\\\");\\n\\n\\n    return correlations;\\n  } //Simple autocorrelation. Better method for long series: FFT[x1] .* FFT[x2]\\n\\n\\n  static autocorrelation(arr1) {\\n    var delaybuf = [...arr1, ...Array(arr1.length).fill(0)];\\n    var mean1 = this.mean(arr1); //Estimators\\n\\n    var arr1Est = arr1.reduce((sum, item) => sum += Math.pow(item - mean1, 2));\\n    arr1Est = Math.sqrt(arr1Est);\\n\\n    var _arr1estsqrd = 1 / (arr1Est * arr1Est);\\n\\n    var correlations = new Array(arr1.length).fill(0);\\n\\n    for (var delay = 0; delay < arr1.length; delay++) {\\n      var r = arr1.reduce((sum, item, i) => sum += (item - mean1) * (delaybuf[delay + i] - mean1));\\n      correlations[delay] = r * _arr1estsqrd;\\n    }\\n\\n    return correlations;\\n  } //Compute correlograms of the given array of arrays (of equal length). Input array of equal length arrays of latest raw data (use dat = eeg32instance.getTaggedRawData())\\n\\n\\n  static correlograms(dat = [[], []]) {\\n    //Coherence network math for data pushed to the atlas\\n    var correlograms = []; //auto and cross correlations for each channel\\n\\n    dat.forEach((row1, i) => {\\n      dat.forEach((row2, j) => {\\n        if (j >= i) {\\n          correlograms.push(Math2.crosscorrelation(row1, row2));\\n        }\\n      });\\n    });\\n    return correlograms; //Output ordered like (tag1:tag1, tag1:tag2 ... tag2:tag2, tag2:tag3 ... tagn:tagn) where autocorrelograms are also included\\n  } //Input data and averaging window, output array of moving averages (should be same size as input array, initial values not fully averaged due to window)\\n\\n\\n  static sma(arr = [], window) {\\n    var smaArr = []; //console.log(arr);\\n\\n    for (var i = 0; i < arr.length; i++) {\\n      if (i == 0) {\\n        smaArr.push(arr[0]);\\n      } else if (i < window) {\\n        //average partial window (prevents delays on screen)\\n        var arrslice = arr.slice(0, i + 1);\\n        smaArr.push(arrslice.reduce((previous, current) => current += previous) / (i + 1));\\n      } else {\\n        //average windows\\n        var arrslice = arr.slice(i - window, i);\\n        smaArr.push(arrslice.reduce((previous, current) => current += previous) / window);\\n      }\\n    } //console.log(temp);\\n\\n\\n    return smaArr;\\n  }\\n\\n  static sum(arr = []) {\\n    if (arr.length > 0) {\\n      var sum = arr.reduce((prev, curr) => curr += prev);\\n      return sum;\\n    } else {\\n      return 0;\\n    }\\n  }\\n\\n  static reduceArrByFactor(arr, factor = 2) {\\n    //faster than interpolating\\n    let x = arr.filter((element, index) => {\\n      return index % factor === 0;\\n    });\\n    return x;\\n  } //Make an array of size n from a to b \\n\\n\\n  static makeArr(startValue, stopValue, nSteps) {\\n    var arr = [];\\n    var step = (stopValue - startValue) / (nSteps - 1);\\n\\n    for (var i = 0; i < nSteps; i++) {\\n      arr.push(startValue + step * i);\\n    }\\n\\n    return arr;\\n  } //Linear interpolation from https://stackoverflow.com/questions/26941168/javascript-interpolate-an-array-of-numbers. Input array and number of samples to fit the data to\\n\\n\\n  static interpolateArray(data, fitCount, scalar = 1) {\\n    var linearInterpolate = function (before, after, atPoint) {\\n      return (before + (after - before) * atPoint) * scalar;\\n    };\\n\\n    var newData = new Array();\\n    var springFactor = new Number((data.length - 1) / (fitCount - 1));\\n    newData[0] = data[0]; // for new allocation\\n\\n    for (var i = 1; i < fitCount - 1; i++) {\\n      var tmp = i * springFactor;\\n      var before = new Number(Math.floor(tmp)).toFixed();\\n      var after = new Number(Math.ceil(tmp)).toFixed();\\n      var atPoint = tmp - before;\\n      newData[i] = linearInterpolate(data[before], data[after], atPoint);\\n    }\\n\\n    newData[fitCount - 1] = data[data.length - 1]; // for new allocation\\n\\n    return newData;\\n  }\\n\\n  static isExtrema(arr, critical = 'peak') {\\n    //Checks if the middle point of the (odd-numbered) array is a local extrema. options: 'peak','valley','tangent'. Even numbered arrays are popped\\n    let ref = [...arr];\\n    if (ref.length % 2 === 0) ref.pop();\\n\\n    if (arr.length > 1) {\\n      let pass = true;\\n\\n      for (let i = 0; i < ref.length; i++) {\\n        let val = ref[i];\\n\\n        if (critical === 'peak') {\\n          //search first derivative\\n          if (i < Math.floor(ref.length * .5) && val >= ref[Math.floor(ref.length * .5)]) {\\n            pass = false;\\n            break;\\n          } else if (i > Math.floor(ref.length * .5) && val >= ref[Math.floor(ref.length * .5)]) {\\n            pass = false;\\n            break;\\n          }\\n        } else if (critical === 'valley') {\\n          //search first derivative\\n          if (i < Math.floor(ref.length * .5) && val <= ref[Math.floor(ref.length * .5)]) {\\n            pass = false;\\n            break;\\n          } else if (i > Math.floor(ref.length * .5) && val <= ref[Math.floor(ref.length * .5)]) {\\n            pass = false;\\n            break;\\n          }\\n        } else {\\n          //look for tangents (best with 2nd derivative usually)\\n          if (i < Math.floor(ref.length * .5) && val <= ref[Math.floor(ref.length * .5)]) {\\n            pass = false;\\n            break;\\n          } else if (i > Math.floor(ref.length * .5) && val <= ref[Math.floor(ref.length * .5)]) {\\n            pass = false;\\n            break;\\n          }\\n        } //|| (i < ref.length*.5 && val <= 0 ) || (i > ref.length*.5 && val > 0)\\n\\n      }\\n\\n      if (critical !== 'peak' && critical !== 'valley' && pass === false) {\\n        pass = true;\\n\\n        for (let i = 0; i < ref.length; i++) {\\n          let val = ref[i];\\n\\n          if (i < Math.floor(ref.length * .5) && val >= ref[Math.floor(ref.length * .5)]) {\\n            pass = false;\\n            break;\\n          } else if (i > Math.floor(ref.length * .5) && val >= ref[Math.floor(ref.length * .5)]) {\\n            pass = false;\\n            break;\\n          }\\n        }\\n      }\\n\\n      return pass;\\n    } else return undefined;\\n  }\\n\\n  static isCriticalPoint(arr, critical = 'peak') {\\n    //Checks if the middle point of the (odd-numbered) array is a critical point. options: 'peak','valley','tangent'. Even numbered arrays are popped\\n    let ref = [...arr];\\n    if (ref.length % 2 === 0) ref.pop();\\n\\n    if (arr.length > 1) {\\n      let pass = true;\\n\\n      for (let i = 0; i < ref.length; i++) {\\n        let val = ref[i];\\n\\n        if (critical === 'peak') {\\n          //search first derivative\\n          if (i < ref.length * .5 && val <= 0) {\\n            pass = false;\\n            break;\\n          } else if (i > ref.length * .5 && val > 0) {\\n            pass = false;\\n            break;\\n          }\\n        } else if (critical === 'valley') {\\n          //search first derivative\\n          if (i < ref.length * .5 && val >= 0) {\\n            pass = false;\\n            break;\\n          } else if (i > ref.length * .5 && val < 0) {\\n            pass = false;\\n            break;\\n          }\\n        } else {\\n          //look for tangents (best with 2nd derivative usually)\\n          if (i < ref.length * .5 && val >= 0) {\\n            pass = false;\\n            break;\\n          } else if (i > ref.length * .5 && val < 0) {\\n            pass = false;\\n            break;\\n          }\\n        }\\n      }\\n\\n      if (critical !== 'peak' && critical !== 'valley' && pass === false) {\\n        pass = true;\\n\\n        for (let i = 0; i < ref.length; i++) {\\n          let val = ref[i];\\n\\n          if (i < ref.length * .5 && val <= 0) {\\n            pass = false;\\n            break;\\n          } else if (i > ref.length * .5 && val > 0) {\\n            pass = false;\\n            break;\\n          }\\n        }\\n      }\\n\\n      return pass;\\n    } else return undefined;\\n  } //returns array of indices of detected peaks/valleys\\n\\n\\n  static peakDetect = (smoothedArray, type = 'peak', window = 49) => {\\n    let mid = Math.floor(window * .5);\\n    let peaks = []; //console.log(smoothedArray.length-window)\\n\\n    for (let i = 0; i < smoothedArray.length - window; i++) {\\n      let isPeak = this.isExtrema(smoothedArray.slice(i, i + window), type);\\n\\n      if (isPeak) {\\n        peaks.push(i + mid - 1);\\n      }\\n    }\\n\\n    return peaks;\\n  }; //gets a mean threshold based on peaks in an array\\n\\n  static getPeakThreshold(arr, peakIndices, thresholdVar) {\\n    let threshold;\\n    let filtered = arr.filter((o, i) => {\\n      if (peakIndices.indexOf(i) > -1) return true;\\n    });\\n\\n    if (thresholdVar === 0) {\\n      threshold = this.mean(filtered);\\n    } else threshold = (thresholdVar + this.mean(filtered)) * 0.5;\\n\\n    return threshold;\\n  } //-------------------------------------------------------------\\n  //The following n-dimensional Eigenvalue/PCA Math was adapted from: https://github.com/johnmihalik/eigenvector/blob/master/pca.js\\n\\n\\n  static column(mat, x) {\\n    let col = new Array(mat.length).fill(0).map(() => new Array(1).fill(0));\\n\\n    for (let i = 0; i < mat.length; i++) {\\n      col[i][0] = mat[i][x];\\n    }\\n\\n    return col;\\n  } //flatten a vector of 1-value vectors\\n\\n\\n  static flatten_vector(v) {\\n    let v_new = [];\\n\\n    for (let i = 0; i < v.length; i++) {\\n      v_new[i] = v[i][0];\\n    }\\n\\n    return v_new;\\n  }\\n\\n  static squared_difference(v1, v2) {\\n    let sum = 0.0;\\n\\n    for (let i = 0; i < v1.length; i++) {\\n      sum = sum + Math.pow(v1[i] - v2[i], 2);\\n    }\\n\\n    return sum;\\n  } // See: https://math.stackexchange.com/questions/768882/power-method-for-finding-all-eigenvectors\\n\\n\\n  static shift_deflate(mat, eigenvalue, eigenvector) {\\n    let len = Math.sqrt(this.matmul(this.transpose(eigenvector), eigenvector));\\n    let U = this.matscale(eigenvector, 1.0 / len);\\n    let delta = this.matscale(this.matmul(U, this.transpose(U)), eigenvalue);\\n    let M_new = this.matsub(mat, delta);\\n    return M_new;\\n  }\\n\\n  static eigenvalue_of_vector(mat, eigenvector) {\\n    // Xt * M * x\\n    ev = this.matmul(this.matmul(this.transpose(eigenvector), mat), eigenvector);\\n    return ev;\\n  } //Input square 2D matrix\\n\\n\\n  static power_iteration(mat, tolerance = 0.00001, max_iterations = 1000) {\\n    let rank = mat.length; // Initialize the first guess pf the eigenvector to a row vector of the sqrt of the rank\\n\\n    let eigenvector = new Array(rank).fill(0).map(() => new Array(1).fill(Math.sqrt(rank))); // Compute the corresponding eigenvalue\\n\\n    let eigenvalue = this.eigenvalue_of_vector(mat, eigenvector);\\n    let epsilon = 1.0;\\n    let iter = 0;\\n\\n    while (epsilon > tolerance && iter < max_iterations) {\\n      let old_eigenvalue = JSON.parse(JSON.stringify(eigenvalue)); // Multiply the Matrix M by the guessed eigenveector\\n\\n      let Mv = this.matmul(mat, eigenvector); // Normalize the eigenvector to unit length\\n\\n      eigenvector = this.normalize(Mv); // Calculate the associated eigenvalue with the eigenvector (transpose(v) * M * v)\\n\\n      eigenvalue = this.eigenvalue_of_vector(mat, eigenvector); // Calculate the epsilon of the differences\\n\\n      epsilon = Math.abs(eigenvalue - old_eigenvalue);\\n      iter++;\\n    }\\n\\n    ;\\n    return [eigenvalue, eigenvector];\\n  } //Input square 2D matrix\\n\\n\\n  static eigens(mat, tolerance = 0.0001, max_iterations = 1000) {\\n    let eigenvalues = [];\\n    let eigenvectors = [];\\n\\n    for (let i = 0; i < mat.length; i++) {\\n      // Compute the remaining most prominent eigenvector of the matrix M\\n      let result = this.power_iteration(mat, tolerance, max_iterations); // Separate the eigenvalue and vector from the return array\\n\\n      let eigenvalue = result[0];\\n      let eigenvector = result[1];\\n      eigenvalues[i] = eigenvalue;\\n      eigenvectors[i] = this.flatten_vector(eigenvector); // Now remove or peel off the last eigenvector\\n\\n      mat = this.shift_deflate(mat, eigenvalue, eigenvector);\\n    }\\n\\n    return [eigenvalues, eigenvectors];\\n  } //Input square 2D matrix. For eeg data you input a square covariance matrix of the signal data (or the z-scores of the signal data)\\n\\n\\n  static pca(mat, tolerance = 0.00001) {\\n    let dims = mat.length;\\n    let t = new Array(dims);\\n    let p = new Array(dims);\\n    let mat_t = this.transpose(mat);\\n    t[0] = this.column(mat, 0);\\n    let epsilon = 1.0;\\n    let iter = 0;\\n\\n    while (espilon > tolerance) {\\n      iter++;\\n      p[0] = this.matmul(mat_t, t[0]);\\n      let tp = this.matmul(this.transpose(t[0]), t[0]);\\n      p[0] = this.matscale(p[0], 1.0 / tp); // Normalize p\\n\\n      let p_length = Math.sqrt(this.matmul(this.transpose(p[0]), p[0]));\\n      p[0] = this.matscale(p[0], 1.0 / p_length);\\n      let t_new = this.matmul(mat, p[0]);\\n      let pp = this.matmul(this.transpose(p[0]), p[0]);\\n      t_new = this.matscale(t_new, 1.0 / pp);\\n      epsilon = this.squared_difference(t[0], t_new);\\n      t[0] = JSON.parse(JSON.stringify(t_new));\\n    }\\n\\n    let components = this.matmul(this.transpose(t[0]), t[0]);\\n    return components;\\n  } //-------------------------------------------------------------\\n  //pass in 1 second of raw data ish recommended, desired event timestamps and signals are ordered from least current to most current \\n\\n\\n  static p300(event_timestamps = [], raw_signal = [], signal_timestamps = [], sps = 256) {\\n    let smoothingstep = Math.floor(sps / 10); //300ms width peak, 1/10th sec smoothing for filtering\\n\\n    let smoothed = this.sma(raw_signal, smoothingstep);\\n    let peaks = this.peakDetect(smoothed, 'peak', smoothingstep); //returns indices of peaks\\n\\n    let mean = this.mean(smoothed);\\n    let std = this.std(smoothed, mean);\\n    let p_idx = 0;\\n    let candidates = [];\\n\\n    if (peaks.length > 0) {\\n      event_timestamps.forEach((t, j) => {\\n        while (signal_timestamps[peaks[p_idx]] < t + 200) {\\n          //roll over peaks that are behind of the latest event + 200ms\\n          p_idx++;\\n          if (!peaks[p_idx]) break;\\n        }\\n\\n        let tempi = 0;\\n        let tempcandidates = [];\\n\\n        while (signal_timestamps[peaks[p_idx + tempi]] < t + 600) {\\n          //get peaks that are behind the latest event + (200ms-600ms)\\n          tempcandidates.push(p_idx + tempi);\\n          tempi++;\\n          if (!peaks[p_idx + tempi]) break;\\n        }\\n\\n        if (tempcandidates.length > 1) {\\n          //if multiple peaks found choose the biggest one for the main p300 peak (not worrying about p1,p2,n1,n2 yet)\\n          let peakvals = [];\\n          tempcandidates.forEach(tc => {\\n            peakvals.push(smoothed[peaks[tc]]);\\n          });\\n          let max = Math.max(...peakvals);\\n          let maxi = tempcandidates[peakvals.indexOf(max)];\\n          candidates.push({\\n            event_timestamp: t,\\n            event_index: j,\\n            peak_timestamp: signal_timestamps[[peaks[maxi]]],\\n            signal_index: [peaks[maxi]],\\n            signal_amplitude: raw_signal[[peaks[maxi]]],\\n            zscore: (smoothed[peaks[maxi]] - mean) / std //significance measure\\n\\n          });\\n        } else if (tempcandidates.length === 1) candidates.push({\\n          event_timestamp: t,\\n          event_index: j,\\n          peak_timestamp: signal_timestamps[peaks[tempcandidates[0]]],\\n          signal_index: peaks[tempcandidates[0]],\\n          signal_amplitude: raw_signal[[peaks[tempcandidates[0]]]],\\n          zscore: (smoothed[peaks[tempcandidates[0]]] - mean) / std //significance measure\\n\\n        });\\n      });\\n    }\\n\\n    return candidates;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ 539:\\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\\n\\n\\\"use strict\\\";\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"LG\\\": () => (/* binding */ ProxyManager)\\n/* harmony export */ });\\n/* unused harmony exports EventDispatcher, ElementProxyReceiver */\\n//From Worker Thread\\nfunction noop() {} /////////////https://threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html\\n\\n\\nclass EventDispatcher {\\n  addEventListener(type, listener) {\\n    if (this._listeners === undefined) this._listeners = {};\\n    const listeners = this._listeners;\\n\\n    if (listeners[type] === undefined) {\\n      listeners[type] = [];\\n    }\\n\\n    if (listeners[type].indexOf(listener) === -1) {\\n      listeners[type].push(listener);\\n    }\\n  }\\n\\n  hasEventListener(type, listener) {\\n    if (this._listeners === undefined) return false;\\n    const listeners = this._listeners;\\n    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;\\n  }\\n\\n  removeEventListener(type, listener) {\\n    if (this._listeners === undefined) return;\\n    const listeners = this._listeners;\\n    const listenerArray = listeners[type];\\n\\n    if (listenerArray !== undefined) {\\n      const index = listenerArray.indexOf(listener);\\n\\n      if (index !== -1) {\\n        listenerArray.splice(index, 1);\\n      }\\n    }\\n  }\\n\\n  dispatchEvent(event) {\\n    if (this._listeners === undefined) return;\\n    const listeners = this._listeners;\\n    const listenerArray = listeners[event.type];\\n\\n    if (listenerArray !== undefined) {\\n      event.target = this; // Make a copy, in case listeners are removed while iterating.\\n\\n      const array = listenerArray.slice(0);\\n\\n      for (let i = 0, l = array.length; i < l; i++) {\\n        array[i].call(this, event);\\n      }\\n\\n      event.target = null;\\n    }\\n  }\\n\\n} /////////////https://threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html\\n\\nclass ElementProxyReceiver extends EventDispatcher {\\n  constructor() {\\n    super(); // because OrbitControls try to set style.touchAction;\\n\\n    this.style = {};\\n  }\\n\\n  get clientWidth() {\\n    return this.width;\\n  }\\n\\n  get clientHeight() {\\n    return this.height;\\n  } // OrbitControls call these as of r132. Maybe we should implement them\\n\\n\\n  setPointerCapture() {}\\n\\n  releasePointerCapture() {}\\n\\n  getBoundingClientRect() {\\n    return {\\n      left: this.left,\\n      top: this.top,\\n      width: this.width,\\n      height: this.height,\\n      right: this.left + this.width,\\n      bottom: this.top + this.height\\n    };\\n  }\\n\\n  handleEvent(data) {\\n    if (data.type === 'size') {\\n      this.left = data.left;\\n      this.top = data.top;\\n      this.width = data.width;\\n      this.height = data.height;\\n      return;\\n    }\\n\\n    data.preventDefault = noop;\\n    data.stopPropagation = noop;\\n    this.dispatchEvent(data);\\n  }\\n\\n  focus() {}\\n\\n} /////////////https://threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html\\n\\nclass ProxyManager {\\n  constructor() {\\n    this.id = 'proxy' + Math.floor(Math.random() * 10000);\\n    this.targets = {};\\n    this.handleEvent = this.handleEvent.bind(this);\\n  }\\n\\n  makeProxy(data) {\\n    const {\\n      id\\n    } = data;\\n    const proxy = new ElementProxyReceiver();\\n    this.targets[id] = proxy;\\n  }\\n\\n  getProxy(id) {\\n    return this.targets[id];\\n  }\\n\\n  handleEvent(data) {\\n    this.targets[data.id].handleEvent(data.data);\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ 521:\\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\\n\\n\\\"use strict\\\";\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"Y\\\": () => (/* binding */ CallbackManager)\\n/* harmony export */ });\\n/* harmony import */ var gpujsutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(526);\\n/* harmony import */ var _Math2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(343);\\n/* harmony import */ var _Event_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(228);\\n/* harmony import */ var _ProxyListener_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(539);\\n\\n\\n\\n\\n\\nlet dynamicImport = async url => {\\n  let module = await __webpack_require__(776)(url);\\n  return module;\\n}; //Get the text inside of a function (regular or arrow);\\n\\n\\nfunction getFunctionBody(methodString) {\\n  return methodString.toString().replace(/^\\\\W*(function[^{]+\\\\{([\\\\s\\\\S]*)\\\\}|[^=]+=>[^{]*\\\\{([\\\\s\\\\S]*)\\\\}|[^=]+=>(.+))/i, '$2$3$4');\\n}\\n\\nfunction getFunctionHead(methodString) {\\n  let fnstring = methodString.toString();\\n  return fnstring.slice(0, fnstring.indexOf('{') + 1);\\n}\\n\\nfunction buildNewFunction(head, body) {\\n  let newFunc = eval(head + body + '}');\\n  return newFunc;\\n}\\n\\nfunction isFunction(string) {\\n  let regex = new RegExp('(|[a-zA-Z]\\\\w*|\\\\([a-zA-Z]\\\\w*(,\\\\s*[a-zA-Z]\\\\w*)*\\\\))\\\\s*=>');\\n  let func = typeof string === 'string' ? string.substring(0, 10).includes('function') : false;\\n  let arrow = typeof string === 'string' ? regex.test(string) : false;\\n  if (func || arrow) return true;else return false;\\n}\\n\\nfunction parseFunctionFromText(method) {\\n  //Get the text inside of a function (regular or arrow);\\n  let getFunctionBody = methodString => {\\n    return methodString.replace(/^\\\\W*(function[^{]+\\\\{([\\\\s\\\\S]*)\\\\}|[^=]+=>[^{]*\\\\{([\\\\s\\\\S]*)\\\\}|[^=]+=>(.+))/i, '$2$3$4');\\n  };\\n\\n  let getFunctionHead = methodString => {\\n    let startindex = methodString.indexOf(')');\\n    return methodString.slice(0, methodString.indexOf('{', startindex) + 1);\\n  };\\n\\n  let newFuncHead = getFunctionHead(method);\\n  let newFuncBody = getFunctionBody(method);\\n  let newFunc;\\n\\n  if (newFuncHead.includes('function ')) {\\n    let varName = newFuncHead.split('(')[1].split(')')[0];\\n    newFunc = new Function(varName, newFuncBody);\\n  } else {\\n    if (newFuncHead.substring(0, 6) === newFuncBody.substring(0, 6)) {\\n      //newFuncBody = newFuncBody.substring(newFuncHead.length);\\n      let varName = newFuncHead.split('(')[1].split(')')[0]; //console.log(varName, newFuncHead ,newFuncBody);\\n\\n      newFunc = new Function(varName, newFuncBody.substring(newFuncBody.indexOf('{') + 1, newFuncBody.length - 1));\\n    } else newFunc = eval(newFuncHead + newFuncBody + \\\"}\\\");\\n  }\\n\\n  return newFunc;\\n}\\n\\nclass CallbackManager {\\n  ctx;\\n  context;\\n\\n  constructor() {\\n    try {\\n      window.gpu = new gpujsutils__WEBPACK_IMPORTED_MODULE_0__/* .gpuUtils */ .T9();\\n      this.gpu = window.gpu;\\n    } catch {\\n      let gpu = new gpujsutils__WEBPACK_IMPORTED_MODULE_0__/* .gpuUtils */ .T9();\\n      this.gpu = gpu;\\n    }\\n\\n    this.EVENTS = new _Event_js__WEBPACK_IMPORTED_MODULE_2__/* .Events */ .z();\\n    this.EVENTSETTINGS = [];\\n    this.canvas = new OffscreenCanvas(512, 512); //can add fnctions and refer to this.offscreen \\n\\n    this.ANIMATION = undefined;\\n    this.ANIMATIONFUNC = undefined;\\n    this.ANIMATING = false;\\n    this.ANIMFRAMETIME = performance.now(); //ms based on UTC stamps\\n\\n    this.threeUtil = undefined;\\n    this.PROXYMANAGER = new _ProxyListener_js__WEBPACK_IMPORTED_MODULE_3__/* .ProxyManager */ .LG();\\n    this.ID = Math.floor(Math.random() * 1000); //just a reference for discerning threads \\n\\n    try {\\n      if (window) console.log('worker in window!');\\n    } catch (err) {\\n      self.document = {}; //threejs hack\\n    } //args = array of expected arguments\\n    //origin = optional tag on input object\\n    //self = this. scope for variables within the callbackmanager (including values set)\\n\\n\\n    this.callbacks = [{\\n      //ping pong, just validates responsiveness\\n      case: 'ping',\\n      callback: (self, args, origin) => {\\n        return 'pong';\\n      }\\n    }, {\\n      //return a list of function calls available on the worker\\n      case: 'list',\\n      callback: (self, args, origin) => {\\n        let list = [];\\n        this.callbacks.forEach(obj => {\\n          list.push(obj.case);\\n        });\\n        return list;\\n      }\\n    }, {\\n      //add a local function, can implement whole algorithm pipelines on-the-fly\\n      case: 'addfunc',\\n      callback: (self, args, origin) => {\\n        //arg0 = name, arg1 = function string (arrow or normal)\\n        let newFunc = parseFunctionFromText(args[1]);\\n        let newCallback = {\\n          case: args[0],\\n          callback: newFunc\\n        };\\n        let found = self.callbacks.findIndex(c => {\\n          if (c.case === newCallback.case) return c;\\n        });\\n        if (found != -1) self.callbacks[found] = newCallback;else self.callbacks.push(newCallback);\\n        return true;\\n      }\\n    }, {\\n      //set locally accessible values, just make sure not to overwrite the defaults in the callbackManager\\n      case: 'setValues',\\n      callback: (self, args, origin) => {\\n        if (typeof args === 'object') {\\n          Object.keys(args).forEach(key => {\\n            self[key] = args[key]; //variables will be accessible in functions as this.x or this['x']\\n\\n            if (self.threeUtil) self.threeUtil[key] = args[key];\\n          });\\n          return true;\\n        } else return false;\\n      }\\n    }, {\\n      //append array values\\n      case: 'appendValues',\\n      callback: (self, args, origin) => {\\n        if (typeof args === 'object') {\\n          Object.keys(args).forEach(key => {\\n            if (!self[key]) self[key] = args[key];else if (Array.isArray(args[key])) self[key].push(args[key]); //variables will be accessible in functions as this.x or this['x']\\n            else self[key] = args[key];\\n          });\\n          return true;\\n        } else return false;\\n      }\\n    }, {\\n      //for use with transfers\\n      case: 'setValuesFromArrayBuffers',\\n      callback: (self, args, origin) => {\\n        if (typeof args === 'object') {\\n          Object.keys(args).forEach(key => {\\n            if (args[key].__proto__.__proto__.constructor.name === 'TypedArray') self[key] = Array.from(args[key]);else self[key] = args[key];\\n          });\\n          return true;\\n        } else return false;\\n      }\\n    }, {\\n      //for use with transfers\\n      case: 'appendValuesFromArrayBuffers',\\n      callback: (self, args, origin) => {\\n        if (typeof args === 'object') {\\n          Object.keys(args).forEach(key => {\\n            if (!self[key] && args[key].__proto__.__proto__.constructor.name === 'TypedArray') self[key] = Array.from(args[key]);else if (!self[key]) self[key] = args[key];else if (args[key].__proto__.__proto__.constructor.name === 'TypedArray') self[key].push(Array.from(args[key]));else if (Array.isArray(args[key])) self[key].push(args[key]); //variables will be accessible in functions as this.x or this['x']\\n            else self[key] = args[key];\\n          });\\n          return true;\\n        } else return false;\\n      }\\n    }, {\\n      //parses a stringified class prototype (class x{}.toString()) containing function methods for use on the worker\\n      case: 'transferClassObject',\\n      callback: (self, args, origin) => {\\n        if (typeof args === 'object') {\\n          Object.keys(args).forEach(key => {\\n            if (typeof args[key] === 'string') {\\n              let obj = args[key];\\n              if (args[key].indexOf('class') === 0) obj = eval('(' + args[key] + ')');\\n              self[key] = obj; //variables will be accessible in functions as this.x or this['x']\\n              //console.log(self,key,obj);\\n\\n              if (self.threeUtil) self.threeUtil[key] = obj;\\n            }\\n          });\\n          return true;\\n        } else return false;\\n      }\\n    }, {\\n      //add a gpu function call usable in kernels, follow gpujs's tutorials and pass stringified functions using their format\\n      case: 'addgpufunc',\\n      callback: (self, args, origin) => {\\n        //arg0 = gpu in-thread function string\\n        return self.gpu.addFunction(parseFunctionFromText(args[0]));\\n      }\\n    }, {\\n      //add a gpu kernels, follow gpujs's tutorials and pass stringified functions using their format\\n      case: 'addkernel',\\n      callback: (self, args, origin) => {\\n        //arg0 = kernel name, arg1 = kernel function string\\n        return self.gpu.addKernel(args[0], parseFunctionFromText(args[1]));\\n      }\\n    }, {\\n      //call a custom gpu kernel\\n      case: 'callkernel',\\n      callback: (self, args, origin) => {\\n        //arg0 = kernel name, args.slice(1) = kernel input arguments\\n        return self.gpu.callKernel(args[0], args.slice(1)); //generalized gpu kernel calls\\n      }\\n    }, {\\n      //MessageChannel port, it just runs the whole callback system to keep it pain-free, while allowing messages from other workers\\n      case: 'addport',\\n      callback: (self, args, origin) => {\\n        //args[0] = eventName, args[1] = case, only fires event if from specific same origin\\n        let port = args[1];\\n        port.onmessage = onmessage; //sets up a new receiver source (from other workers, perform addevent on the other worker)\\n\\n        this[args[0]] = port; //locally \\n      }\\n    }, {\\n      //add an event to the event manager, this helps building automated pipelines between threads\\n      case: 'addevent',\\n      callback: (self, args, origin) => {\\n        //args[0] = eventName, args[1] = case, only fires event if from specific same origin\\n        self.EVENTSETTINGS.push({\\n          eventName: args[0],\\n          case: args[1],\\n          port: args[2],\\n          origin: origin\\n        }); //console.log(args);\\n\\n        if (args[2]) {\\n          let port = args[2];\\n          port.onmessage = onmessage; //attach the port onmessage event\\n\\n          this[args[0] + 'port'] = port;\\n        }\\n\\n        return true;\\n      }\\n    }, {\\n      //internal event subscription, look at Event.js for usage, its essentially a function trigger manager for creating algorithms\\n      case: 'subevent',\\n      callback: (self, args, origin) => {\\n        //args[0] = eventName, args[1] = response function(self,args,origin) -> lets you reference self for setting variables\\n        if (typeof args[0] !== 'string') return false;\\n        let response = parseFunctionFromText(args[1]);\\n        let eventSetting = this.checkEvents(args[0]); //this will contain the port setting if there is any\\n        //console.log(args, eventSetting)\\n\\n        return self.EVENTS.subEvent(args[0], output => {\\n          response(self, output, origin, eventSetting?.port, eventSetting?.eventName); //function wrapper so you can access self from the event subscription\\n        });\\n      }\\n    }, {\\n      //internal event unsubscribe\\n      case: 'unsubevent',\\n      callback: (self, args, origin) => {\\n        //args[0] = eventName, args[1] = case, only fires event if from specific same origin\\n        return self.EVENTS.unsubEvent(args[0], args[1]);\\n      }\\n    }, {\\n      //resize an offscreen canvas\\n      case: 'resizecanvas',\\n      callback: (self, args, origin) => {\\n        self.canvas.width = args[0];\\n        self.canvas.height = args[1];\\n        return true;\\n      }\\n    }, {\\n      //args[0] = ProxyManager Id returned from startProxy, args[1] = event object\\n      case: 'proxyHandler',\\n      callback: (self, args, origin) => {\\n        if (args.type === 'makeProxy') {\\n          self.PROXYMANAGER.makeProxy(args);\\n          const proxy = self.PROXYMANAGER.getProxy(args.id);\\n          proxy.ownerDocument = proxy; // HACK!\\n\\n          self[args.id] = proxy;\\n        } else if (args.type === 'event') {\\n          self.PROXYMANAGER.handleEvent(args);\\n        } else return false;\\n\\n        return true;\\n      }\\n    }, {\\n      case: 'initThree',\\n      callback: async (self, args, origin) => {\\n        if (self.ANIMATING) {\\n          self.ANIMATING = false;\\n          cancelAnimationFrame(self.ANIMATION);\\n        }\\n\\n        if (!self.threeUtil) {\\n          let module = await dynamicImport('./workerThreeUtils.js');\\n          self.threeUtil = new module.threeUtil(self.canvas, self, self.PROXYMANAGER.getProxy(args[0]));\\n          self.THREE = self.threeUtil.THREE; //add another reference for the hell of it\\n        }\\n\\n        if (typeof args[1] === 'object') {\\n          //first is the setup function\\n          await this.runCallback('setValues', args[1]);\\n        } //console.log(args)\\n\\n\\n        if (args[2]) {\\n          //first is the setup function\\n          self.threeUtil.setup = parseFunctionFromText(args[2]);\\n        }\\n\\n        if (args[3]) {\\n          //next is the draw function (for 1 frame)\\n          self.threeUtil.draw = parseFunctionFromText(args[3]);\\n        }\\n\\n        if (args[4]) {\\n          self.threeUtil.clear = parseFunctionFromText(args[4]);\\n        }\\n\\n        self.threeUtil.clear(self, args, origin);\\n        self.threeUtil.setup(self, args, origin); //console.log(self.threeUtil);\\n\\n        return true;\\n      }\\n    }, {\\n      case: 'startThree',\\n      callback: async (self, args, origin) => {\\n        //run the setup to start the three animation\\n        if (this.ANIMATING) {\\n          self.ANIMATING = false;\\n          cancelAnimationFrame(self.ANIMATION);\\n        }\\n\\n        if (!this.threeUtil) {\\n          let module = await dynamicImport('./workerThreeUtils.js'); //console.log(module);\\n\\n          self.threeUtil = new module.threeUtil(self.canvas, self, self.PROXYMANAGER.getProxy(args[0]));\\n        }\\n\\n        if (this.threeUtil) {\\n          self.threeUtil.clear(self, args, origin);\\n          self.threeUtil.setup(self, args, origin);\\n        }\\n\\n        return true;\\n      }\\n    }, {\\n      case: 'clearThree',\\n      callback: (self, args, origin) => {\\n        //run the clear function to stop three\\n        if (this.threeUtil) {\\n          this.threeUtil.clear(self, args, origin);\\n        }\\n\\n        return true;\\n      }\\n    }, {\\n      case: 'setAnimation',\\n      callback: (self, args, origin) => {\\n        //pass a draw function to be run on an animation loop. Reference this.canvas and this.context or canvas and context. Reference values with this.x etc. and use setValues to set the values from another thread\\n        this.animationFunc = parseFunctionFromText(args[0]);\\n        return true;\\n      }\\n    }, {\\n      case: 'startAnimation',\\n      callback: (self, args, origin) => {\\n        //console.log(this.animationFunc.toString(), this.canvas, this.angle, this.angleChange, this.bgColor)\\n        let anim = () => {\\n          if (self.ANIMATING) {\\n            self.animationFunc(self, args, origin);\\n            self.ANIMFRAMETIME = performance.now() - self.ANIMFRAMETIME;\\n            let emitevent = self.checkEvents('render', origin);\\n            let dict = {\\n              foo: 'render',\\n              output: self.ANIMFRAMETIME,\\n              origin: origin\\n            };\\n            self.ANIMFRAMETIME = performance.now();\\n\\n            if (emitevent) {\\n              self.EVENTS.emit('render', dict);\\n            } else {\\n              postMessage(dict);\\n            }\\n\\n            requestAnimationFrame(anim);\\n          }\\n        };\\n\\n        if (this.ANIMATING) {\\n          self.ANIMATING = false;\\n          cancelAnimationFrame(self.ANIMATION);\\n          setTimeout(() => {\\n            self.ANIMATING = true;\\n            self.ANIMATION = requestAnimationFrame(anim);\\n          }, 300);\\n        } else {\\n          self.ANIMATING = true;\\n          console.log('begin animation');\\n          self.ANIMATION = requestAnimationFrame(anim);\\n        }\\n\\n        return true;\\n      }\\n    }, {\\n      case: 'stopAnimation',\\n      callback: (self, args, origin) => {\\n        if (self.ANIMATING) {\\n          self.ANIMATING = false;\\n          cancelAnimationFrame(self.ANIMATION);\\n          return true;\\n        } else return false;\\n      }\\n    }, {\\n      case: 'render',\\n      callback: (self, args, origin) => {\\n        //runs the animation function\\n        self.animationFunc(self, args, origin);\\n        let time = performance.now() - self.ANIMFRAMETIME;\\n        tselfhis.ANIMFRAMETIME = performance.now();\\n        return time;\\n      }\\n    }, {\\n      case: 'xcor',\\n      callback: (self, args, origin) => {\\n        return _Math2__WEBPACK_IMPORTED_MODULE_1__/* .Math2.crosscorrelation */ .d.crosscorrelation(...args);\\n      }\\n    }, {\\n      case: 'autocor',\\n      callback: (self, args, origin) => {\\n        return _Math2__WEBPACK_IMPORTED_MODULE_1__/* .Math2.autocorrelation */ .d.autocorrelation(args);\\n      }\\n    }, {\\n      case: 'cov1d',\\n      callback: (self, args, origin) => {\\n        return _Math2__WEBPACK_IMPORTED_MODULE_1__/* .Math2.cov1d */ .d.cov1d(...args);\\n      }\\n    }, {\\n      case: 'cov2d',\\n      callback: (self, args, origin) => {\\n        return _Math2__WEBPACK_IMPORTED_MODULE_1__/* .Math2.cov2d */ .d.cov2d(args);\\n      }\\n    }, {\\n      case: 'sma',\\n      callback: (self, args, origin) => {\\n        return _Math2__WEBPACK_IMPORTED_MODULE_1__/* .Math2.sma */ .d.sma(...args);\\n      }\\n    }, {\\n      case: 'dft',\\n      callback: (self, args, origin) => {\\n        if (args[2] == undefined) args[2] = 1;\\n        return self.gpu.gpuDFT(...args);\\n      }\\n    }, {\\n      case: 'multidft',\\n      callback: (self, args, origin) => {\\n        if (args[2] == undefined) args[2] = 1;\\n        return self.gpu.MultiChannelDFT(...args);\\n      }\\n    }, {\\n      case: 'multidftbandpass',\\n      callback: (self, args, origin) => {\\n        if (args[4] == undefined) args[4] = 1;\\n        return self.gpu.MultiChannelDFT_Bandpass(...args);\\n      }\\n    }, {\\n      case: 'fft',\\n      callback: (self, args, origin) => {\\n        if (args[2] == undefined) args[2] = 1;\\n        return self.gpu.gpuFFT(...args);\\n      }\\n    }, {\\n      case: 'multifft',\\n      callback: (self, args, origin) => {\\n        if (args[2] == undefined) args[2] = 1;\\n        return self.gpu.MultiChannelFFT(...args);\\n      }\\n    }, {\\n      case: 'multifftbandpass',\\n      callback: (self, args, origin) => {\\n        if (args[4] == undefined) args[4] = 1;\\n        return self.gpu.MultiChannelFFT_Bandpass(...args);\\n      }\\n    }, {\\n      case: 'gpucoh',\\n      callback: (self, args, origin) => {\\n        return self.gpu.gpuCoherence(...args);\\n      }\\n    }, {\\n      case: 'coherence',\\n      callback: (self, args, origin) => {\\n        const correlograms = _Math2__WEBPACK_IMPORTED_MODULE_1__/* .Math2.correlograms */ .d.correlograms(args[0]);\\n        const buffer = [...args[0], ...correlograms]; //console.log(buffer)\\n\\n        var dfts;\\n        var scalar = 1; //console.log(mins)\\n        //console.log(buffer);\\n\\n        dfts = self.gpu.MultiChannelDFT_Bandpass(buffer, args[1], args[2], args[3], scalar); //console.log(dfts)\\n\\n        const cordfts = dfts[1].splice(args[0].length, buffer.length - args[0].length); //console.log(cordfts)\\n\\n        const coherenceResults = [];\\n        const nChannels = args[0].length; //cross-correlation dfts arranged like e.g. for 4 channels: [0:0, 0:1, 0:2, 0:3, 1:1, 1:2, 1:3, 2:2, 2:3, 3:3] etc.\\n\\n        var k = 0;\\n        var l = 0;\\n        cordfts.forEach((row, i) => {\\n          //move autocorrelation results to front to save brain power\\n          if (l + k === nChannels) {\\n            var temp = cordfts.splice(i, 1);\\n            k++;\\n            cordfts.splice(k, 0, ...temp);\\n            l = 0; //console.log(i);\\n          }\\n\\n          l++;\\n        }); //Now arranged like [0:0,1:1,2:2,3:3,0:1,0:2,0:3,1:2,1:3,2:3]\\n        //Outputs FFT coherence data in order of channel data inputted e.g. for 4 channels resulting DFTs = [0:1,0:2,0:3,1:2,1:3,2:3];\\n\\n        var autoFFTproducts = [];\\n        k = 0;\\n        l = 1;\\n        cordfts.forEach((dft, i) => {\\n          var newdft = new Array(dft.length).fill(0);\\n\\n          if (i < nChannels) {\\n            //sort out autocorrelogram FFTs\\n            dft.forEach((amp, j) => {\\n              newdft[j] = amp; //*dfts[1][i][j];\\n            });\\n            autoFFTproducts.push(newdft);\\n          } else {\\n            //now multiply cross correlogram ffts and divide by autocorrelogram ffts (magnitude squared coherence)\\n            dft.forEach((amp, j) => {\\n              newdft[j] = amp * amp / (autoFFTproducts[k][j] * autoFFTproducts[k + l][j]); //Magnitude squared coherence;\\n\\n              if (newdft[j] > 1) {\\n                newdft[j] = 1;\\n              } //caps the values at 1\\n              //newdft[j] = Math.pow(newdft[j],.125)\\n\\n            });\\n            l++;\\n\\n            if (l + k === nChannels) {\\n              k++;\\n              l = 1;\\n            }\\n\\n            coherenceResults.push(newdft);\\n          }\\n        });\\n        return [dfts[0], dfts[1], coherenceResults];\\n      }\\n    }];\\n  }\\n\\n  addCallback(functionName, callback = (self, args, origin) => {}) {\\n    if (!functionName || !callback) return false;\\n    this.removeCallback(functionName); //removes existing callback if it is there\\n\\n    this.callbacks.push({\\n      case: functionName,\\n      callback: callback\\n    });\\n    return true;\\n  }\\n\\n  removeCallback(functionName) {\\n    let foundidx;\\n    let found = this.callbacks.find((o, i) => {\\n      if (o.case === functionName) {\\n        foundidx = i;\\n        return true;\\n      }\\n    });\\n\\n    if (found) {\\n      this.callbacks.splice(i, 1);\\n      return true;\\n    } else return false;\\n  }\\n\\n  async runCallback(functionName, input = [], origin) {\\n    let output = undefined;\\n    await Promise.all(this.callbacks.map(async (o, i) => {\\n      if (o.case === functionName) {\\n        output = await o.callback(this, input, origin);\\n        return true;\\n      } else if (o.aliases) {\\n        if (o.aliases.indexOf(functionName) > -1) {\\n          output = await o.callback(this, input, origin, user);\\n          return true;\\n        }\\n      }\\n\\n      return false;\\n    }));\\n    return output;\\n  }\\n\\n  checkEvents(functionName, origin) {\\n    let found = this.EVENTSETTINGS.find(o => {\\n      if (o.origin && origin && o.case && functionName) {\\n        if (o.origin === origin && o.case === functionName) return true;else return false;\\n      } else if (o.case && functionName) {\\n        if (o.case === functionName) return true;else return false;\\n      } else if (o.origin && origin) {\\n        if (o.origin === origin) return true;else return false;\\n      } else return false;\\n    }); //console.log(functionName,origin,found)\\n\\n    return found;\\n  }\\n\\n  async checkCallbacks(event) {\\n    //console.log(event);\\n    let output = 'function not defined';\\n    if (!event.data) return output;\\n    await Promise.all(this.callbacks.map(async (o, i) => {\\n      if (o.case === event.data.foo || o.case === event.data.case) {\\n        if (event.data.input) output = await o.callback(this, event.data.input, event.data.origin);else if (event.data.args) output = await o.callback(this, event.data.args, event.data.origin);else output = await o.callback(this, undefined, event.data.origin); //no inputs\\n\\n        return true;\\n      } else return false;\\n    }));\\n    return output;\\n  }\\n\\n}\\n\\n/***/ }),\\n\\n/***/ 759:\\n/***/ ((module) => {\\n\\n/**\\r\\n * gpu.js\\r\\n * http://gpu.rocks/\\r\\n *\\r\\n * GPU Accelerated JavaScript\\r\\n *\\r\\n * @version 2.11.0\\r\\n * @date Tue Jan 05 2021 15:55:59 GMT-0500 (Eastern Standard Time)\\r\\n *\\r\\n * @license MIT\\r\\n * The MIT License\\r\\n *\\r\\n * Copyright (c) 2021 gpu.js Team\\r\\n */(function(f){\\r\\n     if(true){module.exports=f()}\\r\\n     else { var g; }})\\r\\n     (function(){\\r\\n         var define,module,exports;\\r\\n         return (function(){\\r\\n             function r(e,n,t){\\r\\n                 function o(i,f){if(!n[i]){if(!e[i]){\\r\\n                     var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error(\\\"Cannot find module '\\\"+i+\\\"'\\\");throw a.code=\\\"MODULE_NOT_FOUND\\\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){\\r\\n    (function (global, factory) {\\r\\n        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\\r\\n        typeof define === 'function' && define.amd ? define(['exports'], factory) :\\r\\n        (global = global || self, factory(global.acorn = {}));\\r\\n      }(this, function (exports) { 'use strict';\\r\\n      \\r\\n      \\r\\n        var reservedWords = {\\r\\n          3: \\\"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\\\",\\r\\n          5: \\\"class enum extends super const export import\\\",\\r\\n          6: \\\"enum\\\",\\r\\n          strict: \\\"implements interface let package private protected public static yield\\\",\\r\\n          strictBind: \\\"eval arguments\\\"\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var ecma5AndLessKeywords = \\\"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\\\";\\r\\n      \\r\\n        var keywords = {\\r\\n          5: ecma5AndLessKeywords,\\r\\n          \\\"5module\\\": ecma5AndLessKeywords + \\\" export import\\\",\\r\\n          6: ecma5AndLessKeywords + \\\" const class extends export import super\\\"\\r\\n        };\\r\\n      \\r\\n        var keywordRelationalOperator = /^in(stanceof)?$/;\\r\\n      \\r\\n      \\r\\n        var nonASCIIidentifierStartChars = \\\"\\\\xaa\\\\xb5\\\\xba\\\\xc0-\\\\xd6\\\\xd8-\\\\xf6\\\\xf8-\\\\u02c1\\\\u02c6-\\\\u02d1\\\\u02e0-\\\\u02e4\\\\u02ec\\\\u02ee\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037a-\\\\u037d\\\\u037f\\\\u0386\\\\u0388-\\\\u038a\\\\u038c\\\\u038e-\\\\u03a1\\\\u03a3-\\\\u03f5\\\\u03f7-\\\\u0481\\\\u048a-\\\\u052f\\\\u0531-\\\\u0556\\\\u0559\\\\u0560-\\\\u0588\\\\u05d0-\\\\u05ea\\\\u05ef-\\\\u05f2\\\\u0620-\\\\u064a\\\\u066e\\\\u066f\\\\u0671-\\\\u06d3\\\\u06d5\\\\u06e5\\\\u06e6\\\\u06ee\\\\u06ef\\\\u06fa-\\\\u06fc\\\\u06ff\\\\u0710\\\\u0712-\\\\u072f\\\\u074d-\\\\u07a5\\\\u07b1\\\\u07ca-\\\\u07ea\\\\u07f4\\\\u07f5\\\\u07fa\\\\u0800-\\\\u0815\\\\u081a\\\\u0824\\\\u0828\\\\u0840-\\\\u0858\\\\u0860-\\\\u086a\\\\u08a0-\\\\u08b4\\\\u08b6-\\\\u08bd\\\\u0904-\\\\u0939\\\\u093d\\\\u0950\\\\u0958-\\\\u0961\\\\u0971-\\\\u0980\\\\u0985-\\\\u098c\\\\u098f\\\\u0990\\\\u0993-\\\\u09a8\\\\u09aa-\\\\u09b0\\\\u09b2\\\\u09b6-\\\\u09b9\\\\u09bd\\\\u09ce\\\\u09dc\\\\u09dd\\\\u09df-\\\\u09e1\\\\u09f0\\\\u09f1\\\\u09fc\\\\u0a05-\\\\u0a0a\\\\u0a0f\\\\u0a10\\\\u0a13-\\\\u0a28\\\\u0a2a-\\\\u0a30\\\\u0a32\\\\u0a33\\\\u0a35\\\\u0a36\\\\u0a38\\\\u0a39\\\\u0a59-\\\\u0a5c\\\\u0a5e\\\\u0a72-\\\\u0a74\\\\u0a85-\\\\u0a8d\\\\u0a8f-\\\\u0a91\\\\u0a93-\\\\u0aa8\\\\u0aaa-\\\\u0ab0\\\\u0ab2\\\\u0ab3\\\\u0ab5-\\\\u0ab9\\\\u0abd\\\\u0ad0\\\\u0ae0\\\\u0ae1\\\\u0af9\\\\u0b05-\\\\u0b0c\\\\u0b0f\\\\u0b10\\\\u0b13-\\\\u0b28\\\\u0b2a-\\\\u0b30\\\\u0b32\\\\u0b33\\\\u0b35-\\\\u0b39\\\\u0b3d\\\\u0b5c\\\\u0b5d\\\\u0b5f-\\\\u0b61\\\\u0b71\\\\u0b83\\\\u0b85-\\\\u0b8a\\\\u0b8e-\\\\u0b90\\\\u0b92-\\\\u0b95\\\\u0b99\\\\u0b9a\\\\u0b9c\\\\u0b9e\\\\u0b9f\\\\u0ba3\\\\u0ba4\\\\u0ba8-\\\\u0baa\\\\u0bae-\\\\u0bb9\\\\u0bd0\\\\u0c05-\\\\u0c0c\\\\u0c0e-\\\\u0c10\\\\u0c12-\\\\u0c28\\\\u0c2a-\\\\u0c39\\\\u0c3d\\\\u0c58-\\\\u0c5a\\\\u0c60\\\\u0c61\\\\u0c80\\\\u0c85-\\\\u0c8c\\\\u0c8e-\\\\u0c90\\\\u0c92-\\\\u0ca8\\\\u0caa-\\\\u0cb3\\\\u0cb5-\\\\u0cb9\\\\u0cbd\\\\u0cde\\\\u0ce0\\\\u0ce1\\\\u0cf1\\\\u0cf2\\\\u0d05-\\\\u0d0c\\\\u0d0e-\\\\u0d10\\\\u0d12-\\\\u0d3a\\\\u0d3d\\\\u0d4e\\\\u0d54-\\\\u0d56\\\\u0d5f-\\\\u0d61\\\\u0d7a-\\\\u0d7f\\\\u0d85-\\\\u0d96\\\\u0d9a-\\\\u0db1\\\\u0db3-\\\\u0dbb\\\\u0dbd\\\\u0dc0-\\\\u0dc6\\\\u0e01-\\\\u0e30\\\\u0e32\\\\u0e33\\\\u0e40-\\\\u0e46\\\\u0e81\\\\u0e82\\\\u0e84\\\\u0e86-\\\\u0e8a\\\\u0e8c-\\\\u0ea3\\\\u0ea5\\\\u0ea7-\\\\u0eb0\\\\u0eb2\\\\u0eb3\\\\u0ebd\\\\u0ec0-\\\\u0ec4\\\\u0ec6\\\\u0edc-\\\\u0edf\\\\u0f00\\\\u0f40-\\\\u0f47\\\\u0f49-\\\\u0f6c\\\\u0f88-\\\\u0f8c\\\\u1000-\\\\u102a\\\\u103f\\\\u1050-\\\\u1055\\\\u105a-\\\\u105d\\\\u1061\\\\u1065\\\\u1066\\\\u106e-\\\\u1070\\\\u1075-\\\\u1081\\\\u108e\\\\u10a0-\\\\u10c5\\\\u10c7\\\\u10cd\\\\u10d0-\\\\u10fa\\\\u10fc-\\\\u1248\\\\u124a-\\\\u124d\\\\u1250-\\\\u1256\\\\u1258\\\\u125a-\\\\u125d\\\\u1260-\\\\u1288\\\\u128a-\\\\u128d\\\\u1290-\\\\u12b0\\\\u12b2-\\\\u12b5\\\\u12b8-\\\\u12be\\\\u12c0\\\\u12c2-\\\\u12c5\\\\u12c8-\\\\u12d6\\\\u12d8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135a\\\\u1380-\\\\u138f\\\\u13a0-\\\\u13f5\\\\u13f8-\\\\u13fd\\\\u1401-\\\\u166c\\\\u166f-\\\\u167f\\\\u1681-\\\\u169a\\\\u16a0-\\\\u16ea\\\\u16ee-\\\\u16f8\\\\u1700-\\\\u170c\\\\u170e-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176c\\\\u176e-\\\\u1770\\\\u1780-\\\\u17b3\\\\u17d7\\\\u17dc\\\\u1820-\\\\u1878\\\\u1880-\\\\u18a8\\\\u18aa\\\\u18b0-\\\\u18f5\\\\u1900-\\\\u191e\\\\u1950-\\\\u196d\\\\u1970-\\\\u1974\\\\u1980-\\\\u19ab\\\\u19b0-\\\\u19c9\\\\u1a00-\\\\u1a16\\\\u1a20-\\\\u1a54\\\\u1aa7\\\\u1b05-\\\\u1b33\\\\u1b45-\\\\u1b4b\\\\u1b83-\\\\u1ba0\\\\u1bae\\\\u1baf\\\\u1bba-\\\\u1be5\\\\u1c00-\\\\u1c23\\\\u1c4d-\\\\u1c4f\\\\u1c5a-\\\\u1c7d\\\\u1c80-\\\\u1c88\\\\u1c90-\\\\u1cba\\\\u1cbd-\\\\u1cbf\\\\u1ce9-\\\\u1cec\\\\u1cee-\\\\u1cf3\\\\u1cf5\\\\u1cf6\\\\u1cfa\\\\u1d00-\\\\u1dbf\\\\u1e00-\\\\u1f15\\\\u1f18-\\\\u1f1d\\\\u1f20-\\\\u1f45\\\\u1f48-\\\\u1f4d\\\\u1f50-\\\\u1f57\\\\u1f59\\\\u1f5b\\\\u1f5d\\\\u1f5f-\\\\u1f7d\\\\u1f80-\\\\u1fb4\\\\u1fb6-\\\\u1fbc\\\\u1fbe\\\\u1fc2-\\\\u1fc4\\\\u1fc6-\\\\u1fcc\\\\u1fd0-\\\\u1fd3\\\\u1fd6-\\\\u1fdb\\\\u1fe0-\\\\u1fec\\\\u1ff2-\\\\u1ff4\\\\u1ff6-\\\\u1ffc\\\\u2071\\\\u207f\\\\u2090-\\\\u209c\\\\u2102\\\\u2107\\\\u210a-\\\\u2113\\\\u2115\\\\u2118-\\\\u211d\\\\u2124\\\\u2126\\\\u2128\\\\u212a-\\\\u2139\\\\u213c-\\\\u213f\\\\u2145-\\\\u2149\\\\u214e\\\\u2160-\\\\u2188\\\\u2c00-\\\\u2c2e\\\\u2c30-\\\\u2c5e\\\\u2c60-\\\\u2ce4\\\\u2ceb-\\\\u2cee\\\\u2cf2\\\\u2cf3\\\\u2d00-\\\\u2d25\\\\u2d27\\\\u2d2d\\\\u2d30-\\\\u2d67\\\\u2d6f\\\\u2d80-\\\\u2d96\\\\u2da0-\\\\u2da6\\\\u2da8-\\\\u2dae\\\\u2db0-\\\\u2db6\\\\u2db8-\\\\u2dbe\\\\u2dc0-\\\\u2dc6\\\\u2dc8-\\\\u2dce\\\\u2dd0-\\\\u2dd6\\\\u2dd8-\\\\u2dde\\\\u3005-\\\\u3007\\\\u3021-\\\\u3029\\\\u3031-\\\\u3035\\\\u3038-\\\\u303c\\\\u3041-\\\\u3096\\\\u309b-\\\\u309f\\\\u30a1-\\\\u30fa\\\\u30fc-\\\\u30ff\\\\u3105-\\\\u312f\\\\u3131-\\\\u318e\\\\u31a0-\\\\u31ba\\\\u31f0-\\\\u31ff\\\\u3400-\\\\u4db5\\\\u4e00-\\\\u9fef\\\\ua000-\\\\ua48c\\\\ua4d0-\\\\ua4fd\\\\ua500-\\\\ua60c\\\\ua610-\\\\ua61f\\\\ua62a\\\\ua62b\\\\ua640-\\\\ua66e\\\\ua67f-\\\\ua69d\\\\ua6a0-\\\\ua6ef\\\\ua717-\\\\ua71f\\\\ua722-\\\\ua788\\\\ua78b-\\\\ua7bf\\\\ua7c2-\\\\ua7c6\\\\ua7f7-\\\\ua801\\\\ua803-\\\\ua805\\\\ua807-\\\\ua80a\\\\ua80c-\\\\ua822\\\\ua840-\\\\ua873\\\\ua882-\\\\ua8b3\\\\ua8f2-\\\\ua8f7\\\\ua8fb\\\\ua8fd\\\\ua8fe\\\\ua90a-\\\\ua925\\\\ua930-\\\\ua946\\\\ua960-\\\\ua97c\\\\ua984-\\\\ua9b2\\\\ua9cf\\\\ua9e0-\\\\ua9e4\\\\ua9e6-\\\\ua9ef\\\\ua9fa-\\\\ua9fe\\\\uaa00-\\\\uaa28\\\\uaa40-\\\\uaa42\\\\uaa44-\\\\uaa4b\\\\uaa60-\\\\uaa76\\\\uaa7a\\\\uaa7e-\\\\uaaaf\\\\uaab1\\\\uaab5\\\\uaab6\\\\uaab9-\\\\uaabd\\\\uaac0\\\\uaac2\\\\uaadb-\\\\uaadd\\\\uaae0-\\\\uaaea\\\\uaaf2-\\\\uaaf4\\\\uab01-\\\\uab06\\\\uab09-\\\\uab0e\\\\uab11-\\\\uab16\\\\uab20-\\\\uab26\\\\uab28-\\\\uab2e\\\\uab30-\\\\uab5a\\\\uab5c-\\\\uab67\\\\uab70-\\\\uabe2\\\\uac00-\\\\ud7a3\\\\ud7b0-\\\\ud7c6\\\\ud7cb-\\\\ud7fb\\\\uf900-\\\\ufa6d\\\\ufa70-\\\\ufad9\\\\ufb00-\\\\ufb06\\\\ufb13-\\\\ufb17\\\\ufb1d\\\\ufb1f-\\\\ufb28\\\\ufb2a-\\\\ufb36\\\\ufb38-\\\\ufb3c\\\\ufb3e\\\\ufb40\\\\ufb41\\\\ufb43\\\\ufb44\\\\ufb46-\\\\ufbb1\\\\ufbd3-\\\\ufd3d\\\\ufd50-\\\\ufd8f\\\\ufd92-\\\\ufdc7\\\\ufdf0-\\\\ufdfb\\\\ufe70-\\\\ufe74\\\\ufe76-\\\\ufefc\\\\uff21-\\\\uff3a\\\\uff41-\\\\uff5a\\\\uff66-\\\\uffbe\\\\uffc2-\\\\uffc7\\\\uffca-\\\\uffcf\\\\uffd2-\\\\uffd7\\\\uffda-\\\\uffdc\\\";\\r\\n        var nonASCIIidentifierChars = \\\"\\\\u200c\\\\u200d\\\\xb7\\\\u0300-\\\\u036f\\\\u0387\\\\u0483-\\\\u0487\\\\u0591-\\\\u05bd\\\\u05bf\\\\u05c1\\\\u05c2\\\\u05c4\\\\u05c5\\\\u05c7\\\\u0610-\\\\u061a\\\\u064b-\\\\u0669\\\\u0670\\\\u06d6-\\\\u06dc\\\\u06df-\\\\u06e4\\\\u06e7\\\\u06e8\\\\u06ea-\\\\u06ed\\\\u06f0-\\\\u06f9\\\\u0711\\\\u0730-\\\\u074a\\\\u07a6-\\\\u07b0\\\\u07c0-\\\\u07c9\\\\u07eb-\\\\u07f3\\\\u07fd\\\\u0816-\\\\u0819\\\\u081b-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082d\\\\u0859-\\\\u085b\\\\u08d3-\\\\u08e1\\\\u08e3-\\\\u0903\\\\u093a-\\\\u093c\\\\u093e-\\\\u094f\\\\u0951-\\\\u0957\\\\u0962\\\\u0963\\\\u0966-\\\\u096f\\\\u0981-\\\\u0983\\\\u09bc\\\\u09be-\\\\u09c4\\\\u09c7\\\\u09c8\\\\u09cb-\\\\u09cd\\\\u09d7\\\\u09e2\\\\u09e3\\\\u09e6-\\\\u09ef\\\\u09fe\\\\u0a01-\\\\u0a03\\\\u0a3c\\\\u0a3e-\\\\u0a42\\\\u0a47\\\\u0a48\\\\u0a4b-\\\\u0a4d\\\\u0a51\\\\u0a66-\\\\u0a71\\\\u0a75\\\\u0a81-\\\\u0a83\\\\u0abc\\\\u0abe-\\\\u0ac5\\\\u0ac7-\\\\u0ac9\\\\u0acb-\\\\u0acd\\\\u0ae2\\\\u0ae3\\\\u0ae6-\\\\u0aef\\\\u0afa-\\\\u0aff\\\\u0b01-\\\\u0b03\\\\u0b3c\\\\u0b3e-\\\\u0b44\\\\u0b47\\\\u0b48\\\\u0b4b-\\\\u0b4d\\\\u0b56\\\\u0b57\\\\u0b62\\\\u0b63\\\\u0b66-\\\\u0b6f\\\\u0b82\\\\u0bbe-\\\\u0bc2\\\\u0bc6-\\\\u0bc8\\\\u0bca-\\\\u0bcd\\\\u0bd7\\\\u0be6-\\\\u0bef\\\\u0c00-\\\\u0c04\\\\u0c3e-\\\\u0c44\\\\u0c46-\\\\u0c48\\\\u0c4a-\\\\u0c4d\\\\u0c55\\\\u0c56\\\\u0c62\\\\u0c63\\\\u0c66-\\\\u0c6f\\\\u0c81-\\\\u0c83\\\\u0cbc\\\\u0cbe-\\\\u0cc4\\\\u0cc6-\\\\u0cc8\\\\u0cca-\\\\u0ccd\\\\u0cd5\\\\u0cd6\\\\u0ce2\\\\u0ce3\\\\u0ce6-\\\\u0cef\\\\u0d00-\\\\u0d03\\\\u0d3b\\\\u0d3c\\\\u0d3e-\\\\u0d44\\\\u0d46-\\\\u0d48\\\\u0d4a-\\\\u0d4d\\\\u0d57\\\\u0d62\\\\u0d63\\\\u0d66-\\\\u0d6f\\\\u0d82\\\\u0d83\\\\u0dca\\\\u0dcf-\\\\u0dd4\\\\u0dd6\\\\u0dd8-\\\\u0ddf\\\\u0de6-\\\\u0def\\\\u0df2\\\\u0df3\\\\u0e31\\\\u0e34-\\\\u0e3a\\\\u0e47-\\\\u0e4e\\\\u0e50-\\\\u0e59\\\\u0eb1\\\\u0eb4-\\\\u0ebc\\\\u0ec8-\\\\u0ecd\\\\u0ed0-\\\\u0ed9\\\\u0f18\\\\u0f19\\\\u0f20-\\\\u0f29\\\\u0f35\\\\u0f37\\\\u0f39\\\\u0f3e\\\\u0f3f\\\\u0f71-\\\\u0f84\\\\u0f86\\\\u0f87\\\\u0f8d-\\\\u0f97\\\\u0f99-\\\\u0fbc\\\\u0fc6\\\\u102b-\\\\u103e\\\\u1040-\\\\u1049\\\\u1056-\\\\u1059\\\\u105e-\\\\u1060\\\\u1062-\\\\u1064\\\\u1067-\\\\u106d\\\\u1071-\\\\u1074\\\\u1082-\\\\u108d\\\\u108f-\\\\u109d\\\\u135d-\\\\u135f\\\\u1369-\\\\u1371\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17b4-\\\\u17d3\\\\u17dd\\\\u17e0-\\\\u17e9\\\\u180b-\\\\u180d\\\\u1810-\\\\u1819\\\\u18a9\\\\u1920-\\\\u192b\\\\u1930-\\\\u193b\\\\u1946-\\\\u194f\\\\u19d0-\\\\u19da\\\\u1a17-\\\\u1a1b\\\\u1a55-\\\\u1a5e\\\\u1a60-\\\\u1a7c\\\\u1a7f-\\\\u1a89\\\\u1a90-\\\\u1a99\\\\u1ab0-\\\\u1abd\\\\u1b00-\\\\u1b04\\\\u1b34-\\\\u1b44\\\\u1b50-\\\\u1b59\\\\u1b6b-\\\\u1b73\\\\u1b80-\\\\u1b82\\\\u1ba1-\\\\u1bad\\\\u1bb0-\\\\u1bb9\\\\u1be6-\\\\u1bf3\\\\u1c24-\\\\u1c37\\\\u1c40-\\\\u1c49\\\\u1c50-\\\\u1c59\\\\u1cd0-\\\\u1cd2\\\\u1cd4-\\\\u1ce8\\\\u1ced\\\\u1cf4\\\\u1cf7-\\\\u1cf9\\\\u1dc0-\\\\u1df9\\\\u1dfb-\\\\u1dff\\\\u203f\\\\u2040\\\\u2054\\\\u20d0-\\\\u20dc\\\\u20e1\\\\u20e5-\\\\u20f0\\\\u2cef-\\\\u2cf1\\\\u2d7f\\\\u2de0-\\\\u2dff\\\\u302a-\\\\u302f\\\\u3099\\\\u309a\\\\ua620-\\\\ua629\\\\ua66f\\\\ua674-\\\\ua67d\\\\ua69e\\\\ua69f\\\\ua6f0\\\\ua6f1\\\\ua802\\\\ua806\\\\ua80b\\\\ua823-\\\\ua827\\\\ua880\\\\ua881\\\\ua8b4-\\\\ua8c5\\\\ua8d0-\\\\ua8d9\\\\ua8e0-\\\\ua8f1\\\\ua8ff-\\\\ua909\\\\ua926-\\\\ua92d\\\\ua947-\\\\ua953\\\\ua980-\\\\ua983\\\\ua9b3-\\\\ua9c0\\\\ua9d0-\\\\ua9d9\\\\ua9e5\\\\ua9f0-\\\\ua9f9\\\\uaa29-\\\\uaa36\\\\uaa43\\\\uaa4c\\\\uaa4d\\\\uaa50-\\\\uaa59\\\\uaa7b-\\\\uaa7d\\\\uaab0\\\\uaab2-\\\\uaab4\\\\uaab7\\\\uaab8\\\\uaabe\\\\uaabf\\\\uaac1\\\\uaaeb-\\\\uaaef\\\\uaaf5\\\\uaaf6\\\\uabe3-\\\\uabea\\\\uabec\\\\uabed\\\\uabf0-\\\\uabf9\\\\ufb1e\\\\ufe00-\\\\ufe0f\\\\ufe20-\\\\ufe2f\\\\ufe33\\\\ufe34\\\\ufe4d-\\\\ufe4f\\\\uff10-\\\\uff19\\\\uff3f\\\";\\r\\n      \\r\\n        var nonASCIIidentifierStart = new RegExp(\\\"[\\\" + nonASCIIidentifierStartChars + \\\"]\\\");\\r\\n        var nonASCIIidentifier = new RegExp(\\\"[\\\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \\\"]\\\");\\r\\n      \\r\\n        nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\\r\\n      \\r\\n      \\r\\n        var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\\r\\n      \\r\\n        var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];\\r\\n      \\r\\n        function isInAstralSet(code, set) {\\r\\n          var pos = 0x10000;\\r\\n          for (var i = 0; i < set.length; i += 2) {\\r\\n            pos += set[i];\\r\\n            if (pos > code) { return false }\\r\\n            pos += set[i + 1];\\r\\n            if (pos >= code) { return true }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n      \\r\\n        function isIdentifierStart(code, astral) {\\r\\n          if (code < 65) { return code === 36 }\\r\\n          if (code < 91) { return true }\\r\\n          if (code < 97) { return code === 95 }\\r\\n          if (code < 123) { return true }\\r\\n          if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\\r\\n          if (astral === false) { return false }\\r\\n          return isInAstralSet(code, astralIdentifierStartCodes)\\r\\n        }\\r\\n      \\r\\n      \\r\\n        function isIdentifierChar(code, astral) {\\r\\n          if (code < 48) { return code === 36 }\\r\\n          if (code < 58) { return true }\\r\\n          if (code < 65) { return false }\\r\\n          if (code < 91) { return true }\\r\\n          if (code < 97) { return code === 95 }\\r\\n          if (code < 123) { return true }\\r\\n          if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\\r\\n          if (astral === false) { return false }\\r\\n          return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\\r\\n        }\\r\\n      \\r\\n      \\r\\n      \\r\\n      \\r\\n      \\r\\n        var TokenType = function TokenType(label, conf) {\\r\\n          if ( conf === void 0 ) conf = {};\\r\\n      \\r\\n          this.label = label;\\r\\n          this.keyword = conf.keyword;\\r\\n          this.beforeExpr = !!conf.beforeExpr;\\r\\n          this.startsExpr = !!conf.startsExpr;\\r\\n          this.isLoop = !!conf.isLoop;\\r\\n          this.isAssign = !!conf.isAssign;\\r\\n          this.prefix = !!conf.prefix;\\r\\n          this.postfix = !!conf.postfix;\\r\\n          this.binop = conf.binop || null;\\r\\n          this.updateContext = null;\\r\\n        };\\r\\n      \\r\\n        function binop(name, prec) {\\r\\n          return new TokenType(name, {beforeExpr: true, binop: prec})\\r\\n        }\\r\\n        var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\\r\\n      \\r\\n      \\r\\n        var keywords$1 = {};\\r\\n      \\r\\n        function kw(name, options) {\\r\\n          if ( options === void 0 ) options = {};\\r\\n      \\r\\n          options.keyword = name;\\r\\n          return keywords$1[name] = new TokenType(name, options)\\r\\n        }\\r\\n      \\r\\n        var types = {\\r\\n          num: new TokenType(\\\"num\\\", startsExpr),\\r\\n          regexp: new TokenType(\\\"regexp\\\", startsExpr),\\r\\n          string: new TokenType(\\\"string\\\", startsExpr),\\r\\n          name: new TokenType(\\\"name\\\", startsExpr),\\r\\n          eof: new TokenType(\\\"eof\\\"),\\r\\n      \\r\\n          bracketL: new TokenType(\\\"[\\\", {beforeExpr: true, startsExpr: true}),\\r\\n          bracketR: new TokenType(\\\"]\\\"),\\r\\n          braceL: new TokenType(\\\"{\\\", {beforeExpr: true, startsExpr: true}),\\r\\n          braceR: new TokenType(\\\"}\\\"),\\r\\n          parenL: new TokenType(\\\"(\\\", {beforeExpr: true, startsExpr: true}),\\r\\n          parenR: new TokenType(\\\")\\\"),\\r\\n          comma: new TokenType(\\\",\\\", beforeExpr),\\r\\n          semi: new TokenType(\\\";\\\", beforeExpr),\\r\\n          colon: new TokenType(\\\":\\\", beforeExpr),\\r\\n          dot: new TokenType(\\\".\\\"),\\r\\n          question: new TokenType(\\\"?\\\", beforeExpr),\\r\\n          arrow: new TokenType(\\\"=>\\\", beforeExpr),\\r\\n          template: new TokenType(\\\"template\\\"),\\r\\n          invalidTemplate: new TokenType(\\\"invalidTemplate\\\"),\\r\\n          ellipsis: new TokenType(\\\"...\\\", beforeExpr),\\r\\n          backQuote: new TokenType(\\\"`\\\", startsExpr),\\r\\n          dollarBraceL: new TokenType(\\\"${\\\", {beforeExpr: true, startsExpr: true}),\\r\\n      \\r\\n      \\r\\n          eq: new TokenType(\\\"=\\\", {beforeExpr: true, isAssign: true}),\\r\\n          assign: new TokenType(\\\"_=\\\", {beforeExpr: true, isAssign: true}),\\r\\n          incDec: new TokenType(\\\"++/--\\\", {prefix: true, postfix: true, startsExpr: true}),\\r\\n          prefix: new TokenType(\\\"!/~\\\", {beforeExpr: true, prefix: true, startsExpr: true}),\\r\\n          logicalOR: binop(\\\"||\\\", 1),\\r\\n          logicalAND: binop(\\\"&&\\\", 2),\\r\\n          bitwiseOR: binop(\\\"|\\\", 3),\\r\\n          bitwiseXOR: binop(\\\"^\\\", 4),\\r\\n          bitwiseAND: binop(\\\"&\\\", 5),\\r\\n          equality: binop(\\\"==/!=/===/!==\\\", 6),\\r\\n          relational: binop(\\\"</>/<=/>=\\\", 7),\\r\\n          bitShift: binop(\\\"<</>>/>>>\\\", 8),\\r\\n          plusMin: new TokenType(\\\"+/-\\\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\\r\\n          modulo: binop(\\\"%\\\", 10),\\r\\n          star: binop(\\\"*\\\", 10),\\r\\n          slash: binop(\\\"/\\\", 10),\\r\\n          starstar: new TokenType(\\\"**\\\", {beforeExpr: true}),\\r\\n      \\r\\n          _break: kw(\\\"break\\\"),\\r\\n          _case: kw(\\\"case\\\", beforeExpr),\\r\\n          _catch: kw(\\\"catch\\\"),\\r\\n          _continue: kw(\\\"continue\\\"),\\r\\n          _debugger: kw(\\\"debugger\\\"),\\r\\n          _default: kw(\\\"default\\\", beforeExpr),\\r\\n          _do: kw(\\\"do\\\", {isLoop: true, beforeExpr: true}),\\r\\n          _else: kw(\\\"else\\\", beforeExpr),\\r\\n          _finally: kw(\\\"finally\\\"),\\r\\n          _for: kw(\\\"for\\\", {isLoop: true}),\\r\\n          _function: kw(\\\"function\\\", startsExpr),\\r\\n          _if: kw(\\\"if\\\"),\\r\\n          _return: kw(\\\"return\\\", beforeExpr),\\r\\n          _switch: kw(\\\"switch\\\"),\\r\\n          _throw: kw(\\\"throw\\\", beforeExpr),\\r\\n          _try: kw(\\\"try\\\"),\\r\\n          _var: kw(\\\"var\\\"),\\r\\n          _const: kw(\\\"const\\\"),\\r\\n          _while: kw(\\\"while\\\", {isLoop: true}),\\r\\n          _with: kw(\\\"with\\\"),\\r\\n          _new: kw(\\\"new\\\", {beforeExpr: true, startsExpr: true}),\\r\\n          _this: kw(\\\"this\\\", startsExpr),\\r\\n          _super: kw(\\\"super\\\", startsExpr),\\r\\n          _class: kw(\\\"class\\\", startsExpr),\\r\\n          _extends: kw(\\\"extends\\\", beforeExpr),\\r\\n          _export: kw(\\\"export\\\"),\\r\\n          _import: kw(\\\"import\\\", startsExpr),\\r\\n          _null: kw(\\\"null\\\", startsExpr),\\r\\n          _true: kw(\\\"true\\\", startsExpr),\\r\\n          _false: kw(\\\"false\\\", startsExpr),\\r\\n          _in: kw(\\\"in\\\", {beforeExpr: true, binop: 7}),\\r\\n          _instanceof: kw(\\\"instanceof\\\", {beforeExpr: true, binop: 7}),\\r\\n          _typeof: kw(\\\"typeof\\\", {beforeExpr: true, prefix: true, startsExpr: true}),\\r\\n          _void: kw(\\\"void\\\", {beforeExpr: true, prefix: true, startsExpr: true}),\\r\\n          _delete: kw(\\\"delete\\\", {beforeExpr: true, prefix: true, startsExpr: true})\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var lineBreak = /\\\\r\\\\n?|\\\\n|\\\\u2028|\\\\u2029/;\\r\\n        var lineBreakG = new RegExp(lineBreak.source, \\\"g\\\");\\r\\n      \\r\\n        function isNewLine(code, ecma2019String) {\\r\\n          return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\\r\\n        }\\r\\n      \\r\\n        var nonASCIIwhitespace = /[\\\\u1680\\\\u2000-\\\\u200a\\\\u202f\\\\u205f\\\\u3000\\\\ufeff]/;\\r\\n      \\r\\n        var skipWhiteSpace = /(?:\\\\s|\\\\/\\\\/.*|\\\\/\\\\*[^]*?\\\\*\\\\/)*/g;\\r\\n      \\r\\n        var ref = Object.prototype;\\r\\n        var hasOwnProperty = ref.hasOwnProperty;\\r\\n        var toString = ref.toString;\\r\\n      \\r\\n      \\r\\n        function has(obj, propName) {\\r\\n          return hasOwnProperty.call(obj, propName)\\r\\n        }\\r\\n      \\r\\n        var isArray = Array.isArray || (function (obj) { return (\\r\\n          toString.call(obj) === \\\"[object Array]\\\"\\r\\n        ); });\\r\\n      \\r\\n        function wordsRegexp(words) {\\r\\n          return new RegExp(\\\"^(?:\\\" + words.replace(/ /g, \\\"|\\\") + \\\")$\\\")\\r\\n        }\\r\\n      \\r\\n      \\r\\n        var Position = function Position(line, col) {\\r\\n          this.line = line;\\r\\n          this.column = col;\\r\\n        };\\r\\n      \\r\\n        Position.prototype.offset = function offset (n) {\\r\\n          return new Position(this.line, this.column + n)\\r\\n        };\\r\\n      \\r\\n        var SourceLocation = function SourceLocation(p, start, end) {\\r\\n          this.start = start;\\r\\n          this.end = end;\\r\\n          if (p.sourceFile !== null) { this.source = p.sourceFile; }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        function getLineInfo(input, offset) {\\r\\n          for (var line = 1, cur = 0;;) {\\r\\n            lineBreakG.lastIndex = cur;\\r\\n            var match = lineBreakG.exec(input);\\r\\n            if (match && match.index < offset) {\\r\\n              ++line;\\r\\n              cur = match.index + match[0].length;\\r\\n            } else {\\r\\n              return new Position(line, offset - cur)\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n      \\r\\n        var defaultOptions = {\\r\\n          ecmaVersion: 10,\\r\\n          sourceType: \\\"script\\\",\\r\\n          onInsertedSemicolon: null,\\r\\n          onTrailingComma: null,\\r\\n          allowReserved: null,\\r\\n          allowReturnOutsideFunction: false,\\r\\n          allowImportExportEverywhere: false,\\r\\n          allowAwaitOutsideFunction: false,\\r\\n          allowHashBang: false,\\r\\n          locations: false,\\r\\n          onToken: null,\\r\\n          onComment: null,\\r\\n          ranges: false,\\r\\n          program: null,\\r\\n          sourceFile: null,\\r\\n          directSourceFile: null,\\r\\n          preserveParens: false\\r\\n        };\\r\\n      \\r\\n      \\r\\n        function getOptions(opts) {\\r\\n          var options = {};\\r\\n      \\r\\n          for (var opt in defaultOptions)\\r\\n            { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\\r\\n      \\r\\n          if (options.ecmaVersion >= 2015)\\r\\n            { options.ecmaVersion -= 2009; }\\r\\n      \\r\\n          if (options.allowReserved == null)\\r\\n            { options.allowReserved = options.ecmaVersion < 5; }\\r\\n      \\r\\n          if (isArray(options.onToken)) {\\r\\n            var tokens = options.onToken;\\r\\n            options.onToken = function (token) { return tokens.push(token); };\\r\\n          }\\r\\n          if (isArray(options.onComment))\\r\\n            { options.onComment = pushComment(options, options.onComment); }\\r\\n      \\r\\n          return options\\r\\n        }\\r\\n      \\r\\n        function pushComment(options, array) {\\r\\n          return function(block, text, start, end, startLoc, endLoc) {\\r\\n            var comment = {\\r\\n              type: block ? \\\"Block\\\" : \\\"Line\\\",\\r\\n              value: text,\\r\\n              start: start,\\r\\n              end: end\\r\\n            };\\r\\n            if (options.locations)\\r\\n              { comment.loc = new SourceLocation(this, startLoc, endLoc); }\\r\\n            if (options.ranges)\\r\\n              { comment.range = [start, end]; }\\r\\n            array.push(comment);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        var\\r\\n            SCOPE_TOP = 1,\\r\\n            SCOPE_FUNCTION = 2,\\r\\n            SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\\r\\n            SCOPE_ASYNC = 4,\\r\\n            SCOPE_GENERATOR = 8,\\r\\n            SCOPE_ARROW = 16,\\r\\n            SCOPE_SIMPLE_CATCH = 32,\\r\\n            SCOPE_SUPER = 64,\\r\\n            SCOPE_DIRECT_SUPER = 128;\\r\\n      \\r\\n        function functionFlags(async, generator) {\\r\\n          return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\\r\\n        }\\r\\n      \\r\\n        var\\r\\n            BIND_NONE = 0, \\r\\n            BIND_VAR = 1, \\r\\n            BIND_LEXICAL = 2, \\r\\n            BIND_FUNCTION = 3, \\r\\n            BIND_SIMPLE_CATCH = 4, \\r\\n            BIND_OUTSIDE = 5; \\r\\n      \\r\\n        var Parser = function Parser(options, input, startPos) {\\r\\n          this.options = options = getOptions(options);\\r\\n          this.sourceFile = options.sourceFile;\\r\\n          this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \\\"module\\\" ? \\\"5module\\\" : 5]);\\r\\n          var reserved = \\\"\\\";\\r\\n          if (options.allowReserved !== true) {\\r\\n            for (var v = options.ecmaVersion;; v--)\\r\\n              { if (reserved = reservedWords[v]) { break } }\\r\\n            if (options.sourceType === \\\"module\\\") { reserved += \\\" await\\\"; }\\r\\n          }\\r\\n          this.reservedWords = wordsRegexp(reserved);\\r\\n          var reservedStrict = (reserved ? reserved + \\\" \\\" : \\\"\\\") + reservedWords.strict;\\r\\n          this.reservedWordsStrict = wordsRegexp(reservedStrict);\\r\\n          this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \\\" \\\" + reservedWords.strictBind);\\r\\n          this.input = String(input);\\r\\n      \\r\\n          this.containsEsc = false;\\r\\n      \\r\\n      \\r\\n          if (startPos) {\\r\\n            this.pos = startPos;\\r\\n            this.lineStart = this.input.lastIndexOf(\\\"\\\\n\\\", startPos - 1) + 1;\\r\\n            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\\r\\n          } else {\\r\\n            this.pos = this.lineStart = 0;\\r\\n            this.curLine = 1;\\r\\n          }\\r\\n      \\r\\n          this.type = types.eof;\\r\\n          this.value = null;\\r\\n          this.start = this.end = this.pos;\\r\\n          this.startLoc = this.endLoc = this.curPosition();\\r\\n      \\r\\n          this.lastTokEndLoc = this.lastTokStartLoc = null;\\r\\n          this.lastTokStart = this.lastTokEnd = this.pos;\\r\\n      \\r\\n          this.context = this.initialContext();\\r\\n          this.exprAllowed = true;\\r\\n      \\r\\n          this.inModule = options.sourceType === \\\"module\\\";\\r\\n          this.strict = this.inModule || this.strictDirective(this.pos);\\r\\n      \\r\\n          this.potentialArrowAt = -1;\\r\\n      \\r\\n          this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\\r\\n          this.labels = [];\\r\\n          this.undefinedExports = {};\\r\\n      \\r\\n          if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \\\"#!\\\")\\r\\n            { this.skipLineComment(2); }\\r\\n      \\r\\n          this.scopeStack = [];\\r\\n          this.enterScope(SCOPE_TOP);\\r\\n      \\r\\n          this.regexpState = null;\\r\\n        };\\r\\n      \\r\\n        var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\\r\\n      \\r\\n        Parser.prototype.parse = function parse () {\\r\\n          var node = this.options.program || this.startNode();\\r\\n          this.nextToken();\\r\\n          return this.parseTopLevel(node)\\r\\n        };\\r\\n      \\r\\n        prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\\r\\n        prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\\r\\n        prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\\r\\n        prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\\r\\n        prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\\r\\n        prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\\r\\n      \\r\\n        Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\\r\\n      \\r\\n        Parser.extend = function extend () {\\r\\n            var plugins = [], len = arguments.length;\\r\\n            while ( len-- ) plugins[ len ] = arguments[ len ];\\r\\n      \\r\\n          var cls = this;\\r\\n          for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\\r\\n          return cls\\r\\n        };\\r\\n      \\r\\n        Parser.parse = function parse (input, options) {\\r\\n          return new this(options, input).parse()\\r\\n        };\\r\\n      \\r\\n        Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\\r\\n          var parser = new this(options, input, pos);\\r\\n          parser.nextToken();\\r\\n          return parser.parseExpression()\\r\\n        };\\r\\n      \\r\\n        Parser.tokenizer = function tokenizer (input, options) {\\r\\n          return new this(options, input)\\r\\n        };\\r\\n      \\r\\n        Object.defineProperties( Parser.prototype, prototypeAccessors );\\r\\n      \\r\\n        var pp = Parser.prototype;\\r\\n      \\r\\n      \\r\\n        var literal = /^(?:'((?:\\\\\\\\.|[^'])*?)'|\\\"((?:\\\\\\\\.|[^\\\"])*?)\\\")/;\\r\\n        pp.strictDirective = function(start) {\\r\\n          for (;;) {\\r\\n            skipWhiteSpace.lastIndex = start;\\r\\n            start += skipWhiteSpace.exec(this.input)[0].length;\\r\\n            var match = literal.exec(this.input.slice(start));\\r\\n            if (!match) { return false }\\r\\n            if ((match[1] || match[2]) === \\\"use strict\\\") { return true }\\r\\n            start += match[0].length;\\r\\n      \\r\\n            skipWhiteSpace.lastIndex = start;\\r\\n            start += skipWhiteSpace.exec(this.input)[0].length;\\r\\n            if (this.input[start] === \\\";\\\")\\r\\n              { start++; }\\r\\n          }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp.eat = function(type) {\\r\\n          if (this.type === type) {\\r\\n            this.next();\\r\\n            return true\\r\\n          } else {\\r\\n            return false\\r\\n          }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp.isContextual = function(name) {\\r\\n          return this.type === types.name && this.value === name && !this.containsEsc\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp.eatContextual = function(name) {\\r\\n          if (!this.isContextual(name)) { return false }\\r\\n          this.next();\\r\\n          return true\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp.expectContextual = function(name) {\\r\\n          if (!this.eatContextual(name)) { this.unexpected(); }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp.canInsertSemicolon = function() {\\r\\n          return this.type === types.eof ||\\r\\n            this.type === types.braceR ||\\r\\n            lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\\r\\n        };\\r\\n      \\r\\n        pp.insertSemicolon = function() {\\r\\n          if (this.canInsertSemicolon()) {\\r\\n            if (this.options.onInsertedSemicolon)\\r\\n              { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\\r\\n            return true\\r\\n          }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp.semicolon = function() {\\r\\n          if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\\r\\n        };\\r\\n      \\r\\n        pp.afterTrailingComma = function(tokType, notNext) {\\r\\n          if (this.type === tokType) {\\r\\n            if (this.options.onTrailingComma)\\r\\n              { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\\r\\n            if (!notNext)\\r\\n              { this.next(); }\\r\\n            return true\\r\\n          }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp.expect = function(type) {\\r\\n          this.eat(type) || this.unexpected();\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp.unexpected = function(pos) {\\r\\n          this.raise(pos != null ? pos : this.start, \\\"Unexpected token\\\");\\r\\n        };\\r\\n      \\r\\n        function DestructuringErrors() {\\r\\n          this.shorthandAssign =\\r\\n          this.trailingComma =\\r\\n          this.parenthesizedAssign =\\r\\n          this.parenthesizedBind =\\r\\n          this.doubleProto =\\r\\n            -1;\\r\\n        }\\r\\n      \\r\\n        pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\\r\\n          if (!refDestructuringErrors) { return }\\r\\n          if (refDestructuringErrors.trailingComma > -1)\\r\\n            { this.raiseRecoverable(refDestructuringErrors.trailingComma, \\\"Comma is not permitted after the rest element\\\"); }\\r\\n          var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\\r\\n          if (parens > -1) { this.raiseRecoverable(parens, \\\"Parenthesized pattern\\\"); }\\r\\n        };\\r\\n      \\r\\n        pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\\r\\n          if (!refDestructuringErrors) { return false }\\r\\n          var shorthandAssign = refDestructuringErrors.shorthandAssign;\\r\\n          var doubleProto = refDestructuringErrors.doubleProto;\\r\\n          if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\\r\\n          if (shorthandAssign >= 0)\\r\\n            { this.raise(shorthandAssign, \\\"Shorthand property assignments are valid only in destructuring patterns\\\"); }\\r\\n          if (doubleProto >= 0)\\r\\n            { this.raiseRecoverable(doubleProto, \\\"Redefinition of __proto__ property\\\"); }\\r\\n        };\\r\\n      \\r\\n        pp.checkYieldAwaitInDefaultParams = function() {\\r\\n          if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\\r\\n            { this.raise(this.yieldPos, \\\"Yield expression cannot be a default value\\\"); }\\r\\n          if (this.awaitPos)\\r\\n            { this.raise(this.awaitPos, \\\"Await expression cannot be a default value\\\"); }\\r\\n        };\\r\\n      \\r\\n        pp.isSimpleAssignTarget = function(expr) {\\r\\n          if (expr.type === \\\"ParenthesizedExpression\\\")\\r\\n            { return this.isSimpleAssignTarget(expr.expression) }\\r\\n          return expr.type === \\\"Identifier\\\" || expr.type === \\\"MemberExpression\\\"\\r\\n        };\\r\\n      \\r\\n        var pp$1 = Parser.prototype;\\r\\n      \\r\\n      \\r\\n      \\r\\n        pp$1.parseTopLevel = function(node) {\\r\\n          var exports = {};\\r\\n          if (!node.body) { node.body = []; }\\r\\n          while (this.type !== types.eof) {\\r\\n            var stmt = this.parseStatement(null, true, exports);\\r\\n            node.body.push(stmt);\\r\\n          }\\r\\n          if (this.inModule)\\r\\n            { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\\r\\n              {\\r\\n                var name = list[i];\\r\\n      \\r\\n                this.raiseRecoverable(this.undefinedExports[name].start, (\\\"Export '\\\" + name + \\\"' is not defined\\\"));\\r\\n              } }\\r\\n          this.adaptDirectivePrologue(node.body);\\r\\n          this.next();\\r\\n          node.sourceType = this.options.sourceType;\\r\\n          return this.finishNode(node, \\\"Program\\\")\\r\\n        };\\r\\n      \\r\\n        var loopLabel = {kind: \\\"loop\\\"}, switchLabel = {kind: \\\"switch\\\"};\\r\\n      \\r\\n        pp$1.isLet = function(context) {\\r\\n          if (this.options.ecmaVersion < 6 || !this.isContextual(\\\"let\\\")) { return false }\\r\\n          skipWhiteSpace.lastIndex = this.pos;\\r\\n          var skip = skipWhiteSpace.exec(this.input);\\r\\n          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\\r\\n          if (nextCh === 91) { return true } \\r\\n          if (context) { return false }\\r\\n      \\r\\n          if (nextCh === 123) { return true } \\r\\n          if (isIdentifierStart(nextCh, true)) {\\r\\n            var pos = next + 1;\\r\\n            while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\\r\\n            var ident = this.input.slice(next, pos);\\r\\n            if (!keywordRelationalOperator.test(ident)) { return true }\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$1.isAsyncFunction = function() {\\r\\n          if (this.options.ecmaVersion < 8 || !this.isContextual(\\\"async\\\"))\\r\\n            { return false }\\r\\n      \\r\\n          skipWhiteSpace.lastIndex = this.pos;\\r\\n          var skip = skipWhiteSpace.exec(this.input);\\r\\n          var next = this.pos + skip[0].length;\\r\\n          return !lineBreak.test(this.input.slice(this.pos, next)) &&\\r\\n            this.input.slice(next, next + 8) === \\\"function\\\" &&\\r\\n            (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$1.parseStatement = function(context, topLevel, exports) {\\r\\n          var starttype = this.type, node = this.startNode(), kind;\\r\\n      \\r\\n          if (this.isLet(context)) {\\r\\n            starttype = types._var;\\r\\n            kind = \\\"let\\\";\\r\\n          }\\r\\n      \\r\\n      \\r\\n          switch (starttype) {\\r\\n          case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\\r\\n          case types._debugger: return this.parseDebuggerStatement(node)\\r\\n          case types._do: return this.parseDoStatement(node)\\r\\n          case types._for: return this.parseForStatement(node)\\r\\n          case types._function:\\r\\n            if ((context && (this.strict || context !== \\\"if\\\" && context !== \\\"label\\\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\\r\\n            return this.parseFunctionStatement(node, false, !context)\\r\\n          case types._class:\\r\\n            if (context) { this.unexpected(); }\\r\\n            return this.parseClass(node, true)\\r\\n          case types._if: return this.parseIfStatement(node)\\r\\n          case types._return: return this.parseReturnStatement(node)\\r\\n          case types._switch: return this.parseSwitchStatement(node)\\r\\n          case types._throw: return this.parseThrowStatement(node)\\r\\n          case types._try: return this.parseTryStatement(node)\\r\\n          case types._const: case types._var:\\r\\n            kind = kind || this.value;\\r\\n            if (context && kind !== \\\"var\\\") { this.unexpected(); }\\r\\n            return this.parseVarStatement(node, kind)\\r\\n          case types._while: return this.parseWhileStatement(node)\\r\\n          case types._with: return this.parseWithStatement(node)\\r\\n          case types.braceL: return this.parseBlock(true, node)\\r\\n          case types.semi: return this.parseEmptyStatement(node)\\r\\n          case types._export:\\r\\n          case types._import:\\r\\n            if (this.options.ecmaVersion > 10 && starttype === types._import) {\\r\\n              skipWhiteSpace.lastIndex = this.pos;\\r\\n              var skip = skipWhiteSpace.exec(this.input);\\r\\n              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\\r\\n              if (nextCh === 40) \\r\\n                { return this.parseExpressionStatement(node, this.parseExpression()) }\\r\\n            }\\r\\n      \\r\\n            if (!this.options.allowImportExportEverywhere) {\\r\\n              if (!topLevel)\\r\\n                { this.raise(this.start, \\\"'import' and 'export' may only appear at the top level\\\"); }\\r\\n              if (!this.inModule)\\r\\n                { this.raise(this.start, \\\"'import' and 'export' may appear only with 'sourceType: module'\\\"); }\\r\\n            }\\r\\n            return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\\r\\n      \\r\\n          default:\\r\\n            if (this.isAsyncFunction()) {\\r\\n              if (context) { this.unexpected(); }\\r\\n              this.next();\\r\\n              return this.parseFunctionStatement(node, true, !context)\\r\\n            }\\r\\n      \\r\\n            var maybeName = this.value, expr = this.parseExpression();\\r\\n            if (starttype === types.name && expr.type === \\\"Identifier\\\" && this.eat(types.colon))\\r\\n              { return this.parseLabeledStatement(node, maybeName, expr, context) }\\r\\n            else { return this.parseExpressionStatement(node, expr) }\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$1.parseBreakContinueStatement = function(node, keyword) {\\r\\n          var isBreak = keyword === \\\"break\\\";\\r\\n          this.next();\\r\\n          if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\\r\\n          else if (this.type !== types.name) { this.unexpected(); }\\r\\n          else {\\r\\n            node.label = this.parseIdent();\\r\\n            this.semicolon();\\r\\n          }\\r\\n      \\r\\n          var i = 0;\\r\\n          for (; i < this.labels.length; ++i) {\\r\\n            var lab = this.labels[i];\\r\\n            if (node.label == null || lab.name === node.label.name) {\\r\\n              if (lab.kind != null && (isBreak || lab.kind === \\\"loop\\\")) { break }\\r\\n              if (node.label && isBreak) { break }\\r\\n            }\\r\\n          }\\r\\n          if (i === this.labels.length) { this.raise(node.start, \\\"Unsyntactic \\\" + keyword); }\\r\\n          return this.finishNode(node, isBreak ? \\\"BreakStatement\\\" : \\\"ContinueStatement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseDebuggerStatement = function(node) {\\r\\n          this.next();\\r\\n          this.semicolon();\\r\\n          return this.finishNode(node, \\\"DebuggerStatement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseDoStatement = function(node) {\\r\\n          this.next();\\r\\n          this.labels.push(loopLabel);\\r\\n          node.body = this.parseStatement(\\\"do\\\");\\r\\n          this.labels.pop();\\r\\n          this.expect(types._while);\\r\\n          node.test = this.parseParenExpression();\\r\\n          if (this.options.ecmaVersion >= 6)\\r\\n            { this.eat(types.semi); }\\r\\n          else\\r\\n            { this.semicolon(); }\\r\\n          return this.finishNode(node, \\\"DoWhileStatement\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$1.parseForStatement = function(node) {\\r\\n          this.next();\\r\\n          var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\\\"await\\\")) ? this.lastTokStart : -1;\\r\\n          this.labels.push(loopLabel);\\r\\n          this.enterScope(0);\\r\\n          this.expect(types.parenL);\\r\\n          if (this.type === types.semi) {\\r\\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\\r\\n            return this.parseFor(node, null)\\r\\n          }\\r\\n          var isLet = this.isLet();\\r\\n          if (this.type === types._var || this.type === types._const || isLet) {\\r\\n            var init$1 = this.startNode(), kind = isLet ? \\\"let\\\" : this.value;\\r\\n            this.next();\\r\\n            this.parseVar(init$1, true, kind);\\r\\n            this.finishNode(init$1, \\\"VariableDeclaration\\\");\\r\\n            if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\\\"of\\\"))) && init$1.declarations.length === 1) {\\r\\n              if (this.options.ecmaVersion >= 9) {\\r\\n                if (this.type === types._in) {\\r\\n                  if (awaitAt > -1) { this.unexpected(awaitAt); }\\r\\n                } else { node.await = awaitAt > -1; }\\r\\n              }\\r\\n              return this.parseForIn(node, init$1)\\r\\n            }\\r\\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\\r\\n            return this.parseFor(node, init$1)\\r\\n          }\\r\\n          var refDestructuringErrors = new DestructuringErrors;\\r\\n          var init = this.parseExpression(true, refDestructuringErrors);\\r\\n          if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\\\"of\\\"))) {\\r\\n            if (this.options.ecmaVersion >= 9) {\\r\\n              if (this.type === types._in) {\\r\\n                if (awaitAt > -1) { this.unexpected(awaitAt); }\\r\\n              } else { node.await = awaitAt > -1; }\\r\\n            }\\r\\n            this.toAssignable(init, false, refDestructuringErrors);\\r\\n            this.checkLVal(init);\\r\\n            return this.parseForIn(node, init)\\r\\n          } else {\\r\\n            this.checkExpressionErrors(refDestructuringErrors, true);\\r\\n          }\\r\\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\\r\\n          return this.parseFor(node, init)\\r\\n        };\\r\\n      \\r\\n        pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\\r\\n          this.next();\\r\\n          return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\\r\\n        };\\r\\n      \\r\\n        pp$1.parseIfStatement = function(node) {\\r\\n          this.next();\\r\\n          node.test = this.parseParenExpression();\\r\\n          node.consequent = this.parseStatement(\\\"if\\\");\\r\\n          node.alternate = this.eat(types._else) ? this.parseStatement(\\\"if\\\") : null;\\r\\n          return this.finishNode(node, \\\"IfStatement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseReturnStatement = function(node) {\\r\\n          if (!this.inFunction && !this.options.allowReturnOutsideFunction)\\r\\n            { this.raise(this.start, \\\"'return' outside of function\\\"); }\\r\\n          this.next();\\r\\n      \\r\\n      \\r\\n          if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\\r\\n          else { node.argument = this.parseExpression(); this.semicolon(); }\\r\\n          return this.finishNode(node, \\\"ReturnStatement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseSwitchStatement = function(node) {\\r\\n          this.next();\\r\\n          node.discriminant = this.parseParenExpression();\\r\\n          node.cases = [];\\r\\n          this.expect(types.braceL);\\r\\n          this.labels.push(switchLabel);\\r\\n          this.enterScope(0);\\r\\n      \\r\\n      \\r\\n          var cur;\\r\\n          for (var sawDefault = false; this.type !== types.braceR;) {\\r\\n            if (this.type === types._case || this.type === types._default) {\\r\\n              var isCase = this.type === types._case;\\r\\n              if (cur) { this.finishNode(cur, \\\"SwitchCase\\\"); }\\r\\n              node.cases.push(cur = this.startNode());\\r\\n              cur.consequent = [];\\r\\n              this.next();\\r\\n              if (isCase) {\\r\\n                cur.test = this.parseExpression();\\r\\n              } else {\\r\\n                if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \\\"Multiple default clauses\\\"); }\\r\\n                sawDefault = true;\\r\\n                cur.test = null;\\r\\n              }\\r\\n              this.expect(types.colon);\\r\\n            } else {\\r\\n              if (!cur) { this.unexpected(); }\\r\\n              cur.consequent.push(this.parseStatement(null));\\r\\n            }\\r\\n          }\\r\\n          this.exitScope();\\r\\n          if (cur) { this.finishNode(cur, \\\"SwitchCase\\\"); }\\r\\n          this.next(); \\r\\n          this.labels.pop();\\r\\n          return this.finishNode(node, \\\"SwitchStatement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseThrowStatement = function(node) {\\r\\n          this.next();\\r\\n          if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\\r\\n            { this.raise(this.lastTokEnd, \\\"Illegal newline after throw\\\"); }\\r\\n          node.argument = this.parseExpression();\\r\\n          this.semicolon();\\r\\n          return this.finishNode(node, \\\"ThrowStatement\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var empty = [];\\r\\n      \\r\\n        pp$1.parseTryStatement = function(node) {\\r\\n          this.next();\\r\\n          node.block = this.parseBlock();\\r\\n          node.handler = null;\\r\\n          if (this.type === types._catch) {\\r\\n            var clause = this.startNode();\\r\\n            this.next();\\r\\n            if (this.eat(types.parenL)) {\\r\\n              clause.param = this.parseBindingAtom();\\r\\n              var simple = clause.param.type === \\\"Identifier\\\";\\r\\n              this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\\r\\n              this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\\r\\n              this.expect(types.parenR);\\r\\n            } else {\\r\\n              if (this.options.ecmaVersion < 10) { this.unexpected(); }\\r\\n              clause.param = null;\\r\\n              this.enterScope(0);\\r\\n            }\\r\\n            clause.body = this.parseBlock(false);\\r\\n            this.exitScope();\\r\\n            node.handler = this.finishNode(clause, \\\"CatchClause\\\");\\r\\n          }\\r\\n          node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\\r\\n          if (!node.handler && !node.finalizer)\\r\\n            { this.raise(node.start, \\\"Missing catch or finally clause\\\"); }\\r\\n          return this.finishNode(node, \\\"TryStatement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseVarStatement = function(node, kind) {\\r\\n          this.next();\\r\\n          this.parseVar(node, false, kind);\\r\\n          this.semicolon();\\r\\n          return this.finishNode(node, \\\"VariableDeclaration\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseWhileStatement = function(node) {\\r\\n          this.next();\\r\\n          node.test = this.parseParenExpression();\\r\\n          this.labels.push(loopLabel);\\r\\n          node.body = this.parseStatement(\\\"while\\\");\\r\\n          this.labels.pop();\\r\\n          return this.finishNode(node, \\\"WhileStatement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseWithStatement = function(node) {\\r\\n          if (this.strict) { this.raise(this.start, \\\"'with' in strict mode\\\"); }\\r\\n          this.next();\\r\\n          node.object = this.parseParenExpression();\\r\\n          node.body = this.parseStatement(\\\"with\\\");\\r\\n          return this.finishNode(node, \\\"WithStatement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseEmptyStatement = function(node) {\\r\\n          this.next();\\r\\n          return this.finishNode(node, \\\"EmptyStatement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\\r\\n          for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\\r\\n            {\\r\\n            var label = list[i$1];\\r\\n      \\r\\n            if (label.name === maybeName)\\r\\n              { this.raise(expr.start, \\\"Label '\\\" + maybeName + \\\"' is already declared\\\");\\r\\n          } }\\r\\n          var kind = this.type.isLoop ? \\\"loop\\\" : this.type === types._switch ? \\\"switch\\\" : null;\\r\\n          for (var i = this.labels.length - 1; i >= 0; i--) {\\r\\n            var label$1 = this.labels[i];\\r\\n            if (label$1.statementStart === node.start) {\\r\\n              label$1.statementStart = this.start;\\r\\n              label$1.kind = kind;\\r\\n            } else { break }\\r\\n          }\\r\\n          this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\\r\\n          node.body = this.parseStatement(context ? context.indexOf(\\\"label\\\") === -1 ? context + \\\"label\\\" : context : \\\"label\\\");\\r\\n          this.labels.pop();\\r\\n          node.label = expr;\\r\\n          return this.finishNode(node, \\\"LabeledStatement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseExpressionStatement = function(node, expr) {\\r\\n          node.expression = expr;\\r\\n          this.semicolon();\\r\\n          return this.finishNode(node, \\\"ExpressionStatement\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$1.parseBlock = function(createNewLexicalScope, node) {\\r\\n          if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\\r\\n          if ( node === void 0 ) node = this.startNode();\\r\\n      \\r\\n          node.body = [];\\r\\n          this.expect(types.braceL);\\r\\n          if (createNewLexicalScope) { this.enterScope(0); }\\r\\n          while (!this.eat(types.braceR)) {\\r\\n            var stmt = this.parseStatement(null);\\r\\n            node.body.push(stmt);\\r\\n          }\\r\\n          if (createNewLexicalScope) { this.exitScope(); }\\r\\n          return this.finishNode(node, \\\"BlockStatement\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$1.parseFor = function(node, init) {\\r\\n          node.init = init;\\r\\n          this.expect(types.semi);\\r\\n          node.test = this.type === types.semi ? null : this.parseExpression();\\r\\n          this.expect(types.semi);\\r\\n          node.update = this.type === types.parenR ? null : this.parseExpression();\\r\\n          this.expect(types.parenR);\\r\\n          node.body = this.parseStatement(\\\"for\\\");\\r\\n          this.exitScope();\\r\\n          this.labels.pop();\\r\\n          return this.finishNode(node, \\\"ForStatement\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$1.parseForIn = function(node, init) {\\r\\n          var isForIn = this.type === types._in;\\r\\n          this.next();\\r\\n      \\r\\n          if (\\r\\n            init.type === \\\"VariableDeclaration\\\" &&\\r\\n            init.declarations[0].init != null &&\\r\\n            (\\r\\n              !isForIn ||\\r\\n              this.options.ecmaVersion < 8 ||\\r\\n              this.strict ||\\r\\n              init.kind !== \\\"var\\\" ||\\r\\n              init.declarations[0].id.type !== \\\"Identifier\\\"\\r\\n            )\\r\\n          ) {\\r\\n            this.raise(\\r\\n              init.start,\\r\\n              ((isForIn ? \\\"for-in\\\" : \\\"for-of\\\") + \\\" loop variable declaration may not have an initializer\\\")\\r\\n            );\\r\\n          } else if (init.type === \\\"AssignmentPattern\\\") {\\r\\n            this.raise(init.start, \\\"Invalid left-hand side in for-loop\\\");\\r\\n          }\\r\\n          node.left = init;\\r\\n          node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\\r\\n          this.expect(types.parenR);\\r\\n          node.body = this.parseStatement(\\\"for\\\");\\r\\n          this.exitScope();\\r\\n          this.labels.pop();\\r\\n          return this.finishNode(node, isForIn ? \\\"ForInStatement\\\" : \\\"ForOfStatement\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$1.parseVar = function(node, isFor, kind) {\\r\\n          node.declarations = [];\\r\\n          node.kind = kind;\\r\\n          for (;;) {\\r\\n            var decl = this.startNode();\\r\\n            this.parseVarId(decl, kind);\\r\\n            if (this.eat(types.eq)) {\\r\\n              decl.init = this.parseMaybeAssign(isFor);\\r\\n            } else if (kind === \\\"const\\\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\\\"of\\\")))) {\\r\\n              this.unexpected();\\r\\n            } else if (decl.id.type !== \\\"Identifier\\\" && !(isFor && (this.type === types._in || this.isContextual(\\\"of\\\")))) {\\r\\n              this.raise(this.lastTokEnd, \\\"Complex binding patterns require an initialization value\\\");\\r\\n            } else {\\r\\n              decl.init = null;\\r\\n            }\\r\\n            node.declarations.push(this.finishNode(decl, \\\"VariableDeclarator\\\"));\\r\\n            if (!this.eat(types.comma)) { break }\\r\\n          }\\r\\n          return node\\r\\n        };\\r\\n      \\r\\n        pp$1.parseVarId = function(decl, kind) {\\r\\n          decl.id = this.parseBindingAtom();\\r\\n          this.checkLVal(decl.id, kind === \\\"var\\\" ? BIND_VAR : BIND_LEXICAL, false);\\r\\n        };\\r\\n      \\r\\n        var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\\r\\n      \\r\\n      \\r\\n        pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\\r\\n          this.initFunction(node);\\r\\n          if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\\r\\n            if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\\r\\n              { this.unexpected(); }\\r\\n            node.generator = this.eat(types.star);\\r\\n          }\\r\\n          if (this.options.ecmaVersion >= 8)\\r\\n            { node.async = !!isAsync; }\\r\\n      \\r\\n          if (statement & FUNC_STATEMENT) {\\r\\n            node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\\r\\n            if (node.id && !(statement & FUNC_HANGING_STATEMENT))\\r\\n              { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\\r\\n          }\\r\\n      \\r\\n          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\\r\\n          this.yieldPos = 0;\\r\\n          this.awaitPos = 0;\\r\\n          this.awaitIdentPos = 0;\\r\\n          this.enterScope(functionFlags(node.async, node.generator));\\r\\n      \\r\\n          if (!(statement & FUNC_STATEMENT))\\r\\n            { node.id = this.type === types.name ? this.parseIdent() : null; }\\r\\n      \\r\\n          this.parseFunctionParams(node);\\r\\n          this.parseFunctionBody(node, allowExpressionBody, false);\\r\\n      \\r\\n          this.yieldPos = oldYieldPos;\\r\\n          this.awaitPos = oldAwaitPos;\\r\\n          this.awaitIdentPos = oldAwaitIdentPos;\\r\\n          return this.finishNode(node, (statement & FUNC_STATEMENT) ? \\\"FunctionDeclaration\\\" : \\\"FunctionExpression\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseFunctionParams = function(node) {\\r\\n          this.expect(types.parenL);\\r\\n          node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\\r\\n          this.checkYieldAwaitInDefaultParams();\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$1.parseClass = function(node, isStatement) {\\r\\n          this.next();\\r\\n      \\r\\n          var oldStrict = this.strict;\\r\\n          this.strict = true;\\r\\n      \\r\\n          this.parseClassId(node, isStatement);\\r\\n          this.parseClassSuper(node);\\r\\n          var classBody = this.startNode();\\r\\n          var hadConstructor = false;\\r\\n          classBody.body = [];\\r\\n          this.expect(types.braceL);\\r\\n          while (!this.eat(types.braceR)) {\\r\\n            var element = this.parseClassElement(node.superClass !== null);\\r\\n            if (element) {\\r\\n              classBody.body.push(element);\\r\\n              if (element.type === \\\"MethodDefinition\\\" && element.kind === \\\"constructor\\\") {\\r\\n                if (hadConstructor) { this.raise(element.start, \\\"Duplicate constructor in the same class\\\"); }\\r\\n                hadConstructor = true;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n          node.body = this.finishNode(classBody, \\\"ClassBody\\\");\\r\\n          this.strict = oldStrict;\\r\\n          return this.finishNode(node, isStatement ? \\\"ClassDeclaration\\\" : \\\"ClassExpression\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseClassElement = function(constructorAllowsSuper) {\\r\\n          var this$1 = this;\\r\\n      \\r\\n          if (this.eat(types.semi)) { return null }\\r\\n      \\r\\n          var method = this.startNode();\\r\\n          var tryContextual = function (k, noLineBreak) {\\r\\n            if ( noLineBreak === void 0 ) noLineBreak = false;\\r\\n      \\r\\n            var start = this$1.start, startLoc = this$1.startLoc;\\r\\n            if (!this$1.eatContextual(k)) { return false }\\r\\n            if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\\r\\n            if (method.key) { this$1.unexpected(); }\\r\\n            method.computed = false;\\r\\n            method.key = this$1.startNodeAt(start, startLoc);\\r\\n            method.key.name = k;\\r\\n            this$1.finishNode(method.key, \\\"Identifier\\\");\\r\\n            return false\\r\\n          };\\r\\n      \\r\\n          method.kind = \\\"method\\\";\\r\\n          method.static = tryContextual(\\\"static\\\");\\r\\n          var isGenerator = this.eat(types.star);\\r\\n          var isAsync = false;\\r\\n          if (!isGenerator) {\\r\\n            if (this.options.ecmaVersion >= 8 && tryContextual(\\\"async\\\", true)) {\\r\\n              isAsync = true;\\r\\n              isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\\r\\n            } else if (tryContextual(\\\"get\\\")) {\\r\\n              method.kind = \\\"get\\\";\\r\\n            } else if (tryContextual(\\\"set\\\")) {\\r\\n              method.kind = \\\"set\\\";\\r\\n            }\\r\\n          }\\r\\n          if (!method.key) { this.parsePropertyName(method); }\\r\\n          var key = method.key;\\r\\n          var allowsDirectSuper = false;\\r\\n          if (!method.computed && !method.static && (key.type === \\\"Identifier\\\" && key.name === \\\"constructor\\\" ||\\r\\n              key.type === \\\"Literal\\\" && key.value === \\\"constructor\\\")) {\\r\\n            if (method.kind !== \\\"method\\\") { this.raise(key.start, \\\"Constructor can't have get/set modifier\\\"); }\\r\\n            if (isGenerator) { this.raise(key.start, \\\"Constructor can't be a generator\\\"); }\\r\\n            if (isAsync) { this.raise(key.start, \\\"Constructor can't be an async method\\\"); }\\r\\n            method.kind = \\\"constructor\\\";\\r\\n            allowsDirectSuper = constructorAllowsSuper;\\r\\n          } else if (method.static && key.type === \\\"Identifier\\\" && key.name === \\\"prototype\\\") {\\r\\n            this.raise(key.start, \\\"Classes may not have a static property named prototype\\\");\\r\\n          }\\r\\n          this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\\r\\n          if (method.kind === \\\"get\\\" && method.value.params.length !== 0)\\r\\n            { this.raiseRecoverable(method.value.start, \\\"getter should have no params\\\"); }\\r\\n          if (method.kind === \\\"set\\\" && method.value.params.length !== 1)\\r\\n            { this.raiseRecoverable(method.value.start, \\\"setter should have exactly one param\\\"); }\\r\\n          if (method.kind === \\\"set\\\" && method.value.params[0].type === \\\"RestElement\\\")\\r\\n            { this.raiseRecoverable(method.value.params[0].start, \\\"Setter cannot use rest params\\\"); }\\r\\n          return method\\r\\n        };\\r\\n      \\r\\n        pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\\r\\n          method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\\r\\n          return this.finishNode(method, \\\"MethodDefinition\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.parseClassId = function(node, isStatement) {\\r\\n          if (this.type === types.name) {\\r\\n            node.id = this.parseIdent();\\r\\n            if (isStatement)\\r\\n              { this.checkLVal(node.id, BIND_LEXICAL, false); }\\r\\n          } else {\\r\\n            if (isStatement === true)\\r\\n              { this.unexpected(); }\\r\\n            node.id = null;\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$1.parseClassSuper = function(node) {\\r\\n          node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$1.parseExport = function(node, exports) {\\r\\n          this.next();\\r\\n          if (this.eat(types.star)) {\\r\\n            this.expectContextual(\\\"from\\\");\\r\\n            if (this.type !== types.string) { this.unexpected(); }\\r\\n            node.source = this.parseExprAtom();\\r\\n            this.semicolon();\\r\\n            return this.finishNode(node, \\\"ExportAllDeclaration\\\")\\r\\n          }\\r\\n          if (this.eat(types._default)) { \\r\\n            this.checkExport(exports, \\\"default\\\", this.lastTokStart);\\r\\n            var isAsync;\\r\\n            if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\\r\\n              var fNode = this.startNode();\\r\\n              this.next();\\r\\n              if (isAsync) { this.next(); }\\r\\n              node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\\r\\n            } else if (this.type === types._class) {\\r\\n              var cNode = this.startNode();\\r\\n              node.declaration = this.parseClass(cNode, \\\"nullableID\\\");\\r\\n            } else {\\r\\n              node.declaration = this.parseMaybeAssign();\\r\\n              this.semicolon();\\r\\n            }\\r\\n            return this.finishNode(node, \\\"ExportDefaultDeclaration\\\")\\r\\n          }\\r\\n          if (this.shouldParseExportStatement()) {\\r\\n            node.declaration = this.parseStatement(null);\\r\\n            if (node.declaration.type === \\\"VariableDeclaration\\\")\\r\\n              { this.checkVariableExport(exports, node.declaration.declarations); }\\r\\n            else\\r\\n              { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\\r\\n            node.specifiers = [];\\r\\n            node.source = null;\\r\\n          } else { \\r\\n            node.declaration = null;\\r\\n            node.specifiers = this.parseExportSpecifiers(exports);\\r\\n            if (this.eatContextual(\\\"from\\\")) {\\r\\n              if (this.type !== types.string) { this.unexpected(); }\\r\\n              node.source = this.parseExprAtom();\\r\\n            } else {\\r\\n              for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\\r\\n                var spec = list[i];\\r\\n      \\r\\n                this.checkUnreserved(spec.local);\\r\\n                this.checkLocalExport(spec.local);\\r\\n              }\\r\\n      \\r\\n              node.source = null;\\r\\n            }\\r\\n            this.semicolon();\\r\\n          }\\r\\n          return this.finishNode(node, \\\"ExportNamedDeclaration\\\")\\r\\n        };\\r\\n      \\r\\n        pp$1.checkExport = function(exports, name, pos) {\\r\\n          if (!exports) { return }\\r\\n          if (has(exports, name))\\r\\n            { this.raiseRecoverable(pos, \\\"Duplicate export '\\\" + name + \\\"'\\\"); }\\r\\n          exports[name] = true;\\r\\n        };\\r\\n      \\r\\n        pp$1.checkPatternExport = function(exports, pat) {\\r\\n          var type = pat.type;\\r\\n          if (type === \\\"Identifier\\\")\\r\\n            { this.checkExport(exports, pat.name, pat.start); }\\r\\n          else if (type === \\\"ObjectPattern\\\")\\r\\n            { for (var i = 0, list = pat.properties; i < list.length; i += 1)\\r\\n              {\\r\\n                var prop = list[i];\\r\\n      \\r\\n                this.checkPatternExport(exports, prop);\\r\\n              } }\\r\\n          else if (type === \\\"ArrayPattern\\\")\\r\\n            { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\\r\\n              var elt = list$1[i$1];\\r\\n      \\r\\n                if (elt) { this.checkPatternExport(exports, elt); }\\r\\n            } }\\r\\n          else if (type === \\\"Property\\\")\\r\\n            { this.checkPatternExport(exports, pat.value); }\\r\\n          else if (type === \\\"AssignmentPattern\\\")\\r\\n            { this.checkPatternExport(exports, pat.left); }\\r\\n          else if (type === \\\"RestElement\\\")\\r\\n            { this.checkPatternExport(exports, pat.argument); }\\r\\n          else if (type === \\\"ParenthesizedExpression\\\")\\r\\n            { this.checkPatternExport(exports, pat.expression); }\\r\\n        };\\r\\n      \\r\\n        pp$1.checkVariableExport = function(exports, decls) {\\r\\n          if (!exports) { return }\\r\\n          for (var i = 0, list = decls; i < list.length; i += 1)\\r\\n            {\\r\\n            var decl = list[i];\\r\\n      \\r\\n            this.checkPatternExport(exports, decl.id);\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$1.shouldParseExportStatement = function() {\\r\\n          return this.type.keyword === \\\"var\\\" ||\\r\\n            this.type.keyword === \\\"const\\\" ||\\r\\n            this.type.keyword === \\\"class\\\" ||\\r\\n            this.type.keyword === \\\"function\\\" ||\\r\\n            this.isLet() ||\\r\\n            this.isAsyncFunction()\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$1.parseExportSpecifiers = function(exports) {\\r\\n          var nodes = [], first = true;\\r\\n          this.expect(types.braceL);\\r\\n          while (!this.eat(types.braceR)) {\\r\\n            if (!first) {\\r\\n              this.expect(types.comma);\\r\\n              if (this.afterTrailingComma(types.braceR)) { break }\\r\\n            } else { first = false; }\\r\\n      \\r\\n            var node = this.startNode();\\r\\n            node.local = this.parseIdent(true);\\r\\n            node.exported = this.eatContextual(\\\"as\\\") ? this.parseIdent(true) : node.local;\\r\\n            this.checkExport(exports, node.exported.name, node.exported.start);\\r\\n            nodes.push(this.finishNode(node, \\\"ExportSpecifier\\\"));\\r\\n          }\\r\\n          return nodes\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$1.parseImport = function(node) {\\r\\n          this.next();\\r\\n          if (this.type === types.string) {\\r\\n            node.specifiers = empty;\\r\\n            node.source = this.parseExprAtom();\\r\\n          } else {\\r\\n            node.specifiers = this.parseImportSpecifiers();\\r\\n            this.expectContextual(\\\"from\\\");\\r\\n            node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\\r\\n          }\\r\\n          this.semicolon();\\r\\n          return this.finishNode(node, \\\"ImportDeclaration\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$1.parseImportSpecifiers = function() {\\r\\n          var nodes = [], first = true;\\r\\n          if (this.type === types.name) {\\r\\n            var node = this.startNode();\\r\\n            node.local = this.parseIdent();\\r\\n            this.checkLVal(node.local, BIND_LEXICAL);\\r\\n            nodes.push(this.finishNode(node, \\\"ImportDefaultSpecifier\\\"));\\r\\n            if (!this.eat(types.comma)) { return nodes }\\r\\n          }\\r\\n          if (this.type === types.star) {\\r\\n            var node$1 = this.startNode();\\r\\n            this.next();\\r\\n            this.expectContextual(\\\"as\\\");\\r\\n            node$1.local = this.parseIdent();\\r\\n            this.checkLVal(node$1.local, BIND_LEXICAL);\\r\\n            nodes.push(this.finishNode(node$1, \\\"ImportNamespaceSpecifier\\\"));\\r\\n            return nodes\\r\\n          }\\r\\n          this.expect(types.braceL);\\r\\n          while (!this.eat(types.braceR)) {\\r\\n            if (!first) {\\r\\n              this.expect(types.comma);\\r\\n              if (this.afterTrailingComma(types.braceR)) { break }\\r\\n            } else { first = false; }\\r\\n      \\r\\n            var node$2 = this.startNode();\\r\\n            node$2.imported = this.parseIdent(true);\\r\\n            if (this.eatContextual(\\\"as\\\")) {\\r\\n              node$2.local = this.parseIdent();\\r\\n            } else {\\r\\n              this.checkUnreserved(node$2.imported);\\r\\n              node$2.local = node$2.imported;\\r\\n            }\\r\\n            this.checkLVal(node$2.local, BIND_LEXICAL);\\r\\n            nodes.push(this.finishNode(node$2, \\\"ImportSpecifier\\\"));\\r\\n          }\\r\\n          return nodes\\r\\n        };\\r\\n      \\r\\n        pp$1.adaptDirectivePrologue = function(statements) {\\r\\n          for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\\r\\n            statements[i].directive = statements[i].expression.raw.slice(1, -1);\\r\\n          }\\r\\n        };\\r\\n        pp$1.isDirectiveCandidate = function(statement) {\\r\\n          return (\\r\\n            statement.type === \\\"ExpressionStatement\\\" &&\\r\\n            statement.expression.type === \\\"Literal\\\" &&\\r\\n            typeof statement.expression.value === \\\"string\\\" &&\\r\\n            (this.input[statement.start] === \\\"\\\\\\\"\\\" || this.input[statement.start] === \\\"'\\\")\\r\\n          )\\r\\n        };\\r\\n      \\r\\n        var pp$2 = Parser.prototype;\\r\\n      \\r\\n      \\r\\n        pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\\r\\n          if (this.options.ecmaVersion >= 6 && node) {\\r\\n            switch (node.type) {\\r\\n            case \\\"Identifier\\\":\\r\\n              if (this.inAsync && node.name === \\\"await\\\")\\r\\n                { this.raise(node.start, \\\"Cannot use 'await' as identifier inside an async function\\\"); }\\r\\n              break\\r\\n      \\r\\n            case \\\"ObjectPattern\\\":\\r\\n            case \\\"ArrayPattern\\\":\\r\\n            case \\\"RestElement\\\":\\r\\n              break\\r\\n      \\r\\n            case \\\"ObjectExpression\\\":\\r\\n              node.type = \\\"ObjectPattern\\\";\\r\\n              if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\\r\\n              for (var i = 0, list = node.properties; i < list.length; i += 1) {\\r\\n                var prop = list[i];\\r\\n      \\r\\n              this.toAssignable(prop, isBinding);\\r\\n                if (\\r\\n                  prop.type === \\\"RestElement\\\" &&\\r\\n                  (prop.argument.type === \\\"ArrayPattern\\\" || prop.argument.type === \\\"ObjectPattern\\\")\\r\\n                ) {\\r\\n                  this.raise(prop.argument.start, \\\"Unexpected token\\\");\\r\\n                }\\r\\n              }\\r\\n              break\\r\\n      \\r\\n            case \\\"Property\\\":\\r\\n              if (node.kind !== \\\"init\\\") { this.raise(node.key.start, \\\"Object pattern can't contain getter or setter\\\"); }\\r\\n              this.toAssignable(node.value, isBinding);\\r\\n              break\\r\\n      \\r\\n            case \\\"ArrayExpression\\\":\\r\\n              node.type = \\\"ArrayPattern\\\";\\r\\n              if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\\r\\n              this.toAssignableList(node.elements, isBinding);\\r\\n              break\\r\\n      \\r\\n            case \\\"SpreadElement\\\":\\r\\n              node.type = \\\"RestElement\\\";\\r\\n              this.toAssignable(node.argument, isBinding);\\r\\n              if (node.argument.type === \\\"AssignmentPattern\\\")\\r\\n                { this.raise(node.argument.start, \\\"Rest elements cannot have a default value\\\"); }\\r\\n              break\\r\\n      \\r\\n            case \\\"AssignmentExpression\\\":\\r\\n              if (node.operator !== \\\"=\\\") { this.raise(node.left.end, \\\"Only '=' operator can be used for specifying default value.\\\"); }\\r\\n              node.type = \\\"AssignmentPattern\\\";\\r\\n              delete node.operator;\\r\\n              this.toAssignable(node.left, isBinding);\\r\\n      \\r\\n            case \\\"AssignmentPattern\\\":\\r\\n              break\\r\\n      \\r\\n            case \\\"ParenthesizedExpression\\\":\\r\\n              this.toAssignable(node.expression, isBinding, refDestructuringErrors);\\r\\n              break\\r\\n      \\r\\n            case \\\"MemberExpression\\\":\\r\\n              if (!isBinding) { break }\\r\\n      \\r\\n            default:\\r\\n              this.raise(node.start, \\\"Assigning to rvalue\\\");\\r\\n            }\\r\\n          } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\\r\\n          return node\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$2.toAssignableList = function(exprList, isBinding) {\\r\\n          var end = exprList.length;\\r\\n          for (var i = 0; i < end; i++) {\\r\\n            var elt = exprList[i];\\r\\n            if (elt) { this.toAssignable(elt, isBinding); }\\r\\n          }\\r\\n          if (end) {\\r\\n            var last = exprList[end - 1];\\r\\n            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \\\"RestElement\\\" && last.argument.type !== \\\"Identifier\\\")\\r\\n              { this.unexpected(last.argument.start); }\\r\\n          }\\r\\n          return exprList\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$2.parseSpread = function(refDestructuringErrors) {\\r\\n          var node = this.startNode();\\r\\n          this.next();\\r\\n          node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\\r\\n          return this.finishNode(node, \\\"SpreadElement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$2.parseRestBinding = function() {\\r\\n          var node = this.startNode();\\r\\n          this.next();\\r\\n      \\r\\n          if (this.options.ecmaVersion === 6 && this.type !== types.name)\\r\\n            { this.unexpected(); }\\r\\n      \\r\\n          node.argument = this.parseBindingAtom();\\r\\n      \\r\\n          return this.finishNode(node, \\\"RestElement\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$2.parseBindingAtom = function() {\\r\\n          if (this.options.ecmaVersion >= 6) {\\r\\n            switch (this.type) {\\r\\n            case types.bracketL:\\r\\n              var node = this.startNode();\\r\\n              this.next();\\r\\n              node.elements = this.parseBindingList(types.bracketR, true, true);\\r\\n              return this.finishNode(node, \\\"ArrayPattern\\\")\\r\\n      \\r\\n            case types.braceL:\\r\\n              return this.parseObj(true)\\r\\n            }\\r\\n          }\\r\\n          return this.parseIdent()\\r\\n        };\\r\\n      \\r\\n        pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\\r\\n          var elts = [], first = true;\\r\\n          while (!this.eat(close)) {\\r\\n            if (first) { first = false; }\\r\\n            else { this.expect(types.comma); }\\r\\n            if (allowEmpty && this.type === types.comma) {\\r\\n              elts.push(null);\\r\\n            } else if (allowTrailingComma && this.afterTrailingComma(close)) {\\r\\n              break\\r\\n            } else if (this.type === types.ellipsis) {\\r\\n              var rest = this.parseRestBinding();\\r\\n              this.parseBindingListItem(rest);\\r\\n              elts.push(rest);\\r\\n              if (this.type === types.comma) { this.raise(this.start, \\\"Comma is not permitted after the rest element\\\"); }\\r\\n              this.expect(close);\\r\\n              break\\r\\n            } else {\\r\\n              var elem = this.parseMaybeDefault(this.start, this.startLoc);\\r\\n              this.parseBindingListItem(elem);\\r\\n              elts.push(elem);\\r\\n            }\\r\\n          }\\r\\n          return elts\\r\\n        };\\r\\n      \\r\\n        pp$2.parseBindingListItem = function(param) {\\r\\n          return param\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\\r\\n          left = left || this.parseBindingAtom();\\r\\n          if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\\r\\n          var node = this.startNodeAt(startPos, startLoc);\\r\\n          node.left = left;\\r\\n          node.right = this.parseMaybeAssign();\\r\\n          return this.finishNode(node, \\\"AssignmentPattern\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$2.checkLVal = function(expr, bindingType, checkClashes) {\\r\\n          if ( bindingType === void 0 ) bindingType = BIND_NONE;\\r\\n      \\r\\n          switch (expr.type) {\\r\\n          case \\\"Identifier\\\":\\r\\n            if (bindingType === BIND_LEXICAL && expr.name === \\\"let\\\")\\r\\n              { this.raiseRecoverable(expr.start, \\\"let is disallowed as a lexically bound name\\\"); }\\r\\n            if (this.strict && this.reservedWordsStrictBind.test(expr.name))\\r\\n              { this.raiseRecoverable(expr.start, (bindingType ? \\\"Binding \\\" : \\\"Assigning to \\\") + expr.name + \\\" in strict mode\\\"); }\\r\\n            if (checkClashes) {\\r\\n              if (has(checkClashes, expr.name))\\r\\n                { this.raiseRecoverable(expr.start, \\\"Argument name clash\\\"); }\\r\\n              checkClashes[expr.name] = true;\\r\\n            }\\r\\n            if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\\r\\n            break\\r\\n      \\r\\n          case \\\"MemberExpression\\\":\\r\\n            if (bindingType) { this.raiseRecoverable(expr.start, \\\"Binding member expression\\\"); }\\r\\n            break\\r\\n      \\r\\n          case \\\"ObjectPattern\\\":\\r\\n            for (var i = 0, list = expr.properties; i < list.length; i += 1)\\r\\n              {\\r\\n            var prop = list[i];\\r\\n      \\r\\n            this.checkLVal(prop, bindingType, checkClashes);\\r\\n          }\\r\\n            break\\r\\n      \\r\\n          case \\\"Property\\\":\\r\\n            this.checkLVal(expr.value, bindingType, checkClashes);\\r\\n            break\\r\\n      \\r\\n          case \\\"ArrayPattern\\\":\\r\\n            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\\r\\n              var elem = list$1[i$1];\\r\\n      \\r\\n            if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\\r\\n            }\\r\\n            break\\r\\n      \\r\\n          case \\\"AssignmentPattern\\\":\\r\\n            this.checkLVal(expr.left, bindingType, checkClashes);\\r\\n            break\\r\\n      \\r\\n          case \\\"RestElement\\\":\\r\\n            this.checkLVal(expr.argument, bindingType, checkClashes);\\r\\n            break\\r\\n      \\r\\n          case \\\"ParenthesizedExpression\\\":\\r\\n            this.checkLVal(expr.expression, bindingType, checkClashes);\\r\\n            break\\r\\n      \\r\\n          default:\\r\\n            this.raise(expr.start, (bindingType ? \\\"Binding\\\" : \\\"Assigning to\\\") + \\\" rvalue\\\");\\r\\n          }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var pp$3 = Parser.prototype;\\r\\n      \\r\\n      \\r\\n        pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\\r\\n          if (this.options.ecmaVersion >= 9 && prop.type === \\\"SpreadElement\\\")\\r\\n            { return }\\r\\n          if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\\r\\n            { return }\\r\\n          var key = prop.key;\\r\\n          var name;\\r\\n          switch (key.type) {\\r\\n          case \\\"Identifier\\\": name = key.name; break\\r\\n          case \\\"Literal\\\": name = String(key.value); break\\r\\n          default: return\\r\\n          }\\r\\n          var kind = prop.kind;\\r\\n          if (this.options.ecmaVersion >= 6) {\\r\\n            if (name === \\\"__proto__\\\" && kind === \\\"init\\\") {\\r\\n              if (propHash.proto) {\\r\\n                if (refDestructuringErrors) {\\r\\n                  if (refDestructuringErrors.doubleProto < 0)\\r\\n                    { refDestructuringErrors.doubleProto = key.start; }\\r\\n                } else { this.raiseRecoverable(key.start, \\\"Redefinition of __proto__ property\\\"); }\\r\\n              }\\r\\n              propHash.proto = true;\\r\\n            }\\r\\n            return\\r\\n          }\\r\\n          name = \\\"$\\\" + name;\\r\\n          var other = propHash[name];\\r\\n          if (other) {\\r\\n            var redefinition;\\r\\n            if (kind === \\\"init\\\") {\\r\\n              redefinition = this.strict && other.init || other.get || other.set;\\r\\n            } else {\\r\\n              redefinition = other.init || other[kind];\\r\\n            }\\r\\n            if (redefinition)\\r\\n              { this.raiseRecoverable(key.start, \\\"Redefinition of property\\\"); }\\r\\n          } else {\\r\\n            other = propHash[name] = {\\r\\n              init: false,\\r\\n              get: false,\\r\\n              set: false\\r\\n            };\\r\\n          }\\r\\n          other[kind] = true;\\r\\n        };\\r\\n      \\r\\n      \\r\\n      \\r\\n      \\r\\n        pp$3.parseExpression = function(noIn, refDestructuringErrors) {\\r\\n          var startPos = this.start, startLoc = this.startLoc;\\r\\n          var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\\r\\n          if (this.type === types.comma) {\\r\\n            var node = this.startNodeAt(startPos, startLoc);\\r\\n            node.expressions = [expr];\\r\\n            while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\\r\\n            return this.finishNode(node, \\\"SequenceExpression\\\")\\r\\n          }\\r\\n          return expr\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\\r\\n          if (this.isContextual(\\\"yield\\\")) {\\r\\n            if (this.inGenerator) { return this.parseYield(noIn) }\\r\\n            else { this.exprAllowed = false; }\\r\\n          }\\r\\n      \\r\\n          var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\\r\\n          if (refDestructuringErrors) {\\r\\n            oldParenAssign = refDestructuringErrors.parenthesizedAssign;\\r\\n            oldTrailingComma = refDestructuringErrors.trailingComma;\\r\\n            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\\r\\n          } else {\\r\\n            refDestructuringErrors = new DestructuringErrors;\\r\\n            ownDestructuringErrors = true;\\r\\n          }\\r\\n      \\r\\n          var startPos = this.start, startLoc = this.startLoc;\\r\\n          if (this.type === types.parenL || this.type === types.name)\\r\\n            { this.potentialArrowAt = this.start; }\\r\\n          var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\\r\\n          if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\\r\\n          if (this.type.isAssign) {\\r\\n            var node = this.startNodeAt(startPos, startLoc);\\r\\n            node.operator = this.value;\\r\\n            node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\\r\\n            if (!ownDestructuringErrors) {\\r\\n              refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;\\r\\n            }\\r\\n            if (refDestructuringErrors.shorthandAssign >= node.left.start)\\r\\n              { refDestructuringErrors.shorthandAssign = -1; } \\r\\n            this.checkLVal(left);\\r\\n            this.next();\\r\\n            node.right = this.parseMaybeAssign(noIn);\\r\\n            return this.finishNode(node, \\\"AssignmentExpression\\\")\\r\\n          } else {\\r\\n            if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\\r\\n          }\\r\\n          if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\\r\\n          if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\\r\\n          return left\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\\r\\n          var startPos = this.start, startLoc = this.startLoc;\\r\\n          var expr = this.parseExprOps(noIn, refDestructuringErrors);\\r\\n          if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\\r\\n          if (this.eat(types.question)) {\\r\\n            var node = this.startNodeAt(startPos, startLoc);\\r\\n            node.test = expr;\\r\\n            node.consequent = this.parseMaybeAssign();\\r\\n            this.expect(types.colon);\\r\\n            node.alternate = this.parseMaybeAssign(noIn);\\r\\n            return this.finishNode(node, \\\"ConditionalExpression\\\")\\r\\n          }\\r\\n          return expr\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseExprOps = function(noIn, refDestructuringErrors) {\\r\\n          var startPos = this.start, startLoc = this.startLoc;\\r\\n          var expr = this.parseMaybeUnary(refDestructuringErrors, false);\\r\\n          if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\\r\\n          return expr.start === startPos && expr.type === \\\"ArrowFunctionExpression\\\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\\r\\n          var prec = this.type.binop;\\r\\n          if (prec != null && (!noIn || this.type !== types._in)) {\\r\\n            if (prec > minPrec) {\\r\\n              var logical = this.type === types.logicalOR || this.type === types.logicalAND;\\r\\n              var op = this.value;\\r\\n              this.next();\\r\\n              var startPos = this.start, startLoc = this.startLoc;\\r\\n              var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\\r\\n              var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\\r\\n              return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\\r\\n            }\\r\\n          }\\r\\n          return left\\r\\n        };\\r\\n      \\r\\n        pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\\r\\n          var node = this.startNodeAt(startPos, startLoc);\\r\\n          node.left = left;\\r\\n          node.operator = op;\\r\\n          node.right = right;\\r\\n          return this.finishNode(node, logical ? \\\"LogicalExpression\\\" : \\\"BinaryExpression\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\\r\\n          var startPos = this.start, startLoc = this.startLoc, expr;\\r\\n          if (this.isContextual(\\\"await\\\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\\r\\n            expr = this.parseAwait();\\r\\n            sawUnary = true;\\r\\n          } else if (this.type.prefix) {\\r\\n            var node = this.startNode(), update = this.type === types.incDec;\\r\\n            node.operator = this.value;\\r\\n            node.prefix = true;\\r\\n            this.next();\\r\\n            node.argument = this.parseMaybeUnary(null, true);\\r\\n            this.checkExpressionErrors(refDestructuringErrors, true);\\r\\n            if (update) { this.checkLVal(node.argument); }\\r\\n            else if (this.strict && node.operator === \\\"delete\\\" &&\\r\\n                     node.argument.type === \\\"Identifier\\\")\\r\\n              { this.raiseRecoverable(node.start, \\\"Deleting local variable in strict mode\\\"); }\\r\\n            else { sawUnary = true; }\\r\\n            expr = this.finishNode(node, update ? \\\"UpdateExpression\\\" : \\\"UnaryExpression\\\");\\r\\n          } else {\\r\\n            expr = this.parseExprSubscripts(refDestructuringErrors);\\r\\n            if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\\r\\n            while (this.type.postfix && !this.canInsertSemicolon()) {\\r\\n              var node$1 = this.startNodeAt(startPos, startLoc);\\r\\n              node$1.operator = this.value;\\r\\n              node$1.prefix = false;\\r\\n              node$1.argument = expr;\\r\\n              this.checkLVal(expr);\\r\\n              this.next();\\r\\n              expr = this.finishNode(node$1, \\\"UpdateExpression\\\");\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          if (!sawUnary && this.eat(types.starstar))\\r\\n            { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \\\"**\\\", false) }\\r\\n          else\\r\\n            { return expr }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseExprSubscripts = function(refDestructuringErrors) {\\r\\n          var startPos = this.start, startLoc = this.startLoc;\\r\\n          var expr = this.parseExprAtom(refDestructuringErrors);\\r\\n          if (expr.type === \\\"ArrowFunctionExpression\\\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \\\")\\\")\\r\\n            { return expr }\\r\\n          var result = this.parseSubscripts(expr, startPos, startLoc);\\r\\n          if (refDestructuringErrors && result.type === \\\"MemberExpression\\\") {\\r\\n            if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\\r\\n            if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\\r\\n          }\\r\\n          return result\\r\\n        };\\r\\n      \\r\\n        pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\\r\\n          var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \\\"Identifier\\\" && base.name === \\\"async\\\" &&\\r\\n              this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \\\"async\\\";\\r\\n          while (true) {\\r\\n            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\\r\\n            if (element === base || element.type === \\\"ArrowFunctionExpression\\\") { return element }\\r\\n            base = element;\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\\r\\n          var computed = this.eat(types.bracketL);\\r\\n          if (computed || this.eat(types.dot)) {\\r\\n            var node = this.startNodeAt(startPos, startLoc);\\r\\n            node.object = base;\\r\\n            node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \\\"never\\\");\\r\\n            node.computed = !!computed;\\r\\n            if (computed) { this.expect(types.bracketR); }\\r\\n            base = this.finishNode(node, \\\"MemberExpression\\\");\\r\\n          } else if (!noCalls && this.eat(types.parenL)) {\\r\\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\\r\\n            this.yieldPos = 0;\\r\\n            this.awaitPos = 0;\\r\\n            this.awaitIdentPos = 0;\\r\\n            var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\\r\\n            if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\\r\\n              this.checkPatternErrors(refDestructuringErrors, false);\\r\\n              this.checkYieldAwaitInDefaultParams();\\r\\n              if (this.awaitIdentPos > 0)\\r\\n                { this.raise(this.awaitIdentPos, \\\"Cannot use 'await' as identifier inside an async function\\\"); }\\r\\n              this.yieldPos = oldYieldPos;\\r\\n              this.awaitPos = oldAwaitPos;\\r\\n              this.awaitIdentPos = oldAwaitIdentPos;\\r\\n              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\\r\\n            }\\r\\n            this.checkExpressionErrors(refDestructuringErrors, true);\\r\\n            this.yieldPos = oldYieldPos || this.yieldPos;\\r\\n            this.awaitPos = oldAwaitPos || this.awaitPos;\\r\\n            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\\r\\n            var node$1 = this.startNodeAt(startPos, startLoc);\\r\\n            node$1.callee = base;\\r\\n            node$1.arguments = exprList;\\r\\n            base = this.finishNode(node$1, \\\"CallExpression\\\");\\r\\n          } else if (this.type === types.backQuote) {\\r\\n            var node$2 = this.startNodeAt(startPos, startLoc);\\r\\n            node$2.tag = base;\\r\\n            node$2.quasi = this.parseTemplate({isTagged: true});\\r\\n            base = this.finishNode(node$2, \\\"TaggedTemplateExpression\\\");\\r\\n          }\\r\\n          return base\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseExprAtom = function(refDestructuringErrors) {\\r\\n          if (this.type === types.slash) { this.readRegexp(); }\\r\\n      \\r\\n          var node, canBeArrow = this.potentialArrowAt === this.start;\\r\\n          switch (this.type) {\\r\\n          case types._super:\\r\\n            if (!this.allowSuper)\\r\\n              { this.raise(this.start, \\\"'super' keyword outside a method\\\"); }\\r\\n            node = this.startNode();\\r\\n            this.next();\\r\\n            if (this.type === types.parenL && !this.allowDirectSuper)\\r\\n              { this.raise(node.start, \\\"super() call outside constructor of a subclass\\\"); }\\r\\n            if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\\r\\n              { this.unexpected(); }\\r\\n            return this.finishNode(node, \\\"Super\\\")\\r\\n      \\r\\n          case types._this:\\r\\n            node = this.startNode();\\r\\n            this.next();\\r\\n            return this.finishNode(node, \\\"ThisExpression\\\")\\r\\n      \\r\\n          case types.name:\\r\\n            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\\r\\n            var id = this.parseIdent(false);\\r\\n            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \\\"async\\\" && !this.canInsertSemicolon() && this.eat(types._function))\\r\\n              { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\\r\\n            if (canBeArrow && !this.canInsertSemicolon()) {\\r\\n              if (this.eat(types.arrow))\\r\\n                { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\\r\\n              if (this.options.ecmaVersion >= 8 && id.name === \\\"async\\\" && this.type === types.name && !containsEsc) {\\r\\n                id = this.parseIdent(false);\\r\\n                if (this.canInsertSemicolon() || !this.eat(types.arrow))\\r\\n                  { this.unexpected(); }\\r\\n                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\\r\\n              }\\r\\n            }\\r\\n            return id\\r\\n      \\r\\n          case types.regexp:\\r\\n            var value = this.value;\\r\\n            node = this.parseLiteral(value.value);\\r\\n            node.regex = {pattern: value.pattern, flags: value.flags};\\r\\n            return node\\r\\n      \\r\\n          case types.num: case types.string:\\r\\n            return this.parseLiteral(this.value)\\r\\n      \\r\\n          case types._null: case types._true: case types._false:\\r\\n            node = this.startNode();\\r\\n            node.value = this.type === types._null ? null : this.type === types._true;\\r\\n            node.raw = this.type.keyword;\\r\\n            this.next();\\r\\n            return this.finishNode(node, \\\"Literal\\\")\\r\\n      \\r\\n          case types.parenL:\\r\\n            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\\r\\n            if (refDestructuringErrors) {\\r\\n              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\\r\\n                { refDestructuringErrors.parenthesizedAssign = start; }\\r\\n              if (refDestructuringErrors.parenthesizedBind < 0)\\r\\n                { refDestructuringErrors.parenthesizedBind = start; }\\r\\n            }\\r\\n            return expr\\r\\n      \\r\\n          case types.bracketL:\\r\\n            node = this.startNode();\\r\\n            this.next();\\r\\n            node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\\r\\n            return this.finishNode(node, \\\"ArrayExpression\\\")\\r\\n      \\r\\n          case types.braceL:\\r\\n            return this.parseObj(false, refDestructuringErrors)\\r\\n      \\r\\n          case types._function:\\r\\n            node = this.startNode();\\r\\n            this.next();\\r\\n            return this.parseFunction(node, 0)\\r\\n      \\r\\n          case types._class:\\r\\n            return this.parseClass(this.startNode(), false)\\r\\n      \\r\\n          case types._new:\\r\\n            return this.parseNew()\\r\\n      \\r\\n          case types.backQuote:\\r\\n            return this.parseTemplate()\\r\\n      \\r\\n          case types._import:\\r\\n            if (this.options.ecmaVersion >= 11) {\\r\\n              return this.parseExprImport()\\r\\n            } else {\\r\\n              return this.unexpected()\\r\\n            }\\r\\n      \\r\\n          default:\\r\\n            this.unexpected();\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$3.parseExprImport = function() {\\r\\n          var node = this.startNode();\\r\\n          this.next(); \\r\\n          switch (this.type) {\\r\\n          case types.parenL:\\r\\n            return this.parseDynamicImport(node)\\r\\n          default:\\r\\n            this.unexpected();\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$3.parseDynamicImport = function(node) {\\r\\n          this.next(); \\r\\n      \\r\\n          node.source = this.parseMaybeAssign();\\r\\n      \\r\\n          if (!this.eat(types.parenR)) {\\r\\n            var errorPos = this.start;\\r\\n            if (this.eat(types.comma) && this.eat(types.parenR)) {\\r\\n              this.raiseRecoverable(errorPos, \\\"Trailing comma is not allowed in import()\\\");\\r\\n            } else {\\r\\n              this.unexpected(errorPos);\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          return this.finishNode(node, \\\"ImportExpression\\\")\\r\\n        };\\r\\n      \\r\\n        pp$3.parseLiteral = function(value) {\\r\\n          var node = this.startNode();\\r\\n          node.value = value;\\r\\n          node.raw = this.input.slice(this.start, this.end);\\r\\n          if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\\r\\n          this.next();\\r\\n          return this.finishNode(node, \\\"Literal\\\")\\r\\n        };\\r\\n      \\r\\n        pp$3.parseParenExpression = function() {\\r\\n          this.expect(types.parenL);\\r\\n          var val = this.parseExpression();\\r\\n          this.expect(types.parenR);\\r\\n          return val\\r\\n        };\\r\\n      \\r\\n        pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\\r\\n          var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\\r\\n          if (this.options.ecmaVersion >= 6) {\\r\\n            this.next();\\r\\n      \\r\\n            var innerStartPos = this.start, innerStartLoc = this.startLoc;\\r\\n            var exprList = [], first = true, lastIsComma = false;\\r\\n            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\\r\\n            this.yieldPos = 0;\\r\\n            this.awaitPos = 0;\\r\\n            while (this.type !== types.parenR) {\\r\\n              first ? first = false : this.expect(types.comma);\\r\\n              if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\\r\\n                lastIsComma = true;\\r\\n                break\\r\\n              } else if (this.type === types.ellipsis) {\\r\\n                spreadStart = this.start;\\r\\n                exprList.push(this.parseParenItem(this.parseRestBinding()));\\r\\n                if (this.type === types.comma) { this.raise(this.start, \\\"Comma is not permitted after the rest element\\\"); }\\r\\n                break\\r\\n              } else {\\r\\n                exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\\r\\n              }\\r\\n            }\\r\\n            var innerEndPos = this.start, innerEndLoc = this.startLoc;\\r\\n            this.expect(types.parenR);\\r\\n      \\r\\n            if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\\r\\n              this.checkPatternErrors(refDestructuringErrors, false);\\r\\n              this.checkYieldAwaitInDefaultParams();\\r\\n              this.yieldPos = oldYieldPos;\\r\\n              this.awaitPos = oldAwaitPos;\\r\\n              return this.parseParenArrowList(startPos, startLoc, exprList)\\r\\n            }\\r\\n      \\r\\n            if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\\r\\n            if (spreadStart) { this.unexpected(spreadStart); }\\r\\n            this.checkExpressionErrors(refDestructuringErrors, true);\\r\\n            this.yieldPos = oldYieldPos || this.yieldPos;\\r\\n            this.awaitPos = oldAwaitPos || this.awaitPos;\\r\\n      \\r\\n            if (exprList.length > 1) {\\r\\n              val = this.startNodeAt(innerStartPos, innerStartLoc);\\r\\n              val.expressions = exprList;\\r\\n              this.finishNodeAt(val, \\\"SequenceExpression\\\", innerEndPos, innerEndLoc);\\r\\n            } else {\\r\\n              val = exprList[0];\\r\\n            }\\r\\n          } else {\\r\\n            val = this.parseParenExpression();\\r\\n          }\\r\\n      \\r\\n          if (this.options.preserveParens) {\\r\\n            var par = this.startNodeAt(startPos, startLoc);\\r\\n            par.expression = val;\\r\\n            return this.finishNode(par, \\\"ParenthesizedExpression\\\")\\r\\n          } else {\\r\\n            return val\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$3.parseParenItem = function(item) {\\r\\n          return item\\r\\n        };\\r\\n      \\r\\n        pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\\r\\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var empty$1 = [];\\r\\n      \\r\\n        pp$3.parseNew = function() {\\r\\n          if (this.containsEsc) { this.raiseRecoverable(this.start, \\\"Escape sequence in keyword new\\\"); }\\r\\n          var node = this.startNode();\\r\\n          var meta = this.parseIdent(true);\\r\\n          if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\\r\\n            node.meta = meta;\\r\\n            var containsEsc = this.containsEsc;\\r\\n            node.property = this.parseIdent(true);\\r\\n            if (node.property.name !== \\\"target\\\" || containsEsc)\\r\\n              { this.raiseRecoverable(node.property.start, \\\"The only valid meta property for new is new.target\\\"); }\\r\\n            if (!this.inNonArrowFunction())\\r\\n              { this.raiseRecoverable(node.start, \\\"new.target can only be used in functions\\\"); }\\r\\n            return this.finishNode(node, \\\"MetaProperty\\\")\\r\\n          }\\r\\n          var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;\\r\\n          node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\\r\\n          if (isImport && node.callee.type === \\\"ImportExpression\\\") {\\r\\n            this.raise(startPos, \\\"Cannot use new with import()\\\");\\r\\n          }\\r\\n          if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\\r\\n          else { node.arguments = empty$1; }\\r\\n          return this.finishNode(node, \\\"NewExpression\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseTemplateElement = function(ref) {\\r\\n          var isTagged = ref.isTagged;\\r\\n      \\r\\n          var elem = this.startNode();\\r\\n          if (this.type === types.invalidTemplate) {\\r\\n            if (!isTagged) {\\r\\n              this.raiseRecoverable(this.start, \\\"Bad escape sequence in untagged template literal\\\");\\r\\n            }\\r\\n            elem.value = {\\r\\n              raw: this.value,\\r\\n              cooked: null\\r\\n            };\\r\\n          } else {\\r\\n            elem.value = {\\r\\n              raw: this.input.slice(this.start, this.end).replace(/\\\\r\\\\n?/g, \\\"\\\\n\\\"),\\r\\n              cooked: this.value\\r\\n            };\\r\\n          }\\r\\n          this.next();\\r\\n          elem.tail = this.type === types.backQuote;\\r\\n          return this.finishNode(elem, \\\"TemplateElement\\\")\\r\\n        };\\r\\n      \\r\\n        pp$3.parseTemplate = function(ref) {\\r\\n          if ( ref === void 0 ) ref = {};\\r\\n          var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\\r\\n      \\r\\n          var node = this.startNode();\\r\\n          this.next();\\r\\n          node.expressions = [];\\r\\n          var curElt = this.parseTemplateElement({isTagged: isTagged});\\r\\n          node.quasis = [curElt];\\r\\n          while (!curElt.tail) {\\r\\n            if (this.type === types.eof) { this.raise(this.pos, \\\"Unterminated template literal\\\"); }\\r\\n            this.expect(types.dollarBraceL);\\r\\n            node.expressions.push(this.parseExpression());\\r\\n            this.expect(types.braceR);\\r\\n            node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\\r\\n          }\\r\\n          this.next();\\r\\n          return this.finishNode(node, \\\"TemplateLiteral\\\")\\r\\n        };\\r\\n      \\r\\n        pp$3.isAsyncProp = function(prop) {\\r\\n          return !prop.computed && prop.key.type === \\\"Identifier\\\" && prop.key.name === \\\"async\\\" &&\\r\\n            (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\\r\\n            !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseObj = function(isPattern, refDestructuringErrors) {\\r\\n          var node = this.startNode(), first = true, propHash = {};\\r\\n          node.properties = [];\\r\\n          this.next();\\r\\n          while (!this.eat(types.braceR)) {\\r\\n            if (!first) {\\r\\n              this.expect(types.comma);\\r\\n              if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }\\r\\n            } else { first = false; }\\r\\n      \\r\\n            var prop = this.parseProperty(isPattern, refDestructuringErrors);\\r\\n            if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\\r\\n            node.properties.push(prop);\\r\\n          }\\r\\n          return this.finishNode(node, isPattern ? \\\"ObjectPattern\\\" : \\\"ObjectExpression\\\")\\r\\n        };\\r\\n      \\r\\n        pp$3.parseProperty = function(isPattern, refDestructuringErrors) {\\r\\n          var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\\r\\n          if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\\r\\n            if (isPattern) {\\r\\n              prop.argument = this.parseIdent(false);\\r\\n              if (this.type === types.comma) {\\r\\n                this.raise(this.start, \\\"Comma is not permitted after the rest element\\\");\\r\\n              }\\r\\n              return this.finishNode(prop, \\\"RestElement\\\")\\r\\n            }\\r\\n            if (this.type === types.parenL && refDestructuringErrors) {\\r\\n              if (refDestructuringErrors.parenthesizedAssign < 0) {\\r\\n                refDestructuringErrors.parenthesizedAssign = this.start;\\r\\n              }\\r\\n              if (refDestructuringErrors.parenthesizedBind < 0) {\\r\\n                refDestructuringErrors.parenthesizedBind = this.start;\\r\\n              }\\r\\n            }\\r\\n            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\\r\\n            if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\\r\\n              refDestructuringErrors.trailingComma = this.start;\\r\\n            }\\r\\n            return this.finishNode(prop, \\\"SpreadElement\\\")\\r\\n          }\\r\\n          if (this.options.ecmaVersion >= 6) {\\r\\n            prop.method = false;\\r\\n            prop.shorthand = false;\\r\\n            if (isPattern || refDestructuringErrors) {\\r\\n              startPos = this.start;\\r\\n              startLoc = this.startLoc;\\r\\n            }\\r\\n            if (!isPattern)\\r\\n              { isGenerator = this.eat(types.star); }\\r\\n          }\\r\\n          var containsEsc = this.containsEsc;\\r\\n          this.parsePropertyName(prop);\\r\\n          if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\\r\\n            isAsync = true;\\r\\n            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\\r\\n            this.parsePropertyName(prop, refDestructuringErrors);\\r\\n          } else {\\r\\n            isAsync = false;\\r\\n          }\\r\\n          this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\\r\\n          return this.finishNode(prop, \\\"Property\\\")\\r\\n        };\\r\\n      \\r\\n        pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\\r\\n          if ((isGenerator || isAsync) && this.type === types.colon)\\r\\n            { this.unexpected(); }\\r\\n      \\r\\n          if (this.eat(types.colon)) {\\r\\n            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\\r\\n            prop.kind = \\\"init\\\";\\r\\n          } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\\r\\n            if (isPattern) { this.unexpected(); }\\r\\n            prop.kind = \\\"init\\\";\\r\\n            prop.method = true;\\r\\n            prop.value = this.parseMethod(isGenerator, isAsync);\\r\\n          } else if (!isPattern && !containsEsc &&\\r\\n                     this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \\\"Identifier\\\" &&\\r\\n                     (prop.key.name === \\\"get\\\" || prop.key.name === \\\"set\\\") &&\\r\\n                     (this.type !== types.comma && this.type !== types.braceR)) {\\r\\n            if (isGenerator || isAsync) { this.unexpected(); }\\r\\n            prop.kind = prop.key.name;\\r\\n            this.parsePropertyName(prop);\\r\\n            prop.value = this.parseMethod(false);\\r\\n            var paramCount = prop.kind === \\\"get\\\" ? 0 : 1;\\r\\n            if (prop.value.params.length !== paramCount) {\\r\\n              var start = prop.value.start;\\r\\n              if (prop.kind === \\\"get\\\")\\r\\n                { this.raiseRecoverable(start, \\\"getter should have no params\\\"); }\\r\\n              else\\r\\n                { this.raiseRecoverable(start, \\\"setter should have exactly one param\\\"); }\\r\\n            } else {\\r\\n              if (prop.kind === \\\"set\\\" && prop.value.params[0].type === \\\"RestElement\\\")\\r\\n                { this.raiseRecoverable(prop.value.params[0].start, \\\"Setter cannot use rest params\\\"); }\\r\\n            }\\r\\n          } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \\\"Identifier\\\") {\\r\\n            if (isGenerator || isAsync) { this.unexpected(); }\\r\\n            this.checkUnreserved(prop.key);\\r\\n            if (prop.key.name === \\\"await\\\" && !this.awaitIdentPos)\\r\\n              { this.awaitIdentPos = startPos; }\\r\\n            prop.kind = \\\"init\\\";\\r\\n            if (isPattern) {\\r\\n              prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\\r\\n            } else if (this.type === types.eq && refDestructuringErrors) {\\r\\n              if (refDestructuringErrors.shorthandAssign < 0)\\r\\n                { refDestructuringErrors.shorthandAssign = this.start; }\\r\\n              prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\\r\\n            } else {\\r\\n              prop.value = prop.key;\\r\\n            }\\r\\n            prop.shorthand = true;\\r\\n          } else { this.unexpected(); }\\r\\n        };\\r\\n      \\r\\n        pp$3.parsePropertyName = function(prop) {\\r\\n          if (this.options.ecmaVersion >= 6) {\\r\\n            if (this.eat(types.bracketL)) {\\r\\n              prop.computed = true;\\r\\n              prop.key = this.parseMaybeAssign();\\r\\n              this.expect(types.bracketR);\\r\\n              return prop.key\\r\\n            } else {\\r\\n              prop.computed = false;\\r\\n            }\\r\\n          }\\r\\n          return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \\\"never\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.initFunction = function(node) {\\r\\n          node.id = null;\\r\\n          if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\\r\\n          if (this.options.ecmaVersion >= 8) { node.async = false; }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\\r\\n          var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\\r\\n      \\r\\n          this.initFunction(node);\\r\\n          if (this.options.ecmaVersion >= 6)\\r\\n            { node.generator = isGenerator; }\\r\\n          if (this.options.ecmaVersion >= 8)\\r\\n            { node.async = !!isAsync; }\\r\\n      \\r\\n          this.yieldPos = 0;\\r\\n          this.awaitPos = 0;\\r\\n          this.awaitIdentPos = 0;\\r\\n          this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\\r\\n      \\r\\n          this.expect(types.parenL);\\r\\n          node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\\r\\n          this.checkYieldAwaitInDefaultParams();\\r\\n          this.parseFunctionBody(node, false, true);\\r\\n      \\r\\n          this.yieldPos = oldYieldPos;\\r\\n          this.awaitPos = oldAwaitPos;\\r\\n          this.awaitIdentPos = oldAwaitIdentPos;\\r\\n          return this.finishNode(node, \\\"FunctionExpression\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseArrowExpression = function(node, params, isAsync) {\\r\\n          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\\r\\n      \\r\\n          this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\\r\\n          this.initFunction(node);\\r\\n          if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\\r\\n      \\r\\n          this.yieldPos = 0;\\r\\n          this.awaitPos = 0;\\r\\n          this.awaitIdentPos = 0;\\r\\n      \\r\\n          node.params = this.toAssignableList(params, true);\\r\\n          this.parseFunctionBody(node, true, false);\\r\\n      \\r\\n          this.yieldPos = oldYieldPos;\\r\\n          this.awaitPos = oldAwaitPos;\\r\\n          this.awaitIdentPos = oldAwaitIdentPos;\\r\\n          return this.finishNode(node, \\\"ArrowFunctionExpression\\\")\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\\r\\n          var isExpression = isArrowFunction && this.type !== types.braceL;\\r\\n          var oldStrict = this.strict, useStrict = false;\\r\\n      \\r\\n          if (isExpression) {\\r\\n            node.body = this.parseMaybeAssign();\\r\\n            node.expression = true;\\r\\n            this.checkParams(node, false);\\r\\n          } else {\\r\\n            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\\r\\n            if (!oldStrict || nonSimple) {\\r\\n              useStrict = this.strictDirective(this.end);\\r\\n              if (useStrict && nonSimple)\\r\\n                { this.raiseRecoverable(node.start, \\\"Illegal 'use strict' directive in function with non-simple parameter list\\\"); }\\r\\n            }\\r\\n            var oldLabels = this.labels;\\r\\n            this.labels = [];\\r\\n            if (useStrict) { this.strict = true; }\\r\\n      \\r\\n            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\\r\\n            node.body = this.parseBlock(false);\\r\\n            node.expression = false;\\r\\n            this.adaptDirectivePrologue(node.body.body);\\r\\n            this.labels = oldLabels;\\r\\n          }\\r\\n          this.exitScope();\\r\\n      \\r\\n          if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\\r\\n          this.strict = oldStrict;\\r\\n        };\\r\\n      \\r\\n        pp$3.isSimpleParamList = function(params) {\\r\\n          for (var i = 0, list = params; i < list.length; i += 1)\\r\\n            {\\r\\n            var param = list[i];\\r\\n      \\r\\n            if (param.type !== \\\"Identifier\\\") { return false\\r\\n          } }\\r\\n          return true\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.checkParams = function(node, allowDuplicates) {\\r\\n          var nameHash = {};\\r\\n          for (var i = 0, list = node.params; i < list.length; i += 1)\\r\\n            {\\r\\n            var param = list[i];\\r\\n      \\r\\n            this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\\r\\n          }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\\r\\n          var elts = [], first = true;\\r\\n          while (!this.eat(close)) {\\r\\n            if (!first) {\\r\\n              this.expect(types.comma);\\r\\n              if (allowTrailingComma && this.afterTrailingComma(close)) { break }\\r\\n            } else { first = false; }\\r\\n      \\r\\n            var elt = (void 0);\\r\\n            if (allowEmpty && this.type === types.comma)\\r\\n              { elt = null; }\\r\\n            else if (this.type === types.ellipsis) {\\r\\n              elt = this.parseSpread(refDestructuringErrors);\\r\\n              if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\\r\\n                { refDestructuringErrors.trailingComma = this.start; }\\r\\n            } else {\\r\\n              elt = this.parseMaybeAssign(false, refDestructuringErrors);\\r\\n            }\\r\\n            elts.push(elt);\\r\\n          }\\r\\n          return elts\\r\\n        };\\r\\n      \\r\\n        pp$3.checkUnreserved = function(ref) {\\r\\n          var start = ref.start;\\r\\n          var end = ref.end;\\r\\n          var name = ref.name;\\r\\n      \\r\\n          if (this.inGenerator && name === \\\"yield\\\")\\r\\n            { this.raiseRecoverable(start, \\\"Cannot use 'yield' as identifier inside a generator\\\"); }\\r\\n          if (this.inAsync && name === \\\"await\\\")\\r\\n            { this.raiseRecoverable(start, \\\"Cannot use 'await' as identifier inside an async function\\\"); }\\r\\n          if (this.keywords.test(name))\\r\\n            { this.raise(start, (\\\"Unexpected keyword '\\\" + name + \\\"'\\\")); }\\r\\n          if (this.options.ecmaVersion < 6 &&\\r\\n            this.input.slice(start, end).indexOf(\\\"\\\\\\\\\\\") !== -1) { return }\\r\\n          var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\\r\\n          if (re.test(name)) {\\r\\n            if (!this.inAsync && name === \\\"await\\\")\\r\\n              { this.raiseRecoverable(start, \\\"Cannot use keyword 'await' outside an async function\\\"); }\\r\\n            this.raiseRecoverable(start, (\\\"The keyword '\\\" + name + \\\"' is reserved\\\"));\\r\\n          }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseIdent = function(liberal, isBinding) {\\r\\n          var node = this.startNode();\\r\\n          if (this.type === types.name) {\\r\\n            node.name = this.value;\\r\\n          } else if (this.type.keyword) {\\r\\n            node.name = this.type.keyword;\\r\\n      \\r\\n            if ((node.name === \\\"class\\\" || node.name === \\\"function\\\") &&\\r\\n                (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\\r\\n              this.context.pop();\\r\\n            }\\r\\n          } else {\\r\\n            this.unexpected();\\r\\n          }\\r\\n          this.next(!!liberal);\\r\\n          this.finishNode(node, \\\"Identifier\\\");\\r\\n          if (!liberal) {\\r\\n            this.checkUnreserved(node);\\r\\n            if (node.name === \\\"await\\\" && !this.awaitIdentPos)\\r\\n              { this.awaitIdentPos = node.start; }\\r\\n          }\\r\\n          return node\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$3.parseYield = function(noIn) {\\r\\n          if (!this.yieldPos) { this.yieldPos = this.start; }\\r\\n      \\r\\n          var node = this.startNode();\\r\\n          this.next();\\r\\n          if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\\r\\n            node.delegate = false;\\r\\n            node.argument = null;\\r\\n          } else {\\r\\n            node.delegate = this.eat(types.star);\\r\\n            node.argument = this.parseMaybeAssign(noIn);\\r\\n          }\\r\\n          return this.finishNode(node, \\\"YieldExpression\\\")\\r\\n        };\\r\\n      \\r\\n        pp$3.parseAwait = function() {\\r\\n          if (!this.awaitPos) { this.awaitPos = this.start; }\\r\\n      \\r\\n          var node = this.startNode();\\r\\n          this.next();\\r\\n          node.argument = this.parseMaybeUnary(null, false);\\r\\n          return this.finishNode(node, \\\"AwaitExpression\\\")\\r\\n        };\\r\\n      \\r\\n        var pp$4 = Parser.prototype;\\r\\n      \\r\\n      \\r\\n        pp$4.raise = function(pos, message) {\\r\\n          var loc = getLineInfo(this.input, pos);\\r\\n          message += \\\" (\\\" + loc.line + \\\":\\\" + loc.column + \\\")\\\";\\r\\n          var err = new SyntaxError(message);\\r\\n          err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\\r\\n          throw err\\r\\n        };\\r\\n      \\r\\n        pp$4.raiseRecoverable = pp$4.raise;\\r\\n      \\r\\n        pp$4.curPosition = function() {\\r\\n          if (this.options.locations) {\\r\\n            return new Position(this.curLine, this.pos - this.lineStart)\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        var pp$5 = Parser.prototype;\\r\\n      \\r\\n        var Scope = function Scope(flags) {\\r\\n          this.flags = flags;\\r\\n          this.var = [];\\r\\n          this.lexical = [];\\r\\n          this.functions = [];\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$5.enterScope = function(flags) {\\r\\n          this.scopeStack.push(new Scope(flags));\\r\\n        };\\r\\n      \\r\\n        pp$5.exitScope = function() {\\r\\n          this.scopeStack.pop();\\r\\n        };\\r\\n      \\r\\n        pp$5.treatFunctionsAsVarInScope = function(scope) {\\r\\n          return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\\r\\n        };\\r\\n      \\r\\n        pp$5.declareName = function(name, bindingType, pos) {\\r\\n          var redeclared = false;\\r\\n          if (bindingType === BIND_LEXICAL) {\\r\\n            var scope = this.currentScope();\\r\\n            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\\r\\n            scope.lexical.push(name);\\r\\n            if (this.inModule && (scope.flags & SCOPE_TOP))\\r\\n              { delete this.undefinedExports[name]; }\\r\\n          } else if (bindingType === BIND_SIMPLE_CATCH) {\\r\\n            var scope$1 = this.currentScope();\\r\\n            scope$1.lexical.push(name);\\r\\n          } else if (bindingType === BIND_FUNCTION) {\\r\\n            var scope$2 = this.currentScope();\\r\\n            if (this.treatFunctionsAsVar)\\r\\n              { redeclared = scope$2.lexical.indexOf(name) > -1; }\\r\\n            else\\r\\n              { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\\r\\n            scope$2.functions.push(name);\\r\\n          } else {\\r\\n            for (var i = this.scopeStack.length - 1; i >= 0; --i) {\\r\\n              var scope$3 = this.scopeStack[i];\\r\\n              if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\\r\\n                  !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\\r\\n                redeclared = true;\\r\\n                break\\r\\n              }\\r\\n              scope$3.var.push(name);\\r\\n              if (this.inModule && (scope$3.flags & SCOPE_TOP))\\r\\n                { delete this.undefinedExports[name]; }\\r\\n              if (scope$3.flags & SCOPE_VAR) { break }\\r\\n            }\\r\\n          }\\r\\n          if (redeclared) { this.raiseRecoverable(pos, (\\\"Identifier '\\\" + name + \\\"' has already been declared\\\")); }\\r\\n        };\\r\\n      \\r\\n        pp$5.checkLocalExport = function(id) {\\r\\n          if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\\r\\n              this.scopeStack[0].var.indexOf(id.name) === -1) {\\r\\n            this.undefinedExports[id.name] = id;\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$5.currentScope = function() {\\r\\n          return this.scopeStack[this.scopeStack.length - 1]\\r\\n        };\\r\\n      \\r\\n        pp$5.currentVarScope = function() {\\r\\n          for (var i = this.scopeStack.length - 1;; i--) {\\r\\n            var scope = this.scopeStack[i];\\r\\n            if (scope.flags & SCOPE_VAR) { return scope }\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$5.currentThisScope = function() {\\r\\n          for (var i = this.scopeStack.length - 1;; i--) {\\r\\n            var scope = this.scopeStack[i];\\r\\n            if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        var Node = function Node(parser, pos, loc) {\\r\\n          this.type = \\\"\\\";\\r\\n          this.start = pos;\\r\\n          this.end = 0;\\r\\n          if (parser.options.locations)\\r\\n            { this.loc = new SourceLocation(parser, loc); }\\r\\n          if (parser.options.directSourceFile)\\r\\n            { this.sourceFile = parser.options.directSourceFile; }\\r\\n          if (parser.options.ranges)\\r\\n            { this.range = [pos, 0]; }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var pp$6 = Parser.prototype;\\r\\n      \\r\\n        pp$6.startNode = function() {\\r\\n          return new Node(this, this.start, this.startLoc)\\r\\n        };\\r\\n      \\r\\n        pp$6.startNodeAt = function(pos, loc) {\\r\\n          return new Node(this, pos, loc)\\r\\n        };\\r\\n      \\r\\n      \\r\\n        function finishNodeAt(node, type, pos, loc) {\\r\\n          node.type = type;\\r\\n          node.end = pos;\\r\\n          if (this.options.locations)\\r\\n            { node.loc.end = loc; }\\r\\n          if (this.options.ranges)\\r\\n            { node.range[1] = pos; }\\r\\n          return node\\r\\n        }\\r\\n      \\r\\n        pp$6.finishNode = function(node, type) {\\r\\n          return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$6.finishNodeAt = function(node, type, pos, loc) {\\r\\n          return finishNodeAt.call(this, node, type, pos, loc)\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\\r\\n          this.token = token;\\r\\n          this.isExpr = !!isExpr;\\r\\n          this.preserveSpace = !!preserveSpace;\\r\\n          this.override = override;\\r\\n          this.generator = !!generator;\\r\\n        };\\r\\n      \\r\\n        var types$1 = {\\r\\n          b_stat: new TokContext(\\\"{\\\", false),\\r\\n          b_expr: new TokContext(\\\"{\\\", true),\\r\\n          b_tmpl: new TokContext(\\\"${\\\", false),\\r\\n          p_stat: new TokContext(\\\"(\\\", false),\\r\\n          p_expr: new TokContext(\\\"(\\\", true),\\r\\n          q_tmpl: new TokContext(\\\"`\\\", true, true, function (p) { return p.tryReadTemplateToken(); }),\\r\\n          f_stat: new TokContext(\\\"function\\\", false),\\r\\n          f_expr: new TokContext(\\\"function\\\", true),\\r\\n          f_expr_gen: new TokContext(\\\"function\\\", true, false, null, true),\\r\\n          f_gen: new TokContext(\\\"function\\\", false, false, null, true)\\r\\n        };\\r\\n      \\r\\n        var pp$7 = Parser.prototype;\\r\\n      \\r\\n        pp$7.initialContext = function() {\\r\\n          return [types$1.b_stat]\\r\\n        };\\r\\n      \\r\\n        pp$7.braceIsBlock = function(prevType) {\\r\\n          var parent = this.curContext();\\r\\n          if (parent === types$1.f_expr || parent === types$1.f_stat)\\r\\n            { return true }\\r\\n          if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\\r\\n            { return !parent.isExpr }\\r\\n      \\r\\n          if (prevType === types._return || prevType === types.name && this.exprAllowed)\\r\\n            { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\\r\\n          if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\\r\\n            { return true }\\r\\n          if (prevType === types.braceL)\\r\\n            { return parent === types$1.b_stat }\\r\\n          if (prevType === types._var || prevType === types._const || prevType === types.name)\\r\\n            { return false }\\r\\n          return !this.exprAllowed\\r\\n        };\\r\\n      \\r\\n        pp$7.inGeneratorContext = function() {\\r\\n          for (var i = this.context.length - 1; i >= 1; i--) {\\r\\n            var context = this.context[i];\\r\\n            if (context.token === \\\"function\\\")\\r\\n              { return context.generator }\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$7.updateContext = function(prevType) {\\r\\n          var update, type = this.type;\\r\\n          if (type.keyword && prevType === types.dot)\\r\\n            { this.exprAllowed = false; }\\r\\n          else if (update = type.updateContext)\\r\\n            { update.call(this, prevType); }\\r\\n          else\\r\\n            { this.exprAllowed = type.beforeExpr; }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        types.parenR.updateContext = types.braceR.updateContext = function() {\\r\\n          if (this.context.length === 1) {\\r\\n            this.exprAllowed = true;\\r\\n            return\\r\\n          }\\r\\n          var out = this.context.pop();\\r\\n          if (out === types$1.b_stat && this.curContext().token === \\\"function\\\") {\\r\\n            out = this.context.pop();\\r\\n          }\\r\\n          this.exprAllowed = !out.isExpr;\\r\\n        };\\r\\n      \\r\\n        types.braceL.updateContext = function(prevType) {\\r\\n          this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\\r\\n          this.exprAllowed = true;\\r\\n        };\\r\\n      \\r\\n        types.dollarBraceL.updateContext = function() {\\r\\n          this.context.push(types$1.b_tmpl);\\r\\n          this.exprAllowed = true;\\r\\n        };\\r\\n      \\r\\n        types.parenL.updateContext = function(prevType) {\\r\\n          var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\\r\\n          this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\\r\\n          this.exprAllowed = true;\\r\\n        };\\r\\n      \\r\\n        types.incDec.updateContext = function() {\\r\\n        };\\r\\n      \\r\\n        types._function.updateContext = types._class.updateContext = function(prevType) {\\r\\n          if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\\r\\n              !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\\r\\n              !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\\r\\n            { this.context.push(types$1.f_expr); }\\r\\n          else\\r\\n            { this.context.push(types$1.f_stat); }\\r\\n          this.exprAllowed = false;\\r\\n        };\\r\\n      \\r\\n        types.backQuote.updateContext = function() {\\r\\n          if (this.curContext() === types$1.q_tmpl)\\r\\n            { this.context.pop(); }\\r\\n          else\\r\\n            { this.context.push(types$1.q_tmpl); }\\r\\n          this.exprAllowed = false;\\r\\n        };\\r\\n      \\r\\n        types.star.updateContext = function(prevType) {\\r\\n          if (prevType === types._function) {\\r\\n            var index = this.context.length - 1;\\r\\n            if (this.context[index] === types$1.f_expr)\\r\\n              { this.context[index] = types$1.f_expr_gen; }\\r\\n            else\\r\\n              { this.context[index] = types$1.f_gen; }\\r\\n          }\\r\\n          this.exprAllowed = true;\\r\\n        };\\r\\n      \\r\\n        types.name.updateContext = function(prevType) {\\r\\n          var allowed = false;\\r\\n          if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\\r\\n            if (this.value === \\\"of\\\" && !this.exprAllowed ||\\r\\n                this.value === \\\"yield\\\" && this.inGeneratorContext())\\r\\n              { allowed = true; }\\r\\n          }\\r\\n          this.exprAllowed = allowed;\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var ecma9BinaryProperties = \\\"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\\\";\\r\\n        var ecma10BinaryProperties = ecma9BinaryProperties + \\\" Extended_Pictographic\\\";\\r\\n        var ecma11BinaryProperties = ecma10BinaryProperties;\\r\\n        var unicodeBinaryProperties = {\\r\\n          9: ecma9BinaryProperties,\\r\\n          10: ecma10BinaryProperties,\\r\\n          11: ecma11BinaryProperties\\r\\n        };\\r\\n      \\r\\n        var unicodeGeneralCategoryValues = \\\"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\\\";\\r\\n      \\r\\n        var ecma9ScriptValues = \\\"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\\\";\\r\\n        var ecma10ScriptValues = ecma9ScriptValues + \\\" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\\\";\\r\\n        var ecma11ScriptValues = ecma10ScriptValues + \\\" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\\\";\\r\\n        var unicodeScriptValues = {\\r\\n          9: ecma9ScriptValues,\\r\\n          10: ecma10ScriptValues,\\r\\n          11: ecma11ScriptValues\\r\\n        };\\r\\n      \\r\\n        var data = {};\\r\\n        function buildUnicodeData(ecmaVersion) {\\r\\n          var d = data[ecmaVersion] = {\\r\\n            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \\\" \\\" + unicodeGeneralCategoryValues),\\r\\n            nonBinary: {\\r\\n              General_Category: wordsRegexp(unicodeGeneralCategoryValues),\\r\\n              Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\\r\\n            }\\r\\n          };\\r\\n          d.nonBinary.Script_Extensions = d.nonBinary.Script;\\r\\n      \\r\\n          d.nonBinary.gc = d.nonBinary.General_Category;\\r\\n          d.nonBinary.sc = d.nonBinary.Script;\\r\\n          d.nonBinary.scx = d.nonBinary.Script_Extensions;\\r\\n        }\\r\\n        buildUnicodeData(9);\\r\\n        buildUnicodeData(10);\\r\\n        buildUnicodeData(11);\\r\\n      \\r\\n        var pp$8 = Parser.prototype;\\r\\n      \\r\\n        var RegExpValidationState = function RegExpValidationState(parser) {\\r\\n          this.parser = parser;\\r\\n          this.validFlags = \\\"gim\\\" + (parser.options.ecmaVersion >= 6 ? \\\"uy\\\" : \\\"\\\") + (parser.options.ecmaVersion >= 9 ? \\\"s\\\" : \\\"\\\");\\r\\n          this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\\r\\n          this.source = \\\"\\\";\\r\\n          this.flags = \\\"\\\";\\r\\n          this.start = 0;\\r\\n          this.switchU = false;\\r\\n          this.switchN = false;\\r\\n          this.pos = 0;\\r\\n          this.lastIntValue = 0;\\r\\n          this.lastStringValue = \\\"\\\";\\r\\n          this.lastAssertionIsQuantifiable = false;\\r\\n          this.numCapturingParens = 0;\\r\\n          this.maxBackReference = 0;\\r\\n          this.groupNames = [];\\r\\n          this.backReferenceNames = [];\\r\\n        };\\r\\n      \\r\\n        RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\\r\\n          var unicode = flags.indexOf(\\\"u\\\") !== -1;\\r\\n          this.start = start | 0;\\r\\n          this.source = pattern + \\\"\\\";\\r\\n          this.flags = flags;\\r\\n          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\\r\\n          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\\r\\n        };\\r\\n      \\r\\n        RegExpValidationState.prototype.raise = function raise (message) {\\r\\n          this.parser.raiseRecoverable(this.start, (\\\"Invalid regular expression: /\\\" + (this.source) + \\\"/: \\\" + message));\\r\\n        };\\r\\n      \\r\\n        RegExpValidationState.prototype.at = function at (i) {\\r\\n          var s = this.source;\\r\\n          var l = s.length;\\r\\n          if (i >= l) {\\r\\n            return -1\\r\\n          }\\r\\n          var c = s.charCodeAt(i);\\r\\n          if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\\r\\n            return c\\r\\n          }\\r\\n          var next = s.charCodeAt(i + 1);\\r\\n          return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\\r\\n        };\\r\\n      \\r\\n        RegExpValidationState.prototype.nextIndex = function nextIndex (i) {\\r\\n          var s = this.source;\\r\\n          var l = s.length;\\r\\n          if (i >= l) {\\r\\n            return l\\r\\n          }\\r\\n          var c = s.charCodeAt(i), next;\\r\\n          if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\\r\\n              (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\\r\\n            return i + 1\\r\\n          }\\r\\n          return i + 2\\r\\n        };\\r\\n      \\r\\n        RegExpValidationState.prototype.current = function current () {\\r\\n          return this.at(this.pos)\\r\\n        };\\r\\n      \\r\\n        RegExpValidationState.prototype.lookahead = function lookahead () {\\r\\n          return this.at(this.nextIndex(this.pos))\\r\\n        };\\r\\n      \\r\\n        RegExpValidationState.prototype.advance = function advance () {\\r\\n          this.pos = this.nextIndex(this.pos);\\r\\n        };\\r\\n      \\r\\n        RegExpValidationState.prototype.eat = function eat (ch) {\\r\\n          if (this.current() === ch) {\\r\\n            this.advance();\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        function codePointToString(ch) {\\r\\n          if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\\r\\n          ch -= 0x10000;\\r\\n          return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\\r\\n        }\\r\\n      \\r\\n        pp$8.validateRegExpFlags = function(state) {\\r\\n          var validFlags = state.validFlags;\\r\\n          var flags = state.flags;\\r\\n      \\r\\n          for (var i = 0; i < flags.length; i++) {\\r\\n            var flag = flags.charAt(i);\\r\\n            if (validFlags.indexOf(flag) === -1) {\\r\\n              this.raise(state.start, \\\"Invalid regular expression flag\\\");\\r\\n            }\\r\\n            if (flags.indexOf(flag, i + 1) > -1) {\\r\\n              this.raise(state.start, \\\"Duplicate regular expression flag\\\");\\r\\n            }\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$8.validateRegExpPattern = function(state) {\\r\\n          this.regexp_pattern(state);\\r\\n      \\r\\n          if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\\r\\n            state.switchN = true;\\r\\n            this.regexp_pattern(state);\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_pattern = function(state) {\\r\\n          state.pos = 0;\\r\\n          state.lastIntValue = 0;\\r\\n          state.lastStringValue = \\\"\\\";\\r\\n          state.lastAssertionIsQuantifiable = false;\\r\\n          state.numCapturingParens = 0;\\r\\n          state.maxBackReference = 0;\\r\\n          state.groupNames.length = 0;\\r\\n          state.backReferenceNames.length = 0;\\r\\n      \\r\\n          this.regexp_disjunction(state);\\r\\n      \\r\\n          if (state.pos !== state.source.length) {\\r\\n            if (state.eat(0x29 )) {\\r\\n              state.raise(\\\"Unmatched ')'\\\");\\r\\n            }\\r\\n            if (state.eat(0x5D ) || state.eat(0x7D )) {\\r\\n              state.raise(\\\"Lone quantifier brackets\\\");\\r\\n            }\\r\\n          }\\r\\n          if (state.maxBackReference > state.numCapturingParens) {\\r\\n            state.raise(\\\"Invalid escape\\\");\\r\\n          }\\r\\n          for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\\r\\n            var name = list[i];\\r\\n      \\r\\n            if (state.groupNames.indexOf(name) === -1) {\\r\\n              state.raise(\\\"Invalid named capture referenced\\\");\\r\\n            }\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_disjunction = function(state) {\\r\\n          this.regexp_alternative(state);\\r\\n          while (state.eat(0x7C )) {\\r\\n            this.regexp_alternative(state);\\r\\n          }\\r\\n      \\r\\n          if (this.regexp_eatQuantifier(state, true)) {\\r\\n            state.raise(\\\"Nothing to repeat\\\");\\r\\n          }\\r\\n          if (state.eat(0x7B )) {\\r\\n            state.raise(\\\"Lone quantifier brackets\\\");\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_alternative = function(state) {\\r\\n          while (state.pos < state.source.length && this.regexp_eatTerm(state))\\r\\n            { }\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatTerm = function(state) {\\r\\n          if (this.regexp_eatAssertion(state)) {\\r\\n            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\\r\\n              if (state.switchU) {\\r\\n                state.raise(\\\"Invalid quantifier\\\");\\r\\n              }\\r\\n            }\\r\\n            return true\\r\\n          }\\r\\n      \\r\\n          if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\\r\\n            this.regexp_eatQuantifier(state);\\r\\n            return true\\r\\n          }\\r\\n      \\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatAssertion = function(state) {\\r\\n          var start = state.pos;\\r\\n          state.lastAssertionIsQuantifiable = false;\\r\\n      \\r\\n          if (state.eat(0x5E ) || state.eat(0x24 )) {\\r\\n            return true\\r\\n          }\\r\\n      \\r\\n          if (state.eat(0x5C )) {\\r\\n            if (state.eat(0x42 ) || state.eat(0x62 )) {\\r\\n              return true\\r\\n            }\\r\\n            state.pos = start;\\r\\n          }\\r\\n      \\r\\n          if (state.eat(0x28 ) && state.eat(0x3F )) {\\r\\n            var lookbehind = false;\\r\\n            if (this.options.ecmaVersion >= 9) {\\r\\n              lookbehind = state.eat(0x3C );\\r\\n            }\\r\\n            if (state.eat(0x3D ) || state.eat(0x21 )) {\\r\\n              this.regexp_disjunction(state);\\r\\n              if (!state.eat(0x29 )) {\\r\\n                state.raise(\\\"Unterminated group\\\");\\r\\n              }\\r\\n              state.lastAssertionIsQuantifiable = !lookbehind;\\r\\n              return true\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          state.pos = start;\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatQuantifier = function(state, noError) {\\r\\n          if ( noError === void 0 ) noError = false;\\r\\n      \\r\\n          if (this.regexp_eatQuantifierPrefix(state, noError)) {\\r\\n            state.eat(0x3F );\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatQuantifierPrefix = function(state, noError) {\\r\\n          return (\\r\\n            state.eat(0x2A ) ||\\r\\n            state.eat(0x2B ) ||\\r\\n            state.eat(0x3F ) ||\\r\\n            this.regexp_eatBracedQuantifier(state, noError)\\r\\n          )\\r\\n        };\\r\\n        pp$8.regexp_eatBracedQuantifier = function(state, noError) {\\r\\n          var start = state.pos;\\r\\n          if (state.eat(0x7B )) {\\r\\n            var min = 0, max = -1;\\r\\n            if (this.regexp_eatDecimalDigits(state)) {\\r\\n              min = state.lastIntValue;\\r\\n              if (state.eat(0x2C ) && this.regexp_eatDecimalDigits(state)) {\\r\\n                max = state.lastIntValue;\\r\\n              }\\r\\n              if (state.eat(0x7D )) {\\r\\n                if (max !== -1 && max < min && !noError) {\\r\\n                  state.raise(\\\"numbers out of order in {} quantifier\\\");\\r\\n                }\\r\\n                return true\\r\\n              }\\r\\n            }\\r\\n            if (state.switchU && !noError) {\\r\\n              state.raise(\\\"Incomplete quantifier\\\");\\r\\n            }\\r\\n            state.pos = start;\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatAtom = function(state) {\\r\\n          return (\\r\\n            this.regexp_eatPatternCharacters(state) ||\\r\\n            state.eat(0x2E ) ||\\r\\n            this.regexp_eatReverseSolidusAtomEscape(state) ||\\r\\n            this.regexp_eatCharacterClass(state) ||\\r\\n            this.regexp_eatUncapturingGroup(state) ||\\r\\n            this.regexp_eatCapturingGroup(state)\\r\\n          )\\r\\n        };\\r\\n        pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\\r\\n          var start = state.pos;\\r\\n          if (state.eat(0x5C )) {\\r\\n            if (this.regexp_eatAtomEscape(state)) {\\r\\n              return true\\r\\n            }\\r\\n            state.pos = start;\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n        pp$8.regexp_eatUncapturingGroup = function(state) {\\r\\n          var start = state.pos;\\r\\n          if (state.eat(0x28 )) {\\r\\n            if (state.eat(0x3F ) && state.eat(0x3A )) {\\r\\n              this.regexp_disjunction(state);\\r\\n              if (state.eat(0x29 )) {\\r\\n                return true\\r\\n              }\\r\\n              state.raise(\\\"Unterminated group\\\");\\r\\n            }\\r\\n            state.pos = start;\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n        pp$8.regexp_eatCapturingGroup = function(state) {\\r\\n          if (state.eat(0x28 )) {\\r\\n            if (this.options.ecmaVersion >= 9) {\\r\\n              this.regexp_groupSpecifier(state);\\r\\n            } else if (state.current() === 0x3F ) {\\r\\n              state.raise(\\\"Invalid group\\\");\\r\\n            }\\r\\n            this.regexp_disjunction(state);\\r\\n            if (state.eat(0x29 )) {\\r\\n              state.numCapturingParens += 1;\\r\\n              return true\\r\\n            }\\r\\n            state.raise(\\\"Unterminated group\\\");\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatExtendedAtom = function(state) {\\r\\n          return (\\r\\n            state.eat(0x2E ) ||\\r\\n            this.regexp_eatReverseSolidusAtomEscape(state) ||\\r\\n            this.regexp_eatCharacterClass(state) ||\\r\\n            this.regexp_eatUncapturingGroup(state) ||\\r\\n            this.regexp_eatCapturingGroup(state) ||\\r\\n            this.regexp_eatInvalidBracedQuantifier(state) ||\\r\\n            this.regexp_eatExtendedPatternCharacter(state)\\r\\n          )\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatInvalidBracedQuantifier = function(state) {\\r\\n          if (this.regexp_eatBracedQuantifier(state, true)) {\\r\\n            state.raise(\\\"Nothing to repeat\\\");\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatSyntaxCharacter = function(state) {\\r\\n          var ch = state.current();\\r\\n          if (isSyntaxCharacter(ch)) {\\r\\n            state.lastIntValue = ch;\\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n        function isSyntaxCharacter(ch) {\\r\\n          return (\\r\\n            ch === 0x24  ||\\r\\n            ch >= 0x28  && ch <= 0x2B  ||\\r\\n            ch === 0x2E  ||\\r\\n            ch === 0x3F  ||\\r\\n            ch >= 0x5B  && ch <= 0x5E  ||\\r\\n            ch >= 0x7B  && ch <= 0x7D \\r\\n          )\\r\\n        }\\r\\n      \\r\\n        pp$8.regexp_eatPatternCharacters = function(state) {\\r\\n          var start = state.pos;\\r\\n          var ch = 0;\\r\\n          while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\\r\\n            state.advance();\\r\\n          }\\r\\n          return state.pos !== start\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatExtendedPatternCharacter = function(state) {\\r\\n          var ch = state.current();\\r\\n          if (\\r\\n            ch !== -1 &&\\r\\n            ch !== 0x24  &&\\r\\n            !(ch >= 0x28  && ch <= 0x2B ) &&\\r\\n            ch !== 0x2E  &&\\r\\n            ch !== 0x3F  &&\\r\\n            ch !== 0x5B  &&\\r\\n            ch !== 0x5E  &&\\r\\n            ch !== 0x7C \\r\\n          ) {\\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_groupSpecifier = function(state) {\\r\\n          if (state.eat(0x3F )) {\\r\\n            if (this.regexp_eatGroupName(state)) {\\r\\n              if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\\r\\n                state.raise(\\\"Duplicate capture group name\\\");\\r\\n              }\\r\\n              state.groupNames.push(state.lastStringValue);\\r\\n              return\\r\\n            }\\r\\n            state.raise(\\\"Invalid group\\\");\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatGroupName = function(state) {\\r\\n          state.lastStringValue = \\\"\\\";\\r\\n          if (state.eat(0x3C )) {\\r\\n            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E )) {\\r\\n              return true\\r\\n            }\\r\\n            state.raise(\\\"Invalid capture group name\\\");\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatRegExpIdentifierName = function(state) {\\r\\n          state.lastStringValue = \\\"\\\";\\r\\n          if (this.regexp_eatRegExpIdentifierStart(state)) {\\r\\n            state.lastStringValue += codePointToString(state.lastIntValue);\\r\\n            while (this.regexp_eatRegExpIdentifierPart(state)) {\\r\\n              state.lastStringValue += codePointToString(state.lastIntValue);\\r\\n            }\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatRegExpIdentifierStart = function(state) {\\r\\n          var start = state.pos;\\r\\n          var ch = state.current();\\r\\n          state.advance();\\r\\n      \\r\\n          if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\\r\\n            ch = state.lastIntValue;\\r\\n          }\\r\\n          if (isRegExpIdentifierStart(ch)) {\\r\\n            state.lastIntValue = ch;\\r\\n            return true\\r\\n          }\\r\\n      \\r\\n          state.pos = start;\\r\\n          return false\\r\\n        };\\r\\n        function isRegExpIdentifierStart(ch) {\\r\\n          return isIdentifierStart(ch, true) || ch === 0x24  || ch === 0x5F \\r\\n        }\\r\\n      \\r\\n        pp$8.regexp_eatRegExpIdentifierPart = function(state) {\\r\\n          var start = state.pos;\\r\\n          var ch = state.current();\\r\\n          state.advance();\\r\\n      \\r\\n          if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\\r\\n            ch = state.lastIntValue;\\r\\n          }\\r\\n          if (isRegExpIdentifierPart(ch)) {\\r\\n            state.lastIntValue = ch;\\r\\n            return true\\r\\n          }\\r\\n      \\r\\n          state.pos = start;\\r\\n          return false\\r\\n        };\\r\\n        function isRegExpIdentifierPart(ch) {\\r\\n          return isIdentifierChar(ch, true) || ch === 0x24  || ch === 0x5F  || ch === 0x200C  || ch === 0x200D \\r\\n        }\\r\\n      \\r\\n        pp$8.regexp_eatAtomEscape = function(state) {\\r\\n          if (\\r\\n            this.regexp_eatBackReference(state) ||\\r\\n            this.regexp_eatCharacterClassEscape(state) ||\\r\\n            this.regexp_eatCharacterEscape(state) ||\\r\\n            (state.switchN && this.regexp_eatKGroupName(state))\\r\\n          ) {\\r\\n            return true\\r\\n          }\\r\\n          if (state.switchU) {\\r\\n            if (state.current() === 0x63 ) {\\r\\n              state.raise(\\\"Invalid unicode escape\\\");\\r\\n            }\\r\\n            state.raise(\\\"Invalid escape\\\");\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n        pp$8.regexp_eatBackReference = function(state) {\\r\\n          var start = state.pos;\\r\\n          if (this.regexp_eatDecimalEscape(state)) {\\r\\n            var n = state.lastIntValue;\\r\\n            if (state.switchU) {\\r\\n              if (n > state.maxBackReference) {\\r\\n                state.maxBackReference = n;\\r\\n              }\\r\\n              return true\\r\\n            }\\r\\n            if (n <= state.numCapturingParens) {\\r\\n              return true\\r\\n            }\\r\\n            state.pos = start;\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n        pp$8.regexp_eatKGroupName = function(state) {\\r\\n          if (state.eat(0x6B )) {\\r\\n            if (this.regexp_eatGroupName(state)) {\\r\\n              state.backReferenceNames.push(state.lastStringValue);\\r\\n              return true\\r\\n            }\\r\\n            state.raise(\\\"Invalid named reference\\\");\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatCharacterEscape = function(state) {\\r\\n          return (\\r\\n            this.regexp_eatControlEscape(state) ||\\r\\n            this.regexp_eatCControlLetter(state) ||\\r\\n            this.regexp_eatZero(state) ||\\r\\n            this.regexp_eatHexEscapeSequence(state) ||\\r\\n            this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\\r\\n            (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\\r\\n            this.regexp_eatIdentityEscape(state)\\r\\n          )\\r\\n        };\\r\\n        pp$8.regexp_eatCControlLetter = function(state) {\\r\\n          var start = state.pos;\\r\\n          if (state.eat(0x63 )) {\\r\\n            if (this.regexp_eatControlLetter(state)) {\\r\\n              return true\\r\\n            }\\r\\n            state.pos = start;\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n        pp$8.regexp_eatZero = function(state) {\\r\\n          if (state.current() === 0x30  && !isDecimalDigit(state.lookahead())) {\\r\\n            state.lastIntValue = 0;\\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatControlEscape = function(state) {\\r\\n          var ch = state.current();\\r\\n          if (ch === 0x74 ) {\\r\\n            state.lastIntValue = 0x09; \\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n          if (ch === 0x6E ) {\\r\\n            state.lastIntValue = 0x0A; \\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n          if (ch === 0x76 ) {\\r\\n            state.lastIntValue = 0x0B; \\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n          if (ch === 0x66 ) {\\r\\n            state.lastIntValue = 0x0C; \\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n          if (ch === 0x72 ) {\\r\\n            state.lastIntValue = 0x0D; \\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatControlLetter = function(state) {\\r\\n          var ch = state.current();\\r\\n          if (isControlLetter(ch)) {\\r\\n            state.lastIntValue = ch % 0x20;\\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n        function isControlLetter(ch) {\\r\\n          return (\\r\\n            (ch >= 0x41  && ch <= 0x5A ) ||\\r\\n            (ch >= 0x61  && ch <= 0x7A )\\r\\n          )\\r\\n        }\\r\\n      \\r\\n        pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\\r\\n          var start = state.pos;\\r\\n      \\r\\n          if (state.eat(0x75 )) {\\r\\n            if (this.regexp_eatFixedHexDigits(state, 4)) {\\r\\n              var lead = state.lastIntValue;\\r\\n              if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\\r\\n                var leadSurrogateEnd = state.pos;\\r\\n                if (state.eat(0x5C ) && state.eat(0x75 ) && this.regexp_eatFixedHexDigits(state, 4)) {\\r\\n                  var trail = state.lastIntValue;\\r\\n                  if (trail >= 0xDC00 && trail <= 0xDFFF) {\\r\\n                    state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\\r\\n                    return true\\r\\n                  }\\r\\n                }\\r\\n                state.pos = leadSurrogateEnd;\\r\\n                state.lastIntValue = lead;\\r\\n              }\\r\\n              return true\\r\\n            }\\r\\n            if (\\r\\n              state.switchU &&\\r\\n              state.eat(0x7B ) &&\\r\\n              this.regexp_eatHexDigits(state) &&\\r\\n              state.eat(0x7D ) &&\\r\\n              isValidUnicode(state.lastIntValue)\\r\\n            ) {\\r\\n              return true\\r\\n            }\\r\\n            if (state.switchU) {\\r\\n              state.raise(\\\"Invalid unicode escape\\\");\\r\\n            }\\r\\n            state.pos = start;\\r\\n          }\\r\\n      \\r\\n          return false\\r\\n        };\\r\\n        function isValidUnicode(ch) {\\r\\n          return ch >= 0 && ch <= 0x10FFFF\\r\\n        }\\r\\n      \\r\\n        pp$8.regexp_eatIdentityEscape = function(state) {\\r\\n          if (state.switchU) {\\r\\n            if (this.regexp_eatSyntaxCharacter(state)) {\\r\\n              return true\\r\\n            }\\r\\n            if (state.eat(0x2F )) {\\r\\n              state.lastIntValue = 0x2F; \\r\\n              return true\\r\\n            }\\r\\n            return false\\r\\n          }\\r\\n      \\r\\n          var ch = state.current();\\r\\n          if (ch !== 0x63  && (!state.switchN || ch !== 0x6B )) {\\r\\n            state.lastIntValue = ch;\\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n      \\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatDecimalEscape = function(state) {\\r\\n          state.lastIntValue = 0;\\r\\n          var ch = state.current();\\r\\n          if (ch >= 0x31  && ch <= 0x39 ) {\\r\\n            do {\\r\\n              state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );\\r\\n              state.advance();\\r\\n            } while ((ch = state.current()) >= 0x30  && ch <= 0x39 )\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatCharacterClassEscape = function(state) {\\r\\n          var ch = state.current();\\r\\n      \\r\\n          if (isCharacterClassEscape(ch)) {\\r\\n            state.lastIntValue = -1;\\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n      \\r\\n          if (\\r\\n            state.switchU &&\\r\\n            this.options.ecmaVersion >= 9 &&\\r\\n            (ch === 0x50  || ch === 0x70 )\\r\\n          ) {\\r\\n            state.lastIntValue = -1;\\r\\n            state.advance();\\r\\n            if (\\r\\n              state.eat(0x7B ) &&\\r\\n              this.regexp_eatUnicodePropertyValueExpression(state) &&\\r\\n              state.eat(0x7D )\\r\\n            ) {\\r\\n              return true\\r\\n            }\\r\\n            state.raise(\\\"Invalid property name\\\");\\r\\n          }\\r\\n      \\r\\n          return false\\r\\n        };\\r\\n        function isCharacterClassEscape(ch) {\\r\\n          return (\\r\\n            ch === 0x64  ||\\r\\n            ch === 0x44  ||\\r\\n            ch === 0x73  ||\\r\\n            ch === 0x53  ||\\r\\n            ch === 0x77  ||\\r\\n            ch === 0x57 \\r\\n          )\\r\\n        }\\r\\n      \\r\\n        pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\\r\\n          var start = state.pos;\\r\\n      \\r\\n          if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D )) {\\r\\n            var name = state.lastStringValue;\\r\\n            if (this.regexp_eatUnicodePropertyValue(state)) {\\r\\n              var value = state.lastStringValue;\\r\\n              this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\\r\\n              return true\\r\\n            }\\r\\n          }\\r\\n          state.pos = start;\\r\\n      \\r\\n          if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\\r\\n            var nameOrValue = state.lastStringValue;\\r\\n            this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n        pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\\r\\n          if (!has(state.unicodeProperties.nonBinary, name))\\r\\n            { state.raise(\\\"Invalid property name\\\"); }\\r\\n          if (!state.unicodeProperties.nonBinary[name].test(value))\\r\\n            { state.raise(\\\"Invalid property value\\\"); }\\r\\n        };\\r\\n        pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\\r\\n          if (!state.unicodeProperties.binary.test(nameOrValue))\\r\\n            { state.raise(\\\"Invalid property name\\\"); }\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatUnicodePropertyName = function(state) {\\r\\n          var ch = 0;\\r\\n          state.lastStringValue = \\\"\\\";\\r\\n          while (isUnicodePropertyNameCharacter(ch = state.current())) {\\r\\n            state.lastStringValue += codePointToString(ch);\\r\\n            state.advance();\\r\\n          }\\r\\n          return state.lastStringValue !== \\\"\\\"\\r\\n        };\\r\\n        function isUnicodePropertyNameCharacter(ch) {\\r\\n          return isControlLetter(ch) || ch === 0x5F \\r\\n        }\\r\\n      \\r\\n        pp$8.regexp_eatUnicodePropertyValue = function(state) {\\r\\n          var ch = 0;\\r\\n          state.lastStringValue = \\\"\\\";\\r\\n          while (isUnicodePropertyValueCharacter(ch = state.current())) {\\r\\n            state.lastStringValue += codePointToString(ch);\\r\\n            state.advance();\\r\\n          }\\r\\n          return state.lastStringValue !== \\\"\\\"\\r\\n        };\\r\\n        function isUnicodePropertyValueCharacter(ch) {\\r\\n          return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\\r\\n        }\\r\\n      \\r\\n        pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\\r\\n          return this.regexp_eatUnicodePropertyValue(state)\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatCharacterClass = function(state) {\\r\\n          if (state.eat(0x5B )) {\\r\\n            state.eat(0x5E );\\r\\n            this.regexp_classRanges(state);\\r\\n            if (state.eat(0x5D )) {\\r\\n              return true\\r\\n            }\\r\\n            state.raise(\\\"Unterminated character class\\\");\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_classRanges = function(state) {\\r\\n          while (this.regexp_eatClassAtom(state)) {\\r\\n            var left = state.lastIntValue;\\r\\n            if (state.eat(0x2D ) && this.regexp_eatClassAtom(state)) {\\r\\n              var right = state.lastIntValue;\\r\\n              if (state.switchU && (left === -1 || right === -1)) {\\r\\n                state.raise(\\\"Invalid character class\\\");\\r\\n              }\\r\\n              if (left !== -1 && right !== -1 && left > right) {\\r\\n                state.raise(\\\"Range out of order in character class\\\");\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatClassAtom = function(state) {\\r\\n          var start = state.pos;\\r\\n      \\r\\n          if (state.eat(0x5C )) {\\r\\n            if (this.regexp_eatClassEscape(state)) {\\r\\n              return true\\r\\n            }\\r\\n            if (state.switchU) {\\r\\n              var ch$1 = state.current();\\r\\n              if (ch$1 === 0x63  || isOctalDigit(ch$1)) {\\r\\n                state.raise(\\\"Invalid class escape\\\");\\r\\n              }\\r\\n              state.raise(\\\"Invalid escape\\\");\\r\\n            }\\r\\n            state.pos = start;\\r\\n          }\\r\\n      \\r\\n          var ch = state.current();\\r\\n          if (ch !== 0x5D ) {\\r\\n            state.lastIntValue = ch;\\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n      \\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatClassEscape = function(state) {\\r\\n          var start = state.pos;\\r\\n      \\r\\n          if (state.eat(0x62 )) {\\r\\n            state.lastIntValue = 0x08; \\r\\n            return true\\r\\n          }\\r\\n      \\r\\n          if (state.switchU && state.eat(0x2D )) {\\r\\n            state.lastIntValue = 0x2D; \\r\\n            return true\\r\\n          }\\r\\n      \\r\\n          if (!state.switchU && state.eat(0x63 )) {\\r\\n            if (this.regexp_eatClassControlLetter(state)) {\\r\\n              return true\\r\\n            }\\r\\n            state.pos = start;\\r\\n          }\\r\\n      \\r\\n          return (\\r\\n            this.regexp_eatCharacterClassEscape(state) ||\\r\\n            this.regexp_eatCharacterEscape(state)\\r\\n          )\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatClassControlLetter = function(state) {\\r\\n          var ch = state.current();\\r\\n          if (isDecimalDigit(ch) || ch === 0x5F ) {\\r\\n            state.lastIntValue = ch % 0x20;\\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatHexEscapeSequence = function(state) {\\r\\n          var start = state.pos;\\r\\n          if (state.eat(0x78 )) {\\r\\n            if (this.regexp_eatFixedHexDigits(state, 2)) {\\r\\n              return true\\r\\n            }\\r\\n            if (state.switchU) {\\r\\n              state.raise(\\\"Invalid escape\\\");\\r\\n            }\\r\\n            state.pos = start;\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatDecimalDigits = function(state) {\\r\\n          var start = state.pos;\\r\\n          var ch = 0;\\r\\n          state.lastIntValue = 0;\\r\\n          while (isDecimalDigit(ch = state.current())) {\\r\\n            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );\\r\\n            state.advance();\\r\\n          }\\r\\n          return state.pos !== start\\r\\n        };\\r\\n        function isDecimalDigit(ch) {\\r\\n          return ch >= 0x30  && ch <= 0x39 \\r\\n        }\\r\\n      \\r\\n        pp$8.regexp_eatHexDigits = function(state) {\\r\\n          var start = state.pos;\\r\\n          var ch = 0;\\r\\n          state.lastIntValue = 0;\\r\\n          while (isHexDigit(ch = state.current())) {\\r\\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\\r\\n            state.advance();\\r\\n          }\\r\\n          return state.pos !== start\\r\\n        };\\r\\n        function isHexDigit(ch) {\\r\\n          return (\\r\\n            (ch >= 0x30  && ch <= 0x39 ) ||\\r\\n            (ch >= 0x41  && ch <= 0x46 ) ||\\r\\n            (ch >= 0x61  && ch <= 0x66 )\\r\\n          )\\r\\n        }\\r\\n        function hexToInt(ch) {\\r\\n          if (ch >= 0x41  && ch <= 0x46 ) {\\r\\n            return 10 + (ch - 0x41 )\\r\\n          }\\r\\n          if (ch >= 0x61  && ch <= 0x66 ) {\\r\\n            return 10 + (ch - 0x61 )\\r\\n          }\\r\\n          return ch - 0x30 \\r\\n        }\\r\\n      \\r\\n        pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\\r\\n          if (this.regexp_eatOctalDigit(state)) {\\r\\n            var n1 = state.lastIntValue;\\r\\n            if (this.regexp_eatOctalDigit(state)) {\\r\\n              var n2 = state.lastIntValue;\\r\\n              if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\\r\\n                state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\\r\\n              } else {\\r\\n                state.lastIntValue = n1 * 8 + n2;\\r\\n              }\\r\\n            } else {\\r\\n              state.lastIntValue = n1;\\r\\n            }\\r\\n            return true\\r\\n          }\\r\\n          return false\\r\\n        };\\r\\n      \\r\\n        pp$8.regexp_eatOctalDigit = function(state) {\\r\\n          var ch = state.current();\\r\\n          if (isOctalDigit(ch)) {\\r\\n            state.lastIntValue = ch - 0x30; \\r\\n            state.advance();\\r\\n            return true\\r\\n          }\\r\\n          state.lastIntValue = 0;\\r\\n          return false\\r\\n        };\\r\\n        function isOctalDigit(ch) {\\r\\n          return ch >= 0x30  && ch <= 0x37 \\r\\n        }\\r\\n      \\r\\n        pp$8.regexp_eatFixedHexDigits = function(state, length) {\\r\\n          var start = state.pos;\\r\\n          state.lastIntValue = 0;\\r\\n          for (var i = 0; i < length; ++i) {\\r\\n            var ch = state.current();\\r\\n            if (!isHexDigit(ch)) {\\r\\n              state.pos = start;\\r\\n              return false\\r\\n            }\\r\\n            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\\r\\n            state.advance();\\r\\n          }\\r\\n          return true\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var Token = function Token(p) {\\r\\n          this.type = p.type;\\r\\n          this.value = p.value;\\r\\n          this.start = p.start;\\r\\n          this.end = p.end;\\r\\n          if (p.options.locations)\\r\\n            { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\\r\\n          if (p.options.ranges)\\r\\n            { this.range = [p.start, p.end]; }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var pp$9 = Parser.prototype;\\r\\n      \\r\\n      \\r\\n        pp$9.next = function(ignoreEscapeSequenceInKeyword) {\\r\\n          if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)\\r\\n            { this.raiseRecoverable(this.start, \\\"Escape sequence in keyword \\\" + this.type.keyword); }\\r\\n          if (this.options.onToken)\\r\\n            { this.options.onToken(new Token(this)); }\\r\\n      \\r\\n          this.lastTokEnd = this.end;\\r\\n          this.lastTokStart = this.start;\\r\\n          this.lastTokEndLoc = this.endLoc;\\r\\n          this.lastTokStartLoc = this.startLoc;\\r\\n          this.nextToken();\\r\\n        };\\r\\n      \\r\\n        pp$9.getToken = function() {\\r\\n          this.next();\\r\\n          return new Token(this)\\r\\n        };\\r\\n      \\r\\n        if (typeof Symbol !== \\\"undefined\\\")\\r\\n          { pp$9[Symbol.iterator] = function() {\\r\\n            var this$1 = this;\\r\\n      \\r\\n            return {\\r\\n              next: function () {\\r\\n                var token = this$1.getToken();\\r\\n                return {\\r\\n                  done: token.type === types.eof,\\r\\n                  value: token\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n          }; }\\r\\n      \\r\\n      \\r\\n        pp$9.curContext = function() {\\r\\n          return this.context[this.context.length - 1]\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$9.nextToken = function() {\\r\\n          var curContext = this.curContext();\\r\\n          if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\\r\\n      \\r\\n          this.start = this.pos;\\r\\n          if (this.options.locations) { this.startLoc = this.curPosition(); }\\r\\n          if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\\r\\n      \\r\\n          if (curContext.override) { return curContext.override(this) }\\r\\n          else { this.readToken(this.fullCharCodeAtPos()); }\\r\\n        };\\r\\n      \\r\\n        pp$9.readToken = function(code) {\\r\\n          if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 )\\r\\n            { return this.readWord() }\\r\\n      \\r\\n          return this.getTokenFromCode(code)\\r\\n        };\\r\\n      \\r\\n        pp$9.fullCharCodeAtPos = function() {\\r\\n          var code = this.input.charCodeAt(this.pos);\\r\\n          if (code <= 0xd7ff || code >= 0xe000) { return code }\\r\\n          var next = this.input.charCodeAt(this.pos + 1);\\r\\n          return (code << 10) + next - 0x35fdc00\\r\\n        };\\r\\n      \\r\\n        pp$9.skipBlockComment = function() {\\r\\n          var startLoc = this.options.onComment && this.curPosition();\\r\\n          var start = this.pos, end = this.input.indexOf(\\\"*/\\\", this.pos += 2);\\r\\n          if (end === -1) { this.raise(this.pos - 2, \\\"Unterminated comment\\\"); }\\r\\n          this.pos = end + 2;\\r\\n          if (this.options.locations) {\\r\\n            lineBreakG.lastIndex = start;\\r\\n            var match;\\r\\n            while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\\r\\n              ++this.curLine;\\r\\n              this.lineStart = match.index + match[0].length;\\r\\n            }\\r\\n          }\\r\\n          if (this.options.onComment)\\r\\n            { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\\r\\n                                   startLoc, this.curPosition()); }\\r\\n        };\\r\\n      \\r\\n        pp$9.skipLineComment = function(startSkip) {\\r\\n          var start = this.pos;\\r\\n          var startLoc = this.options.onComment && this.curPosition();\\r\\n          var ch = this.input.charCodeAt(this.pos += startSkip);\\r\\n          while (this.pos < this.input.length && !isNewLine(ch)) {\\r\\n            ch = this.input.charCodeAt(++this.pos);\\r\\n          }\\r\\n          if (this.options.onComment)\\r\\n            { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\\r\\n                                   startLoc, this.curPosition()); }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$9.skipSpace = function() {\\r\\n          loop: while (this.pos < this.input.length) {\\r\\n            var ch = this.input.charCodeAt(this.pos);\\r\\n            switch (ch) {\\r\\n            case 32: case 160: \\r\\n              ++this.pos;\\r\\n              break\\r\\n            case 13:\\r\\n              if (this.input.charCodeAt(this.pos + 1) === 10) {\\r\\n                ++this.pos;\\r\\n              }\\r\\n            case 10: case 8232: case 8233:\\r\\n              ++this.pos;\\r\\n              if (this.options.locations) {\\r\\n                ++this.curLine;\\r\\n                this.lineStart = this.pos;\\r\\n              }\\r\\n              break\\r\\n            case 47: \\r\\n              switch (this.input.charCodeAt(this.pos + 1)) {\\r\\n              case 42: \\r\\n                this.skipBlockComment();\\r\\n                break\\r\\n              case 47:\\r\\n                this.skipLineComment(2);\\r\\n                break\\r\\n              default:\\r\\n                break loop\\r\\n              }\\r\\n              break\\r\\n            default:\\r\\n              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\\r\\n                ++this.pos;\\r\\n              } else {\\r\\n                break loop\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$9.finishToken = function(type, val) {\\r\\n          this.end = this.pos;\\r\\n          if (this.options.locations) { this.endLoc = this.curPosition(); }\\r\\n          var prevType = this.type;\\r\\n          this.type = type;\\r\\n          this.value = val;\\r\\n      \\r\\n          this.updateContext(prevType);\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$9.readToken_dot = function() {\\r\\n          var next = this.input.charCodeAt(this.pos + 1);\\r\\n          if (next >= 48 && next <= 57) { return this.readNumber(true) }\\r\\n          var next2 = this.input.charCodeAt(this.pos + 2);\\r\\n          if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { \\r\\n            this.pos += 3;\\r\\n            return this.finishToken(types.ellipsis)\\r\\n          } else {\\r\\n            ++this.pos;\\r\\n            return this.finishToken(types.dot)\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$9.readToken_slash = function() { \\r\\n          var next = this.input.charCodeAt(this.pos + 1);\\r\\n          if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\\r\\n          if (next === 61) { return this.finishOp(types.assign, 2) }\\r\\n          return this.finishOp(types.slash, 1)\\r\\n        };\\r\\n      \\r\\n        pp$9.readToken_mult_modulo_exp = function(code) { \\r\\n          var next = this.input.charCodeAt(this.pos + 1);\\r\\n          var size = 1;\\r\\n          var tokentype = code === 42 ? types.star : types.modulo;\\r\\n      \\r\\n          if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\\r\\n            ++size;\\r\\n            tokentype = types.starstar;\\r\\n            next = this.input.charCodeAt(this.pos + 2);\\r\\n          }\\r\\n      \\r\\n          if (next === 61) { return this.finishOp(types.assign, size + 1) }\\r\\n          return this.finishOp(tokentype, size)\\r\\n        };\\r\\n      \\r\\n        pp$9.readToken_pipe_amp = function(code) { \\r\\n          var next = this.input.charCodeAt(this.pos + 1);\\r\\n          if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\\r\\n          if (next === 61) { return this.finishOp(types.assign, 2) }\\r\\n          return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\\r\\n        };\\r\\n      \\r\\n        pp$9.readToken_caret = function() { \\r\\n          var next = this.input.charCodeAt(this.pos + 1);\\r\\n          if (next === 61) { return this.finishOp(types.assign, 2) }\\r\\n          return this.finishOp(types.bitwiseXOR, 1)\\r\\n        };\\r\\n      \\r\\n        pp$9.readToken_plus_min = function(code) { \\r\\n          var next = this.input.charCodeAt(this.pos + 1);\\r\\n          if (next === code) {\\r\\n            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\\r\\n                (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\\r\\n              this.skipLineComment(3);\\r\\n              this.skipSpace();\\r\\n              return this.nextToken()\\r\\n            }\\r\\n            return this.finishOp(types.incDec, 2)\\r\\n          }\\r\\n          if (next === 61) { return this.finishOp(types.assign, 2) }\\r\\n          return this.finishOp(types.plusMin, 1)\\r\\n        };\\r\\n      \\r\\n        pp$9.readToken_lt_gt = function(code) { \\r\\n          var next = this.input.charCodeAt(this.pos + 1);\\r\\n          var size = 1;\\r\\n          if (next === code) {\\r\\n            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\\r\\n            if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\\r\\n            return this.finishOp(types.bitShift, size)\\r\\n          }\\r\\n          if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\\r\\n              this.input.charCodeAt(this.pos + 3) === 45) {\\r\\n            this.skipLineComment(4);\\r\\n            this.skipSpace();\\r\\n            return this.nextToken()\\r\\n          }\\r\\n          if (next === 61) { size = 2; }\\r\\n          return this.finishOp(types.relational, size)\\r\\n        };\\r\\n      \\r\\n        pp$9.readToken_eq_excl = function(code) { \\r\\n          var next = this.input.charCodeAt(this.pos + 1);\\r\\n          if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\\r\\n          if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { \\r\\n            this.pos += 2;\\r\\n            return this.finishToken(types.arrow)\\r\\n          }\\r\\n          return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\\r\\n        };\\r\\n      \\r\\n        pp$9.getTokenFromCode = function(code) {\\r\\n          switch (code) {\\r\\n          case 46: \\r\\n            return this.readToken_dot()\\r\\n      \\r\\n          case 40: ++this.pos; return this.finishToken(types.parenL)\\r\\n          case 41: ++this.pos; return this.finishToken(types.parenR)\\r\\n          case 59: ++this.pos; return this.finishToken(types.semi)\\r\\n          case 44: ++this.pos; return this.finishToken(types.comma)\\r\\n          case 91: ++this.pos; return this.finishToken(types.bracketL)\\r\\n          case 93: ++this.pos; return this.finishToken(types.bracketR)\\r\\n          case 123: ++this.pos; return this.finishToken(types.braceL)\\r\\n          case 125: ++this.pos; return this.finishToken(types.braceR)\\r\\n          case 58: ++this.pos; return this.finishToken(types.colon)\\r\\n          case 63: ++this.pos; return this.finishToken(types.question)\\r\\n      \\r\\n          case 96: \\r\\n            if (this.options.ecmaVersion < 6) { break }\\r\\n            ++this.pos;\\r\\n            return this.finishToken(types.backQuote)\\r\\n      \\r\\n          case 48: \\r\\n            var next = this.input.charCodeAt(this.pos + 1);\\r\\n            if (next === 120 || next === 88) { return this.readRadixNumber(16) } \\r\\n            if (this.options.ecmaVersion >= 6) {\\r\\n              if (next === 111 || next === 79) { return this.readRadixNumber(8) } \\r\\n              if (next === 98 || next === 66) { return this.readRadixNumber(2) } \\r\\n            }\\r\\n      \\r\\n          case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: \\r\\n            return this.readNumber(false)\\r\\n      \\r\\n          case 34: case 39: \\r\\n            return this.readString(code)\\r\\n      \\r\\n      \\r\\n          case 47: \\r\\n            return this.readToken_slash()\\r\\n      \\r\\n          case 37: case 42: \\r\\n            return this.readToken_mult_modulo_exp(code)\\r\\n      \\r\\n          case 124: case 38: \\r\\n            return this.readToken_pipe_amp(code)\\r\\n      \\r\\n          case 94: \\r\\n            return this.readToken_caret()\\r\\n      \\r\\n          case 43: case 45: \\r\\n            return this.readToken_plus_min(code)\\r\\n      \\r\\n          case 60: case 62: \\r\\n            return this.readToken_lt_gt(code)\\r\\n      \\r\\n          case 61: case 33: \\r\\n            return this.readToken_eq_excl(code)\\r\\n      \\r\\n          case 126: \\r\\n            return this.finishOp(types.prefix, 1)\\r\\n          }\\r\\n      \\r\\n          this.raise(this.pos, \\\"Unexpected character '\\\" + codePointToString$1(code) + \\\"'\\\");\\r\\n        };\\r\\n      \\r\\n        pp$9.finishOp = function(type, size) {\\r\\n          var str = this.input.slice(this.pos, this.pos + size);\\r\\n          this.pos += size;\\r\\n          return this.finishToken(type, str)\\r\\n        };\\r\\n      \\r\\n        pp$9.readRegexp = function() {\\r\\n          var escaped, inClass, start = this.pos;\\r\\n          for (;;) {\\r\\n            if (this.pos >= this.input.length) { this.raise(start, \\\"Unterminated regular expression\\\"); }\\r\\n            var ch = this.input.charAt(this.pos);\\r\\n            if (lineBreak.test(ch)) { this.raise(start, \\\"Unterminated regular expression\\\"); }\\r\\n            if (!escaped) {\\r\\n              if (ch === \\\"[\\\") { inClass = true; }\\r\\n              else if (ch === \\\"]\\\" && inClass) { inClass = false; }\\r\\n              else if (ch === \\\"/\\\" && !inClass) { break }\\r\\n              escaped = ch === \\\"\\\\\\\\\\\";\\r\\n            } else { escaped = false; }\\r\\n            ++this.pos;\\r\\n          }\\r\\n          var pattern = this.input.slice(start, this.pos);\\r\\n          ++this.pos;\\r\\n          var flagsStart = this.pos;\\r\\n          var flags = this.readWord1();\\r\\n          if (this.containsEsc) { this.unexpected(flagsStart); }\\r\\n      \\r\\n          var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\\r\\n          state.reset(start, pattern, flags);\\r\\n          this.validateRegExpFlags(state);\\r\\n          this.validateRegExpPattern(state);\\r\\n      \\r\\n          var value = null;\\r\\n          try {\\r\\n            value = new RegExp(pattern, flags);\\r\\n          } catch (e) {\\r\\n          }\\r\\n      \\r\\n          return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$9.readInt = function(radix, len) {\\r\\n          var start = this.pos, total = 0;\\r\\n          for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\\r\\n            var code = this.input.charCodeAt(this.pos), val = (void 0);\\r\\n            if (code >= 97) { val = code - 97 + 10; } \\r\\n            else if (code >= 65) { val = code - 65 + 10; } \\r\\n            else if (code >= 48 && code <= 57) { val = code - 48; } \\r\\n            else { val = Infinity; }\\r\\n            if (val >= radix) { break }\\r\\n            ++this.pos;\\r\\n            total = total * radix + val;\\r\\n          }\\r\\n          if (this.pos === start || len != null && this.pos - start !== len) { return null }\\r\\n      \\r\\n          return total\\r\\n        };\\r\\n      \\r\\n        pp$9.readRadixNumber = function(radix) {\\r\\n          var start = this.pos;\\r\\n          this.pos += 2; \\r\\n          var val = this.readInt(radix);\\r\\n          if (val == null) { this.raise(this.start + 2, \\\"Expected number in radix \\\" + radix); }\\r\\n          if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\\r\\n            val = typeof BigInt !== \\\"undefined\\\" ? BigInt(this.input.slice(start, this.pos)) : null;\\r\\n            ++this.pos;\\r\\n          } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \\\"Identifier directly after number\\\"); }\\r\\n          return this.finishToken(types.num, val)\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$9.readNumber = function(startsWithDot) {\\r\\n          var start = this.pos;\\r\\n          if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \\\"Invalid number\\\"); }\\r\\n          var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\\r\\n          if (octal && this.strict) { this.raise(start, \\\"Invalid number\\\"); }\\r\\n          var next = this.input.charCodeAt(this.pos);\\r\\n          if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\\r\\n            var str$1 = this.input.slice(start, this.pos);\\r\\n            var val$1 = typeof BigInt !== \\\"undefined\\\" ? BigInt(str$1) : null;\\r\\n            ++this.pos;\\r\\n            if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \\\"Identifier directly after number\\\"); }\\r\\n            return this.finishToken(types.num, val$1)\\r\\n          }\\r\\n          if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\\r\\n          if (next === 46 && !octal) { \\r\\n            ++this.pos;\\r\\n            this.readInt(10);\\r\\n            next = this.input.charCodeAt(this.pos);\\r\\n          }\\r\\n          if ((next === 69 || next === 101) && !octal) { \\r\\n            next = this.input.charCodeAt(++this.pos);\\r\\n            if (next === 43 || next === 45) { ++this.pos; } \\r\\n            if (this.readInt(10) === null) { this.raise(start, \\\"Invalid number\\\"); }\\r\\n          }\\r\\n          if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \\\"Identifier directly after number\\\"); }\\r\\n      \\r\\n          var str = this.input.slice(start, this.pos);\\r\\n          var val = octal ? parseInt(str, 8) : parseFloat(str);\\r\\n          return this.finishToken(types.num, val)\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$9.readCodePoint = function() {\\r\\n          var ch = this.input.charCodeAt(this.pos), code;\\r\\n      \\r\\n          if (ch === 123) { \\r\\n            if (this.options.ecmaVersion < 6) { this.unexpected(); }\\r\\n            var codePos = ++this.pos;\\r\\n            code = this.readHexChar(this.input.indexOf(\\\"}\\\", this.pos) - this.pos);\\r\\n            ++this.pos;\\r\\n            if (code > 0x10FFFF) { this.invalidStringToken(codePos, \\\"Code point out of bounds\\\"); }\\r\\n          } else {\\r\\n            code = this.readHexChar(4);\\r\\n          }\\r\\n          return code\\r\\n        };\\r\\n      \\r\\n        function codePointToString$1(code) {\\r\\n          if (code <= 0xFFFF) { return String.fromCharCode(code) }\\r\\n          code -= 0x10000;\\r\\n          return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\\r\\n        }\\r\\n      \\r\\n        pp$9.readString = function(quote) {\\r\\n          var out = \\\"\\\", chunkStart = ++this.pos;\\r\\n          for (;;) {\\r\\n            if (this.pos >= this.input.length) { this.raise(this.start, \\\"Unterminated string constant\\\"); }\\r\\n            var ch = this.input.charCodeAt(this.pos);\\r\\n            if (ch === quote) { break }\\r\\n            if (ch === 92) { \\r\\n              out += this.input.slice(chunkStart, this.pos);\\r\\n              out += this.readEscapedChar(false);\\r\\n              chunkStart = this.pos;\\r\\n            } else {\\r\\n              if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \\\"Unterminated string constant\\\"); }\\r\\n              ++this.pos;\\r\\n            }\\r\\n          }\\r\\n          out += this.input.slice(chunkStart, this.pos++);\\r\\n          return this.finishToken(types.string, out)\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var INVALID_TEMPLATE_ESCAPE_ERROR = {};\\r\\n      \\r\\n        pp$9.tryReadTemplateToken = function() {\\r\\n          this.inTemplateElement = true;\\r\\n          try {\\r\\n            this.readTmplToken();\\r\\n          } catch (err) {\\r\\n            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\\r\\n              this.readInvalidTemplateToken();\\r\\n            } else {\\r\\n              throw err\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          this.inTemplateElement = false;\\r\\n        };\\r\\n      \\r\\n        pp$9.invalidStringToken = function(position, message) {\\r\\n          if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\\r\\n            throw INVALID_TEMPLATE_ESCAPE_ERROR\\r\\n          } else {\\r\\n            this.raise(position, message);\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$9.readTmplToken = function() {\\r\\n          var out = \\\"\\\", chunkStart = this.pos;\\r\\n          for (;;) {\\r\\n            if (this.pos >= this.input.length) { this.raise(this.start, \\\"Unterminated template\\\"); }\\r\\n            var ch = this.input.charCodeAt(this.pos);\\r\\n            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { \\r\\n              if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\\r\\n                if (ch === 36) {\\r\\n                  this.pos += 2;\\r\\n                  return this.finishToken(types.dollarBraceL)\\r\\n                } else {\\r\\n                  ++this.pos;\\r\\n                  return this.finishToken(types.backQuote)\\r\\n                }\\r\\n              }\\r\\n              out += this.input.slice(chunkStart, this.pos);\\r\\n              return this.finishToken(types.template, out)\\r\\n            }\\r\\n            if (ch === 92) { \\r\\n              out += this.input.slice(chunkStart, this.pos);\\r\\n              out += this.readEscapedChar(true);\\r\\n              chunkStart = this.pos;\\r\\n            } else if (isNewLine(ch)) {\\r\\n              out += this.input.slice(chunkStart, this.pos);\\r\\n              ++this.pos;\\r\\n              switch (ch) {\\r\\n              case 13:\\r\\n                if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\\r\\n              case 10:\\r\\n                out += \\\"\\\\n\\\";\\r\\n                break\\r\\n              default:\\r\\n                out += String.fromCharCode(ch);\\r\\n                break\\r\\n              }\\r\\n              if (this.options.locations) {\\r\\n                ++this.curLine;\\r\\n                this.lineStart = this.pos;\\r\\n              }\\r\\n              chunkStart = this.pos;\\r\\n            } else {\\r\\n              ++this.pos;\\r\\n            }\\r\\n          }\\r\\n        };\\r\\n      \\r\\n        pp$9.readInvalidTemplateToken = function() {\\r\\n          for (; this.pos < this.input.length; this.pos++) {\\r\\n            switch (this.input[this.pos]) {\\r\\n            case \\\"\\\\\\\\\\\":\\r\\n              ++this.pos;\\r\\n              break\\r\\n      \\r\\n            case \\\"$\\\":\\r\\n              if (this.input[this.pos + 1] !== \\\"{\\\") {\\r\\n                break\\r\\n              }\\r\\n      \\r\\n            case \\\"`\\\":\\r\\n              return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\\r\\n      \\r\\n            }\\r\\n          }\\r\\n          this.raise(this.start, \\\"Unterminated template\\\");\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$9.readEscapedChar = function(inTemplate) {\\r\\n          var ch = this.input.charCodeAt(++this.pos);\\r\\n          ++this.pos;\\r\\n          switch (ch) {\\r\\n          case 110: return \\\"\\\\n\\\" \\r\\n          case 114: return \\\"\\\\r\\\" \\r\\n          case 120: return String.fromCharCode(this.readHexChar(2)) \\r\\n          case 117: return codePointToString$1(this.readCodePoint()) \\r\\n          case 116: return \\\"\\\\t\\\" \\r\\n          case 98: return \\\"\\\\b\\\" \\r\\n          case 118: return \\\"\\\\u000b\\\" \\r\\n          case 102: return \\\"\\\\f\\\" \\r\\n          case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } \\r\\n          case 10: \\r\\n            if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\\r\\n            return \\\"\\\"\\r\\n          case 56:\\r\\n          case 57:\\r\\n            if (inTemplate) {\\r\\n              var codePos = this.pos - 1;\\r\\n      \\r\\n              this.invalidStringToken(\\r\\n                codePos,\\r\\n                \\\"Invalid escape sequence in template string\\\"\\r\\n              );\\r\\n      \\r\\n              return null\\r\\n            }\\r\\n          default:\\r\\n            if (ch >= 48 && ch <= 55) {\\r\\n              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\\r\\n              var octal = parseInt(octalStr, 8);\\r\\n              if (octal > 255) {\\r\\n                octalStr = octalStr.slice(0, -1);\\r\\n                octal = parseInt(octalStr, 8);\\r\\n              }\\r\\n              this.pos += octalStr.length - 1;\\r\\n              ch = this.input.charCodeAt(this.pos);\\r\\n              if ((octalStr !== \\\"0\\\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\\r\\n                this.invalidStringToken(\\r\\n                  this.pos - 1 - octalStr.length,\\r\\n                  inTemplate\\r\\n                    ? \\\"Octal literal in template string\\\"\\r\\n                    : \\\"Octal literal in strict mode\\\"\\r\\n                );\\r\\n              }\\r\\n              return String.fromCharCode(octal)\\r\\n            }\\r\\n            if (isNewLine(ch)) {\\r\\n              return \\\"\\\"\\r\\n            }\\r\\n            return String.fromCharCode(ch)\\r\\n          }\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$9.readHexChar = function(len) {\\r\\n          var codePos = this.pos;\\r\\n          var n = this.readInt(16, len);\\r\\n          if (n === null) { this.invalidStringToken(codePos, \\\"Bad character escape sequence\\\"); }\\r\\n          return n\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$9.readWord1 = function() {\\r\\n          this.containsEsc = false;\\r\\n          var word = \\\"\\\", first = true, chunkStart = this.pos;\\r\\n          var astral = this.options.ecmaVersion >= 6;\\r\\n          while (this.pos < this.input.length) {\\r\\n            var ch = this.fullCharCodeAtPos();\\r\\n            if (isIdentifierChar(ch, astral)) {\\r\\n              this.pos += ch <= 0xffff ? 1 : 2;\\r\\n            } else if (ch === 92) { \\r\\n              this.containsEsc = true;\\r\\n              word += this.input.slice(chunkStart, this.pos);\\r\\n              var escStart = this.pos;\\r\\n              if (this.input.charCodeAt(++this.pos) !== 117) \\r\\n                { this.invalidStringToken(this.pos, \\\"Expecting Unicode escape sequence \\\\\\\\uXXXX\\\"); }\\r\\n              ++this.pos;\\r\\n              var esc = this.readCodePoint();\\r\\n              if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\\r\\n                { this.invalidStringToken(escStart, \\\"Invalid Unicode escape\\\"); }\\r\\n              word += codePointToString$1(esc);\\r\\n              chunkStart = this.pos;\\r\\n            } else {\\r\\n              break\\r\\n            }\\r\\n            first = false;\\r\\n          }\\r\\n          return word + this.input.slice(chunkStart, this.pos)\\r\\n        };\\r\\n      \\r\\n      \\r\\n        pp$9.readWord = function() {\\r\\n          var word = this.readWord1();\\r\\n          var type = types.name;\\r\\n          if (this.keywords.test(word)) {\\r\\n            type = keywords$1[word];\\r\\n          }\\r\\n          return this.finishToken(type, word)\\r\\n        };\\r\\n      \\r\\n      \\r\\n        var version = \\\"7.1.0\\\";\\r\\n      \\r\\n        Parser.acorn = {\\r\\n          Parser: Parser,\\r\\n          version: version,\\r\\n          defaultOptions: defaultOptions,\\r\\n          Position: Position,\\r\\n          SourceLocation: SourceLocation,\\r\\n          getLineInfo: getLineInfo,\\r\\n          Node: Node,\\r\\n          TokenType: TokenType,\\r\\n          tokTypes: types,\\r\\n          keywordTypes: keywords$1,\\r\\n          TokContext: TokContext,\\r\\n          tokContexts: types$1,\\r\\n          isIdentifierChar: isIdentifierChar,\\r\\n          isIdentifierStart: isIdentifierStart,\\r\\n          Token: Token,\\r\\n          isNewLine: isNewLine,\\r\\n          lineBreak: lineBreak,\\r\\n          lineBreakG: lineBreakG,\\r\\n          nonASCIIwhitespace: nonASCIIwhitespace\\r\\n        };\\r\\n      \\r\\n      \\r\\n        function parse(input, options) {\\r\\n          return Parser.parse(input, options)\\r\\n        }\\r\\n      \\r\\n      \\r\\n        function parseExpressionAt(input, pos, options) {\\r\\n          return Parser.parseExpressionAt(input, pos, options)\\r\\n        }\\r\\n      \\r\\n      \\r\\n        function tokenizer(input, options) {\\r\\n          return Parser.tokenizer(input, options)\\r\\n        }\\r\\n      \\r\\n        exports.Node = Node;\\r\\n        exports.Parser = Parser;\\r\\n        exports.Position = Position;\\r\\n        exports.SourceLocation = SourceLocation;\\r\\n        exports.TokContext = TokContext;\\r\\n        exports.Token = Token;\\r\\n        exports.TokenType = TokenType;\\r\\n        exports.defaultOptions = defaultOptions;\\r\\n        exports.getLineInfo = getLineInfo;\\r\\n        exports.isIdentifierChar = isIdentifierChar;\\r\\n        exports.isIdentifierStart = isIdentifierStart;\\r\\n        exports.isNewLine = isNewLine;\\r\\n        exports.keywordTypes = keywords$1;\\r\\n        exports.lineBreak = lineBreak;\\r\\n        exports.lineBreakG = lineBreakG;\\r\\n        exports.nonASCIIwhitespace = nonASCIIwhitespace;\\r\\n        exports.parse = parse;\\r\\n        exports.parseExpressionAt = parseExpressionAt;\\r\\n        exports.tokContexts = types$1;\\r\\n        exports.tokTypes = types;\\r\\n        exports.tokenizer = tokenizer;\\r\\n        exports.version = version;\\r\\n      \\r\\n        Object.defineProperty(exports, '__esModule', { value: true });\\r\\n      \\r\\n      }));\\r\\n      \\r\\n      },{}],2:[function(require,module,exports){\\r\\n      \\r\\n      },{}],3:[function(require,module,exports){\\r\\n      function glWiretap(gl, options = {}) {\\r\\n        const {\\r\\n          contextName = 'gl',\\r\\n          throwGetError,\\r\\n          useTrackablePrimitives,\\r\\n          readPixelsFile,\\r\\n          recording = [],\\r\\n          variables = {},\\r\\n          onReadPixels,\\r\\n          onUnrecognizedArgumentLookup,\\r\\n        } = options;\\r\\n        const proxy = new Proxy(gl, { get: listen });\\r\\n        const contextVariables = [];\\r\\n        const entityNames = {};\\r\\n        let imageCount = 0;\\r\\n        let indent = '';\\r\\n        let readPixelsVariableName;\\r\\n        return proxy;\\r\\n        function listen(obj, property) {\\r\\n          switch (property) {\\r\\n            case 'addComment': return addComment;\\r\\n            case 'checkThrowError': return checkThrowError;\\r\\n            case 'getReadPixelsVariableName': return readPixelsVariableName;\\r\\n            case 'insertVariable': return insertVariable;\\r\\n            case 'reset': return reset;\\r\\n            case 'setIndent': return setIndent;\\r\\n            case 'toString': return toString;\\r\\n            case 'getContextVariableName': return getContextVariableName;\\r\\n          }\\r\\n          if (typeof gl[property] === 'function') {\\r\\n            return function() { \\r\\n              switch (property) {\\r\\n                case 'getError':\\r\\n                  if (throwGetError) {\\r\\n                    recording.push(`${indent}if (${contextName}.getError() !== ${contextName}.NONE) throw new Error('error');`);\\r\\n                  } else {\\r\\n                    recording.push(`${indent}${contextName}.getError();`); \\r\\n                  }\\r\\n                  return gl.getError();\\r\\n                case 'getExtension': {\\r\\n                  const variableName = `${contextName}Variables${contextVariables.length}`;\\r\\n                  recording.push(`${indent}const ${variableName} = ${contextName}.getExtension('${arguments[0]}');`);\\r\\n                  const extension = gl.getExtension(arguments[0]);\\r\\n                  if (extension && typeof extension === 'object') {\\r\\n                    const tappedExtension = glExtensionWiretap(extension, {\\r\\n                      getEntity,\\r\\n                      useTrackablePrimitives,\\r\\n                      recording,\\r\\n                      contextName: variableName,\\r\\n                      contextVariables,\\r\\n                      variables,\\r\\n                      indent,\\r\\n                      onUnrecognizedArgumentLookup,\\r\\n                    });\\r\\n                    contextVariables.push(tappedExtension);\\r\\n                    return tappedExtension;\\r\\n                  } else {\\r\\n                    contextVariables.push(null);\\r\\n                  }\\r\\n                  return extension;\\r\\n                }\\r\\n                case 'readPixels':\\r\\n                  const i = contextVariables.indexOf(arguments[6]);\\r\\n                  let targetVariableName;\\r\\n                  if (i === -1) {\\r\\n                    const variableName = getVariableName(arguments[6]);\\r\\n                    if (variableName) {\\r\\n                      targetVariableName = variableName;\\r\\n                      recording.push(`${indent}${variableName}`);\\r\\n                    } else {\\r\\n                      targetVariableName = `${contextName}Variable${contextVariables.length}`;\\r\\n                      contextVariables.push(arguments[6]);\\r\\n                      recording.push(`${indent}const ${targetVariableName} = new ${arguments[6].constructor.name}(${arguments[6].length});`);\\r\\n                    }\\r\\n                  } else {\\r\\n                    targetVariableName = `${contextName}Variable${i}`;\\r\\n                  }\\r\\n                  readPixelsVariableName = targetVariableName;\\r\\n                  const argumentAsStrings = [\\r\\n                    arguments[0],\\r\\n                    arguments[1],\\r\\n                    arguments[2],\\r\\n                    arguments[3],\\r\\n                    getEntity(arguments[4]),\\r\\n                    getEntity(arguments[5]),\\r\\n                    targetVariableName\\r\\n                  ];\\r\\n                  recording.push(`${indent}${contextName}.readPixels(${argumentAsStrings.join(', ')});`);\\r\\n                  if (readPixelsFile) {\\r\\n                    writePPM(arguments[2], arguments[3]);\\r\\n                  }\\r\\n                  if (onReadPixels) {\\r\\n                    onReadPixels(targetVariableName, argumentAsStrings);\\r\\n                  }\\r\\n                  return gl.readPixels.apply(gl, arguments);\\r\\n                case 'drawBuffers':\\r\\n                  recording.push(`${indent}${contextName}.drawBuffers([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup } )}]);`);\\r\\n                  return gl.drawBuffers(arguments[0]);\\r\\n              }\\r\\n              let result = gl[property].apply(gl, arguments);\\r\\n              switch (typeof result) {\\r\\n                case 'undefined':\\r\\n                  recording.push(`${indent}${methodCallToString(property, arguments)};`);\\r\\n                  return;\\r\\n                case 'number':\\r\\n                case 'boolean':\\r\\n                  if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {\\r\\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\\r\\n                    contextVariables.push(result = trackablePrimitive(result));\\r\\n                    break;\\r\\n                  }\\r\\n                default:\\r\\n                  if (result === null) {\\r\\n                    recording.push(`${methodCallToString(property, arguments)};`);\\r\\n                  } else {\\r\\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\\r\\n                  }\\r\\n      \\r\\n                  contextVariables.push(result);\\r\\n              }\\r\\n              return result;\\r\\n            }\\r\\n          }\\r\\n          entityNames[gl[property]] = property;\\r\\n          return gl[property];\\r\\n        }\\r\\n        function toString() {\\r\\n          return recording.join('\\\\n');\\r\\n        }\\r\\n        function reset() {\\r\\n          while (recording.length > 0) {\\r\\n            recording.pop();\\r\\n          }\\r\\n        }\\r\\n        function insertVariable(name, value) {\\r\\n          variables[name] = value;\\r\\n        }\\r\\n        function getEntity(value) {\\r\\n          const name = entityNames[value];\\r\\n          if (name) {\\r\\n            return contextName + '.' + name;\\r\\n          }\\r\\n          return value;\\r\\n        }\\r\\n        function setIndent(spaces) {\\r\\n          indent = ' '.repeat(spaces);\\r\\n        }\\r\\n        function addVariable(value, source) {\\r\\n          const variableName = `${contextName}Variable${contextVariables.length}`;\\r\\n          recording.push(`${indent}const ${variableName} = ${source};`);\\r\\n          contextVariables.push(value);\\r\\n          return variableName;\\r\\n        }\\r\\n        function writePPM(width, height) {\\r\\n          const sourceVariable = `${contextName}Variable${contextVariables.length}`;\\r\\n          const imageVariable = `imageDatum${imageCount}`;\\r\\n          recording.push(`${indent}let ${imageVariable} = [\\\"P3\\\\\\\\n# ${readPixelsFile}.ppm\\\\\\\\n\\\", ${width}, ' ', ${height}, \\\"\\\\\\\\n255\\\\\\\\n\\\"].join(\\\"\\\");`);\\r\\n          recording.push(`${indent}for (let i = 0; i < ${imageVariable}.length; i += 4) {`);\\r\\n          recording.push(`${indent}  ${imageVariable} += ${sourceVariable}[i] + ' ' + ${sourceVariable}[i + 1] + ' ' + ${sourceVariable}[i + 2] + ' ';`);\\r\\n          recording.push(`${indent}}`);\\r\\n          recording.push(`${indent}if (typeof require !== \\\"undefined\\\") {`);\\r\\n          recording.push(`${indent}  require('fs').writeFileSync('./${readPixelsFile}.ppm', ${imageVariable});`);\\r\\n          recording.push(`${indent}}`);\\r\\n          imageCount++;\\r\\n        }\\r\\n        function addComment(value) {\\r\\n          recording.push(`${indent}// ${value}`);\\r\\n        }\\r\\n        function checkThrowError() {\\r\\n          recording.push(`${indent}(() => {\\r\\n      ${indent}const error = ${contextName}.getError();\\r\\n      ${indent}if (error !== ${contextName}.NONE) {\\r\\n      ${indent}  const names = Object.getOwnPropertyNames(gl);\\r\\n      ${indent}  for (let i = 0; i < names.length; i++) {\\r\\n      ${indent}    const name = names[i];\\r\\n      ${indent}    if (${contextName}[name] === error) {\\r\\n      ${indent}      throw new Error('${contextName} threw ' + name);\\r\\n      ${indent}    }\\r\\n      ${indent}  }\\r\\n      ${indent}}\\r\\n      ${indent}})();`);\\r\\n        }\\r\\n        function methodCallToString(method, args) {\\r\\n          return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;\\r\\n        }\\r\\n      \\r\\n        function getVariableName(value) {\\r\\n          if (variables) {\\r\\n            for (const name in variables) {\\r\\n              if (variables[name] === value) {\\r\\n                return name;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n          return null;\\r\\n        }\\r\\n      \\r\\n        function getContextVariableName(value) {\\r\\n          const i = contextVariables.indexOf(value);\\r\\n          if (i !== -1) {\\r\\n            return `${contextName}Variable${i}`;\\r\\n          }\\r\\n          return null;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      function glExtensionWiretap(extension, options) {\\r\\n        const proxy = new Proxy(extension, { get: listen });\\r\\n        const extensionEntityNames = {};\\r\\n        const {\\r\\n          contextName,\\r\\n          contextVariables,\\r\\n          getEntity,\\r\\n          useTrackablePrimitives,\\r\\n          recording,\\r\\n          variables,\\r\\n          indent,\\r\\n          onUnrecognizedArgumentLookup,\\r\\n        } = options;\\r\\n        return proxy;\\r\\n        function listen(obj, property) {\\r\\n          if (typeof obj[property] === 'function') {\\r\\n            return function() {\\r\\n              switch (property) {\\r\\n                case 'drawBuffersWEBGL':\\r\\n                  recording.push(`${indent}${contextName}.drawBuffersWEBGL([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })}]);`);\\r\\n                  return extension.drawBuffersWEBGL(arguments[0]);\\r\\n              }\\r\\n              let result = extension[property].apply(extension, arguments);\\r\\n              switch (typeof result) {\\r\\n                case 'undefined':\\r\\n                  recording.push(`${indent}${methodCallToString(property, arguments)};`);\\r\\n                  return;\\r\\n                case 'number':\\r\\n                case 'boolean':\\r\\n                  if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {\\r\\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\\r\\n                    contextVariables.push(result = trackablePrimitive(result));\\r\\n                  } else {\\r\\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\\r\\n                    contextVariables.push(result);\\r\\n                  }\\r\\n                  break;\\r\\n                default:\\r\\n                  if (result === null) {\\r\\n                    recording.push(`${methodCallToString(property, arguments)};`);\\r\\n                  } else {\\r\\n                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);\\r\\n                  }\\r\\n                  contextVariables.push(result);\\r\\n              }\\r\\n              return result;\\r\\n            };\\r\\n          }\\r\\n          extensionEntityNames[extension[property]] = property;\\r\\n          return extension[property];\\r\\n        }\\r\\n      \\r\\n        function getExtensionEntity(value) {\\r\\n          if (extensionEntityNames.hasOwnProperty(value)) {\\r\\n            return `${contextName}.${extensionEntityNames[value]}`;\\r\\n          }\\r\\n          return getEntity(value);\\r\\n        }\\r\\n      \\r\\n        function methodCallToString(method, args) {\\r\\n          return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;\\r\\n        }\\r\\n      \\r\\n        function addVariable(value, source) {\\r\\n          const variableName = `${contextName}Variable${contextVariables.length}`;\\r\\n          contextVariables.push(value);\\r\\n          recording.push(`${indent}const ${variableName} = ${source};`);\\r\\n          return variableName;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      function argumentsToString(args, options) {\\r\\n        const { variables, onUnrecognizedArgumentLookup } = options;\\r\\n        return (Array.from(args).map((arg) => {\\r\\n          const variableName = getVariableName(arg);\\r\\n          if (variableName) {\\r\\n            return variableName;\\r\\n          }\\r\\n          return argumentToString(arg, options);\\r\\n        }).join(', '));\\r\\n      \\r\\n        function getVariableName(value) {\\r\\n          if (variables) {\\r\\n            for (const name in variables) {\\r\\n              if (!variables.hasOwnProperty(name)) continue;\\r\\n              if (variables[name] === value) {\\r\\n                return name;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n          if (onUnrecognizedArgumentLookup) {\\r\\n            return onUnrecognizedArgumentLookup(value);\\r\\n          }\\r\\n          return null;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      function argumentToString(arg, options) {\\r\\n        const { contextName, contextVariables, getEntity, addVariable, onUnrecognizedArgumentLookup } = options;\\r\\n        if (typeof arg === 'undefined') {\\r\\n          return 'undefined';\\r\\n        }\\r\\n        if (arg === null) {\\r\\n          return 'null';\\r\\n        }\\r\\n        const i = contextVariables.indexOf(arg);\\r\\n        if (i > -1) {\\r\\n          return `${contextName}Variable${i}`;\\r\\n        }\\r\\n        switch (arg.constructor.name) {\\r\\n          case 'String':\\r\\n            const hasLines = /\\\\n/.test(arg);\\r\\n            const hasSingleQuotes = /'/.test(arg);\\r\\n            const hasDoubleQuotes = /\\\"/.test(arg);\\r\\n            if (hasLines) {\\r\\n              return '`' + arg + '`';\\r\\n            } else if (hasSingleQuotes && !hasDoubleQuotes) {\\r\\n              return '\\\"' + arg + '\\\"';\\r\\n            } else if (!hasSingleQuotes && hasDoubleQuotes) {\\r\\n              return \\\"'\\\" + arg + \\\"'\\\";\\r\\n            } else {\\r\\n              return '\\\\'' + arg + '\\\\'';\\r\\n            }\\r\\n          case 'Number': return getEntity(arg);\\r\\n          case 'Boolean': return getEntity(arg);\\r\\n          case 'Array':\\r\\n            return addVariable(arg, `new ${arg.constructor.name}([${Array.from(arg).join(',')}])`);\\r\\n          case 'Float32Array':\\r\\n          case 'Uint8Array':\\r\\n          case 'Uint16Array':\\r\\n          case 'Int32Array':\\r\\n            return addVariable(arg, `new ${arg.constructor.name}(${JSON.stringify(Array.from(arg))})`);\\r\\n          default:\\r\\n            if (onUnrecognizedArgumentLookup) {\\r\\n              const instantiationString = onUnrecognizedArgumentLookup(arg);\\r\\n              if (instantiationString) {\\r\\n                return instantiationString;\\r\\n              }\\r\\n            }\\r\\n            throw new Error(`unrecognized argument type ${arg.constructor.name}`);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      function trackablePrimitive(value) {\\r\\n        return new value.constructor(value);\\r\\n      }\\r\\n      \\r\\n      if (typeof module !== 'undefined') {\\r\\n        module.exports = { glWiretap, glExtensionWiretap };\\r\\n      }\\r\\n      \\r\\n      if (typeof window !== 'undefined') {\\r\\n        glWiretap.glExtensionWiretap = glExtensionWiretap;\\r\\n        window.glWiretap = glWiretap;\\r\\n      }\\r\\n      \\r\\n      },{}],4:[function(require,module,exports){\\r\\n      function setupArguments(args) {\\r\\n        const newArguments = new Array(args.length);\\r\\n        for (let i = 0; i < args.length; i++) {\\r\\n          const arg = args[i];\\r\\n          if (arg.toArray) {\\r\\n            newArguments[i] = arg.toArray();\\r\\n          } else {\\r\\n            newArguments[i] = arg;\\r\\n          }\\r\\n        }\\r\\n        return newArguments;\\r\\n      }\\r\\n      \\r\\n      function mock1D() {\\r\\n        const args = setupArguments(arguments);\\r\\n        const row = new Float32Array(this.output.x);\\r\\n        for (let x = 0; x < this.output.x; x++) {\\r\\n          this.thread.x = x;\\r\\n          this.thread.y = 0;\\r\\n          this.thread.z = 0;\\r\\n          row[x] = this._fn.apply(this, args);\\r\\n        }\\r\\n        return row;\\r\\n      }\\r\\n      \\r\\n      function mock2D() {\\r\\n        const args = setupArguments(arguments);\\r\\n        const matrix = new Array(this.output.y);\\r\\n        for (let y = 0; y < this.output.y; y++) {\\r\\n          const row = new Float32Array(this.output.x);\\r\\n          for (let x = 0; x < this.output.x; x++) {\\r\\n            this.thread.x = x;\\r\\n            this.thread.y = y;\\r\\n            this.thread.z = 0;\\r\\n            row[x] = this._fn.apply(this, args);\\r\\n          }\\r\\n          matrix[y] = row;\\r\\n        }\\r\\n        return matrix;\\r\\n      }\\r\\n      \\r\\n      function mock2DGraphical() {\\r\\n        const args = setupArguments(arguments);\\r\\n        for (let y = 0; y < this.output.y; y++) {\\r\\n          for (let x = 0; x < this.output.x; x++) {\\r\\n            this.thread.x = x;\\r\\n            this.thread.y = y;\\r\\n            this.thread.z = 0;\\r\\n            this._fn.apply(this, args);\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      function mock3D() {\\r\\n        const args = setupArguments(arguments);\\r\\n        const cube = new Array(this.output.z);\\r\\n        for (let z = 0; z < this.output.z; z++) {\\r\\n          const matrix = new Array(this.output.y);\\r\\n          for (let y = 0; y < this.output.y; y++) {\\r\\n            const row = new Float32Array(this.output.x);\\r\\n            for (let x = 0; x < this.output.x; x++) {\\r\\n              this.thread.x = x;\\r\\n              this.thread.y = y;\\r\\n              this.thread.z = z;\\r\\n              row[x] = this._fn.apply(this, args);\\r\\n            }\\r\\n            matrix[y] = row;\\r\\n          }\\r\\n          cube[z] = matrix;\\r\\n        }\\r\\n        return cube;\\r\\n      }\\r\\n      \\r\\n      function apiDecorate(kernel) {\\r\\n        kernel.setOutput = (output) => {\\r\\n          kernel.output = setupOutput(output);\\r\\n          if (kernel.graphical) {\\r\\n            setupGraphical(kernel);\\r\\n          }\\r\\n        };\\r\\n        kernel.toJSON = () => {\\r\\n          throw new Error('Not usable with gpuMock');\\r\\n        };\\r\\n        kernel.setConstants = (flag) => {\\r\\n          kernel.constants = flag;\\r\\n          return kernel;\\r\\n        };\\r\\n        kernel.setGraphical = (flag) => {\\r\\n          kernel.graphical = flag;\\r\\n          return kernel;\\r\\n        };\\r\\n        kernel.setCanvas = (flag) => {\\r\\n          kernel.canvas = flag;\\r\\n          return kernel;\\r\\n        };\\r\\n        kernel.setContext = (flag) => {\\r\\n          kernel.context = flag;\\r\\n          return kernel;\\r\\n        };\\r\\n        kernel.destroy = () => {};\\r\\n        kernel.validateSettings = () => {};\\r\\n        if (kernel.graphical && kernel.output) {\\r\\n          setupGraphical(kernel);\\r\\n        }\\r\\n        kernel.exec = function() {\\r\\n          return new Promise((resolve, reject) => {\\r\\n            try {\\r\\n              resolve(kernel.apply(kernel, arguments));\\r\\n            } catch(e) {\\r\\n              reject(e);\\r\\n            }\\r\\n          });\\r\\n        };\\r\\n        kernel.getPixels = (flip) => {\\r\\n          const {x, y} = kernel.output;\\r\\n          return flip ? flipPixels(kernel._imageData.data, x, y) : kernel._imageData.data.slice(0);\\r\\n        };\\r\\n        kernel.color = function(r, g, b, a) {\\r\\n          if (typeof a === 'undefined') {\\r\\n            a = 1;\\r\\n          }\\r\\n      \\r\\n          r = Math.floor(r * 255);\\r\\n          g = Math.floor(g * 255);\\r\\n          b = Math.floor(b * 255);\\r\\n          a = Math.floor(a * 255);\\r\\n      \\r\\n          const width = kernel.output.x;\\r\\n          const height = kernel.output.y;\\r\\n      \\r\\n          const x = kernel.thread.x;\\r\\n          const y = height - kernel.thread.y - 1;\\r\\n      \\r\\n          const index = x + y * width;\\r\\n      \\r\\n          kernel._colorData[index * 4 + 0] = r;\\r\\n          kernel._colorData[index * 4 + 1] = g;\\r\\n          kernel._colorData[index * 4 + 2] = b;\\r\\n          kernel._colorData[index * 4 + 3] = a;\\r\\n        };\\r\\n      \\r\\n        const mockMethod = () => kernel;\\r\\n        const methods = [\\r\\n          'setWarnVarUsage',\\r\\n          'setArgumentTypes',\\r\\n          'setTactic',\\r\\n          'setOptimizeFloatMemory',\\r\\n          'setDebug',\\r\\n          'setLoopMaxIterations',\\r\\n          'setConstantTypes',\\r\\n          'setFunctions',\\r\\n          'setNativeFunctions',\\r\\n          'setInjectedNative',\\r\\n          'setPipeline',\\r\\n          'setPrecision',\\r\\n          'setOutputToTexture',\\r\\n          'setImmutable',\\r\\n          'setStrictIntegers',\\r\\n          'setDynamicOutput',\\r\\n          'setHardcodeConstants',\\r\\n          'setDynamicArguments',\\r\\n          'setUseLegacyEncoder',\\r\\n          'setWarnVarUsage',\\r\\n          'addSubKernel',\\r\\n        ];\\r\\n        for (let i = 0; i < methods.length; i++) {\\r\\n          kernel[methods[i]] = mockMethod;\\r\\n        }\\r\\n        return kernel;\\r\\n      }\\r\\n      \\r\\n      function setupGraphical(kernel) {\\r\\n        const {x, y} = kernel.output;\\r\\n        if (kernel.context && kernel.context.createImageData) {\\r\\n          const data = new Uint8ClampedArray(x * y * 4);\\r\\n          kernel._imageData = kernel.context.createImageData(x, y);\\r\\n          kernel._colorData = data;\\r\\n        } else {\\r\\n          const data = new Uint8ClampedArray(x * y * 4);\\r\\n          kernel._imageData = { data };\\r\\n          kernel._colorData = data;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      function setupOutput(output) {\\r\\n        let result = null;\\r\\n        if (output.length) {\\r\\n          if (output.length === 3) {\\r\\n            const [x,y,z] = output;\\r\\n            result = { x, y, z };\\r\\n          } else if (output.length === 2) {\\r\\n            const [x,y] = output;\\r\\n            result = { x, y };\\r\\n          } else {\\r\\n            const [x] = output;\\r\\n            result = { x };\\r\\n          }\\r\\n        } else {\\r\\n          result = output;\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      \\r\\n      function gpuMock(fn, settings = {}) {\\r\\n        const output = settings.output ? setupOutput(settings.output) : null;\\r\\n        function kernel() {\\r\\n          if (kernel.output.z) {\\r\\n            return mock3D.apply(kernel, arguments);\\r\\n          } else if (kernel.output.y) {\\r\\n            if (kernel.graphical) {\\r\\n              return mock2DGraphical.apply(kernel, arguments);\\r\\n            }\\r\\n            return mock2D.apply(kernel, arguments);\\r\\n          } else {\\r\\n            return mock1D.apply(kernel, arguments);\\r\\n          }\\r\\n        }\\r\\n        kernel._fn = fn;\\r\\n        kernel.constants = settings.constants || null;\\r\\n        kernel.context = settings.context || null;\\r\\n        kernel.canvas = settings.canvas || null;\\r\\n        kernel.graphical = settings.graphical || false;\\r\\n        kernel._imageData = null;\\r\\n        kernel._colorData = null;\\r\\n        kernel.output = output;\\r\\n        kernel.thread = {\\r\\n          x: 0,\\r\\n          y: 0,\\r\\n          z: 0\\r\\n        };\\r\\n        return apiDecorate(kernel);\\r\\n      }\\r\\n      \\r\\n      function flipPixels(pixels, width, height) {\\r\\n        const halfHeight = height / 2 | 0; \\r\\n        const bytesPerRow = width * 4;\\r\\n        const temp = new Uint8ClampedArray(width * 4);\\r\\n        const result = pixels.slice(0);\\r\\n        for (let y = 0; y < halfHeight; ++y) {\\r\\n          const topOffset = y * bytesPerRow;\\r\\n          const bottomOffset = (height - y - 1) * bytesPerRow;\\r\\n      \\r\\n          temp.set(result.subarray(topOffset, topOffset + bytesPerRow));\\r\\n      \\r\\n          result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);\\r\\n      \\r\\n          result.set(temp, bottomOffset);\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        gpuMock\\r\\n      };\\r\\n      \\r\\n      },{}],5:[function(require,module,exports){\\r\\n      const { utils } = require('./utils');\\r\\n      \\r\\n      function alias(name, source) {\\r\\n        const fnString = source.toString();\\r\\n        return new Function(`return function ${ name } (${ utils.getArgumentNamesFromString(fnString).join(', ') }) {\\r\\n        ${ utils.getFunctionBodyFromString(fnString) }\\r\\n      }`)();\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        alias\\r\\n      };\\r\\n      },{\\\"./utils\\\":114}],6:[function(require,module,exports){\\r\\n      const { FunctionNode } = require('../function-node');\\r\\n      \\r\\n      class CPUFunctionNode extends FunctionNode {\\r\\n        astFunction(ast, retArr) {\\r\\n      \\r\\n          if (!this.isRootKernel) {\\r\\n            retArr.push('function');\\r\\n            retArr.push(' ');\\r\\n            retArr.push(this.name);\\r\\n            retArr.push('(');\\r\\n      \\r\\n            for (let i = 0; i < this.argumentNames.length; ++i) {\\r\\n              const argumentName = this.argumentNames[i];\\r\\n      \\r\\n              if (i > 0) {\\r\\n                retArr.push(', ');\\r\\n              }\\r\\n              retArr.push('user_');\\r\\n              retArr.push(argumentName);\\r\\n            }\\r\\n      \\r\\n            retArr.push(') {\\\\n');\\r\\n          }\\r\\n      \\r\\n          for (let i = 0; i < ast.body.body.length; ++i) {\\r\\n            this.astGeneric(ast.body.body[i], retArr);\\r\\n            retArr.push('\\\\n');\\r\\n          }\\r\\n      \\r\\n          if (!this.isRootKernel) {\\r\\n            retArr.push('}\\\\n');\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astReturnStatement(ast, retArr) {\\r\\n          const type = this.returnType || this.getType(ast.argument);\\r\\n      \\r\\n          if (!this.returnType) {\\r\\n            this.returnType = type;\\r\\n          }\\r\\n      \\r\\n          if (this.isRootKernel) {\\r\\n            retArr.push(this.leadingReturnStatement);\\r\\n            this.astGeneric(ast.argument, retArr);\\r\\n            retArr.push(';\\\\n');\\r\\n            retArr.push(this.followingReturnStatement);\\r\\n            retArr.push('continue;\\\\n');\\r\\n          } else if (this.isSubKernel) {\\r\\n            retArr.push(`subKernelResult_${ this.name } = `);\\r\\n            this.astGeneric(ast.argument, retArr);\\r\\n            retArr.push(';');\\r\\n            retArr.push(`return subKernelResult_${ this.name };`);\\r\\n          } else {\\r\\n            retArr.push('return ');\\r\\n            this.astGeneric(ast.argument, retArr);\\r\\n            retArr.push(';');\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astLiteral(ast, retArr) {\\r\\n      \\r\\n          if (isNaN(ast.value)) {\\r\\n            throw this.astErrorOutput(\\r\\n              'Non-numeric literal not supported : ' + ast.value,\\r\\n              ast\\r\\n            );\\r\\n          }\\r\\n      \\r\\n          retArr.push(ast.value);\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astBinaryExpression(ast, retArr) {\\r\\n          retArr.push('(');\\r\\n          this.astGeneric(ast.left, retArr);\\r\\n          retArr.push(ast.operator);\\r\\n          this.astGeneric(ast.right, retArr);\\r\\n          retArr.push(')');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astIdentifierExpression(idtNode, retArr) {\\r\\n          if (idtNode.type !== 'Identifier') {\\r\\n            throw this.astErrorOutput(\\r\\n              'IdentifierExpression - not an Identifier',\\r\\n              idtNode\\r\\n            );\\r\\n          }\\r\\n      \\r\\n          switch (idtNode.name) {\\r\\n            case 'Infinity':\\r\\n              retArr.push('Infinity');\\r\\n              break;\\r\\n            default:\\r\\n              if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {\\r\\n                retArr.push('constants_' + idtNode.name);\\r\\n              } else {\\r\\n                retArr.push('user_' + idtNode.name);\\r\\n              }\\r\\n          }\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astForStatement(forNode, retArr) {\\r\\n          if (forNode.type !== 'ForStatement') {\\r\\n            throw this.astErrorOutput('Invalid for statement', forNode);\\r\\n          }\\r\\n      \\r\\n          const initArr = [];\\r\\n          const testArr = [];\\r\\n          const updateArr = [];\\r\\n          const bodyArr = [];\\r\\n          let isSafe = null;\\r\\n      \\r\\n          if (forNode.init) {\\r\\n            this.pushState('in-for-loop-init');\\r\\n            this.astGeneric(forNode.init, initArr);\\r\\n            for (let i = 0; i < initArr.length; i++) {\\r\\n              if (initArr[i].includes && initArr[i].includes(',')) {\\r\\n                isSafe = false;\\r\\n              }\\r\\n            }\\r\\n            this.popState('in-for-loop-init');\\r\\n          } else {\\r\\n            isSafe = false;\\r\\n          }\\r\\n      \\r\\n          if (forNode.test) {\\r\\n            this.astGeneric(forNode.test, testArr);\\r\\n          } else {\\r\\n            isSafe = false;\\r\\n          }\\r\\n      \\r\\n          if (forNode.update) {\\r\\n            this.astGeneric(forNode.update, updateArr);\\r\\n          } else {\\r\\n            isSafe = false;\\r\\n          }\\r\\n      \\r\\n          if (forNode.body) {\\r\\n            this.pushState('loop-body');\\r\\n            this.astGeneric(forNode.body, bodyArr);\\r\\n            this.popState('loop-body');\\r\\n          }\\r\\n      \\r\\n          if (isSafe === null) {\\r\\n            isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);\\r\\n          }\\r\\n      \\r\\n          if (isSafe) {\\r\\n            retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\\\\n`);\\r\\n            retArr.push(bodyArr.join(''));\\r\\n            retArr.push('}\\\\n');\\r\\n          } else {\\r\\n            const iVariableName = this.getInternalVariableName('safeI');\\r\\n            if (initArr.length > 0) {\\r\\n              retArr.push(initArr.join(''), ';\\\\n');\\r\\n            }\\r\\n            retArr.push(`for (let ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\\\n`);\\r\\n            if (testArr.length > 0) {\\r\\n              retArr.push(`if (!${testArr.join('')}) break;\\\\n`);\\r\\n            }\\r\\n            retArr.push(bodyArr.join(''));\\r\\n            retArr.push(`\\\\n${updateArr.join('')};`);\\r\\n            retArr.push('}\\\\n');\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astWhileStatement(whileNode, retArr) {\\r\\n          if (whileNode.type !== 'WhileStatement') {\\r\\n            throw this.astErrorOutput(\\r\\n              'Invalid while statement',\\r\\n              whileNode\\r\\n            );\\r\\n          }\\r\\n      \\r\\n          retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');\\r\\n          retArr.push('if (');\\r\\n          this.astGeneric(whileNode.test, retArr);\\r\\n          retArr.push(') {\\\\n');\\r\\n          this.astGeneric(whileNode.body, retArr);\\r\\n          retArr.push('} else {\\\\n');\\r\\n          retArr.push('break;\\\\n');\\r\\n          retArr.push('}\\\\n');\\r\\n          retArr.push('}\\\\n');\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astDoWhileStatement(doWhileNode, retArr) {\\r\\n          if (doWhileNode.type !== 'DoWhileStatement') {\\r\\n            throw this.astErrorOutput(\\r\\n              'Invalid while statement',\\r\\n              doWhileNode\\r\\n            );\\r\\n          }\\r\\n      \\r\\n          retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');\\r\\n          this.astGeneric(doWhileNode.body, retArr);\\r\\n          retArr.push('if (!');\\r\\n          this.astGeneric(doWhileNode.test, retArr);\\r\\n          retArr.push(') {\\\\n');\\r\\n          retArr.push('break;\\\\n');\\r\\n          retArr.push('}\\\\n');\\r\\n          retArr.push('}\\\\n');\\r\\n      \\r\\n          return retArr;\\r\\n      \\r\\n        }\\r\\n      \\r\\n        astAssignmentExpression(assNode, retArr) {\\r\\n          const declaration = this.getDeclaration(assNode.left);\\r\\n          if (declaration && !declaration.assignable) {\\r\\n            throw this.astErrorOutput(`Variable ${assNode.left.name} is not assignable here`, assNode);\\r\\n          }\\r\\n          this.astGeneric(assNode.left, retArr);\\r\\n          retArr.push(assNode.operator);\\r\\n          this.astGeneric(assNode.right, retArr);\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astBlockStatement(bNode, retArr) {\\r\\n          if (this.isState('loop-body')) {\\r\\n            this.pushState('block-body'); \\r\\n            for (let i = 0; i < bNode.body.length; i++) {\\r\\n              this.astGeneric(bNode.body[i], retArr);\\r\\n            }\\r\\n            this.popState('block-body');\\r\\n          } else {\\r\\n            retArr.push('{\\\\n');\\r\\n            for (let i = 0; i < bNode.body.length; i++) {\\r\\n              this.astGeneric(bNode.body[i], retArr);\\r\\n            }\\r\\n            retArr.push('}\\\\n');\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astVariableDeclaration(varDecNode, retArr) {\\r\\n          retArr.push(`${varDecNode.kind} `);\\r\\n          const { declarations } = varDecNode;\\r\\n          for (let i = 0; i < declarations.length; i++) {\\r\\n            if (i > 0) {\\r\\n              retArr.push(',');\\r\\n            }\\r\\n            const declaration = declarations[i];\\r\\n            const info = this.getDeclaration(declaration.id);\\r\\n            if (!info.valueType) {\\r\\n              info.valueType = this.getType(declaration.init);\\r\\n            }\\r\\n            this.astGeneric(declaration, retArr);\\r\\n          }\\r\\n          if (!this.isState('in-for-loop-init')) {\\r\\n            retArr.push(';');\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astIfStatement(ifNode, retArr) {\\r\\n          retArr.push('if (');\\r\\n          this.astGeneric(ifNode.test, retArr);\\r\\n          retArr.push(')');\\r\\n          if (ifNode.consequent.type === 'BlockStatement') {\\r\\n            this.astGeneric(ifNode.consequent, retArr);\\r\\n          } else {\\r\\n            retArr.push(' {\\\\n');\\r\\n            this.astGeneric(ifNode.consequent, retArr);\\r\\n            retArr.push('\\\\n}\\\\n');\\r\\n          }\\r\\n      \\r\\n          if (ifNode.alternate) {\\r\\n            retArr.push('else ');\\r\\n            if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {\\r\\n              this.astGeneric(ifNode.alternate, retArr);\\r\\n            } else {\\r\\n              retArr.push(' {\\\\n');\\r\\n              this.astGeneric(ifNode.alternate, retArr);\\r\\n              retArr.push('\\\\n}\\\\n');\\r\\n            }\\r\\n          }\\r\\n          return retArr;\\r\\n      \\r\\n        }\\r\\n      \\r\\n        astSwitchStatement(ast, retArr) {\\r\\n          const { discriminant, cases } = ast;\\r\\n          retArr.push('switch (');\\r\\n          this.astGeneric(discriminant, retArr);\\r\\n          retArr.push(') {\\\\n');\\r\\n          for (let i = 0; i < cases.length; i++) {\\r\\n            if (cases[i].test === null) {\\r\\n              retArr.push('default:\\\\n');\\r\\n              this.astGeneric(cases[i].consequent, retArr);\\r\\n              if (cases[i].consequent && cases[i].consequent.length > 0) {\\r\\n                retArr.push('break;\\\\n');\\r\\n              }\\r\\n              continue;\\r\\n            }\\r\\n            retArr.push('case ');\\r\\n            this.astGeneric(cases[i].test, retArr);\\r\\n            retArr.push(':\\\\n');\\r\\n            if (cases[i].consequent && cases[i].consequent.length > 0) {\\r\\n              this.astGeneric(cases[i].consequent, retArr);\\r\\n              retArr.push('break;\\\\n');\\r\\n            }\\r\\n          }\\r\\n          retArr.push('\\\\n}');\\r\\n        }\\r\\n      \\r\\n        astThisExpression(tNode, retArr) {\\r\\n          retArr.push('_this');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astMemberExpression(mNode, retArr) {\\r\\n          const {\\r\\n            signature,\\r\\n            type,\\r\\n            property,\\r\\n            xProperty,\\r\\n            yProperty,\\r\\n            zProperty,\\r\\n            name,\\r\\n            origin\\r\\n          } = this.getMemberExpressionDetails(mNode);\\r\\n          switch (signature) {\\r\\n            case 'this.thread.value':\\r\\n              retArr.push(`_this.thread.${ name }`);\\r\\n              return retArr;\\r\\n            case 'this.output.value':\\r\\n              switch (name) {\\r\\n                case 'x':\\r\\n                  retArr.push('outputX');\\r\\n                  break;\\r\\n                case 'y':\\r\\n                  retArr.push('outputY');\\r\\n                  break;\\r\\n                case 'z':\\r\\n                  retArr.push('outputZ');\\r\\n                  break;\\r\\n                default:\\r\\n                  throw this.astErrorOutput('Unexpected expression', mNode);\\r\\n              }\\r\\n              return retArr;\\r\\n            case 'value':\\r\\n              throw this.astErrorOutput('Unexpected expression', mNode);\\r\\n            case 'value[]':\\r\\n            case 'value[][]':\\r\\n            case 'value[][][]':\\r\\n            case 'value.value':\\r\\n              if (origin === 'Math') {\\r\\n                retArr.push(Math[name]);\\r\\n                return retArr;\\r\\n              }\\r\\n              switch (property) {\\r\\n                case 'r':\\r\\n                  retArr.push(`user_${ name }[0]`);\\r\\n                  return retArr;\\r\\n                case 'g':\\r\\n                  retArr.push(`user_${ name }[1]`);\\r\\n                  return retArr;\\r\\n                case 'b':\\r\\n                  retArr.push(`user_${ name }[2]`);\\r\\n                  return retArr;\\r\\n                case 'a':\\r\\n                  retArr.push(`user_${ name }[3]`);\\r\\n                  return retArr;\\r\\n              }\\r\\n              break;\\r\\n            case 'this.constants.value':\\r\\n            case 'this.constants.value[]':\\r\\n            case 'this.constants.value[][]':\\r\\n            case 'this.constants.value[][][]':\\r\\n              break;\\r\\n            case 'fn()[]':\\r\\n              this.astGeneric(mNode.object, retArr);\\r\\n              retArr.push('[');\\r\\n              this.astGeneric(mNode.property, retArr);\\r\\n              retArr.push(']');\\r\\n              return retArr;\\r\\n            case 'fn()[][]':\\r\\n              this.astGeneric(mNode.object.object, retArr);\\r\\n              retArr.push('[');\\r\\n              this.astGeneric(mNode.object.property, retArr);\\r\\n              retArr.push(']');\\r\\n              retArr.push('[');\\r\\n              this.astGeneric(mNode.property, retArr);\\r\\n              retArr.push(']');\\r\\n              return retArr;\\r\\n            default:\\r\\n              throw this.astErrorOutput('Unexpected expression', mNode);\\r\\n          }\\r\\n      \\r\\n          if (!mNode.computed) {\\r\\n            switch (type) {\\r\\n              case 'Number':\\r\\n              case 'Integer':\\r\\n              case 'Float':\\r\\n              case 'Boolean':\\r\\n                retArr.push(`${origin}_${name}`);\\r\\n                return retArr;\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          const markupName = `${origin}_${name}`;\\r\\n      \\r\\n          switch (type) {\\r\\n            case 'Array(2)':\\r\\n            case 'Array(3)':\\r\\n            case 'Array(4)':\\r\\n            case 'Matrix(2)':\\r\\n            case 'Matrix(3)':\\r\\n            case 'Matrix(4)':\\r\\n            case 'HTMLImageArray':\\r\\n            case 'ArrayTexture(1)':\\r\\n            case 'ArrayTexture(2)':\\r\\n            case 'ArrayTexture(3)':\\r\\n            case 'ArrayTexture(4)':\\r\\n            case 'HTMLImage':\\r\\n            default:\\r\\n              let size;\\r\\n              let isInput;\\r\\n              if (origin === 'constants') {\\r\\n                const constant = this.constants[name];\\r\\n                isInput = this.constantTypes[name] === 'Input';\\r\\n                size = isInput ? constant.size : null;\\r\\n              } else {\\r\\n                isInput = this.isInput(name);\\r\\n                size = isInput ? this.argumentSizes[this.argumentNames.indexOf(name)] : null;\\r\\n              }\\r\\n              retArr.push(`${ markupName }`);\\r\\n              if (zProperty && yProperty) {\\r\\n                if (isInput) {\\r\\n                  retArr.push('[(');\\r\\n                  this.astGeneric(zProperty, retArr);\\r\\n                  retArr.push(`*${ this.dynamicArguments ? '(outputY * outputX)' : size[1] * size[0] })+(`);\\r\\n                  this.astGeneric(yProperty, retArr);\\r\\n                  retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);\\r\\n                  this.astGeneric(xProperty, retArr);\\r\\n                  retArr.push(']');\\r\\n                } else {\\r\\n                  retArr.push('[');\\r\\n                  this.astGeneric(zProperty, retArr);\\r\\n                  retArr.push(']');\\r\\n                  retArr.push('[');\\r\\n                  this.astGeneric(yProperty, retArr);\\r\\n                  retArr.push(']');\\r\\n                  retArr.push('[');\\r\\n                  this.astGeneric(xProperty, retArr);\\r\\n                  retArr.push(']');\\r\\n                }\\r\\n              } else if (yProperty) {\\r\\n                if (isInput) {\\r\\n                  retArr.push('[(');\\r\\n                  this.astGeneric(yProperty, retArr);\\r\\n                  retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);\\r\\n                  this.astGeneric(xProperty, retArr);\\r\\n                  retArr.push(']');\\r\\n                } else {\\r\\n                  retArr.push('[');\\r\\n                  this.astGeneric(yProperty, retArr);\\r\\n                  retArr.push(']');\\r\\n                  retArr.push('[');\\r\\n                  this.astGeneric(xProperty, retArr);\\r\\n                  retArr.push(']');\\r\\n                }\\r\\n              } else if (typeof xProperty !== 'undefined') {\\r\\n                retArr.push('[');\\r\\n                this.astGeneric(xProperty, retArr);\\r\\n                retArr.push(']');\\r\\n              }\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astCallExpression(ast, retArr) {\\r\\n          if (ast.type !== 'CallExpression') {\\r\\n            throw this.astErrorOutput('Unknown CallExpression', ast);\\r\\n          }\\r\\n          let functionName = this.astMemberExpressionUnroll(ast.callee);\\r\\n      \\r\\n          if (this.calledFunctions.indexOf(functionName) < 0) {\\r\\n            this.calledFunctions.push(functionName);\\r\\n          }\\r\\n      \\r\\n          const isMathFunction = this.isAstMathFunction(ast);\\r\\n      \\r\\n          if (this.onFunctionCall) {\\r\\n            this.onFunctionCall(this.name, functionName, ast.arguments);\\r\\n          }\\r\\n      \\r\\n          retArr.push(functionName);\\r\\n      \\r\\n          retArr.push('(');\\r\\n          const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];\\r\\n          for (let i = 0; i < ast.arguments.length; ++i) {\\r\\n            const argument = ast.arguments[i];\\r\\n      \\r\\n            let argumentType = this.getType(argument);\\r\\n            if (!targetTypes[i]) {\\r\\n              this.triggerImplyArgumentType(functionName, i, argumentType, this);\\r\\n            }\\r\\n      \\r\\n            if (i > 0) {\\r\\n              retArr.push(', ');\\r\\n            }\\r\\n            this.astGeneric(argument, retArr);\\r\\n          }\\r\\n          retArr.push(')');\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astArrayExpression(arrNode, retArr) {\\r\\n          const returnType = this.getType(arrNode);\\r\\n          const arrLen = arrNode.elements.length;\\r\\n          const elements = [];\\r\\n          for (let i = 0; i < arrLen; ++i) {\\r\\n            const element = [];\\r\\n            this.astGeneric(arrNode.elements[i], element);\\r\\n            elements.push(element.join(''));\\r\\n          }\\r\\n          switch (returnType) {\\r\\n            case 'Matrix(2)':\\r\\n            case 'Matrix(3)':\\r\\n            case 'Matrix(4)':\\r\\n              retArr.push(`[${elements.join(', ')}]`);\\r\\n              break;\\r\\n            default:\\r\\n              retArr.push(`new Float32Array([${elements.join(', ')}])`);\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astDebuggerStatement(arrNode, retArr) {\\r\\n          retArr.push('debugger;');\\r\\n          return retArr;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        CPUFunctionNode\\r\\n      };\\r\\n      },{\\\"../function-node\\\":10}],7:[function(require,module,exports){\\r\\n      const { utils } = require('../../utils');\\r\\n      \\r\\n      function constantsToString(constants, types) {\\r\\n        const results = [];\\r\\n        for (const name in types) {\\r\\n          if (!types.hasOwnProperty(name)) continue;\\r\\n          const type = types[name];\\r\\n          const constant = constants[name];\\r\\n          switch (type) {\\r\\n            case 'Number':\\r\\n            case 'Integer':\\r\\n            case 'Float':\\r\\n            case 'Boolean':\\r\\n              results.push(`${name}:${constant}`);\\r\\n              break;\\r\\n            case 'Array(2)':\\r\\n            case 'Array(3)':\\r\\n            case 'Array(4)':\\r\\n            case 'Matrix(2)':\\r\\n            case 'Matrix(3)':\\r\\n            case 'Matrix(4)':\\r\\n              results.push(`${name}:new ${constant.constructor.name}(${JSON.stringify(Array.from(constant))})`);\\r\\n              break;\\r\\n          }\\r\\n        }\\r\\n        return `{ ${ results.join() } }`;\\r\\n      }\\r\\n      \\r\\n      function cpuKernelString(cpuKernel, name) {\\r\\n        const header = [];\\r\\n        const thisProperties = [];\\r\\n        const beforeReturn = [];\\r\\n      \\r\\n        const useFunctionKeyword = !/^function/.test(cpuKernel.color.toString());\\r\\n      \\r\\n        header.push(\\r\\n          '  const { context, canvas, constants: incomingConstants } = settings;',\\r\\n          `  const output = new Int32Array(${JSON.stringify(Array.from(cpuKernel.output))});`,\\r\\n          `  const _constantTypes = ${JSON.stringify(cpuKernel.constantTypes)};`,\\r\\n          `  const _constants = ${constantsToString(cpuKernel.constants, cpuKernel.constantTypes)};`,\\r\\n        );\\r\\n      \\r\\n        thisProperties.push(\\r\\n          '    constants: _constants,',\\r\\n          '    context,',\\r\\n          '    output,',\\r\\n          '    thread: {x: 0, y: 0, z: 0},',\\r\\n        );\\r\\n      \\r\\n        if (cpuKernel.graphical) {\\r\\n          header.push(`  const _imageData = context.createImageData(${cpuKernel.output[0]}, ${cpuKernel.output[1]});`);\\r\\n          header.push(`  const _colorData = new Uint8ClampedArray(${cpuKernel.output[0]} * ${cpuKernel.output[1]} * 4);`);\\r\\n      \\r\\n          const colorFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.color.toString(), {\\r\\n            thisLookup: (propertyName) => {\\r\\n              switch (propertyName) {\\r\\n                case '_colorData':\\r\\n                  return '_colorData';\\r\\n                case '_imageData':\\r\\n                  return '_imageData';\\r\\n                case 'output':\\r\\n                  return 'output';\\r\\n                case 'thread':\\r\\n                  return 'this.thread';\\r\\n              }\\r\\n              return JSON.stringify(cpuKernel[propertyName]);\\r\\n            },\\r\\n            findDependency: (object, name) => {\\r\\n              return null;\\r\\n            }\\r\\n          });\\r\\n      \\r\\n          const getPixelsFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.getPixels.toString(), {\\r\\n            thisLookup: (propertyName) => {\\r\\n              switch (propertyName) {\\r\\n                case '_colorData':\\r\\n                  return '_colorData';\\r\\n                case '_imageData':\\r\\n                  return '_imageData';\\r\\n                case 'output':\\r\\n                  return 'output';\\r\\n                case 'thread':\\r\\n                  return 'this.thread';\\r\\n              }\\r\\n              return JSON.stringify(cpuKernel[propertyName]);\\r\\n            },\\r\\n            findDependency: () => {\\r\\n              return null;\\r\\n            }\\r\\n          });\\r\\n      \\r\\n          thisProperties.push(\\r\\n            '    _imageData,',\\r\\n            '    _colorData,',\\r\\n            `    color: ${colorFn},`,\\r\\n          );\\r\\n      \\r\\n          beforeReturn.push(\\r\\n            `  kernel.getPixels = ${getPixelsFn};`\\r\\n          );\\r\\n        }\\r\\n      \\r\\n        const constantTypes = [];\\r\\n        const constantKeys = Object.keys(cpuKernel.constantTypes);\\r\\n        for (let i = 0; i < constantKeys.length; i++) {\\r\\n          constantTypes.push(cpuKernel.constantTypes[constantKeys]);\\r\\n        }\\r\\n        if (cpuKernel.argumentTypes.indexOf('HTMLImageArray') !== -1 || constantTypes.indexOf('HTMLImageArray') !== -1) {\\r\\n          const flattenedImageTo3DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo3DArray.toString(), {\\r\\n            doNotDefine: ['canvas'],\\r\\n            findDependency: (object, name) => {\\r\\n              if (object === 'this') {\\r\\n                return (useFunctionKeyword ? 'function ' : '') + cpuKernel[name].toString();\\r\\n              }\\r\\n              return null;\\r\\n            },\\r\\n            thisLookup: (propertyName) => {\\r\\n              switch (propertyName) {\\r\\n                case 'canvas':\\r\\n                  return;\\r\\n                case 'context':\\r\\n                  return 'context';\\r\\n              }\\r\\n            }\\r\\n          });\\r\\n          beforeReturn.push(flattenedImageTo3DArray);\\r\\n          thisProperties.push(`    _mediaTo2DArray,`);\\r\\n          thisProperties.push(`    _imageTo3DArray,`);\\r\\n        } else if (cpuKernel.argumentTypes.indexOf('HTMLImage') !== -1 || constantTypes.indexOf('HTMLImage') !== -1) {\\r\\n          const flattenedImageTo2DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._mediaTo2DArray.toString(), {\\r\\n            findDependency: (object, name) => {\\r\\n              return null;\\r\\n            },\\r\\n            thisLookup: (propertyName) => {\\r\\n              switch (propertyName) {\\r\\n                case 'canvas':\\r\\n                  return 'settings.canvas';\\r\\n                case 'context':\\r\\n                  return 'settings.context';\\r\\n              }\\r\\n              throw new Error('unhandled thisLookup');\\r\\n            }\\r\\n          });\\r\\n          beforeReturn.push(flattenedImageTo2DArray);\\r\\n          thisProperties.push(`    _mediaTo2DArray,`);\\r\\n        }\\r\\n      \\r\\n        return `function(settings) {\\r\\n      ${ header.join('\\\\n') }\\r\\n        for (const p in _constantTypes) {\\r\\n          if (!_constantTypes.hasOwnProperty(p)) continue;\\r\\n          const type = _constantTypes[p];\\r\\n          switch (type) {\\r\\n            case 'Number':\\r\\n            case 'Integer':\\r\\n            case 'Float':\\r\\n            case 'Boolean':\\r\\n            case 'Array(2)':\\r\\n            case 'Array(3)':\\r\\n            case 'Array(4)':\\r\\n            case 'Matrix(2)':\\r\\n            case 'Matrix(3)':\\r\\n            case 'Matrix(4)':\\r\\n              if (incomingConstants.hasOwnProperty(p)) {\\r\\n                console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');\\r\\n              }\\r\\n              continue;\\r\\n          }\\r\\n          if (!incomingConstants.hasOwnProperty(p)) {\\r\\n            throw new Error('constant ' + p + ' not found');\\r\\n          }\\r\\n          _constants[p] = incomingConstants[p];\\r\\n        }\\r\\n        const kernel = (function() {\\r\\n      ${cpuKernel._kernelString}\\r\\n        })\\r\\n          .apply({ ${thisProperties.join('\\\\n')} });\\r\\n        ${ beforeReturn.join('\\\\n') }\\r\\n        return kernel;\\r\\n      }`;\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        cpuKernelString\\r\\n      };\\r\\n      },{\\\"../../utils\\\":114}],8:[function(require,module,exports){\\r\\n      const { Kernel } = require('../kernel');\\r\\n      const { FunctionBuilder } = require('../function-builder');\\r\\n      const { CPUFunctionNode } = require('./function-node');\\r\\n      const { utils } = require('../../utils');\\r\\n      const { cpuKernelString } = require('./kernel-string');\\r\\n      \\r\\n      class CPUKernel extends Kernel {\\r\\n        static getFeatures() {\\r\\n          return this.features;\\r\\n        }\\r\\n        static get features() {\\r\\n          return Object.freeze({\\r\\n            kernelMap: true,\\r\\n            isIntegerDivisionAccurate: true\\r\\n          });\\r\\n        }\\r\\n        static get isSupported() {\\r\\n          return true;\\r\\n        }\\r\\n        static isContextMatch(context) {\\r\\n          return false;\\r\\n        }\\r\\n        static get mode() {\\r\\n          return 'cpu';\\r\\n        }\\r\\n      \\r\\n        static nativeFunctionArguments() {\\r\\n          return null;\\r\\n        }\\r\\n      \\r\\n        static nativeFunctionReturnType() {\\r\\n          throw new Error(`Looking up native function return type not supported on ${this.name}`);\\r\\n        }\\r\\n      \\r\\n        static combineKernels(combinedKernel) {\\r\\n          return combinedKernel;\\r\\n        }\\r\\n      \\r\\n        static getSignature(kernel, argumentTypes) {\\r\\n          return 'cpu' + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');\\r\\n        }\\r\\n      \\r\\n        constructor(source, settings) {\\r\\n          super(source, settings);\\r\\n          this.mergeSettings(source.settings || settings);\\r\\n      \\r\\n          this._imageData = null;\\r\\n          this._colorData = null;\\r\\n          this._kernelString = null;\\r\\n          this._prependedString = [];\\r\\n          this.thread = {\\r\\n            x: 0,\\r\\n            y: 0,\\r\\n            z: 0\\r\\n          };\\r\\n          this.translatedSources = null;\\r\\n        }\\r\\n      \\r\\n        initCanvas() {\\r\\n          if (typeof document !== 'undefined') {\\r\\n            return document.createElement('canvas');\\r\\n          } else if (typeof OffscreenCanvas !== 'undefined') {\\r\\n            return new OffscreenCanvas(0, 0);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        initContext() {\\r\\n          if (!this.canvas) return null;\\r\\n          return this.canvas.getContext('2d');\\r\\n        }\\r\\n      \\r\\n        initPlugins(settings) {\\r\\n          return [];\\r\\n        }\\r\\n      \\r\\n        validateSettings(args) {\\r\\n          if (!this.output || this.output.length === 0) {\\r\\n            if (args.length !== 1) {\\r\\n              throw new Error('Auto output only supported for kernels with only one input');\\r\\n            }\\r\\n      \\r\\n            const argType = utils.getVariableType(args[0], this.strictIntegers);\\r\\n            if (argType === 'Array') {\\r\\n              this.output = utils.getDimensions(argType);\\r\\n            } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {\\r\\n              this.output = args[0].output;\\r\\n            } else {\\r\\n              throw new Error('Auto output not supported for input type: ' + argType);\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          if (this.graphical) {\\r\\n            if (this.output.length !== 2) {\\r\\n              throw new Error('Output must have 2 dimensions on graphical mode');\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          this.checkOutput();\\r\\n        }\\r\\n      \\r\\n        translateSource() {\\r\\n          this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';\\r\\n          if (this.subKernels) {\\r\\n            const followingReturnStatement = [];\\r\\n            for (let i = 0; i < this.subKernels.length; i++) {\\r\\n              const {\\r\\n                name\\r\\n              } = this.subKernels[i];\\r\\n              followingReturnStatement.push(this.output.length > 1 ? `resultX_${ name }[x] = subKernelResult_${ name };\\\\n` : `result_${ name }[x] = subKernelResult_${ name };\\\\n`);\\r\\n            }\\r\\n            this.followingReturnStatement = followingReturnStatement.join('');\\r\\n          }\\r\\n          const functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);\\r\\n          this.translatedSources = functionBuilder.getPrototypes('kernel');\\r\\n          if (!this.graphical && !this.returnType) {\\r\\n            this.returnType = functionBuilder.getKernelResultType();\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        build() {\\r\\n          if (this.built) return;\\r\\n          this.setupConstants();\\r\\n          this.setupArguments(arguments);\\r\\n          this.validateSettings(arguments);\\r\\n          this.translateSource();\\r\\n      \\r\\n          if (this.graphical) {\\r\\n            const {\\r\\n              canvas,\\r\\n              output\\r\\n            } = this;\\r\\n            if (!canvas) {\\r\\n              throw new Error('no canvas available for using graphical output');\\r\\n            }\\r\\n            const width = output[0];\\r\\n            const height = output[1] || 1;\\r\\n            canvas.width = width;\\r\\n            canvas.height = height;\\r\\n            this._imageData = this.context.createImageData(width, height);\\r\\n            this._colorData = new Uint8ClampedArray(width * height * 4);\\r\\n          }\\r\\n      \\r\\n          const kernelString = this.getKernelString();\\r\\n          this.kernelString = kernelString;\\r\\n      \\r\\n          if (this.debug) {\\r\\n            console.log('Function output:');\\r\\n            console.log(kernelString);\\r\\n          }\\r\\n      \\r\\n          try {\\r\\n            this.run = new Function([], kernelString).bind(this)();\\r\\n          } catch (e) {\\r\\n            console.error('An error occurred compiling the javascript: ', e);\\r\\n          }\\r\\n          this.buildSignature(arguments);\\r\\n          this.built = true;\\r\\n        }\\r\\n      \\r\\n        color(r, g, b, a) {\\r\\n          if (typeof a === 'undefined') {\\r\\n            a = 1;\\r\\n          }\\r\\n      \\r\\n          r = Math.floor(r * 255);\\r\\n          g = Math.floor(g * 255);\\r\\n          b = Math.floor(b * 255);\\r\\n          a = Math.floor(a * 255);\\r\\n      \\r\\n          const width = this.output[0];\\r\\n          const height = this.output[1];\\r\\n      \\r\\n          const x = this.thread.x;\\r\\n          const y = height - this.thread.y - 1;\\r\\n      \\r\\n          const index = x + y * width;\\r\\n      \\r\\n          this._colorData[index * 4 + 0] = r;\\r\\n          this._colorData[index * 4 + 1] = g;\\r\\n          this._colorData[index * 4 + 2] = b;\\r\\n          this._colorData[index * 4 + 3] = a;\\r\\n        }\\r\\n      \\r\\n        getKernelString() {\\r\\n          if (this._kernelString !== null) return this._kernelString;\\r\\n      \\r\\n          let kernelThreadString = null;\\r\\n          let {\\r\\n            translatedSources\\r\\n          } = this;\\r\\n          if (translatedSources.length > 1) {\\r\\n            translatedSources = translatedSources.filter(fn => {\\r\\n              if (/^function/.test(fn)) return fn;\\r\\n              kernelThreadString = fn;\\r\\n              return false;\\r\\n            });\\r\\n          } else {\\r\\n            kernelThreadString = translatedSources.shift();\\r\\n          }\\r\\n          return this._kernelString = `  const LOOP_MAX = ${ this._getLoopMaxString() };\\r\\n        ${ this.injectedNative || '' }\\r\\n        const _this = this;\\r\\n        ${ this._resultKernelHeader() }\\r\\n        ${ this._processConstants() }\\r\\n        return (${ this.argumentNames.map(argumentName => 'user_' + argumentName).join(', ') }) => {\\r\\n          ${ this._prependedString.join('') }\\r\\n          ${ this._earlyThrows() }\\r\\n          ${ this._processArguments() }\\r\\n          ${ this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString) }\\r\\n          ${ translatedSources.length > 0 ? translatedSources.join('\\\\n') : '' }\\r\\n        };`;\\r\\n        }\\r\\n      \\r\\n        toString() {\\r\\n          return cpuKernelString(this);\\r\\n        }\\r\\n      \\r\\n        _getLoopMaxString() {\\r\\n          return (\\r\\n            this.loopMaxIterations ?\\r\\n            ` ${ parseInt(this.loopMaxIterations) };` :\\r\\n            ' 1000;'\\r\\n          );\\r\\n        }\\r\\n      \\r\\n        _processConstants() {\\r\\n          if (!this.constants) return '';\\r\\n      \\r\\n          const result = [];\\r\\n          for (let p in this.constants) {\\r\\n            const type = this.constantTypes[p];\\r\\n            switch (type) {\\r\\n              case 'HTMLCanvas':\\r\\n              case 'HTMLImage':\\r\\n              case 'HTMLVideo':\\r\\n                result.push(`    const constants_${p} = this._mediaTo2DArray(this.constants.${p});\\\\n`);\\r\\n                break;\\r\\n              case 'HTMLImageArray':\\r\\n                result.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});\\\\n`);\\r\\n                break;\\r\\n              case 'Input':\\r\\n                result.push(`    const constants_${p} = this.constants.${p}.value;\\\\n`);\\r\\n                break;\\r\\n              default:\\r\\n                result.push(`    const constants_${p} = this.constants.${p};\\\\n`);\\r\\n            }\\r\\n          }\\r\\n          return result.join('');\\r\\n        }\\r\\n      \\r\\n        _earlyThrows() {\\r\\n          if (this.graphical) return '';\\r\\n          if (this.immutable) return '';\\r\\n          if (!this.pipeline) return '';\\r\\n          const arrayArguments = [];\\r\\n          for (let i = 0; i < this.argumentTypes.length; i++) {\\r\\n            if (this.argumentTypes[i] === 'Array') {\\r\\n              arrayArguments.push(this.argumentNames[i]);\\r\\n            }\\r\\n          }\\r\\n          if (arrayArguments.length === 0) return '';\\r\\n          const checks = [];\\r\\n          for (let i = 0; i < arrayArguments.length; i++) {\\r\\n            const argumentName = arrayArguments[i];\\r\\n            const checkSubKernels = this._mapSubKernels(subKernel => `user_${argumentName} === result_${subKernel.name}`).join(' || ');\\r\\n            checks.push(`user_${argumentName} === result${checkSubKernels ? ` || ${checkSubKernels}` : ''}`);\\r\\n          }\\r\\n          return `if (${checks.join(' || ')}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`;\\r\\n        }\\r\\n      \\r\\n        _processArguments() {\\r\\n          const result = [];\\r\\n          for (let i = 0; i < this.argumentTypes.length; i++) {\\r\\n            const variableName = `user_${this.argumentNames[i]}`;\\r\\n            switch (this.argumentTypes[i]) {\\r\\n              case 'HTMLCanvas':\\r\\n              case 'HTMLImage':\\r\\n              case 'HTMLVideo':\\r\\n                result.push(`    ${variableName} = this._mediaTo2DArray(${variableName});\\\\n`);\\r\\n                break;\\r\\n              case 'HTMLImageArray':\\r\\n                result.push(`    ${variableName} = this._imageTo3DArray(${variableName});\\\\n`);\\r\\n                break;\\r\\n              case 'Input':\\r\\n                result.push(`    ${variableName} = ${variableName}.value;\\\\n`);\\r\\n                break;\\r\\n              case 'ArrayTexture(1)':\\r\\n              case 'ArrayTexture(2)':\\r\\n              case 'ArrayTexture(3)':\\r\\n              case 'ArrayTexture(4)':\\r\\n              case 'NumberTexture':\\r\\n              case 'MemoryOptimizedNumberTexture':\\r\\n                result.push(`\\r\\n          if (${variableName}.toArray) {\\r\\n            if (!_this.textureCache) {\\r\\n              _this.textureCache = [];\\r\\n              _this.arrayCache = [];\\r\\n            }\\r\\n            const textureIndex = _this.textureCache.indexOf(${variableName});\\r\\n            if (textureIndex !== -1) {\\r\\n              ${variableName} = _this.arrayCache[textureIndex];\\r\\n            } else {\\r\\n              _this.textureCache.push(${variableName});\\r\\n              ${variableName} = ${variableName}.toArray();\\r\\n              _this.arrayCache.push(${variableName});\\r\\n            }\\r\\n          }`);\\r\\n                break;\\r\\n            }\\r\\n          }\\r\\n          return result.join('');\\r\\n        }\\r\\n      \\r\\n        _mediaTo2DArray(media) {\\r\\n          const canvas = this.canvas;\\r\\n          const width = media.width > 0 ? media.width : media.videoWidth;\\r\\n          const height = media.height > 0 ? media.height : media.videoHeight;\\r\\n          if (canvas.width < width) {\\r\\n            canvas.width = width;\\r\\n          }\\r\\n          if (canvas.height < height) {\\r\\n            canvas.height = height;\\r\\n          }\\r\\n          const ctx = this.context;\\r\\n          ctx.drawImage(media, 0, 0, width, height);\\r\\n          const pixelsData = ctx.getImageData(0, 0, width, height).data;\\r\\n          const imageArray = new Array(height);\\r\\n          let index = 0;\\r\\n          for (let y = height - 1; y >= 0; y--) {\\r\\n            const row = imageArray[y] = new Array(width);\\r\\n            for (let x = 0; x < width; x++) {\\r\\n              const pixel = new Float32Array(4);\\r\\n              pixel[0] = pixelsData[index++] / 255; \\r\\n              pixel[1] = pixelsData[index++] / 255; \\r\\n              pixel[2] = pixelsData[index++] / 255; \\r\\n              pixel[3] = pixelsData[index++] / 255; \\r\\n              row[x] = pixel;\\r\\n            }\\r\\n          }\\r\\n          return imageArray;\\r\\n        }\\r\\n      \\r\\n        getPixels(flip) {\\r\\n          const [width, height] = this.output;\\r\\n          return flip ? utils.flipPixels(this._imageData.data, width, height) : this._imageData.data.slice(0);\\r\\n        }\\r\\n      \\r\\n        _imageTo3DArray(images) {\\r\\n          const imagesArray = new Array(images.length);\\r\\n          for (let i = 0; i < images.length; i++) {\\r\\n            imagesArray[i] = this._mediaTo2DArray(images[i]);\\r\\n          }\\r\\n          return imagesArray;\\r\\n        }\\r\\n      \\r\\n        _resultKernelHeader() {\\r\\n          if (this.graphical) return '';\\r\\n          if (this.immutable) return '';\\r\\n          if (!this.pipeline) return '';\\r\\n          switch (this.output.length) {\\r\\n            case 1:\\r\\n              return this._mutableKernel1DResults();\\r\\n            case 2:\\r\\n              return this._mutableKernel2DResults();\\r\\n            case 3:\\r\\n              return this._mutableKernel3DResults();\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        _resultKernelBody(kernelString) {\\r\\n          switch (this.output.length) {\\r\\n            case 1:\\r\\n              return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(kernelString) : this._resultImmutableKernel1DLoop(kernelString)) + this._kernelOutput();\\r\\n            case 2:\\r\\n              return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(kernelString) : this._resultImmutableKernel2DLoop(kernelString)) + this._kernelOutput();\\r\\n            case 3:\\r\\n              return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(kernelString) : this._resultImmutableKernel3DLoop(kernelString)) + this._kernelOutput();\\r\\n            default:\\r\\n              throw new Error('unsupported size kernel');\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        _graphicalKernelBody(kernelThreadString) {\\r\\n          switch (this.output.length) {\\r\\n            case 2:\\r\\n              return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();\\r\\n            default:\\r\\n              throw new Error('unsupported size kernel');\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        _graphicalOutput() {\\r\\n          return `\\r\\n          this._imageData.data.set(this._colorData);\\r\\n          this.context.putImageData(this._imageData, 0, 0);\\r\\n          return;`\\r\\n        }\\r\\n      \\r\\n        _getKernelResultTypeConstructorString() {\\r\\n          switch (this.returnType) {\\r\\n            case 'LiteralInteger':\\r\\n            case 'Number':\\r\\n            case 'Integer':\\r\\n            case 'Float':\\r\\n              return 'Float32Array';\\r\\n            case 'Array(2)':\\r\\n            case 'Array(3)':\\r\\n            case 'Array(4)':\\r\\n              return 'Array';\\r\\n            default:\\r\\n              if (this.graphical) {\\r\\n                return 'Float32Array';\\r\\n              }\\r\\n              throw new Error(`unhandled returnType ${ this.returnType }`);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        _resultImmutableKernel1DLoop(kernelString) {\\r\\n          const constructorString = this._getKernelResultTypeConstructorString();\\r\\n          return `  const outputX = _this.output[0];\\r\\n          const result = new ${constructorString}(outputX);\\r\\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\\\\n`).join('    ') }\\r\\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\\\n`).join('    ') }\\r\\n          for (let x = 0; x < outputX; x++) {\\r\\n            this.thread.x = x;\\r\\n            this.thread.y = 0;\\r\\n            this.thread.z = 0;\\r\\n            ${ kernelString }\\r\\n          }`;\\r\\n        }\\r\\n      \\r\\n        _mutableKernel1DResults() {\\r\\n          const constructorString = this._getKernelResultTypeConstructorString();\\r\\n          return `  const outputX = _this.output[0];\\r\\n          const result = new ${constructorString}(outputX);\\r\\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\\\\n`).join('    ') }\\r\\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\\\n`).join('    ') }`;\\r\\n        }\\r\\n      \\r\\n        _resultMutableKernel1DLoop(kernelString) {\\r\\n          return `  const outputX = _this.output[0];\\r\\n          for (let x = 0; x < outputX; x++) {\\r\\n            this.thread.x = x;\\r\\n            this.thread.y = 0;\\r\\n            this.thread.z = 0;\\r\\n            ${ kernelString }\\r\\n          }`;\\r\\n        }\\r\\n      \\r\\n        _resultImmutableKernel2DLoop(kernelString) {\\r\\n          const constructorString = this._getKernelResultTypeConstructorString();\\r\\n          return `  const outputX = _this.output[0];\\r\\n          const outputY = _this.output[1];\\r\\n          const result = new Array(outputY);\\r\\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\\\\n`).join('    ') }\\r\\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\\\n`).join('    ') }\\r\\n          for (let y = 0; y < outputY; y++) {\\r\\n            this.thread.z = 0;\\r\\n            this.thread.y = y;\\r\\n            const resultX = result[y] = new ${constructorString}(outputX);\\r\\n            ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\\\\n`).join('') }\\r\\n            for (let x = 0; x < outputX; x++) {\\r\\n              this.thread.x = x;\\r\\n              ${ kernelString }\\r\\n            }\\r\\n          }`;\\r\\n        }\\r\\n      \\r\\n        _mutableKernel2DResults() {\\r\\n          const constructorString = this._getKernelResultTypeConstructorString();\\r\\n          return `  const outputX = _this.output[0];\\r\\n          const outputY = _this.output[1];\\r\\n          const result = new Array(outputY);\\r\\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\\\\n`).join('    ') }\\r\\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\\\n`).join('    ') }\\r\\n          for (let y = 0; y < outputY; y++) {\\r\\n            const resultX = result[y] = new ${constructorString}(outputX);\\r\\n            ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\\\\n`).join('') }\\r\\n          }`;\\r\\n        }\\r\\n      \\r\\n        _resultMutableKernel2DLoop(kernelString) {\\r\\n          const constructorString = this._getKernelResultTypeConstructorString();\\r\\n          return `  const outputX = _this.output[0];\\r\\n          const outputY = _this.output[1];\\r\\n          for (let y = 0; y < outputY; y++) {\\r\\n            this.thread.z = 0;\\r\\n            this.thread.y = y;\\r\\n            const resultX = result[y];\\r\\n            ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\\\\n`).join('') }\\r\\n            for (let x = 0; x < outputX; x++) {\\r\\n              this.thread.x = x;\\r\\n              ${ kernelString }\\r\\n            }\\r\\n          }`;\\r\\n        }\\r\\n      \\r\\n        _graphicalKernel2DLoop(kernelString) {\\r\\n          return `  const outputX = _this.output[0];\\r\\n          const outputY = _this.output[1];\\r\\n          for (let y = 0; y < outputY; y++) {\\r\\n            this.thread.z = 0;\\r\\n            this.thread.y = y;\\r\\n            for (let x = 0; x < outputX; x++) {\\r\\n              this.thread.x = x;\\r\\n              ${ kernelString }\\r\\n            }\\r\\n          }`;\\r\\n        }\\r\\n      \\r\\n        _resultImmutableKernel3DLoop(kernelString) {\\r\\n          const constructorString = this._getKernelResultTypeConstructorString();\\r\\n          return `  const outputX = _this.output[0];\\r\\n          const outputY = _this.output[1];\\r\\n          const outputZ = _this.output[2];\\r\\n          const result = new Array(outputZ);\\r\\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\\\\n`).join('    ') }\\r\\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\\\n`).join('    ') }\\r\\n          for (let z = 0; z < outputZ; z++) {\\r\\n            this.thread.z = z;\\r\\n            const resultY = result[z] = new Array(outputY);\\r\\n            ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\\\\n`).join('      ') }\\r\\n            for (let y = 0; y < outputY; y++) {\\r\\n              this.thread.y = y;\\r\\n              const resultX = resultY[y] = new ${constructorString}(outputX);\\r\\n              ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\\\\n`).join('        ') }\\r\\n              for (let x = 0; x < outputX; x++) {\\r\\n                this.thread.x = x;\\r\\n                ${ kernelString }\\r\\n              }\\r\\n            }\\r\\n          }`;\\r\\n        }\\r\\n      \\r\\n        _mutableKernel3DResults() {\\r\\n          const constructorString = this._getKernelResultTypeConstructorString();\\r\\n          return `  const outputX = _this.output[0];\\r\\n          const outputY = _this.output[1];\\r\\n          const outputZ = _this.output[2];\\r\\n          const result = new Array(outputZ);\\r\\n          ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\\\\n`).join('    ') }\\r\\n          ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\\\\n`).join('    ') }\\r\\n          for (let z = 0; z < outputZ; z++) {\\r\\n            const resultY = result[z] = new Array(outputY);\\r\\n            ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\\\\n`).join('      ') }\\r\\n            for (let y = 0; y < outputY; y++) {\\r\\n              const resultX = resultY[y] = new ${constructorString}(outputX);\\r\\n              ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\\\\n`).join('        ') }\\r\\n            }\\r\\n          }`;\\r\\n        }\\r\\n      \\r\\n        _resultMutableKernel3DLoop(kernelString) {\\r\\n          return `  const outputX = _this.output[0];\\r\\n          const outputY = _this.output[1];\\r\\n          const outputZ = _this.output[2];\\r\\n          for (let z = 0; z < outputZ; z++) {\\r\\n            this.thread.z = z;\\r\\n            const resultY = result[z];\\r\\n            for (let y = 0; y < outputY; y++) {\\r\\n              this.thread.y = y;\\r\\n              const resultX = resultY[y];\\r\\n              for (let x = 0; x < outputX; x++) {\\r\\n                this.thread.x = x;\\r\\n                ${ kernelString }\\r\\n              }\\r\\n            }\\r\\n          }`;\\r\\n        }\\r\\n      \\r\\n        _kernelOutput() {\\r\\n          if (!this.subKernels) {\\r\\n            return '\\\\n    return result;';\\r\\n          }\\r\\n          return `\\\\n    return {\\r\\n            result: result,\\r\\n            ${ this.subKernels.map(subKernel => `${ subKernel.property }: result_${ subKernel.name }`).join(',\\\\n      ') }\\r\\n          };`;\\r\\n        }\\r\\n      \\r\\n        _mapSubKernels(fn) {\\r\\n          return this.subKernels === null ? [''] :\\r\\n            this.subKernels.map(fn);\\r\\n        }\\r\\n      \\r\\n        destroy(removeCanvasReference) {\\r\\n          if (removeCanvasReference) {\\r\\n            delete this.canvas;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        static destroyContext(context) {}\\r\\n      \\r\\n        toJSON() {\\r\\n          const json = super.toJSON();\\r\\n          json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();\\r\\n          return json;\\r\\n        }\\r\\n      \\r\\n        setOutput(output) {\\r\\n          super.setOutput(output);\\r\\n          const [width, height] = this.output;\\r\\n          if (this.graphical) {\\r\\n            this._imageData = this.context.createImageData(width, height);\\r\\n            this._colorData = new Uint8ClampedArray(width * height * 4);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        prependString(value) {\\r\\n          if (this._kernelString) throw new Error('Kernel already built');\\r\\n          this._prependedString.push(value);\\r\\n        }\\r\\n      \\r\\n        hasPrependString(value) {\\r\\n          return this._prependedString.indexOf(value) > -1;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        CPUKernel\\r\\n      };\\r\\n      },{\\\"../../utils\\\":114,\\\"../function-builder\\\":9,\\\"../kernel\\\":36,\\\"./function-node\\\":6,\\\"./kernel-string\\\":7}],9:[function(require,module,exports){\\r\\n      class FunctionBuilder {\\r\\n        static fromKernel(kernel, FunctionNode, extraNodeOptions) {\\r\\n          const {\\r\\n            kernelArguments,\\r\\n            kernelConstants,\\r\\n            argumentNames,\\r\\n            argumentSizes,\\r\\n            argumentBitRatios,\\r\\n            constants,\\r\\n            constantBitRatios,\\r\\n            debug,\\r\\n            loopMaxIterations,\\r\\n            nativeFunctions,\\r\\n            output,\\r\\n            optimizeFloatMemory,\\r\\n            precision,\\r\\n            plugins,\\r\\n            source,\\r\\n            subKernels,\\r\\n            functions,\\r\\n            leadingReturnStatement,\\r\\n            followingReturnStatement,\\r\\n            dynamicArguments,\\r\\n            dynamicOutput,\\r\\n          } = kernel;\\r\\n      \\r\\n          const argumentTypes = new Array(kernelArguments.length);\\r\\n          const constantTypes = {};\\r\\n      \\r\\n          for (let i = 0; i < kernelArguments.length; i++) {\\r\\n            argumentTypes[i] = kernelArguments[i].type;\\r\\n          }\\r\\n      \\r\\n          for (let i = 0; i < kernelConstants.length; i++) {\\r\\n            const kernelConstant = kernelConstants[i];\\r\\n            constantTypes[kernelConstant.name] = kernelConstant.type;\\r\\n          }\\r\\n      \\r\\n          const needsArgumentType = (functionName, index) => {\\r\\n            return functionBuilder.needsArgumentType(functionName, index);\\r\\n          };\\r\\n      \\r\\n          const assignArgumentType = (functionName, index, type) => {\\r\\n            functionBuilder.assignArgumentType(functionName, index, type);\\r\\n          };\\r\\n      \\r\\n          const lookupReturnType = (functionName, ast, requestingNode) => {\\r\\n            return functionBuilder.lookupReturnType(functionName, ast, requestingNode);\\r\\n          };\\r\\n      \\r\\n          const lookupFunctionArgumentTypes = (functionName) => {\\r\\n            return functionBuilder.lookupFunctionArgumentTypes(functionName);\\r\\n          };\\r\\n      \\r\\n          const lookupFunctionArgumentName = (functionName, argumentIndex) => {\\r\\n            return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);\\r\\n          };\\r\\n      \\r\\n          const lookupFunctionArgumentBitRatio = (functionName, argumentName) => {\\r\\n            return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);\\r\\n          };\\r\\n      \\r\\n          const triggerImplyArgumentType = (functionName, i, argumentType, requestingNode) => {\\r\\n            functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);\\r\\n          };\\r\\n      \\r\\n          const triggerImplyArgumentBitRatio = (functionName, argumentName, calleeFunctionName, argumentIndex) => {\\r\\n            functionBuilder.assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex);\\r\\n          };\\r\\n      \\r\\n          const onFunctionCall = (functionName, calleeFunctionName, args) => {\\r\\n            functionBuilder.trackFunctionCall(functionName, calleeFunctionName, args);\\r\\n          };\\r\\n      \\r\\n          const onNestedFunction = (ast, source) => {\\r\\n            const argumentNames = [];\\r\\n            for (let i = 0; i < ast.params.length; i++) {\\r\\n              argumentNames.push(ast.params[i].name);\\r\\n            }\\r\\n            const nestedFunction = new FunctionNode(source, Object.assign({}, nodeOptions, {\\r\\n              returnType: null,\\r\\n              ast,\\r\\n              name: ast.id.name,\\r\\n              argumentNames,\\r\\n              lookupReturnType,\\r\\n              lookupFunctionArgumentTypes,\\r\\n              lookupFunctionArgumentName,\\r\\n              lookupFunctionArgumentBitRatio,\\r\\n              needsArgumentType,\\r\\n              assignArgumentType,\\r\\n              triggerImplyArgumentType,\\r\\n              triggerImplyArgumentBitRatio,\\r\\n              onFunctionCall,\\r\\n            }));\\r\\n            nestedFunction.traceFunctionAST(ast);\\r\\n            functionBuilder.addFunctionNode(nestedFunction);\\r\\n          };\\r\\n      \\r\\n          const nodeOptions = Object.assign({\\r\\n            isRootKernel: false,\\r\\n            onNestedFunction,\\r\\n            lookupReturnType,\\r\\n            lookupFunctionArgumentTypes,\\r\\n            lookupFunctionArgumentName,\\r\\n            lookupFunctionArgumentBitRatio,\\r\\n            needsArgumentType,\\r\\n            assignArgumentType,\\r\\n            triggerImplyArgumentType,\\r\\n            triggerImplyArgumentBitRatio,\\r\\n            onFunctionCall,\\r\\n            optimizeFloatMemory,\\r\\n            precision,\\r\\n            constants,\\r\\n            constantTypes,\\r\\n            constantBitRatios,\\r\\n            debug,\\r\\n            loopMaxIterations,\\r\\n            output,\\r\\n            plugins,\\r\\n            dynamicArguments,\\r\\n            dynamicOutput,\\r\\n          }, extraNodeOptions || {});\\r\\n      \\r\\n          const rootNodeOptions = Object.assign({}, nodeOptions, {\\r\\n            isRootKernel: true,\\r\\n            name: 'kernel',\\r\\n            argumentNames,\\r\\n            argumentTypes,\\r\\n            argumentSizes,\\r\\n            argumentBitRatios,\\r\\n            leadingReturnStatement,\\r\\n            followingReturnStatement,\\r\\n          });\\r\\n      \\r\\n          if (typeof source === 'object' && source.functionNodes) {\\r\\n            return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);\\r\\n          }\\r\\n      \\r\\n          const rootNode = new FunctionNode(source, rootNodeOptions);\\r\\n      \\r\\n          let functionNodes = null;\\r\\n          if (functions) {\\r\\n            functionNodes = functions.map((fn) => new FunctionNode(fn.source, {\\r\\n              returnType: fn.returnType,\\r\\n              argumentTypes: fn.argumentTypes,\\r\\n              output,\\r\\n              plugins,\\r\\n              constants,\\r\\n              constantTypes,\\r\\n              constantBitRatios,\\r\\n              optimizeFloatMemory,\\r\\n              precision,\\r\\n              lookupReturnType,\\r\\n              lookupFunctionArgumentTypes,\\r\\n              lookupFunctionArgumentName,\\r\\n              lookupFunctionArgumentBitRatio,\\r\\n              needsArgumentType,\\r\\n              assignArgumentType,\\r\\n              triggerImplyArgumentType,\\r\\n              triggerImplyArgumentBitRatio,\\r\\n              onFunctionCall,\\r\\n              onNestedFunction,\\r\\n            }));\\r\\n          }\\r\\n      \\r\\n          let subKernelNodes = null;\\r\\n          if (subKernels) {\\r\\n            subKernelNodes = subKernels.map((subKernel) => {\\r\\n              const { name, source } = subKernel;\\r\\n              return new FunctionNode(source, Object.assign({}, nodeOptions, {\\r\\n                name,\\r\\n                isSubKernel: true,\\r\\n                isRootKernel: false,\\r\\n              }));\\r\\n            });\\r\\n          }\\r\\n      \\r\\n          const functionBuilder = new FunctionBuilder({\\r\\n            kernel,\\r\\n            rootNode,\\r\\n            functionNodes,\\r\\n            nativeFunctions,\\r\\n            subKernelNodes\\r\\n          });\\r\\n      \\r\\n          return functionBuilder;\\r\\n        }\\r\\n      \\r\\n        constructor(settings) {\\r\\n          settings = settings || {};\\r\\n          this.kernel = settings.kernel;\\r\\n          this.rootNode = settings.rootNode;\\r\\n          this.functionNodes = settings.functionNodes || [];\\r\\n          this.subKernelNodes = settings.subKernelNodes || [];\\r\\n          this.nativeFunctions = settings.nativeFunctions || [];\\r\\n          this.functionMap = {};\\r\\n          this.nativeFunctionNames = [];\\r\\n          this.lookupChain = [];\\r\\n          this.functionNodeDependencies = {};\\r\\n          this.functionCalls = {};\\r\\n      \\r\\n          if (this.rootNode) {\\r\\n            this.functionMap['kernel'] = this.rootNode;\\r\\n          }\\r\\n      \\r\\n          if (this.functionNodes) {\\r\\n            for (let i = 0; i < this.functionNodes.length; i++) {\\r\\n              this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          if (this.subKernelNodes) {\\r\\n            for (let i = 0; i < this.subKernelNodes.length; i++) {\\r\\n              this.functionMap[this.subKernelNodes[i].name] = this.subKernelNodes[i];\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          if (this.nativeFunctions) {\\r\\n            for (let i = 0; i < this.nativeFunctions.length; i++) {\\r\\n              const nativeFunction = this.nativeFunctions[i];\\r\\n              this.nativeFunctionNames.push(nativeFunction.name);\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        addFunctionNode(functionNode) {\\r\\n          if (!functionNode.name) throw new Error('functionNode.name needs set');\\r\\n          this.functionMap[functionNode.name] = functionNode;\\r\\n          if (functionNode.isRootKernel) {\\r\\n            this.rootNode = functionNode;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        traceFunctionCalls(functionName, retList) {\\r\\n          functionName = functionName || 'kernel';\\r\\n          retList = retList || [];\\r\\n      \\r\\n          if (this.nativeFunctionNames.indexOf(functionName) > -1) {\\r\\n            const nativeFunctionIndex = retList.indexOf(functionName);\\r\\n            if (nativeFunctionIndex === -1) {\\r\\n              retList.push(functionName);\\r\\n            } else {\\r\\n              const dependantNativeFunctionName = retList.splice(nativeFunctionIndex, 1)[0];\\r\\n              retList.push(dependantNativeFunctionName);\\r\\n            }\\r\\n            return retList;\\r\\n          }\\r\\n      \\r\\n          const functionNode = this.functionMap[functionName];\\r\\n          if (functionNode) {\\r\\n            const functionIndex = retList.indexOf(functionName);\\r\\n            if (functionIndex === -1) {\\r\\n              retList.push(functionName);\\r\\n              functionNode.toString(); \\r\\n              for (let i = 0; i < functionNode.calledFunctions.length; ++i) {\\r\\n                this.traceFunctionCalls(functionNode.calledFunctions[i], retList);\\r\\n              }\\r\\n            } else {\\r\\n              const dependantFunctionName = retList.splice(functionIndex, 1)[0];\\r\\n              retList.push(dependantFunctionName);\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          return retList;\\r\\n        }\\r\\n      \\r\\n        getPrototypeString(functionName) {\\r\\n          return this.getPrototypes(functionName).join('\\\\n');\\r\\n        }\\r\\n      \\r\\n        getPrototypes(functionName) {\\r\\n          if (this.rootNode) {\\r\\n            this.rootNode.toString();\\r\\n          }\\r\\n          if (functionName) {\\r\\n            return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());\\r\\n          }\\r\\n          return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));\\r\\n        }\\r\\n      \\r\\n        getStringFromFunctionNames(functionList) {\\r\\n          const ret = [];\\r\\n          for (let i = 0; i < functionList.length; ++i) {\\r\\n            const node = this.functionMap[functionList[i]];\\r\\n            if (node) {\\r\\n              ret.push(this.functionMap[functionList[i]].toString());\\r\\n            }\\r\\n          }\\r\\n          return ret.join('\\\\n');\\r\\n        }\\r\\n      \\r\\n        getPrototypesFromFunctionNames(functionList) {\\r\\n          const ret = [];\\r\\n          for (let i = 0; i < functionList.length; ++i) {\\r\\n            const functionName = functionList[i];\\r\\n            const functionIndex = this.nativeFunctionNames.indexOf(functionName);\\r\\n            if (functionIndex > -1) {\\r\\n              ret.push(this.nativeFunctions[functionIndex].source);\\r\\n              continue;\\r\\n            }\\r\\n            const node = this.functionMap[functionName];\\r\\n            if (node) {\\r\\n              ret.push(node.toString());\\r\\n            }\\r\\n          }\\r\\n          return ret;\\r\\n        }\\r\\n      \\r\\n        toJSON() {\\r\\n          return this.traceFunctionCalls(this.rootNode.name).reverse().map(name => {\\r\\n            const nativeIndex = this.nativeFunctions.indexOf(name);\\r\\n            if (nativeIndex > -1) {\\r\\n              return {\\r\\n                name,\\r\\n                source: this.nativeFunctions[nativeIndex].source\\r\\n              };\\r\\n            } else if (this.functionMap[name]) {\\r\\n              return this.functionMap[name].toJSON();\\r\\n            } else {\\r\\n              throw new Error(`function ${ name } not found`);\\r\\n            }\\r\\n          });\\r\\n        }\\r\\n      \\r\\n        fromJSON(jsonFunctionNodes, FunctionNode) {\\r\\n          this.functionMap = {};\\r\\n          for (let i = 0; i < jsonFunctionNodes.length; i++) {\\r\\n            const jsonFunctionNode = jsonFunctionNodes[i];\\r\\n            this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);\\r\\n          }\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        getString(functionName) {\\r\\n          if (functionName) {\\r\\n            return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());\\r\\n          }\\r\\n          return this.getStringFromFunctionNames(Object.keys(this.functionMap));\\r\\n        }\\r\\n      \\r\\n        lookupReturnType(functionName, ast, requestingNode) {\\r\\n          if (ast.type !== 'CallExpression') {\\r\\n            throw new Error(`expected ast type of \\\"CallExpression\\\", but is ${ ast.type }`);\\r\\n          }\\r\\n          if (this._isNativeFunction(functionName)) {\\r\\n            return this._lookupNativeFunctionReturnType(functionName);\\r\\n          } else if (this._isFunction(functionName)) {\\r\\n            const node = this._getFunction(functionName);\\r\\n            if (node.returnType) {\\r\\n              return node.returnType;\\r\\n            } else {\\r\\n              for (let i = 0; i < this.lookupChain.length; i++) {\\r\\n                if (this.lookupChain[i].ast === ast) {\\r\\n                  if (node.argumentTypes.length === 0 && ast.arguments.length > 0) {\\r\\n                    const args = ast.arguments;\\r\\n                    for (let j = 0; j < args.length; j++) {\\r\\n                      this.lookupChain.push({\\r\\n                        name: requestingNode.name,\\r\\n                        ast: args[i],\\r\\n                        requestingNode\\r\\n                      });\\r\\n                      node.argumentTypes[j] = requestingNode.getType(args[j]);\\r\\n                      this.lookupChain.pop();\\r\\n                    }\\r\\n                    return node.returnType = node.getType(node.getJsAST());\\r\\n                  }\\r\\n      \\r\\n                  throw new Error('circlical logic detected!');\\r\\n                }\\r\\n              }\\r\\n              this.lookupChain.push({\\r\\n                name: requestingNode.name,\\r\\n                ast,\\r\\n                requestingNode\\r\\n              });\\r\\n              const type = node.getType(node.getJsAST());\\r\\n              this.lookupChain.pop();\\r\\n              return node.returnType = type;\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          return null;\\r\\n        }\\r\\n      \\r\\n        _getFunction(functionName) {\\r\\n          if (!this._isFunction(functionName)) {\\r\\n            new Error(`Function ${functionName} not found`);\\r\\n          }\\r\\n          return this.functionMap[functionName];\\r\\n        }\\r\\n      \\r\\n        _isFunction(functionName) {\\r\\n          return Boolean(this.functionMap[functionName]);\\r\\n        }\\r\\n      \\r\\n        _getNativeFunction(functionName) {\\r\\n          for (let i = 0; i < this.nativeFunctions.length; i++) {\\r\\n            if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];\\r\\n          }\\r\\n          return null;\\r\\n        }\\r\\n      \\r\\n        _isNativeFunction(functionName) {\\r\\n          return Boolean(this._getNativeFunction(functionName));\\r\\n        }\\r\\n      \\r\\n        _lookupNativeFunctionReturnType(functionName) {\\r\\n          let nativeFunction = this._getNativeFunction(functionName);\\r\\n          if (nativeFunction) {\\r\\n            return nativeFunction.returnType;\\r\\n          }\\r\\n          throw new Error(`Native function ${ functionName } not found`);\\r\\n        }\\r\\n      \\r\\n        lookupFunctionArgumentTypes(functionName) {\\r\\n          if (this._isNativeFunction(functionName)) {\\r\\n            return this._getNativeFunction(functionName).argumentTypes;\\r\\n          } else if (this._isFunction(functionName)) {\\r\\n            return this._getFunction(functionName).argumentTypes;\\r\\n          }\\r\\n          return null;\\r\\n        }\\r\\n      \\r\\n        lookupFunctionArgumentName(functionName, argumentIndex) {\\r\\n          return this._getFunction(functionName).argumentNames[argumentIndex];\\r\\n        }\\r\\n      \\r\\n        lookupFunctionArgumentBitRatio(functionName, argumentName) {\\r\\n          if (!this._isFunction(functionName)) {\\r\\n            throw new Error('function not found');\\r\\n          }\\r\\n          if (this.rootNode.name === functionName) {\\r\\n            const i = this.rootNode.argumentNames.indexOf(argumentName);\\r\\n            if (i !== -1) {\\r\\n              return this.rootNode.argumentBitRatios[i];\\r\\n            }\\r\\n          }\\r\\n          const node = this._getFunction(functionName);\\r\\n          const i = node.argumentNames.indexOf(argumentName);\\r\\n          if (i === -1) {\\r\\n            throw new Error('argument not found');\\r\\n          }\\r\\n          const bitRatio = node.argumentBitRatios[i];\\r\\n          if (typeof bitRatio !== 'number') {\\r\\n            throw new Error('argument bit ratio not found');\\r\\n          }\\r\\n          return bitRatio;\\r\\n        }\\r\\n      \\r\\n        needsArgumentType(functionName, i) {\\r\\n          if (!this._isFunction(functionName)) return false;\\r\\n          const fnNode = this._getFunction(functionName);\\r\\n          return !fnNode.argumentTypes[i];\\r\\n        }\\r\\n      \\r\\n        assignArgumentType(functionName, i, argumentType, requestingNode) {\\r\\n          if (!this._isFunction(functionName)) return;\\r\\n          const fnNode = this._getFunction(functionName);\\r\\n          if (!fnNode.argumentTypes[i]) {\\r\\n            fnNode.argumentTypes[i] = argumentType;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex) {\\r\\n          const node = this._getFunction(functionName);\\r\\n          if (this._isNativeFunction(calleeFunctionName)) return null;\\r\\n          const calleeNode = this._getFunction(calleeFunctionName);\\r\\n          const i = node.argumentNames.indexOf(argumentName);\\r\\n          if (i === -1) {\\r\\n            throw new Error(`Argument ${argumentName} not found in arguments from function ${functionName}`);\\r\\n          }\\r\\n          const bitRatio = node.argumentBitRatios[i];\\r\\n          if (typeof bitRatio !== 'number') {\\r\\n            throw new Error(`Bit ratio for argument ${argumentName} not found in function ${functionName}`);\\r\\n          }\\r\\n          if (!calleeNode.argumentBitRatios) {\\r\\n            calleeNode.argumentBitRatios = new Array(calleeNode.argumentNames.length);\\r\\n          }\\r\\n          const calleeBitRatio = calleeNode.argumentBitRatios[i];\\r\\n          if (typeof calleeBitRatio === 'number') {\\r\\n            if (calleeBitRatio !== bitRatio) {\\r\\n              throw new Error(`Incompatible bit ratio found at function ${functionName} at argument ${argumentName}`);\\r\\n            }\\r\\n            return calleeBitRatio;\\r\\n          }\\r\\n          calleeNode.argumentBitRatios[i] = bitRatio;\\r\\n          return bitRatio;\\r\\n        }\\r\\n      \\r\\n        trackFunctionCall(functionName, calleeFunctionName, args) {\\r\\n          if (!this.functionNodeDependencies[functionName]) {\\r\\n            this.functionNodeDependencies[functionName] = new Set();\\r\\n            this.functionCalls[functionName] = [];\\r\\n          }\\r\\n          this.functionNodeDependencies[functionName].add(calleeFunctionName);\\r\\n          this.functionCalls[functionName].push(args);\\r\\n        }\\r\\n      \\r\\n        getKernelResultType() {\\r\\n          return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);\\r\\n        }\\r\\n      \\r\\n        getSubKernelResultType(index) {\\r\\n          const subKernelNode = this.subKernelNodes[index];\\r\\n          let called = false;\\r\\n          for (let functionCallIndex = 0; functionCallIndex < this.rootNode.functionCalls.length; functionCallIndex++) {\\r\\n            const functionCall = this.rootNode.functionCalls[functionCallIndex];\\r\\n            if (functionCall.ast.callee.name === subKernelNode.name) {\\r\\n              called = true;\\r\\n            }\\r\\n          }\\r\\n          if (!called) {\\r\\n            throw new Error(`SubKernel ${ subKernelNode.name } never called by kernel`);\\r\\n          }\\r\\n          return subKernelNode.returnType || subKernelNode.getType(subKernelNode.getJsAST());\\r\\n        }\\r\\n      \\r\\n        getReturnTypes() {\\r\\n          const result = {\\r\\n            [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast),\\r\\n          };\\r\\n          const list = this.traceFunctionCalls(this.rootNode.name);\\r\\n          for (let i = 0; i < list.length; i++) {\\r\\n            const functionName = list[i];\\r\\n            const functionNode = this.functionMap[functionName];\\r\\n            result[functionName] = functionNode.getType(functionNode.ast);\\r\\n          }\\r\\n          return result;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        FunctionBuilder\\r\\n      };\\r\\n      },{}],10:[function(require,module,exports){\\r\\n      const acorn = require('acorn');\\r\\n      const { utils } = require('../utils');\\r\\n      const { FunctionTracer } = require('./function-tracer');\\r\\n      \\r\\n      class FunctionNode {\\r\\n        constructor(source, settings) {\\r\\n          if (!source && !settings.ast) {\\r\\n            throw new Error('source parameter is missing');\\r\\n          }\\r\\n          settings = settings || {};\\r\\n          this.source = source;\\r\\n          this.ast = null;\\r\\n          this.name = typeof source === 'string' ? settings.isRootKernel ?\\r\\n            'kernel' :\\r\\n            (settings.name || utils.getFunctionNameFromString(source)) : null;\\r\\n          this.calledFunctions = [];\\r\\n          this.constants = {};\\r\\n          this.constantTypes = {};\\r\\n          this.constantBitRatios = {};\\r\\n          this.isRootKernel = false;\\r\\n          this.isSubKernel = false;\\r\\n          this.debug = null;\\r\\n          this.functions = null;\\r\\n          this.identifiers = null;\\r\\n          this.contexts = null;\\r\\n          this.functionCalls = null;\\r\\n          this.states = [];\\r\\n          this.needsArgumentType = null;\\r\\n          this.assignArgumentType = null;\\r\\n          this.lookupReturnType = null;\\r\\n          this.lookupFunctionArgumentTypes = null;\\r\\n          this.lookupFunctionArgumentBitRatio = null;\\r\\n          this.triggerImplyArgumentType = null;\\r\\n          this.triggerImplyArgumentBitRatio = null;\\r\\n          this.onNestedFunction = null;\\r\\n          this.onFunctionCall = null;\\r\\n          this.optimizeFloatMemory = null;\\r\\n          this.precision = null;\\r\\n          this.loopMaxIterations = null;\\r\\n          this.argumentNames = (typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null);\\r\\n          this.argumentTypes = [];\\r\\n          this.argumentSizes = [];\\r\\n          this.argumentBitRatios = null;\\r\\n          this.returnType = null;\\r\\n          this.output = [];\\r\\n          this.plugins = null;\\r\\n          this.leadingReturnStatement = null;\\r\\n          this.followingReturnStatement = null;\\r\\n          this.dynamicOutput = null;\\r\\n          this.dynamicArguments = null;\\r\\n          this.strictTypingChecking = false;\\r\\n          this.fixIntegerDivisionAccuracy = null;\\r\\n      \\r\\n          if (settings) {\\r\\n            for (const p in settings) {\\r\\n              if (!settings.hasOwnProperty(p)) continue;\\r\\n              if (!this.hasOwnProperty(p)) continue;\\r\\n              this[p] = settings[p];\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          this.literalTypes = {};\\r\\n      \\r\\n          this.validate();\\r\\n          this._string = null;\\r\\n          this._internalVariableNames = {};\\r\\n        }\\r\\n      \\r\\n        validate() {\\r\\n          if (typeof this.source !== 'string' && !this.ast) {\\r\\n            throw new Error('this.source not a string');\\r\\n          }\\r\\n      \\r\\n          if (!this.ast && !utils.isFunctionString(this.source)) {\\r\\n            throw new Error('this.source not a function string');\\r\\n          }\\r\\n      \\r\\n          if (!this.name) {\\r\\n            throw new Error('this.name could not be set');\\r\\n          }\\r\\n      \\r\\n          if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {\\r\\n            throw new Error(`argumentTypes count of ${ this.argumentTypes.length } exceeds ${ this.argumentNames.length }`);\\r\\n          }\\r\\n      \\r\\n          if (this.output.length < 1) {\\r\\n            throw new Error('this.output is not big enough');\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        isIdentifierConstant(name) {\\r\\n          if (!this.constants) return false;\\r\\n          return this.constants.hasOwnProperty(name);\\r\\n        }\\r\\n      \\r\\n        isInput(argumentName) {\\r\\n          return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';\\r\\n        }\\r\\n      \\r\\n        pushState(state) {\\r\\n          this.states.push(state);\\r\\n        }\\r\\n      \\r\\n        popState(state) {\\r\\n          if (this.state !== state) {\\r\\n            throw new Error(`Cannot popState ${ state } when in ${ this.state }`);\\r\\n          }\\r\\n          this.states.pop();\\r\\n        }\\r\\n      \\r\\n        isState(state) {\\r\\n          return this.state === state;\\r\\n        }\\r\\n      \\r\\n        get state() {\\r\\n          return this.states[this.states.length - 1];\\r\\n        }\\r\\n      \\r\\n        astMemberExpressionUnroll(ast) {\\r\\n          if (ast.type === 'Identifier') {\\r\\n            return ast.name;\\r\\n          } else if (ast.type === 'ThisExpression') {\\r\\n            return 'this';\\r\\n          }\\r\\n      \\r\\n          if (ast.type === 'MemberExpression') {\\r\\n            if (ast.object && ast.property) {\\r\\n              if (ast.object.hasOwnProperty('name') && ast.object.name !== 'Math') {\\r\\n                return this.astMemberExpressionUnroll(ast.property);\\r\\n              }\\r\\n      \\r\\n              return (\\r\\n                this.astMemberExpressionUnroll(ast.object) +\\r\\n                '.' +\\r\\n                this.astMemberExpressionUnroll(ast.property)\\r\\n              );\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          if (ast.hasOwnProperty('expressions')) {\\r\\n            const firstExpression = ast.expressions[0];\\r\\n            if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {\\r\\n              return this.astMemberExpressionUnroll(ast.expressions[1]);\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);\\r\\n        }\\r\\n      \\r\\n        getJsAST(inParser) {\\r\\n          if (this.ast) {\\r\\n            return this.ast;\\r\\n          }\\r\\n          if (typeof this.source === 'object') {\\r\\n            this.traceFunctionAST(this.source);\\r\\n            return this.ast = this.source;\\r\\n          }\\r\\n      \\r\\n          inParser = inParser || acorn;\\r\\n          if (inParser === null) {\\r\\n            throw new Error('Missing JS to AST parser');\\r\\n          }\\r\\n      \\r\\n          const ast = Object.freeze(inParser.parse(`const parser_${ this.name } = ${ this.source };`, {\\r\\n            locations: true\\r\\n          }));\\r\\n          const functionAST = ast.body[0].declarations[0].init;\\r\\n          this.traceFunctionAST(functionAST);\\r\\n      \\r\\n          if (!ast) {\\r\\n            throw new Error('Failed to parse JS code');\\r\\n          }\\r\\n      \\r\\n          return this.ast = functionAST;\\r\\n        }\\r\\n      \\r\\n        traceFunctionAST(ast) {\\r\\n          const { contexts, declarations, functions, identifiers, functionCalls } = new FunctionTracer(ast);\\r\\n          this.contexts = contexts;\\r\\n          this.identifiers = identifiers;\\r\\n          this.functionCalls = functionCalls;\\r\\n          this.functions = functions;\\r\\n          for (let i = 0; i < declarations.length; i++) {\\r\\n            const declaration = declarations[i];\\r\\n            const { ast, inForLoopInit, inForLoopTest } = declaration;\\r\\n            const { init } = ast;\\r\\n            const dependencies = this.getDependencies(init);\\r\\n            let valueType = null;\\r\\n      \\r\\n            if (inForLoopInit && inForLoopTest) {\\r\\n              valueType = 'Integer';\\r\\n            } else {\\r\\n              if (init) {\\r\\n                const realType = this.getType(init);\\r\\n                switch (realType) {\\r\\n                  case 'Integer':\\r\\n                  case 'Float':\\r\\n                  case 'Number':\\r\\n                    if (init.type === 'MemberExpression') {\\r\\n                      valueType = realType;\\r\\n                    } else {\\r\\n                      valueType = 'Number';\\r\\n                    }\\r\\n                    break;\\r\\n                  case 'LiteralInteger':\\r\\n                    valueType = 'Number';\\r\\n                    break;\\r\\n                  default:\\r\\n                    valueType = realType;\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n            declaration.valueType = valueType;\\r\\n            declaration.dependencies = dependencies;\\r\\n            declaration.isSafe = this.isSafeDependencies(dependencies);\\r\\n          }\\r\\n      \\r\\n          for (let i = 0; i < functions.length; i++) {\\r\\n            this.onNestedFunction(functions[i], this.source);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        getDeclaration(ast) {\\r\\n          for (let i = 0; i < this.identifiers.length; i++) {\\r\\n            const identifier = this.identifiers[i];\\r\\n            if (ast === identifier.ast) {\\r\\n              return identifier.declaration;\\r\\n            }\\r\\n          }\\r\\n          return null;\\r\\n        }\\r\\n      \\r\\n        getVariableType(ast) {\\r\\n          if (ast.type !== 'Identifier') {\\r\\n            throw new Error(`ast of ${ast.type} not \\\"Identifier\\\"`);\\r\\n          }\\r\\n          let type = null;\\r\\n          const argumentIndex = this.argumentNames.indexOf(ast.name);\\r\\n          if (argumentIndex === -1) {\\r\\n            const declaration = this.getDeclaration(ast);\\r\\n            if (declaration) {\\r\\n              return declaration.valueType;\\r\\n            }\\r\\n          } else {\\r\\n            const argumentType = this.argumentTypes[argumentIndex];\\r\\n            if (argumentType) {\\r\\n              type = argumentType;\\r\\n            }\\r\\n          }\\r\\n          if (!type && this.strictTypingChecking) {\\r\\n            throw new Error(`Declaration of ${name} not found`);\\r\\n          }\\r\\n          return type;\\r\\n        }\\r\\n      \\r\\n        getLookupType(type) {\\r\\n          if (!typeLookupMap.hasOwnProperty(type)) {\\r\\n            throw new Error(`unknown typeLookupMap ${ type }`);\\r\\n          }\\r\\n          return typeLookupMap[type];\\r\\n        }\\r\\n      \\r\\n        getConstantType(constantName) {\\r\\n          if (this.constantTypes[constantName]) {\\r\\n            const type = this.constantTypes[constantName];\\r\\n            if (type === 'Float') {\\r\\n              return 'Number';\\r\\n            } else {\\r\\n              return type;\\r\\n            }\\r\\n          }\\r\\n          throw new Error(`Type for constant \\\"${ constantName }\\\" not declared`);\\r\\n        }\\r\\n      \\r\\n        toString() {\\r\\n          if (this._string) return this._string;\\r\\n          return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();\\r\\n        }\\r\\n      \\r\\n        toJSON() {\\r\\n          const settings = {\\r\\n            source: this.source,\\r\\n            name: this.name,\\r\\n            constants: this.constants,\\r\\n            constantTypes: this.constantTypes,\\r\\n            isRootKernel: this.isRootKernel,\\r\\n            isSubKernel: this.isSubKernel,\\r\\n            debug: this.debug,\\r\\n            output: this.output,\\r\\n            loopMaxIterations: this.loopMaxIterations,\\r\\n            argumentNames: this.argumentNames,\\r\\n            argumentTypes: this.argumentTypes,\\r\\n            argumentSizes: this.argumentSizes,\\r\\n            returnType: this.returnType,\\r\\n            leadingReturnStatement: this.leadingReturnStatement,\\r\\n            followingReturnStatement: this.followingReturnStatement,\\r\\n          };\\r\\n      \\r\\n          return {\\r\\n            ast: this.ast,\\r\\n            settings\\r\\n          };\\r\\n        }\\r\\n      \\r\\n        getType(ast) {\\r\\n          if (Array.isArray(ast)) {\\r\\n            return this.getType(ast[ast.length - 1]);\\r\\n          }\\r\\n          switch (ast.type) {\\r\\n            case 'BlockStatement':\\r\\n              return this.getType(ast.body);\\r\\n            case 'ArrayExpression':\\r\\n              const childType = this.getType(ast.elements[0]);\\r\\n              switch (childType) {\\r\\n                case 'Array(2)':\\r\\n                case 'Array(3)':\\r\\n                case 'Array(4)':\\r\\n                  return `Matrix(${ast.elements.length})`;\\r\\n              }\\r\\n              return `Array(${ ast.elements.length })`;\\r\\n            case 'Literal':\\r\\n              const literalKey = this.astKey(ast);\\r\\n              if (this.literalTypes[literalKey]) {\\r\\n                return this.literalTypes[literalKey];\\r\\n              }\\r\\n              if (Number.isInteger(ast.value)) {\\r\\n                return 'LiteralInteger';\\r\\n              } else if (ast.value === true || ast.value === false) {\\r\\n                return 'Boolean';\\r\\n              } else {\\r\\n                return 'Number';\\r\\n              }\\r\\n              case 'AssignmentExpression':\\r\\n                return this.getType(ast.left);\\r\\n              case 'CallExpression':\\r\\n                if (this.isAstMathFunction(ast)) {\\r\\n                  return 'Number';\\r\\n                }\\r\\n                if (!ast.callee || !ast.callee.name) {\\r\\n                  if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {\\r\\n                    const functionName = ast.callee.expressions[ast.callee.expressions.length - 1].property.name;\\r\\n                    this.inferArgumentTypesIfNeeded(functionName, ast.arguments);\\r\\n                    return this.lookupReturnType(functionName, ast, this);\\r\\n                  }\\r\\n                  if (this.getVariableSignature(ast.callee, true) === 'this.color') {\\r\\n                    return null;\\r\\n                  }\\r\\n                  if (ast.callee.type === 'MemberExpression' && ast.callee.object && ast.callee.property && ast.callee.property.name && ast.arguments) {\\r\\n                    const functionName = ast.callee.property.name;\\r\\n                    this.inferArgumentTypesIfNeeded(functionName, ast.arguments);\\r\\n                    return this.lookupReturnType(functionName, ast, this);\\r\\n                  }\\r\\n                  throw this.astErrorOutput('Unknown call expression', ast);\\r\\n                }\\r\\n                if (ast.callee && ast.callee.name) {\\r\\n                  const functionName = ast.callee.name;\\r\\n                  this.inferArgumentTypesIfNeeded(functionName, ast.arguments);\\r\\n                  return this.lookupReturnType(functionName, ast, this);\\r\\n                }\\r\\n                throw this.astErrorOutput(`Unhandled getType Type \\\"${ ast.type }\\\"`, ast);\\r\\n              case 'LogicalExpression':\\r\\n                return 'Boolean';\\r\\n              case 'BinaryExpression':\\r\\n                switch (ast.operator) {\\r\\n                  case '%':\\r\\n                  case '/':\\r\\n                    if (this.fixIntegerDivisionAccuracy) {\\r\\n                      return 'Number';\\r\\n                    } else {\\r\\n                      break;\\r\\n                    }\\r\\n                    case '>':\\r\\n                    case '<':\\r\\n                      return 'Boolean';\\r\\n                    case '&':\\r\\n                    case '|':\\r\\n                    case '^':\\r\\n                    case '<<':\\r\\n                    case '>>':\\r\\n                    case '>>>':\\r\\n                      return 'Integer';\\r\\n                }\\r\\n                const type = this.getType(ast.left);\\r\\n                if (this.isState('skip-literal-correction')) return type;\\r\\n                if (type === 'LiteralInteger') {\\r\\n                  const rightType = this.getType(ast.right);\\r\\n                  if (rightType === 'LiteralInteger') {\\r\\n                    if (ast.left.value % 1 === 0) {\\r\\n                      return 'Integer';\\r\\n                    } else {\\r\\n                      return 'Float';\\r\\n                    }\\r\\n                  }\\r\\n                  return rightType;\\r\\n                }\\r\\n                return typeLookupMap[type] || type;\\r\\n              case 'UpdateExpression':\\r\\n                return this.getType(ast.argument);\\r\\n              case 'UnaryExpression':\\r\\n                if (ast.operator === '~') {\\r\\n                  return 'Integer';\\r\\n                }\\r\\n                return this.getType(ast.argument);\\r\\n              case 'VariableDeclaration': {\\r\\n                const declarations = ast.declarations;\\r\\n                let lastType;\\r\\n                for (let i = 0; i < declarations.length; i++) {\\r\\n                  const declaration = declarations[i];\\r\\n                  lastType = this.getType(declaration);\\r\\n                }\\r\\n                if (!lastType) {\\r\\n                  throw this.astErrorOutput(`Unable to find type for declaration`, ast);\\r\\n                }\\r\\n                return lastType;\\r\\n              }\\r\\n              case 'VariableDeclarator':\\r\\n                const declaration = this.getDeclaration(ast.id);\\r\\n                if (!declaration) {\\r\\n                  throw this.astErrorOutput(`Unable to find declarator`, ast);\\r\\n                }\\r\\n      \\r\\n                if (!declaration.valueType) {\\r\\n                  throw this.astErrorOutput(`Unable to find declarator valueType`, ast);\\r\\n                }\\r\\n      \\r\\n                return declaration.valueType;\\r\\n              case 'Identifier':\\r\\n                if (ast.name === 'Infinity') {\\r\\n                  return 'Number';\\r\\n                }\\r\\n                if (this.isAstVariable(ast)) {\\r\\n                  const signature = this.getVariableSignature(ast);\\r\\n                  if (signature === 'value') {\\r\\n                    return this.getCheckVariableType(ast);\\r\\n                  }\\r\\n                }\\r\\n                const origin = this.findIdentifierOrigin(ast);\\r\\n                if (origin && origin.init) {\\r\\n                  return this.getType(origin.init);\\r\\n                }\\r\\n                return null;\\r\\n              case 'ReturnStatement':\\r\\n                return this.getType(ast.argument);\\r\\n              case 'MemberExpression':\\r\\n                if (this.isAstMathFunction(ast)) {\\r\\n                  switch (ast.property.name) {\\r\\n                    case 'ceil':\\r\\n                      return 'Integer';\\r\\n                    case 'floor':\\r\\n                      return 'Integer';\\r\\n                    case 'round':\\r\\n                      return 'Integer';\\r\\n                  }\\r\\n                  return 'Number';\\r\\n                }\\r\\n                if (this.isAstVariable(ast)) {\\r\\n                  const variableSignature = this.getVariableSignature(ast);\\r\\n                  switch (variableSignature) {\\r\\n                    case 'value[]':\\r\\n                      return this.getLookupType(this.getCheckVariableType(ast.object));\\r\\n                    case 'value[][]':\\r\\n                      return this.getLookupType(this.getCheckVariableType(ast.object.object));\\r\\n                    case 'value[][][]':\\r\\n                      return this.getLookupType(this.getCheckVariableType(ast.object.object.object));\\r\\n                    case 'value[][][][]':\\r\\n                      return this.getLookupType(this.getCheckVariableType(ast.object.object.object.object));\\r\\n                    case 'value.thread.value':\\r\\n                    case 'this.thread.value':\\r\\n                      return 'Integer';\\r\\n                    case 'this.output.value':\\r\\n                      return this.dynamicOutput ? 'Integer' : 'LiteralInteger';\\r\\n                    case 'this.constants.value':\\r\\n                      return this.getConstantType(ast.property.name);\\r\\n                    case 'this.constants.value[]':\\r\\n                      return this.getLookupType(this.getConstantType(ast.object.property.name));\\r\\n                    case 'this.constants.value[][]':\\r\\n                      return this.getLookupType(this.getConstantType(ast.object.object.property.name));\\r\\n                    case 'this.constants.value[][][]':\\r\\n                      return this.getLookupType(this.getConstantType(ast.object.object.object.property.name));\\r\\n                    case 'this.constants.value[][][][]':\\r\\n                      return this.getLookupType(this.getConstantType(ast.object.object.object.object.property.name));\\r\\n                    case 'fn()[]':\\r\\n                    case 'fn()[][]':\\r\\n                    case 'fn()[][][]':\\r\\n                      return this.getLookupType(this.getType(ast.object));\\r\\n                    case 'value.value':\\r\\n                      if (this.isAstMathVariable(ast)) {\\r\\n                        return 'Number';\\r\\n                      }\\r\\n                      switch (ast.property.name) {\\r\\n                        case 'r':\\r\\n                        case 'g':\\r\\n                        case 'b':\\r\\n                        case 'a':\\r\\n                          return this.getLookupType(this.getCheckVariableType(ast.object));\\r\\n                      }\\r\\n                      case '[][]':\\r\\n                        return 'Number';\\r\\n                  }\\r\\n                  throw this.astErrorOutput('Unhandled getType MemberExpression', ast);\\r\\n                }\\r\\n                throw this.astErrorOutput('Unhandled getType MemberExpression', ast);\\r\\n              case 'ConditionalExpression':\\r\\n                return this.getType(ast.consequent);\\r\\n              case 'FunctionDeclaration':\\r\\n              case 'FunctionExpression':\\r\\n                const lastReturn = this.findLastReturn(ast.body);\\r\\n                if (lastReturn) {\\r\\n                  return this.getType(lastReturn);\\r\\n                }\\r\\n                return null;\\r\\n              case 'IfStatement':\\r\\n                return this.getType(ast.consequent);\\r\\n              case 'SequenceExpression':\\r\\n                return this.getType(ast.expressions[ast.expressions.length - 1]);\\r\\n              default:\\r\\n                throw this.astErrorOutput(`Unhandled getType Type \\\"${ ast.type }\\\"`, ast);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        getCheckVariableType(ast) {\\r\\n          const type = this.getVariableType(ast);\\r\\n          if (!type) {\\r\\n            throw this.astErrorOutput(`${ast.type} is not defined`, ast);\\r\\n          }\\r\\n          return type;\\r\\n        }\\r\\n      \\r\\n        inferArgumentTypesIfNeeded(functionName, args) {\\r\\n          for (let i = 0; i < args.length; i++) {\\r\\n            if (!this.needsArgumentType(functionName, i)) continue;\\r\\n            const type = this.getType(args[i]);\\r\\n            if (!type) {\\r\\n              throw this.astErrorOutput(`Unable to infer argument ${i}`, args[i]);\\r\\n            }\\r\\n            this.assignArgumentType(functionName, i, type);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        isAstMathVariable(ast) {\\r\\n          const mathProperties = [\\r\\n            'E',\\r\\n            'PI',\\r\\n            'SQRT2',\\r\\n            'SQRT1_2',\\r\\n            'LN2',\\r\\n            'LN10',\\r\\n            'LOG2E',\\r\\n            'LOG10E',\\r\\n          ];\\r\\n          return ast.type === 'MemberExpression' &&\\r\\n            ast.object && ast.object.type === 'Identifier' &&\\r\\n            ast.object.name === 'Math' &&\\r\\n            ast.property &&\\r\\n            ast.property.type === 'Identifier' &&\\r\\n            mathProperties.indexOf(ast.property.name) > -1;\\r\\n        }\\r\\n      \\r\\n        isAstMathFunction(ast) {\\r\\n          const mathFunctions = [\\r\\n            'abs',\\r\\n            'acos',\\r\\n            'acosh',\\r\\n            'asin',\\r\\n            'asinh',\\r\\n            'atan',\\r\\n            'atan2',\\r\\n            'atanh',\\r\\n            'cbrt',\\r\\n            'ceil',\\r\\n            'clz32',\\r\\n            'cos',\\r\\n            'cosh',\\r\\n            'expm1',\\r\\n            'exp',\\r\\n            'floor',\\r\\n            'fround',\\r\\n            'imul',\\r\\n            'log',\\r\\n            'log2',\\r\\n            'log10',\\r\\n            'log1p',\\r\\n            'max',\\r\\n            'min',\\r\\n            'pow',\\r\\n            'random',\\r\\n            'round',\\r\\n            'sign',\\r\\n            'sin',\\r\\n            'sinh',\\r\\n            'sqrt',\\r\\n            'tan',\\r\\n            'tanh',\\r\\n            'trunc',\\r\\n          ];\\r\\n          return ast.type === 'CallExpression' &&\\r\\n            ast.callee &&\\r\\n            ast.callee.type === 'MemberExpression' &&\\r\\n            ast.callee.object &&\\r\\n            ast.callee.object.type === 'Identifier' &&\\r\\n            ast.callee.object.name === 'Math' &&\\r\\n            ast.callee.property &&\\r\\n            ast.callee.property.type === 'Identifier' &&\\r\\n            mathFunctions.indexOf(ast.callee.property.name) > -1;\\r\\n        }\\r\\n      \\r\\n        isAstVariable(ast) {\\r\\n          return ast.type === 'Identifier' || ast.type === 'MemberExpression';\\r\\n        }\\r\\n      \\r\\n        isSafe(ast) {\\r\\n          return this.isSafeDependencies(this.getDependencies(ast));\\r\\n        }\\r\\n      \\r\\n        isSafeDependencies(dependencies) {\\r\\n          return dependencies && dependencies.every ? dependencies.every(dependency => dependency.isSafe) : true;\\r\\n        }\\r\\n      \\r\\n        getDependencies(ast, dependencies, isNotSafe) {\\r\\n          if (!dependencies) {\\r\\n            dependencies = [];\\r\\n          }\\r\\n          if (!ast) return null;\\r\\n          if (Array.isArray(ast)) {\\r\\n            for (let i = 0; i < ast.length; i++) {\\r\\n              this.getDependencies(ast[i], dependencies, isNotSafe);\\r\\n            }\\r\\n            return dependencies;\\r\\n          }\\r\\n          switch (ast.type) {\\r\\n            case 'AssignmentExpression':\\r\\n              this.getDependencies(ast.left, dependencies, isNotSafe);\\r\\n              this.getDependencies(ast.right, dependencies, isNotSafe);\\r\\n              return dependencies;\\r\\n            case 'ConditionalExpression':\\r\\n              this.getDependencies(ast.test, dependencies, isNotSafe);\\r\\n              this.getDependencies(ast.alternate, dependencies, isNotSafe);\\r\\n              this.getDependencies(ast.consequent, dependencies, isNotSafe);\\r\\n              return dependencies;\\r\\n            case 'Literal':\\r\\n              dependencies.push({\\r\\n                origin: 'literal',\\r\\n                value: ast.value,\\r\\n                isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)\\r\\n              });\\r\\n              break;\\r\\n            case 'VariableDeclarator':\\r\\n              return this.getDependencies(ast.init, dependencies, isNotSafe);\\r\\n            case 'Identifier':\\r\\n              const declaration = this.getDeclaration(ast);\\r\\n              if (declaration) {\\r\\n                dependencies.push({\\r\\n                  name: ast.name,\\r\\n                  origin: 'declaration',\\r\\n                  isSafe: isNotSafe ? false : this.isSafeDependencies(declaration.dependencies),\\r\\n                });\\r\\n              } else if (this.argumentNames.indexOf(ast.name) > -1) {\\r\\n                dependencies.push({\\r\\n                  name: ast.name,\\r\\n                  origin: 'argument',\\r\\n                  isSafe: false,\\r\\n                });\\r\\n              } else if (this.strictTypingChecking) {\\r\\n                throw new Error(`Cannot find identifier origin \\\"${ast.name}\\\"`);\\r\\n              }\\r\\n              break;\\r\\n            case 'FunctionDeclaration':\\r\\n              return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);\\r\\n            case 'ReturnStatement':\\r\\n              return this.getDependencies(ast.argument, dependencies);\\r\\n            case 'BinaryExpression':\\r\\n            case 'LogicalExpression':\\r\\n              isNotSafe = (ast.operator === '/' || ast.operator === '*');\\r\\n              this.getDependencies(ast.left, dependencies, isNotSafe);\\r\\n              this.getDependencies(ast.right, dependencies, isNotSafe);\\r\\n              return dependencies;\\r\\n            case 'UnaryExpression':\\r\\n            case 'UpdateExpression':\\r\\n              return this.getDependencies(ast.argument, dependencies, isNotSafe);\\r\\n            case 'VariableDeclaration':\\r\\n              return this.getDependencies(ast.declarations, dependencies, isNotSafe);\\r\\n            case 'ArrayExpression':\\r\\n              dependencies.push({\\r\\n                origin: 'declaration',\\r\\n                isSafe: true,\\r\\n              });\\r\\n              return dependencies;\\r\\n            case 'CallExpression':\\r\\n              dependencies.push({\\r\\n                origin: 'function',\\r\\n                isSafe: true,\\r\\n              });\\r\\n              return dependencies;\\r\\n            case 'MemberExpression':\\r\\n              const details = this.getMemberExpressionDetails(ast);\\r\\n              switch (details.signature) {\\r\\n                case 'value[]':\\r\\n                  this.getDependencies(ast.object, dependencies, isNotSafe);\\r\\n                  break;\\r\\n                case 'value[][]':\\r\\n                  this.getDependencies(ast.object.object, dependencies, isNotSafe);\\r\\n                  break;\\r\\n                case 'value[][][]':\\r\\n                  this.getDependencies(ast.object.object.object, dependencies, isNotSafe);\\r\\n                  break;\\r\\n                case 'this.output.value':\\r\\n                  if (this.dynamicOutput) {\\r\\n                    dependencies.push({\\r\\n                      name: details.name,\\r\\n                      origin: 'output',\\r\\n                      isSafe: false,\\r\\n                    });\\r\\n                  }\\r\\n                  break;\\r\\n              }\\r\\n              if (details) {\\r\\n                if (details.property) {\\r\\n                  this.getDependencies(details.property, dependencies, isNotSafe);\\r\\n                }\\r\\n                if (details.xProperty) {\\r\\n                  this.getDependencies(details.xProperty, dependencies, isNotSafe);\\r\\n                }\\r\\n                if (details.yProperty) {\\r\\n                  this.getDependencies(details.yProperty, dependencies, isNotSafe);\\r\\n                }\\r\\n                if (details.zProperty) {\\r\\n                  this.getDependencies(details.zProperty, dependencies, isNotSafe);\\r\\n                }\\r\\n                return dependencies;\\r\\n              }\\r\\n              case 'SequenceExpression':\\r\\n                return this.getDependencies(ast.expressions, dependencies, isNotSafe);\\r\\n              default:\\r\\n                throw this.astErrorOutput(`Unhandled type ${ ast.type } in getDependencies`, ast);\\r\\n          }\\r\\n          return dependencies;\\r\\n        }\\r\\n      \\r\\n        getVariableSignature(ast, returnRawValue) {\\r\\n          if (!this.isAstVariable(ast)) {\\r\\n            throw new Error(`ast of type \\\"${ ast.type }\\\" is not a variable signature`);\\r\\n          }\\r\\n          if (ast.type === 'Identifier') {\\r\\n            return 'value';\\r\\n          }\\r\\n          const signature = [];\\r\\n          while (true) {\\r\\n            if (!ast) break;\\r\\n            if (ast.computed) {\\r\\n              signature.push('[]');\\r\\n            } else if (ast.type === 'ThisExpression') {\\r\\n              signature.unshift('this');\\r\\n            } else if (ast.property && ast.property.name) {\\r\\n              if (\\r\\n                ast.property.name === 'x' ||\\r\\n                ast.property.name === 'y' ||\\r\\n                ast.property.name === 'z'\\r\\n              ) {\\r\\n                signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');\\r\\n              } else if (\\r\\n                ast.property.name === 'constants' ||\\r\\n                ast.property.name === 'thread' ||\\r\\n                ast.property.name === 'output'\\r\\n              ) {\\r\\n                signature.unshift('.' + ast.property.name);\\r\\n              } else {\\r\\n                signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');\\r\\n              }\\r\\n            } else if (ast.name) {\\r\\n              signature.unshift(returnRawValue ? ast.name : 'value');\\r\\n            } else if (ast.callee && ast.callee.name) {\\r\\n              signature.unshift(returnRawValue ? ast.callee.name + '()' : 'fn()');\\r\\n            } else if (ast.elements) {\\r\\n              signature.unshift('[]');\\r\\n            } else {\\r\\n              signature.unshift('unknown');\\r\\n            }\\r\\n            ast = ast.object;\\r\\n          }\\r\\n      \\r\\n          const signatureString = signature.join('');\\r\\n          if (returnRawValue) {\\r\\n            return signatureString;\\r\\n          }\\r\\n      \\r\\n          const allowedExpressions = [\\r\\n            'value',\\r\\n            'value[]',\\r\\n            'value[][]',\\r\\n            'value[][][]',\\r\\n            'value[][][][]',\\r\\n            'value.value',\\r\\n            'value.thread.value',\\r\\n            'this.thread.value',\\r\\n            'this.output.value',\\r\\n            'this.constants.value',\\r\\n            'this.constants.value[]',\\r\\n            'this.constants.value[][]',\\r\\n            'this.constants.value[][][]',\\r\\n            'this.constants.value[][][][]',\\r\\n            'fn()[]',\\r\\n            'fn()[][]',\\r\\n            'fn()[][][]',\\r\\n            '[][]',\\r\\n          ];\\r\\n          if (allowedExpressions.indexOf(signatureString) > -1) {\\r\\n            return signatureString;\\r\\n          }\\r\\n          return null;\\r\\n        }\\r\\n      \\r\\n        build() {\\r\\n          return this.toString().length > 0;\\r\\n        }\\r\\n      \\r\\n        astGeneric(ast, retArr) {\\r\\n          if (ast === null) {\\r\\n            throw this.astErrorOutput('NULL ast', ast);\\r\\n          } else {\\r\\n            if (Array.isArray(ast)) {\\r\\n              for (let i = 0; i < ast.length; i++) {\\r\\n                this.astGeneric(ast[i], retArr);\\r\\n              }\\r\\n              return retArr;\\r\\n            }\\r\\n      \\r\\n            switch (ast.type) {\\r\\n              case 'FunctionDeclaration':\\r\\n                return this.astFunctionDeclaration(ast, retArr);\\r\\n              case 'FunctionExpression':\\r\\n                return this.astFunctionExpression(ast, retArr);\\r\\n              case 'ReturnStatement':\\r\\n                return this.astReturnStatement(ast, retArr);\\r\\n              case 'Literal':\\r\\n                return this.astLiteral(ast, retArr);\\r\\n              case 'BinaryExpression':\\r\\n                return this.astBinaryExpression(ast, retArr);\\r\\n              case 'Identifier':\\r\\n                return this.astIdentifierExpression(ast, retArr);\\r\\n              case 'AssignmentExpression':\\r\\n                return this.astAssignmentExpression(ast, retArr);\\r\\n              case 'ExpressionStatement':\\r\\n                return this.astExpressionStatement(ast, retArr);\\r\\n              case 'EmptyStatement':\\r\\n                return this.astEmptyStatement(ast, retArr);\\r\\n              case 'BlockStatement':\\r\\n                return this.astBlockStatement(ast, retArr);\\r\\n              case 'IfStatement':\\r\\n                return this.astIfStatement(ast, retArr);\\r\\n              case 'SwitchStatement':\\r\\n                return this.astSwitchStatement(ast, retArr);\\r\\n              case 'BreakStatement':\\r\\n                return this.astBreakStatement(ast, retArr);\\r\\n              case 'ContinueStatement':\\r\\n                return this.astContinueStatement(ast, retArr);\\r\\n              case 'ForStatement':\\r\\n                return this.astForStatement(ast, retArr);\\r\\n              case 'WhileStatement':\\r\\n                return this.astWhileStatement(ast, retArr);\\r\\n              case 'DoWhileStatement':\\r\\n                return this.astDoWhileStatement(ast, retArr);\\r\\n              case 'VariableDeclaration':\\r\\n                return this.astVariableDeclaration(ast, retArr);\\r\\n              case 'VariableDeclarator':\\r\\n                return this.astVariableDeclarator(ast, retArr);\\r\\n              case 'ThisExpression':\\r\\n                return this.astThisExpression(ast, retArr);\\r\\n              case 'SequenceExpression':\\r\\n                return this.astSequenceExpression(ast, retArr);\\r\\n              case 'UnaryExpression':\\r\\n                return this.astUnaryExpression(ast, retArr);\\r\\n              case 'UpdateExpression':\\r\\n                return this.astUpdateExpression(ast, retArr);\\r\\n              case 'LogicalExpression':\\r\\n                return this.astLogicalExpression(ast, retArr);\\r\\n              case 'MemberExpression':\\r\\n                return this.astMemberExpression(ast, retArr);\\r\\n              case 'CallExpression':\\r\\n                return this.astCallExpression(ast, retArr);\\r\\n              case 'ArrayExpression':\\r\\n                return this.astArrayExpression(ast, retArr);\\r\\n              case 'DebuggerStatement':\\r\\n                return this.astDebuggerStatement(ast, retArr);\\r\\n              case 'ConditionalExpression':\\r\\n                return this.astConditionalExpression(ast, retArr);\\r\\n            }\\r\\n      \\r\\n            throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);\\r\\n          }\\r\\n        }\\r\\n        astErrorOutput(error, ast) {\\r\\n          if (typeof this.source !== 'string') {\\r\\n            return new Error(error);\\r\\n          }\\r\\n      \\r\\n          const debugString = utils.getAstString(this.source, ast);\\r\\n          const leadingSource = this.source.substr(ast.start);\\r\\n          const splitLines = leadingSource.split(/\\\\n/);\\r\\n          const lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;\\r\\n          return new Error(`${error} on line ${ splitLines.length }, position ${ lineBefore.length }:\\\\n ${ debugString }`);\\r\\n        }\\r\\n      \\r\\n        astDebuggerStatement(arrNode, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astConditionalExpression(ast, retArr) {\\r\\n          if (ast.type !== 'ConditionalExpression') {\\r\\n            throw this.astErrorOutput('Not a conditional expression', ast);\\r\\n          }\\r\\n          retArr.push('(');\\r\\n          this.astGeneric(ast.test, retArr);\\r\\n          retArr.push('?');\\r\\n          this.astGeneric(ast.consequent, retArr);\\r\\n          retArr.push(':');\\r\\n          this.astGeneric(ast.alternate, retArr);\\r\\n          retArr.push(')');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astFunction(ast, retArr) {\\r\\n          throw new Error(`\\\"astFunction\\\" not defined on ${ this.constructor.name }`);\\r\\n        }\\r\\n      \\r\\n        astFunctionDeclaration(ast, retArr) {\\r\\n          if (this.isChildFunction(ast)) {\\r\\n            return retArr;\\r\\n          }\\r\\n          return this.astFunction(ast, retArr);\\r\\n        }\\r\\n        astFunctionExpression(ast, retArr) {\\r\\n          if (this.isChildFunction(ast)) {\\r\\n            return retArr;\\r\\n          }\\r\\n          return this.astFunction(ast, retArr);\\r\\n        }\\r\\n        isChildFunction(ast) {\\r\\n          for (let i = 0; i < this.functions.length; i++) {\\r\\n            if (this.functions[i] === ast) {\\r\\n              return true;\\r\\n            }\\r\\n          }\\r\\n          return false;\\r\\n        }\\r\\n        astReturnStatement(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astLiteral(ast, retArr) {\\r\\n          this.literalTypes[this.astKey(ast)] = 'Number';\\r\\n          return retArr;\\r\\n        }\\r\\n        astBinaryExpression(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astIdentifierExpression(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astAssignmentExpression(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astExpressionStatement(esNode, retArr) {\\r\\n          this.astGeneric(esNode.expression, retArr);\\r\\n          retArr.push(';');\\r\\n          return retArr;\\r\\n        }\\r\\n        astEmptyStatement(eNode, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astBlockStatement(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astIfStatement(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astSwitchStatement(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astBreakStatement(brNode, retArr) {\\r\\n          retArr.push('break;');\\r\\n          return retArr;\\r\\n        }\\r\\n        astContinueStatement(crNode, retArr) {\\r\\n          retArr.push('continue;\\\\n');\\r\\n          return retArr;\\r\\n        }\\r\\n        astForStatement(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astWhileStatement(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astDoWhileStatement(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astVariableDeclarator(iVarDecNode, retArr) {\\r\\n          this.astGeneric(iVarDecNode.id, retArr);\\r\\n          if (iVarDecNode.init !== null) {\\r\\n            retArr.push('=');\\r\\n            this.astGeneric(iVarDecNode.init, retArr);\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n        astThisExpression(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astSequenceExpression(sNode, retArr) {\\r\\n          const { expressions } = sNode;\\r\\n          const sequenceResult = [];\\r\\n          for (let i = 0; i < expressions.length; i++) {\\r\\n            const expression = expressions[i];\\r\\n            const expressionResult = [];\\r\\n            this.astGeneric(expression, expressionResult);\\r\\n            sequenceResult.push(expressionResult.join(''));\\r\\n          }\\r\\n          if (sequenceResult.length > 1) {\\r\\n            retArr.push('(', sequenceResult.join(','), ')');\\r\\n          } else {\\r\\n            retArr.push(sequenceResult[0]);\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n        astUnaryExpression(uNode, retArr) {\\r\\n          const unaryResult = this.checkAndUpconvertBitwiseUnary(uNode, retArr);\\r\\n          if (unaryResult) {\\r\\n            return retArr;\\r\\n          }\\r\\n      \\r\\n          if (uNode.prefix) {\\r\\n            retArr.push(uNode.operator);\\r\\n            this.astGeneric(uNode.argument, retArr);\\r\\n          } else {\\r\\n            this.astGeneric(uNode.argument, retArr);\\r\\n            retArr.push(uNode.operator);\\r\\n          }\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        checkAndUpconvertBitwiseUnary(uNode, retArr) {}\\r\\n      \\r\\n        astUpdateExpression(uNode, retArr) {\\r\\n          if (uNode.prefix) {\\r\\n            retArr.push(uNode.operator);\\r\\n            this.astGeneric(uNode.argument, retArr);\\r\\n          } else {\\r\\n            this.astGeneric(uNode.argument, retArr);\\r\\n            retArr.push(uNode.operator);\\r\\n          }\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n        astLogicalExpression(logNode, retArr) {\\r\\n          retArr.push('(');\\r\\n          this.astGeneric(logNode.left, retArr);\\r\\n          retArr.push(logNode.operator);\\r\\n          this.astGeneric(logNode.right, retArr);\\r\\n          retArr.push(')');\\r\\n          return retArr;\\r\\n        }\\r\\n        astMemberExpression(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astCallExpression(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n        astArrayExpression(ast, retArr) {\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        getMemberExpressionDetails(ast) {\\r\\n          if (ast.type !== 'MemberExpression') {\\r\\n            throw this.astErrorOutput(`Expression ${ ast.type } not a MemberExpression`, ast);\\r\\n          }\\r\\n          let name = null;\\r\\n          let type = null;\\r\\n          const variableSignature = this.getVariableSignature(ast);\\r\\n          switch (variableSignature) {\\r\\n            case 'value':\\r\\n              return null;\\r\\n            case 'value.thread.value':\\r\\n            case 'this.thread.value':\\r\\n            case 'this.output.value':\\r\\n              return {\\r\\n                signature: variableSignature,\\r\\n                  type: 'Integer',\\r\\n                  name: ast.property.name\\r\\n              };\\r\\n            case 'value[]':\\r\\n              if (typeof ast.object.name !== 'string') {\\r\\n                throw this.astErrorOutput('Unexpected expression', ast);\\r\\n              }\\r\\n              name = ast.object.name;\\r\\n              return {\\r\\n                name,\\r\\n                origin: 'user',\\r\\n                  signature: variableSignature,\\r\\n                  type: this.getVariableType(ast.object),\\r\\n                  xProperty: ast.property\\r\\n              };\\r\\n            case 'value[][]':\\r\\n              if (typeof ast.object.object.name !== 'string') {\\r\\n                throw this.astErrorOutput('Unexpected expression', ast);\\r\\n              }\\r\\n              name = ast.object.object.name;\\r\\n              return {\\r\\n                name,\\r\\n                origin: 'user',\\r\\n                  signature: variableSignature,\\r\\n                  type: this.getVariableType(ast.object.object),\\r\\n                  yProperty: ast.object.property,\\r\\n                  xProperty: ast.property,\\r\\n              };\\r\\n            case 'value[][][]':\\r\\n              if (typeof ast.object.object.object.name !== 'string') {\\r\\n                throw this.astErrorOutput('Unexpected expression', ast);\\r\\n              }\\r\\n              name = ast.object.object.object.name;\\r\\n              return {\\r\\n                name,\\r\\n                origin: 'user',\\r\\n                  signature: variableSignature,\\r\\n                  type: this.getVariableType(ast.object.object.object),\\r\\n                  zProperty: ast.object.object.property,\\r\\n                  yProperty: ast.object.property,\\r\\n                  xProperty: ast.property,\\r\\n              };\\r\\n            case 'value[][][][]':\\r\\n              if (typeof ast.object.object.object.object.name !== 'string') {\\r\\n                throw this.astErrorOutput('Unexpected expression', ast);\\r\\n              }\\r\\n              name = ast.object.object.object.object.name;\\r\\n              return {\\r\\n                name,\\r\\n                origin: 'user',\\r\\n                  signature: variableSignature,\\r\\n                  type: this.getVariableType(ast.object.object.object.object),\\r\\n                  zProperty: ast.object.object.property,\\r\\n                  yProperty: ast.object.property,\\r\\n                  xProperty: ast.property,\\r\\n              };\\r\\n            case 'value.value':\\r\\n              if (typeof ast.property.name !== 'string') {\\r\\n                throw this.astErrorOutput('Unexpected expression', ast);\\r\\n              }\\r\\n              if (this.isAstMathVariable(ast)) {\\r\\n                name = ast.property.name;\\r\\n                return {\\r\\n                  name,\\r\\n                  origin: 'Math',\\r\\n                  type: 'Number',\\r\\n                  signature: variableSignature,\\r\\n                };\\r\\n              }\\r\\n              switch (ast.property.name) {\\r\\n                case 'r':\\r\\n                case 'g':\\r\\n                case 'b':\\r\\n                case 'a':\\r\\n                  name = ast.object.name;\\r\\n                  return {\\r\\n                    name,\\r\\n                    property: ast.property.name,\\r\\n                      origin: 'user',\\r\\n                      signature: variableSignature,\\r\\n                      type: 'Number'\\r\\n                  };\\r\\n                default:\\r\\n                  throw this.astErrorOutput('Unexpected expression', ast);\\r\\n              }\\r\\n              case 'this.constants.value':\\r\\n                if (typeof ast.property.name !== 'string') {\\r\\n                  throw this.astErrorOutput('Unexpected expression', ast);\\r\\n                }\\r\\n                name = ast.property.name;\\r\\n                type = this.getConstantType(name);\\r\\n                if (!type) {\\r\\n                  throw this.astErrorOutput('Constant has no type', ast);\\r\\n                }\\r\\n                return {\\r\\n                  name,\\r\\n                  type,\\r\\n                  origin: 'constants',\\r\\n                    signature: variableSignature,\\r\\n                };\\r\\n              case 'this.constants.value[]':\\r\\n                if (typeof ast.object.property.name !== 'string') {\\r\\n                  throw this.astErrorOutput('Unexpected expression', ast);\\r\\n                }\\r\\n                name = ast.object.property.name;\\r\\n                type = this.getConstantType(name);\\r\\n                if (!type) {\\r\\n                  throw this.astErrorOutput('Constant has no type', ast);\\r\\n                }\\r\\n                return {\\r\\n                  name,\\r\\n                  type,\\r\\n                  origin: 'constants',\\r\\n                    signature: variableSignature,\\r\\n                    xProperty: ast.property,\\r\\n                };\\r\\n              case 'this.constants.value[][]': {\\r\\n                if (typeof ast.object.object.property.name !== 'string') {\\r\\n                  throw this.astErrorOutput('Unexpected expression', ast);\\r\\n                }\\r\\n                name = ast.object.object.property.name;\\r\\n                type = this.getConstantType(name);\\r\\n                if (!type) {\\r\\n                  throw this.astErrorOutput('Constant has no type', ast);\\r\\n                }\\r\\n                return {\\r\\n                  name,\\r\\n                  type,\\r\\n                  origin: 'constants',\\r\\n                  signature: variableSignature,\\r\\n                  yProperty: ast.object.property,\\r\\n                  xProperty: ast.property,\\r\\n                };\\r\\n              }\\r\\n              case 'this.constants.value[][][]': {\\r\\n                if (typeof ast.object.object.object.property.name !== 'string') {\\r\\n                  throw this.astErrorOutput('Unexpected expression', ast);\\r\\n                }\\r\\n                name = ast.object.object.object.property.name;\\r\\n                type = this.getConstantType(name);\\r\\n                if (!type) {\\r\\n                  throw this.astErrorOutput('Constant has no type', ast);\\r\\n                }\\r\\n                return {\\r\\n                  name,\\r\\n                  type,\\r\\n                  origin: 'constants',\\r\\n                  signature: variableSignature,\\r\\n                  zProperty: ast.object.object.property,\\r\\n                  yProperty: ast.object.property,\\r\\n                  xProperty: ast.property,\\r\\n                };\\r\\n              }\\r\\n              case 'fn()[]':\\r\\n              case 'fn()[][]':\\r\\n              case '[][]':\\r\\n                return {\\r\\n                  signature: variableSignature,\\r\\n                    property: ast.property,\\r\\n                };\\r\\n              default:\\r\\n                throw this.astErrorOutput('Unexpected expression', ast);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        findIdentifierOrigin(astToFind) {\\r\\n          const stack = [this.ast];\\r\\n      \\r\\n          while (stack.length > 0) {\\r\\n            const atNode = stack[0];\\r\\n            if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {\\r\\n              return atNode;\\r\\n            }\\r\\n            stack.shift();\\r\\n            if (atNode.argument) {\\r\\n              stack.push(atNode.argument);\\r\\n            } else if (atNode.body) {\\r\\n              stack.push(atNode.body);\\r\\n            } else if (atNode.declarations) {\\r\\n              stack.push(atNode.declarations);\\r\\n            } else if (Array.isArray(atNode)) {\\r\\n              for (let i = 0; i < atNode.length; i++) {\\r\\n                stack.push(atNode[i]);\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n          return null;\\r\\n        }\\r\\n      \\r\\n        findLastReturn(ast) {\\r\\n          const stack = [ast || this.ast];\\r\\n      \\r\\n          while (stack.length > 0) {\\r\\n            const atNode = stack.pop();\\r\\n            if (atNode.type === 'ReturnStatement') {\\r\\n              return atNode;\\r\\n            }\\r\\n            if (atNode.type === 'FunctionDeclaration') {\\r\\n              continue;\\r\\n            }\\r\\n            if (atNode.argument) {\\r\\n              stack.push(atNode.argument);\\r\\n            } else if (atNode.body) {\\r\\n              stack.push(atNode.body);\\r\\n            } else if (atNode.declarations) {\\r\\n              stack.push(atNode.declarations);\\r\\n            } else if (Array.isArray(atNode)) {\\r\\n              for (let i = 0; i < atNode.length; i++) {\\r\\n                stack.push(atNode[i]);\\r\\n              }\\r\\n            } else if (atNode.consequent) {\\r\\n              stack.push(atNode.consequent);\\r\\n            } else if (atNode.cases) {\\r\\n              stack.push(atNode.cases);\\r\\n            }\\r\\n          }\\r\\n          return null;\\r\\n        }\\r\\n      \\r\\n        getInternalVariableName(name) {\\r\\n          if (!this._internalVariableNames.hasOwnProperty(name)) {\\r\\n            this._internalVariableNames[name] = 0;\\r\\n          }\\r\\n          this._internalVariableNames[name]++;\\r\\n          if (this._internalVariableNames[name] === 1) {\\r\\n            return name;\\r\\n          }\\r\\n          return name + this._internalVariableNames[name];\\r\\n        }\\r\\n      \\r\\n        astKey(ast, separator = ',') {\\r\\n          if (!ast.start || !ast.end) throw new Error('AST start and end needed');\\r\\n          return `${ast.start}${separator}${ast.end}`;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      const typeLookupMap = {\\r\\n        'Number': 'Number',\\r\\n        'Float': 'Float',\\r\\n        'Integer': 'Integer',\\r\\n        'Array': 'Number',\\r\\n        'Array(2)': 'Number',\\r\\n        'Array(3)': 'Number',\\r\\n        'Array(4)': 'Number',\\r\\n        'Matrix(2)': 'Number',\\r\\n        'Matrix(3)': 'Number',\\r\\n        'Matrix(4)': 'Number',\\r\\n        'Array2D': 'Number',\\r\\n        'Array3D': 'Number',\\r\\n        'Input': 'Number',\\r\\n        'HTMLCanvas': 'Array(4)',\\r\\n        'HTMLImage': 'Array(4)',\\r\\n        'HTMLVideo': 'Array(4)',\\r\\n        'HTMLImageArray': 'Array(4)',\\r\\n        'NumberTexture': 'Number',\\r\\n        'MemoryOptimizedNumberTexture': 'Number',\\r\\n        'Array1D(2)': 'Array(2)',\\r\\n        'Array1D(3)': 'Array(3)',\\r\\n        'Array1D(4)': 'Array(4)',\\r\\n        'Array2D(2)': 'Array(2)',\\r\\n        'Array2D(3)': 'Array(3)',\\r\\n        'Array2D(4)': 'Array(4)',\\r\\n        'Array3D(2)': 'Array(2)',\\r\\n        'Array3D(3)': 'Array(3)',\\r\\n        'Array3D(4)': 'Array(4)',\\r\\n        'ArrayTexture(1)': 'Number',\\r\\n        'ArrayTexture(2)': 'Array(2)',\\r\\n        'ArrayTexture(3)': 'Array(3)',\\r\\n        'ArrayTexture(4)': 'Array(4)',\\r\\n      };\\r\\n      \\r\\n      module.exports = {\\r\\n        FunctionNode\\r\\n      };\\r\\n      },{\\\"../utils\\\":114,\\\"./function-tracer\\\":11,\\\"acorn\\\":1}],11:[function(require,module,exports){\\r\\n      const { utils } = require('../utils');\\r\\n      \\r\\n      function last(array) {\\r\\n        return array.length > 0 ? array[array.length - 1] : null;\\r\\n      }\\r\\n      \\r\\n      const states = {\\r\\n        trackIdentifiers: 'trackIdentifiers',\\r\\n        memberExpression: 'memberExpression',\\r\\n        inForLoopInit: 'inForLoopInit'\\r\\n      };\\r\\n      \\r\\n      class FunctionTracer {\\r\\n        constructor(ast) {\\r\\n          this.runningContexts = [];\\r\\n          this.functionContexts = [];\\r\\n          this.contexts = [];\\r\\n          this.functionCalls = [];\\r\\n          this.declarations = [];\\r\\n          this.identifiers = [];\\r\\n          this.functions = [];\\r\\n          this.returnStatements = [];\\r\\n          this.trackedIdentifiers = null;\\r\\n          this.states = [];\\r\\n          this.newFunctionContext();\\r\\n          this.scan(ast);\\r\\n        }\\r\\n      \\r\\n        isState(state) {\\r\\n          return this.states[this.states.length - 1] === state;\\r\\n        }\\r\\n      \\r\\n        hasState(state) {\\r\\n          return this.states.indexOf(state) > -1;\\r\\n        }\\r\\n      \\r\\n        pushState(state) {\\r\\n          this.states.push(state);\\r\\n        }\\r\\n      \\r\\n        popState(state) {\\r\\n          if (this.isState(state)) {\\r\\n            this.states.pop();\\r\\n          } else {\\r\\n            throw new Error(`Cannot pop the non-active state \\\"${state}\\\"`);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        get currentFunctionContext() {\\r\\n          return last(this.functionContexts);\\r\\n        }\\r\\n      \\r\\n        get currentContext() {\\r\\n          return last(this.runningContexts);\\r\\n        }\\r\\n      \\r\\n        newFunctionContext() {\\r\\n          const newContext = { '@contextType': 'function' };\\r\\n          this.contexts.push(newContext);\\r\\n          this.functionContexts.push(newContext);\\r\\n        }\\r\\n      \\r\\n        newContext(run) {\\r\\n          const newContext = Object.assign({ '@contextType': 'const/let' }, this.currentContext);\\r\\n          this.contexts.push(newContext);\\r\\n          this.runningContexts.push(newContext);\\r\\n          run();\\r\\n          const { currentFunctionContext } = this;\\r\\n          for (const p in currentFunctionContext) {\\r\\n            if (!currentFunctionContext.hasOwnProperty(p) || newContext.hasOwnProperty(p)) continue;\\r\\n            newContext[p] = currentFunctionContext[p];\\r\\n          }\\r\\n          this.runningContexts.pop();\\r\\n          return newContext;\\r\\n        }\\r\\n      \\r\\n        useFunctionContext(run) {\\r\\n          const functionContext = last(this.functionContexts);\\r\\n          this.runningContexts.push(functionContext);\\r\\n          run();\\r\\n          this.runningContexts.pop();\\r\\n        }\\r\\n      \\r\\n        getIdentifiers(run) {\\r\\n          const trackedIdentifiers = this.trackedIdentifiers = [];\\r\\n          this.pushState(states.trackIdentifiers);\\r\\n          run();\\r\\n          this.trackedIdentifiers = null;\\r\\n          this.popState(states.trackIdentifiers);\\r\\n          return trackedIdentifiers;\\r\\n        }\\r\\n      \\r\\n        getDeclaration(name) {\\r\\n          const { currentContext, currentFunctionContext, runningContexts } = this;\\r\\n          const declaration = currentContext[name] || currentFunctionContext[name] || null;\\r\\n      \\r\\n          if (\\r\\n            !declaration &&\\r\\n            currentContext === currentFunctionContext &&\\r\\n            runningContexts.length > 0\\r\\n          ) {\\r\\n            const previousRunningContext = runningContexts[runningContexts.length - 2];\\r\\n            if (previousRunningContext[name]) {\\r\\n              return previousRunningContext[name];\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          return declaration;\\r\\n        }\\r\\n      \\r\\n        scan(ast) {\\r\\n          if (!ast) return;\\r\\n          if (Array.isArray(ast)) {\\r\\n            for (let i = 0; i < ast.length; i++) {\\r\\n              this.scan(ast[i]);\\r\\n            }\\r\\n            return;\\r\\n          }\\r\\n          switch (ast.type) {\\r\\n            case 'Program':\\r\\n              this.useFunctionContext(() => {\\r\\n                this.scan(ast.body);\\r\\n              });\\r\\n              break;\\r\\n            case 'BlockStatement':\\r\\n              this.newContext(() => {\\r\\n                this.scan(ast.body);\\r\\n              });\\r\\n              break;\\r\\n            case 'AssignmentExpression':\\r\\n            case 'LogicalExpression':\\r\\n              this.scan(ast.left);\\r\\n              this.scan(ast.right);\\r\\n              break;\\r\\n            case 'BinaryExpression':\\r\\n              this.scan(ast.left);\\r\\n              this.scan(ast.right);\\r\\n              break;\\r\\n            case 'UpdateExpression':\\r\\n              if (ast.operator === '++') {\\r\\n                const declaration = this.getDeclaration(ast.argument.name);\\r\\n                if (declaration) {\\r\\n                  declaration.suggestedType = 'Integer';\\r\\n                }\\r\\n              }\\r\\n              this.scan(ast.argument);\\r\\n              break;\\r\\n            case 'UnaryExpression':\\r\\n              this.scan(ast.argument);\\r\\n              break;\\r\\n            case 'VariableDeclaration':\\r\\n              if (ast.kind === 'var') {\\r\\n                this.useFunctionContext(() => {\\r\\n                  ast.declarations = utils.normalizeDeclarations(ast);\\r\\n                  this.scan(ast.declarations);\\r\\n                });\\r\\n              } else {\\r\\n                ast.declarations = utils.normalizeDeclarations(ast);\\r\\n                this.scan(ast.declarations);\\r\\n              }\\r\\n              break;\\r\\n            case 'VariableDeclarator': {\\r\\n              const { currentContext } = this;\\r\\n              const inForLoopInit = this.hasState(states.inForLoopInit);\\r\\n              const declaration = {\\r\\n                ast: ast,\\r\\n                context: currentContext,\\r\\n                name: ast.id.name,\\r\\n                origin: 'declaration',\\r\\n                inForLoopInit,\\r\\n                inForLoopTest: null,\\r\\n                assignable: currentContext === this.currentFunctionContext || (!inForLoopInit && !currentContext.hasOwnProperty(ast.id.name)),\\r\\n                suggestedType: null,\\r\\n                valueType: null,\\r\\n                dependencies: null,\\r\\n                isSafe: null,\\r\\n              };\\r\\n              if (!currentContext[ast.id.name]) {\\r\\n                currentContext[ast.id.name] = declaration;\\r\\n              }\\r\\n              this.declarations.push(declaration);\\r\\n              this.scan(ast.id);\\r\\n              this.scan(ast.init);\\r\\n              break;\\r\\n            }\\r\\n            case 'FunctionExpression':\\r\\n            case 'FunctionDeclaration':\\r\\n              if (this.runningContexts.length === 0) {\\r\\n                this.scan(ast.body);\\r\\n              } else {\\r\\n                this.functions.push(ast);\\r\\n              }\\r\\n              break;\\r\\n            case 'IfStatement':\\r\\n              this.scan(ast.test);\\r\\n              this.scan(ast.consequent);\\r\\n              if (ast.alternate) this.scan(ast.alternate);\\r\\n              break;\\r\\n            case 'ForStatement': {\\r\\n              let testIdentifiers;\\r\\n              const context = this.newContext(() => {\\r\\n                this.pushState(states.inForLoopInit);\\r\\n                this.scan(ast.init);\\r\\n                this.popState(states.inForLoopInit);\\r\\n      \\r\\n                testIdentifiers = this.getIdentifiers(() => {\\r\\n                  this.scan(ast.test);\\r\\n                });\\r\\n      \\r\\n                this.scan(ast.update);\\r\\n                this.newContext(() => {\\r\\n                  this.scan(ast.body);\\r\\n                });\\r\\n              });\\r\\n      \\r\\n              if (testIdentifiers) {\\r\\n                for (const p in context) {\\r\\n                  if (p === '@contextType') continue;\\r\\n                  if (testIdentifiers.indexOf(p) > -1) {\\r\\n                    context[p].inForLoopTest = true;\\r\\n                  }\\r\\n                }\\r\\n              }\\r\\n              break;\\r\\n            }\\r\\n            case 'DoWhileStatement':\\r\\n            case 'WhileStatement':\\r\\n              this.newContext(() => {\\r\\n                this.scan(ast.body);\\r\\n                this.scan(ast.test);\\r\\n              });\\r\\n              break;\\r\\n            case 'Identifier': {\\r\\n              if (this.isState(states.trackIdentifiers)) {\\r\\n                this.trackedIdentifiers.push(ast.name);\\r\\n              }\\r\\n              this.identifiers.push({\\r\\n                context: this.currentContext,\\r\\n                declaration: this.getDeclaration(ast.name),\\r\\n                ast,\\r\\n              });\\r\\n              break;\\r\\n            }\\r\\n            case 'ReturnStatement':\\r\\n              this.returnStatements.push(ast);\\r\\n              this.scan(ast.argument);\\r\\n              break;\\r\\n            case 'MemberExpression':\\r\\n              this.pushState(states.memberExpression);\\r\\n              this.scan(ast.object);\\r\\n              this.scan(ast.property);\\r\\n              this.popState(states.memberExpression);\\r\\n              break;\\r\\n            case 'ExpressionStatement':\\r\\n              this.scan(ast.expression);\\r\\n              break;\\r\\n            case 'SequenceExpression':\\r\\n              this.scan(ast.expressions);\\r\\n              break;\\r\\n            case 'CallExpression':\\r\\n              this.functionCalls.push({\\r\\n                context: this.currentContext,\\r\\n                ast,\\r\\n              });\\r\\n              this.scan(ast.arguments);\\r\\n              break;\\r\\n            case 'ArrayExpression':\\r\\n              this.scan(ast.elements);\\r\\n              break;\\r\\n            case 'ConditionalExpression':\\r\\n              this.scan(ast.test);\\r\\n              this.scan(ast.alternate);\\r\\n              this.scan(ast.consequent);\\r\\n              break;\\r\\n            case 'SwitchStatement':\\r\\n              this.scan(ast.discriminant);\\r\\n              this.scan(ast.cases);\\r\\n              break;\\r\\n            case 'SwitchCase':\\r\\n              this.scan(ast.test);\\r\\n              this.scan(ast.consequent);\\r\\n              break;\\r\\n      \\r\\n            case 'ThisExpression':\\r\\n            case 'Literal':\\r\\n            case 'DebuggerStatement':\\r\\n            case 'EmptyStatement':\\r\\n            case 'BreakStatement':\\r\\n            case 'ContinueStatement':\\r\\n              break;\\r\\n            default:\\r\\n              throw new Error(`unhandled type \\\"${ast.type}\\\"`);\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        FunctionTracer,\\r\\n      };\\r\\n      },{\\\"../utils\\\":114}],12:[function(require,module,exports){\\r\\n      const { glWiretap } = require('gl-wiretap');\\r\\n      const { utils } = require('../../utils');\\r\\n      \\r\\n      function toStringWithoutUtils(fn) {\\r\\n        return fn.toString()\\r\\n          .replace('=>', '')\\r\\n          .replace(/^function /, '')\\r\\n          .replace(/utils[.]/g, '/*utils.*/');\\r\\n      }\\r\\n      \\r\\n      function glKernelString(Kernel, args, originKernel, setupContextString, destroyContextString) {\\r\\n        if (!originKernel.built) {\\r\\n          originKernel.build.apply(originKernel, args);\\r\\n        }\\r\\n        args = args ? Array.from(args).map(arg => {\\r\\n          switch (typeof arg) {\\r\\n            case 'boolean':\\r\\n              return new Boolean(arg);\\r\\n            case 'number':\\r\\n              return new Number(arg);\\r\\n            default:\\r\\n              return arg;\\r\\n          }\\r\\n        }) : null;\\r\\n        const uploadedValues = [];\\r\\n        const postResult = [];\\r\\n        const context = glWiretap(originKernel.context, {\\r\\n          useTrackablePrimitives: true,\\r\\n          onReadPixels: (targetName) => {\\r\\n            if (kernel.subKernels) {\\r\\n              if (!subKernelsResultVariableSetup) {\\r\\n                postResult.push(`    const result = { result: ${getRenderString(targetName, kernel)} };`);\\r\\n                subKernelsResultVariableSetup = true;\\r\\n              } else {\\r\\n                const property = kernel.subKernels[subKernelsResultIndex++].property;\\r\\n                postResult.push(`    result${isNaN(property) ? '.' + property : `[${property}]`} = ${getRenderString(targetName, kernel)};`);\\r\\n              }\\r\\n              if (subKernelsResultIndex === kernel.subKernels.length) {\\r\\n                postResult.push('    return result;');\\r\\n              }\\r\\n              return;\\r\\n            }\\r\\n            if (targetName) {\\r\\n              postResult.push(`    return ${getRenderString(targetName, kernel)};`);\\r\\n            } else {\\r\\n              postResult.push(`    return null;`);\\r\\n            }\\r\\n          },\\r\\n          onUnrecognizedArgumentLookup: (argument) => {\\r\\n            const argumentName = findKernelValue(argument, kernel.kernelArguments, [], context, uploadedValues);\\r\\n            if (argumentName) {\\r\\n              return argumentName;\\r\\n            }\\r\\n            const constantName = findKernelValue(argument, kernel.kernelConstants, constants ? Object.keys(constants).map(key => constants[key]) : [], context, uploadedValues);\\r\\n            if (constantName) {\\r\\n              return constantName;\\r\\n            }\\r\\n            return null;\\r\\n          }\\r\\n        });\\r\\n        let subKernelsResultVariableSetup = false;\\r\\n        let subKernelsResultIndex = 0;\\r\\n        const {\\r\\n          source,\\r\\n          canvas,\\r\\n          output,\\r\\n          pipeline,\\r\\n          graphical,\\r\\n          loopMaxIterations,\\r\\n          constants,\\r\\n          optimizeFloatMemory,\\r\\n          precision,\\r\\n          fixIntegerDivisionAccuracy,\\r\\n          functions,\\r\\n          nativeFunctions,\\r\\n          subKernels,\\r\\n          immutable,\\r\\n          argumentTypes,\\r\\n          constantTypes,\\r\\n          kernelArguments,\\r\\n          kernelConstants,\\r\\n          tactic,\\r\\n        } = originKernel;\\r\\n        const kernel = new Kernel(source, {\\r\\n          canvas,\\r\\n          context,\\r\\n          checkContext: false,\\r\\n          output,\\r\\n          pipeline,\\r\\n          graphical,\\r\\n          loopMaxIterations,\\r\\n          constants,\\r\\n          optimizeFloatMemory,\\r\\n          precision,\\r\\n          fixIntegerDivisionAccuracy,\\r\\n          functions,\\r\\n          nativeFunctions,\\r\\n          subKernels,\\r\\n          immutable,\\r\\n          argumentTypes,\\r\\n          constantTypes,\\r\\n          tactic,\\r\\n        });\\r\\n        let result = [];\\r\\n        context.setIndent(2);\\r\\n        kernel.build.apply(kernel, args);\\r\\n        result.push(context.toString());\\r\\n        context.reset();\\r\\n      \\r\\n        kernel.kernelArguments.forEach((kernelArgument, i) => {\\r\\n          switch (kernelArgument.type) {\\r\\n            case 'Integer':\\r\\n            case 'Boolean':\\r\\n            case 'Number':\\r\\n            case 'Float':\\r\\n            case 'Array':\\r\\n            case 'Array(2)':\\r\\n            case 'Array(3)':\\r\\n            case 'Array(4)':\\r\\n            case 'HTMLCanvas':\\r\\n            case 'HTMLImage':\\r\\n            case 'HTMLVideo':\\r\\n              context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);\\r\\n              break;\\r\\n            case 'HTMLImageArray':\\r\\n              for (let imageIndex = 0; imageIndex < args[i].length; imageIndex++) {\\r\\n                const arg = args[i];\\r\\n                context.insertVariable(`uploadValue_${kernelArgument.name}[${imageIndex}]`, arg[imageIndex]);\\r\\n              }\\r\\n              break;\\r\\n            case 'Input':\\r\\n              context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);\\r\\n              break;\\r\\n            case 'MemoryOptimizedNumberTexture':\\r\\n            case 'NumberTexture':\\r\\n            case 'Array1D(2)':\\r\\n            case 'Array1D(3)':\\r\\n            case 'Array1D(4)':\\r\\n            case 'Array2D(2)':\\r\\n            case 'Array2D(3)':\\r\\n            case 'Array2D(4)':\\r\\n            case 'Array3D(2)':\\r\\n            case 'Array3D(3)':\\r\\n            case 'Array3D(4)':\\r\\n            case 'ArrayTexture(1)':\\r\\n            case 'ArrayTexture(2)':\\r\\n            case 'ArrayTexture(3)':\\r\\n            case 'ArrayTexture(4)':\\r\\n              context.insertVariable(`uploadValue_${kernelArgument.name}`, args[i].texture);\\r\\n              break;\\r\\n            default:\\r\\n              throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${kernelArgument.type}`);\\r\\n          }\\r\\n        });\\r\\n        result.push('/** start of injected functions **/');\\r\\n        result.push(`function ${toStringWithoutUtils(utils.flattenTo)}`);\\r\\n        result.push(`function ${toStringWithoutUtils(utils.flatten2dArrayTo)}`);\\r\\n        result.push(`function ${toStringWithoutUtils(utils.flatten3dArrayTo)}`);\\r\\n        result.push(`function ${toStringWithoutUtils(utils.flatten4dArrayTo)}`);\\r\\n        result.push(`function ${toStringWithoutUtils(utils.isArray)}`);\\r\\n        if (kernel.renderOutput !== kernel.renderTexture && kernel.formatValues) {\\r\\n          result.push(\\r\\n            `  const renderOutput = function ${toStringWithoutUtils(kernel.formatValues)};`\\r\\n          );\\r\\n        }\\r\\n        result.push('/** end of injected functions **/');\\r\\n        result.push(`  const innerKernel = function (${kernel.kernelArguments.map(kernelArgument => kernelArgument.varName).join(', ')}) {`);\\r\\n        context.setIndent(4);\\r\\n        kernel.run.apply(kernel, args);\\r\\n        if (kernel.renderKernels) {\\r\\n          kernel.renderKernels();\\r\\n        } else if (kernel.renderOutput) {\\r\\n          kernel.renderOutput();\\r\\n        }\\r\\n        result.push('    /** start setup uploads for kernel values **/');\\r\\n        kernel.kernelArguments.forEach(kernelArgument => {\\r\\n          result.push('    ' + kernelArgument.getStringValueHandler().split('\\\\n').join('\\\\n    '));\\r\\n        });\\r\\n        result.push('    /** end setup uploads for kernel values **/');\\r\\n        result.push(context.toString());\\r\\n        if (kernel.renderOutput === kernel.renderTexture) {\\r\\n          context.reset();\\r\\n          const framebufferName = context.getContextVariableName(kernel.framebuffer);\\r\\n          if (kernel.renderKernels) {\\r\\n            const results = kernel.renderKernels();\\r\\n            const textureName = context.getContextVariableName(kernel.texture.texture);\\r\\n            result.push(`    return {\\r\\n            result: {\\r\\n              texture: ${ textureName },\\r\\n              type: '${ results.result.type }',\\r\\n              toArray: ${ getToArrayString(results.result, textureName, framebufferName) }\\r\\n            },`);\\r\\n            const { subKernels, mappedTextures } = kernel;\\r\\n            for (let i = 0; i < subKernels.length; i++) {\\r\\n              const texture = mappedTextures[i];\\r\\n              const subKernel = subKernels[i];\\r\\n              const subKernelResult = results[subKernel.property];\\r\\n              const subKernelTextureName = context.getContextVariableName(texture.texture);\\r\\n              result.push(`\\r\\n            ${subKernel.property}: {\\r\\n              texture: ${ subKernelTextureName },\\r\\n              type: '${ subKernelResult.type }',\\r\\n              toArray: ${ getToArrayString(subKernelResult, subKernelTextureName, framebufferName) }\\r\\n            },`);\\r\\n            }\\r\\n            result.push(`    };`);\\r\\n          } else {\\r\\n            const rendered = kernel.renderOutput();\\r\\n            const textureName = context.getContextVariableName(kernel.texture.texture);\\r\\n            result.push(`    return {\\r\\n              texture: ${ textureName },\\r\\n              type: '${ rendered.type }',\\r\\n              toArray: ${ getToArrayString(rendered, textureName, framebufferName) }\\r\\n            };`);\\r\\n          }\\r\\n        }\\r\\n        result.push(`    ${destroyContextString ? '\\\\n' + destroyContextString + '    ': ''}`);\\r\\n        result.push(postResult.join('\\\\n'));\\r\\n        result.push('  };');\\r\\n        if (kernel.graphical) {\\r\\n          result.push(getGetPixelsString(kernel));\\r\\n          result.push(`  innerKernel.getPixels = getPixels;`);\\r\\n        }\\r\\n        result.push('  return innerKernel;');\\r\\n      \\r\\n        let constantsUpload = [];\\r\\n        kernelConstants.forEach((kernelConstant) => {\\r\\n          constantsUpload.push(`${kernelConstant.getStringValueHandler()}`);\\r\\n        });\\r\\n        return `function kernel(settings) {\\r\\n        const { context, constants } = settings;\\r\\n        ${constantsUpload.join('')}\\r\\n        ${setupContextString ? setupContextString : ''}\\r\\n      ${result.join('\\\\n')}\\r\\n      }`;\\r\\n      }\\r\\n      \\r\\n      function getRenderString(targetName, kernel) {\\r\\n        const readBackValue = kernel.precision === 'single' ? targetName : `new Float32Array(${targetName}.buffer)`;\\r\\n        if (kernel.output[2]) {\\r\\n          return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]}, ${kernel.output[2]})`;\\r\\n        }\\r\\n        if (kernel.output[1]) {\\r\\n          return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]})`;\\r\\n        }\\r\\n      \\r\\n        return `renderOutput(${readBackValue}, ${kernel.output[0]})`;\\r\\n      }\\r\\n      \\r\\n      function getGetPixelsString(kernel) {\\r\\n        const getPixels = kernel.getPixels.toString();\\r\\n        const useFunctionKeyword = !/^function/.test(getPixels);\\r\\n        return utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ getPixels }`, {\\r\\n          findDependency: (object, name) => {\\r\\n            if (object === 'utils') {\\r\\n              return `const ${name} = ${utils[name].toString()};`;\\r\\n            }\\r\\n            return null;\\r\\n          },\\r\\n          thisLookup: (property) => {\\r\\n            if (property === 'context') {\\r\\n              return null;\\r\\n            }\\r\\n            if (kernel.hasOwnProperty(property)) {\\r\\n              return JSON.stringify(kernel[property]);\\r\\n            }\\r\\n            throw new Error(`unhandled thisLookup ${ property }`);\\r\\n          }\\r\\n        });\\r\\n      }\\r\\n      \\r\\n      function getToArrayString(kernelResult, textureName, framebufferName) {\\r\\n        const toArray = kernelResult.toArray.toString();\\r\\n        const useFunctionKeyword = !/^function/.test(toArray);\\r\\n        const flattenedFunctions = utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ toArray }`, {\\r\\n          findDependency: (object, name) => {\\r\\n            if (object === 'utils') {\\r\\n              return `const ${name} = ${utils[name].toString()};`;\\r\\n            } else if (object === 'this') {\\r\\n              if (name === 'framebuffer') {\\r\\n                return '';\\r\\n              }\\r\\n              return `${useFunctionKeyword ? 'function ' : ''}${kernelResult[name].toString()}`;\\r\\n            } else {\\r\\n              throw new Error('unhandled fromObject');\\r\\n            }\\r\\n          },\\r\\n          thisLookup: (property, isDeclaration) => {\\r\\n            if (property === 'texture') {\\r\\n              return textureName;\\r\\n            }\\r\\n            if (property === 'context') {\\r\\n              if (isDeclaration) return null;\\r\\n              return 'gl';\\r\\n            }\\r\\n            if (kernelResult.hasOwnProperty(property)) {\\r\\n              return JSON.stringify(kernelResult[property]);\\r\\n            }\\r\\n            throw new Error(`unhandled thisLookup ${ property }`);\\r\\n          }\\r\\n        });\\r\\n        return `() => {\\r\\n        function framebuffer() { return ${framebufferName}; };\\r\\n        ${flattenedFunctions}\\r\\n        return toArray();\\r\\n        }`;\\r\\n      }\\r\\n      \\r\\n      function findKernelValue(argument, kernelValues, values, context, uploadedValues) {\\r\\n        if (argument === null) return null;\\r\\n        if (kernelValues === null) return null;\\r\\n        switch (typeof argument) {\\r\\n          case 'boolean':\\r\\n          case 'number':\\r\\n            return null;\\r\\n        }\\r\\n        if (\\r\\n          typeof HTMLImageElement !== 'undefined' &&\\r\\n          argument instanceof HTMLImageElement\\r\\n        ) {\\r\\n          for (let i = 0; i < kernelValues.length; i++) {\\r\\n            const kernelValue = kernelValues[i];\\r\\n            if (kernelValue.type !== 'HTMLImageArray' && kernelValue) continue;\\r\\n            if (kernelValue.uploadValue !== argument) continue;\\r\\n            const variableIndex = values[i].indexOf(argument);\\r\\n            if (variableIndex === -1) continue;\\r\\n            const variableName = `uploadValue_${kernelValue.name}[${variableIndex}]`;\\r\\n            context.insertVariable(variableName, argument);\\r\\n            return variableName;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        for (let i = 0; i < kernelValues.length; i++) {\\r\\n          const kernelValue = kernelValues[i];\\r\\n          if (argument !== kernelValue.uploadValue) continue;\\r\\n          const variable = `uploadValue_${kernelValue.name}`;\\r\\n          context.insertVariable(variable, kernelValue);\\r\\n          return variable;\\r\\n        }\\r\\n        return null;\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        glKernelString\\r\\n      };\\r\\n      },{\\\"../../utils\\\":114,\\\"gl-wiretap\\\":3}],13:[function(require,module,exports){\\r\\n      const { Kernel } = require('../kernel');\\r\\n      const { utils } = require('../../utils');\\r\\n      const { GLTextureArray2Float } = require('./texture/array-2-float');\\r\\n      const { GLTextureArray2Float2D } = require('./texture/array-2-float-2d');\\r\\n      const { GLTextureArray2Float3D } = require('./texture/array-2-float-3d');\\r\\n      const { GLTextureArray3Float } = require('./texture/array-3-float');\\r\\n      const { GLTextureArray3Float2D } = require('./texture/array-3-float-2d');\\r\\n      const { GLTextureArray3Float3D } = require('./texture/array-3-float-3d');\\r\\n      const { GLTextureArray4Float } = require('./texture/array-4-float');\\r\\n      const { GLTextureArray4Float2D } = require('./texture/array-4-float-2d');\\r\\n      const { GLTextureArray4Float3D } = require('./texture/array-4-float-3d');\\r\\n      const { GLTextureFloat } = require('./texture/float');\\r\\n      const { GLTextureFloat2D } = require('./texture/float-2d');\\r\\n      const { GLTextureFloat3D } = require('./texture/float-3d');\\r\\n      const { GLTextureMemoryOptimized } = require('./texture/memory-optimized');\\r\\n      const { GLTextureMemoryOptimized2D } = require('./texture/memory-optimized-2d');\\r\\n      const { GLTextureMemoryOptimized3D } = require('./texture/memory-optimized-3d');\\r\\n      const { GLTextureUnsigned } = require('./texture/unsigned');\\r\\n      const { GLTextureUnsigned2D } = require('./texture/unsigned-2d');\\r\\n      const { GLTextureUnsigned3D } = require('./texture/unsigned-3d');\\r\\n      const { GLTextureGraphical } = require('./texture/graphical');\\r\\n      \\r\\n      class GLKernel extends Kernel {\\r\\n        static get mode() {\\r\\n          return 'gpu';\\r\\n        }\\r\\n      \\r\\n        static getIsFloatRead() {\\r\\n          const kernelString = `function kernelFunction() {\\r\\n            return 1;\\r\\n          }`;\\r\\n          const kernel = new this(kernelString, {\\r\\n            context: this.testContext,\\r\\n            canvas: this.testCanvas,\\r\\n            validate: false,\\r\\n            output: [1],\\r\\n            precision: 'single',\\r\\n            returnType: 'Number',\\r\\n            tactic: 'speed',\\r\\n          });\\r\\n          kernel.build();\\r\\n          kernel.run();\\r\\n          const result = kernel.renderOutput();\\r\\n          kernel.destroy(true);\\r\\n          return result[0] === 1;\\r\\n        }\\r\\n      \\r\\n        static getIsIntegerDivisionAccurate() {\\r\\n          function kernelFunction(v1, v2) {\\r\\n            return v1[this.thread.x] / v2[this.thread.x];\\r\\n          }\\r\\n          const kernel = new this(kernelFunction.toString(), {\\r\\n            context: this.testContext,\\r\\n            canvas: this.testCanvas,\\r\\n            validate: false,\\r\\n            output: [2],\\r\\n            returnType: 'Number',\\r\\n            precision: 'unsigned',\\r\\n            tactic: 'speed',\\r\\n          });\\r\\n          const args = [\\r\\n            [6, 6030401],\\r\\n            [3, 3991]\\r\\n          ];\\r\\n          kernel.build.apply(kernel, args);\\r\\n          kernel.run.apply(kernel, args);\\r\\n          const result = kernel.renderOutput();\\r\\n          kernel.destroy(true);\\r\\n          return result[0] === 2 && result[1] === 1511;\\r\\n        }\\r\\n      \\r\\n        static getIsSpeedTacticSupported() {\\r\\n          function kernelFunction(value) {\\r\\n            return value[this.thread.x];\\r\\n          }\\r\\n          const kernel = new this(kernelFunction.toString(), {\\r\\n            context: this.testContext,\\r\\n            canvas: this.testCanvas,\\r\\n            validate: false,\\r\\n            output: [4],\\r\\n            returnType: 'Number',\\r\\n            precision: 'unsigned',\\r\\n            tactic: 'speed',\\r\\n          });\\r\\n          const args = [\\r\\n            [0, 1, 2, 3]\\r\\n          ];\\r\\n          kernel.build.apply(kernel, args);\\r\\n          kernel.run.apply(kernel, args);\\r\\n          const result = kernel.renderOutput();\\r\\n          kernel.destroy(true);\\r\\n          return Math.round(result[0]) === 0 && Math.round(result[1]) === 1 && Math.round(result[2]) === 2 && Math.round(result[3]) === 3;\\r\\n        }\\r\\n      \\r\\n        static get testCanvas() {\\r\\n          throw new Error(`\\\"testCanvas\\\" not defined on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        static get testContext() {\\r\\n          throw new Error(`\\\"testContext\\\" not defined on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        static getFeatures() {\\r\\n          const gl = this.testContext;\\r\\n          const isDrawBuffers = this.getIsDrawBuffers();\\r\\n          return Object.freeze({\\r\\n            isFloatRead: this.getIsFloatRead(),\\r\\n            isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),\\r\\n            isSpeedTacticSupported: this.getIsSpeedTacticSupported(),\\r\\n            isTextureFloat: this.getIsTextureFloat(),\\r\\n            isDrawBuffers,\\r\\n            kernelMap: isDrawBuffers,\\r\\n            channelCount: this.getChannelCount(),\\r\\n            maxTextureSize: this.getMaxTextureSize(),\\r\\n            lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),\\r\\n            lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),\\r\\n            mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),\\r\\n            mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),\\r\\n            highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),\\r\\n            highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),\\r\\n          });\\r\\n        }\\r\\n      \\r\\n        static setupFeatureChecks() {\\r\\n          throw new Error(`\\\"setupFeatureChecks\\\" not defined on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        static getSignature(kernel, argumentTypes) {\\r\\n          return kernel.getVariablePrecisionString() + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');\\r\\n        }\\r\\n      \\r\\n        setFixIntegerDivisionAccuracy(fix) {\\r\\n          this.fixIntegerDivisionAccuracy = fix;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setPrecision(flag) {\\r\\n          this.precision = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setFloatTextures(flag) {\\r\\n          utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');\\r\\n          this.floatTextures = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        static nativeFunctionArguments(source) {\\r\\n          const argumentTypes = [];\\r\\n          const argumentNames = [];\\r\\n          const states = [];\\r\\n          const isStartingVariableName = /^[a-zA-Z_]/;\\r\\n          const isVariableChar = /[a-zA-Z_0-9]/;\\r\\n          let i = 0;\\r\\n          let argumentName = null;\\r\\n          let argumentType = null;\\r\\n          while (i < source.length) {\\r\\n            const char = source[i];\\r\\n            const nextChar = source[i + 1];\\r\\n            const state = states.length > 0 ? states[states.length - 1] : null;\\r\\n      \\r\\n            if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {\\r\\n              states.push('MULTI_LINE_COMMENT');\\r\\n              i += 2;\\r\\n              continue;\\r\\n            } else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {\\r\\n              states.pop();\\r\\n              i += 2;\\r\\n              continue;\\r\\n            }\\r\\n      \\r\\n            else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {\\r\\n              states.push('COMMENT');\\r\\n              i += 2;\\r\\n              continue;\\r\\n            } else if (state === 'COMMENT' && char === '\\\\n') {\\r\\n              states.pop();\\r\\n              i++;\\r\\n              continue;\\r\\n            }\\r\\n      \\r\\n            else if (state === null && char === '(') {\\r\\n              states.push('FUNCTION_ARGUMENTS');\\r\\n              i++;\\r\\n              continue;\\r\\n            } else if (state === 'FUNCTION_ARGUMENTS') {\\r\\n              if (char === ')') {\\r\\n                states.pop();\\r\\n                break;\\r\\n              }\\r\\n              if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {\\r\\n                states.push('DECLARE_VARIABLE');\\r\\n                argumentType = 'float';\\r\\n                argumentName = '';\\r\\n                i += 6;\\r\\n                continue;\\r\\n              } else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {\\r\\n                states.push('DECLARE_VARIABLE');\\r\\n                argumentType = 'int';\\r\\n                argumentName = '';\\r\\n                i += 4;\\r\\n                continue;\\r\\n              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {\\r\\n                states.push('DECLARE_VARIABLE');\\r\\n                argumentType = 'vec2';\\r\\n                argumentName = '';\\r\\n                i += 5;\\r\\n                continue;\\r\\n              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {\\r\\n                states.push('DECLARE_VARIABLE');\\r\\n                argumentType = 'vec3';\\r\\n                argumentName = '';\\r\\n                i += 5;\\r\\n                continue;\\r\\n              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {\\r\\n                states.push('DECLARE_VARIABLE');\\r\\n                argumentType = 'vec4';\\r\\n                argumentName = '';\\r\\n                i += 5;\\r\\n                continue;\\r\\n              }\\r\\n            }\\r\\n      \\r\\n            else if (state === 'DECLARE_VARIABLE') {\\r\\n              if (argumentName === '') {\\r\\n                if (char === ' ') {\\r\\n                  i++;\\r\\n                  continue;\\r\\n                }\\r\\n                if (!isStartingVariableName.test(char)) {\\r\\n                  throw new Error('variable name is not expected string');\\r\\n                }\\r\\n              }\\r\\n              argumentName += char;\\r\\n              if (!isVariableChar.test(nextChar)) {\\r\\n                states.pop();\\r\\n                argumentNames.push(argumentName);\\r\\n                argumentTypes.push(typeMap[argumentType]);\\r\\n              }\\r\\n            }\\r\\n      \\r\\n            i++;\\r\\n          }\\r\\n          if (states.length > 0) {\\r\\n            throw new Error('GLSL function was not parsable');\\r\\n          }\\r\\n          return {\\r\\n            argumentNames,\\r\\n            argumentTypes,\\r\\n          };\\r\\n        }\\r\\n      \\r\\n        static nativeFunctionReturnType(source) {\\r\\n          return typeMap[source.match(/int|float|vec[2-4]/)[0]];\\r\\n        }\\r\\n      \\r\\n        static combineKernels(combinedKernel, lastKernel) {\\r\\n          combinedKernel.apply(null, arguments);\\r\\n          const {\\r\\n            texSize,\\r\\n            context,\\r\\n            threadDim\\r\\n          } = lastKernel.texSize;\\r\\n          let result;\\r\\n          if (lastKernel.precision === 'single') {\\r\\n            const w = texSize[0];\\r\\n            const h = Math.ceil(texSize[1] / 4);\\r\\n            result = new Float32Array(w * h * 4 * 4);\\r\\n            context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);\\r\\n          } else {\\r\\n            const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);\\r\\n            context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);\\r\\n            result = new Float32Array(bytes.buffer);\\r\\n          }\\r\\n      \\r\\n          result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);\\r\\n      \\r\\n          if (lastKernel.output.length === 1) {\\r\\n            return result;\\r\\n          } else if (lastKernel.output.length === 2) {\\r\\n            return utils.splitArray(result, lastKernel.output[0]);\\r\\n          } else if (lastKernel.output.length === 3) {\\r\\n            const cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);\\r\\n            return cube.map(function(x) {\\r\\n              return utils.splitArray(x, lastKernel.output[0]);\\r\\n            });\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        constructor(source, settings) {\\r\\n          super(source, settings);\\r\\n          this.transferValues = null;\\r\\n          this.formatValues = null;\\r\\n          this.TextureConstructor = null;\\r\\n          this.renderOutput = null;\\r\\n          this.renderRawOutput = null;\\r\\n          this.texSize = null;\\r\\n          this.translatedSource = null;\\r\\n          this.compiledFragmentShader = null;\\r\\n          this.compiledVertexShader = null;\\r\\n          this.switchingKernels = null;\\r\\n          this._textureSwitched = null;\\r\\n          this._mappedTextureSwitched = null;\\r\\n        }\\r\\n      \\r\\n        checkTextureSize() {\\r\\n          const { features } = this.constructor;\\r\\n          if (this.texSize[0] > features.maxTextureSize || this.texSize[1] > features.maxTextureSize) {\\r\\n            throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${features.maxTextureSize},${features.maxTextureSize}]`);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        translateSource() {\\r\\n          throw new Error(`\\\"translateSource\\\" not defined on ${this.constructor.name}`);\\r\\n        }\\r\\n      \\r\\n        pickRenderStrategy(args) {\\r\\n          if (this.graphical) {\\r\\n            this.renderRawOutput = this.readPackedPixelsToUint8Array;\\r\\n            this.transferValues = (pixels) => pixels;\\r\\n            this.TextureConstructor = GLTextureGraphical;\\r\\n            return null;\\r\\n          }\\r\\n          if (this.precision === 'unsigned') {\\r\\n            this.renderRawOutput = this.readPackedPixelsToUint8Array;\\r\\n            this.transferValues = this.readPackedPixelsToFloat32Array;\\r\\n            if (this.pipeline) {\\r\\n              this.renderOutput = this.renderTexture;\\r\\n              if (this.subKernels !== null) {\\r\\n                this.renderKernels = this.renderKernelsToTextures;\\r\\n              }\\r\\n              switch (this.returnType) {\\r\\n                case 'LiteralInteger':\\r\\n                case 'Float':\\r\\n                case 'Number':\\r\\n                case 'Integer':\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureUnsigned3D;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureUnsigned2D;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureUnsigned;\\r\\n                    return null;\\r\\n                  }\\r\\n                  case 'Array(2)':\\r\\n                  case 'Array(3)':\\r\\n                  case 'Array(4)':\\r\\n                    return this.requestFallback(args);\\r\\n              }\\r\\n            } else {\\r\\n              if (this.subKernels !== null) {\\r\\n                this.renderKernels = this.renderKernelsToArrays;\\r\\n              }\\r\\n              switch (this.returnType) {\\r\\n                case 'LiteralInteger':\\r\\n                case 'Float':\\r\\n                case 'Number':\\r\\n                case 'Integer':\\r\\n                  this.renderOutput = this.renderValues;\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureUnsigned3D;\\r\\n                    this.formatValues = utils.erect3DPackedFloat;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureUnsigned2D;\\r\\n                    this.formatValues = utils.erect2DPackedFloat;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureUnsigned;\\r\\n                    this.formatValues = utils.erectPackedFloat;\\r\\n                    return null;\\r\\n                  }\\r\\n                  case 'Array(2)':\\r\\n                  case 'Array(3)':\\r\\n                  case 'Array(4)':\\r\\n                    return this.requestFallback(args);\\r\\n              }\\r\\n            }\\r\\n          } else if (this.precision === 'single') {\\r\\n            this.renderRawOutput = this.readFloatPixelsToFloat32Array;\\r\\n            this.transferValues = this.readFloatPixelsToFloat32Array;\\r\\n            if (this.pipeline) {\\r\\n              this.renderOutput = this.renderTexture;\\r\\n              if (this.subKernels !== null) {\\r\\n                this.renderKernels = this.renderKernelsToTextures;\\r\\n              }\\r\\n              switch (this.returnType) {\\r\\n                case 'LiteralInteger':\\r\\n                case 'Float':\\r\\n                case 'Number':\\r\\n                case 'Integer': {\\r\\n                  if (this.optimizeFloatMemory) {\\r\\n                    if (this.output[2] > 0) {\\r\\n                      this.TextureConstructor = GLTextureMemoryOptimized3D;\\r\\n                      return null;\\r\\n                    } else if (this.output[1] > 0) {\\r\\n                      this.TextureConstructor = GLTextureMemoryOptimized2D;\\r\\n                      return null;\\r\\n                    } else {\\r\\n                      this.TextureConstructor = GLTextureMemoryOptimized;\\r\\n                      return null;\\r\\n                    }\\r\\n                  } else {\\r\\n                    if (this.output[2] > 0) {\\r\\n                      this.TextureConstructor = GLTextureFloat3D;\\r\\n                      return null;\\r\\n                    } else if (this.output[1] > 0) {\\r\\n                      this.TextureConstructor = GLTextureFloat2D;\\r\\n                      return null;\\r\\n                    } else {\\r\\n                      this.TextureConstructor = GLTextureFloat;\\r\\n                      return null;\\r\\n                    }\\r\\n                  }\\r\\n                }\\r\\n                case 'Array(2)': {\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray2Float3D;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray2Float2D;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureArray2Float;\\r\\n                    return null;\\r\\n                  }\\r\\n                }\\r\\n                case 'Array(3)': {\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray3Float3D;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray3Float2D;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureArray3Float;\\r\\n                    return null;\\r\\n                  }\\r\\n                }\\r\\n                case 'Array(4)': {\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray4Float3D;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray4Float2D;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureArray4Float;\\r\\n                    return null;\\r\\n                  }\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n            this.renderOutput = this.renderValues;\\r\\n            if (this.subKernels !== null) {\\r\\n              this.renderKernels = this.renderKernelsToArrays;\\r\\n            }\\r\\n            if (this.optimizeFloatMemory) {\\r\\n              switch (this.returnType) {\\r\\n                case 'LiteralInteger':\\r\\n                case 'Float':\\r\\n                case 'Number':\\r\\n                case 'Integer': {\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureMemoryOptimized3D;\\r\\n                    this.formatValues = utils.erectMemoryOptimized3DFloat;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureMemoryOptimized2D;\\r\\n                    this.formatValues = utils.erectMemoryOptimized2DFloat;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureMemoryOptimized;\\r\\n                    this.formatValues = utils.erectMemoryOptimizedFloat;\\r\\n                    return null;\\r\\n                  }\\r\\n                }\\r\\n                case 'Array(2)': {\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray2Float3D;\\r\\n                    this.formatValues = utils.erect3DArray2;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray2Float2D;\\r\\n                    this.formatValues = utils.erect2DArray2;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureArray2Float;\\r\\n                    this.formatValues = utils.erectArray2;\\r\\n                    return null;\\r\\n                  }\\r\\n                }\\r\\n                case 'Array(3)': {\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray3Float3D;\\r\\n                    this.formatValues = utils.erect3DArray3;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray3Float2D;\\r\\n                    this.formatValues = utils.erect2DArray3;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureArray3Float;\\r\\n                    this.formatValues = utils.erectArray3;\\r\\n                    return null;\\r\\n                  }\\r\\n                }\\r\\n                case 'Array(4)': {\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray4Float3D;\\r\\n                    this.formatValues = utils.erect3DArray4;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray4Float2D;\\r\\n                    this.formatValues = utils.erect2DArray4;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureArray4Float;\\r\\n                    this.formatValues = utils.erectArray4;\\r\\n                    return null;\\r\\n                  }\\r\\n                }\\r\\n              }\\r\\n            } else {\\r\\n              switch (this.returnType) {\\r\\n                case 'LiteralInteger':\\r\\n                case 'Float':\\r\\n                case 'Number':\\r\\n                case 'Integer': {\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureFloat3D;\\r\\n                    this.formatValues = utils.erect3DFloat;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureFloat2D;\\r\\n                    this.formatValues = utils.erect2DFloat;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureFloat;\\r\\n                    this.formatValues = utils.erectFloat;\\r\\n                    return null;\\r\\n                  }\\r\\n                }\\r\\n                case 'Array(2)': {\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray2Float3D;\\r\\n                    this.formatValues = utils.erect3DArray2;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray2Float2D;\\r\\n                    this.formatValues = utils.erect2DArray2;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureArray2Float;\\r\\n                    this.formatValues = utils.erectArray2;\\r\\n                    return null;\\r\\n                  }\\r\\n                }\\r\\n                case 'Array(3)': {\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray3Float3D;\\r\\n                    this.formatValues = utils.erect3DArray3;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray3Float2D;\\r\\n                    this.formatValues = utils.erect2DArray3;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureArray3Float;\\r\\n                    this.formatValues = utils.erectArray3;\\r\\n                    return null;\\r\\n                  }\\r\\n                }\\r\\n                case 'Array(4)': {\\r\\n                  if (this.output[2] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray4Float3D;\\r\\n                    this.formatValues = utils.erect3DArray4;\\r\\n                    return null;\\r\\n                  } else if (this.output[1] > 0) {\\r\\n                    this.TextureConstructor = GLTextureArray4Float2D;\\r\\n                    this.formatValues = utils.erect2DArray4;\\r\\n                    return null;\\r\\n                  } else {\\r\\n                    this.TextureConstructor = GLTextureArray4Float;\\r\\n                    this.formatValues = utils.erectArray4;\\r\\n                    return null;\\r\\n                  }\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n          } else {\\r\\n            throw new Error(`unhandled precision of \\\"${this.precision}\\\"`);\\r\\n          }\\r\\n      \\r\\n          throw new Error(`unhandled return type \\\"${this.returnType}\\\"`);\\r\\n        }\\r\\n      \\r\\n        getKernelString() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n      \\r\\n        getMainResultTexture() {\\r\\n          switch (this.returnType) {\\r\\n            case 'LiteralInteger':\\r\\n            case 'Float':\\r\\n            case 'Integer':\\r\\n            case 'Number':\\r\\n              return this.getMainResultNumberTexture();\\r\\n            case 'Array(2)':\\r\\n              return this.getMainResultArray2Texture();\\r\\n            case 'Array(3)':\\r\\n              return this.getMainResultArray3Texture();\\r\\n            case 'Array(4)':\\r\\n              return this.getMainResultArray4Texture();\\r\\n            default:\\r\\n              throw new Error(`unhandled returnType type ${ this.returnType }`);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelNumberTexture() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n        getMainResultSubKernelNumberTexture() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n        getMainResultKernelArray2Texture() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n        getMainResultSubKernelArray2Texture() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n        getMainResultKernelArray3Texture() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n        getMainResultSubKernelArray3Texture() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n        getMainResultKernelArray4Texture() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n        getMainResultSubKernelArray4Texture() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n        getMainResultGraphical() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n        getMainResultMemoryOptimizedFloats() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n        getMainResultPackedPixels() {\\r\\n          throw new Error(`abstract method call`);\\r\\n        }\\r\\n      \\r\\n        getMainResultString() {\\r\\n          if (this.graphical) {\\r\\n            return this.getMainResultGraphical();\\r\\n          } else if (this.precision === 'single') {\\r\\n            if (this.optimizeFloatMemory) {\\r\\n              return this.getMainResultMemoryOptimizedFloats();\\r\\n            }\\r\\n            return this.getMainResultTexture();\\r\\n          } else {\\r\\n            return this.getMainResultPackedPixels();\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        getMainResultNumberTexture() {\\r\\n          return utils.linesToString(this.getMainResultKernelNumberTexture()) +\\r\\n            utils.linesToString(this.getMainResultSubKernelNumberTexture());\\r\\n        }\\r\\n      \\r\\n        getMainResultArray2Texture() {\\r\\n          return utils.linesToString(this.getMainResultKernelArray2Texture()) +\\r\\n            utils.linesToString(this.getMainResultSubKernelArray2Texture());\\r\\n        }\\r\\n      \\r\\n        getMainResultArray3Texture() {\\r\\n          return utils.linesToString(this.getMainResultKernelArray3Texture()) +\\r\\n            utils.linesToString(this.getMainResultSubKernelArray3Texture());\\r\\n        }\\r\\n      \\r\\n        getMainResultArray4Texture() {\\r\\n          return utils.linesToString(this.getMainResultKernelArray4Texture()) +\\r\\n            utils.linesToString(this.getMainResultSubKernelArray4Texture());\\r\\n        }\\r\\n      \\r\\n        getFloatTacticDeclaration() {\\r\\n          const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);\\r\\n          return `precision ${variablePrecision} float;\\\\n`;\\r\\n        }\\r\\n      \\r\\n        getIntTacticDeclaration() {\\r\\n          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic, true)} int;\\\\n`;\\r\\n        }\\r\\n      \\r\\n        getSampler2DTacticDeclaration() {\\r\\n          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;\\\\n`;\\r\\n        }\\r\\n      \\r\\n        getSampler2DArrayTacticDeclaration() {\\r\\n          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;\\\\n`;\\r\\n        }\\r\\n      \\r\\n        renderTexture() {\\r\\n          return this.immutable ? this.texture.clone() : this.texture;\\r\\n        }\\r\\n        readPackedPixelsToUint8Array() {\\r\\n          if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be \\\"unsigned\\\"');\\r\\n          const {\\r\\n            texSize,\\r\\n            context: gl\\r\\n          } = this;\\r\\n          const result = new Uint8Array(texSize[0] * texSize[1] * 4);\\r\\n          gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);\\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        readPackedPixelsToFloat32Array() {\\r\\n          return new Float32Array(this.readPackedPixelsToUint8Array().buffer);\\r\\n        }\\r\\n      \\r\\n        readFloatPixelsToFloat32Array() {\\r\\n          if (this.precision !== 'single') throw new Error('Requires this.precision to be \\\"single\\\"');\\r\\n          const {\\r\\n            texSize,\\r\\n            context: gl\\r\\n          } = this;\\r\\n          const w = texSize[0];\\r\\n          const h = texSize[1];\\r\\n          const result = new Float32Array(w * h * 4);\\r\\n          gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);\\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        getPixels(flip) {\\r\\n          const {\\r\\n            context: gl,\\r\\n            output\\r\\n          } = this;\\r\\n          const [width, height] = output;\\r\\n          const pixels = new Uint8Array(width * height * 4);\\r\\n          gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\\r\\n          return new Uint8ClampedArray((flip ? pixels : utils.flipPixels(pixels, width, height)).buffer);\\r\\n        }\\r\\n      \\r\\n        renderKernelsToArrays() {\\r\\n          const result = {\\r\\n            result: this.renderOutput(),\\r\\n          };\\r\\n          for (let i = 0; i < this.subKernels.length; i++) {\\r\\n            result[this.subKernels[i].property] = this.mappedTextures[i].toArray();\\r\\n          }\\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        renderKernelsToTextures() {\\r\\n          const result = {\\r\\n            result: this.renderOutput(),\\r\\n          };\\r\\n          if (this.immutable) {\\r\\n            for (let i = 0; i < this.subKernels.length; i++) {\\r\\n              result[this.subKernels[i].property] = this.mappedTextures[i].clone();\\r\\n            }\\r\\n          } else {\\r\\n            for (let i = 0; i < this.subKernels.length; i++) {\\r\\n              result[this.subKernels[i].property] = this.mappedTextures[i];\\r\\n            }\\r\\n          }\\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        resetSwitchingKernels() {\\r\\n          const existingValue = this.switchingKernels;\\r\\n          this.switchingKernels = null;\\r\\n          return existingValue;\\r\\n        }\\r\\n      \\r\\n        setOutput(output) {\\r\\n          const newOutput = this.toKernelOutput(output);\\r\\n          if (this.program) {\\r\\n            if (!this.dynamicOutput) {\\r\\n              throw new Error('Resizing a kernel with dynamicOutput: false is not possible');\\r\\n            }\\r\\n            const newThreadDim = [newOutput[0], newOutput[1] || 1, newOutput[2] || 1];\\r\\n            const newTexSize = utils.getKernelTextureSize({\\r\\n              optimizeFloatMemory: this.optimizeFloatMemory,\\r\\n              precision: this.precision,\\r\\n            }, newThreadDim);\\r\\n            const oldTexSize = this.texSize;\\r\\n            if (oldTexSize) {\\r\\n              const oldPrecision = this.getVariablePrecisionString(oldTexSize, this.tactic);\\r\\n              const newPrecision = this.getVariablePrecisionString(newTexSize, this.tactic);\\r\\n              if (oldPrecision !== newPrecision) {\\r\\n                if (this.debug) {\\r\\n                  console.warn('Precision requirement changed, asking GPU instance to recompile');\\r\\n                }\\r\\n                this.switchKernels({\\r\\n                  type: 'outputPrecisionMismatch',\\r\\n                  precision: newPrecision,\\r\\n                  needed: output\\r\\n                });\\r\\n                return;\\r\\n              }\\r\\n            }\\r\\n            this.output = newOutput;\\r\\n            this.threadDim = newThreadDim;\\r\\n            this.texSize = newTexSize;\\r\\n            const { context: gl } = this;\\r\\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\\r\\n            this.updateMaxTexSize();\\r\\n            this.framebuffer.width = this.texSize[0];\\r\\n            this.framebuffer.height = this.texSize[1];\\r\\n            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);\\r\\n            this.canvas.width = this.maxTexSize[0];\\r\\n            this.canvas.height = this.maxTexSize[1];\\r\\n            if (this.texture) {\\r\\n              this.texture.delete();\\r\\n            }\\r\\n            this.texture = null;\\r\\n            this._setupOutputTexture();\\r\\n            if (this.mappedTextures && this.mappedTextures.length > 0) {\\r\\n              for (let i = 0; i < this.mappedTextures.length; i++) {\\r\\n                this.mappedTextures[i].delete();\\r\\n              }\\r\\n              this.mappedTextures = null;\\r\\n              this._setupSubOutputTextures();\\r\\n            }\\r\\n          } else {\\r\\n            this.output = newOutput;\\r\\n          }\\r\\n          return this;\\r\\n        }\\r\\n        renderValues() {\\r\\n          return this.formatValues(\\r\\n            this.transferValues(),\\r\\n            this.output[0],\\r\\n            this.output[1],\\r\\n            this.output[2]\\r\\n          );\\r\\n        }\\r\\n        switchKernels(reason) {\\r\\n          if (this.switchingKernels) {\\r\\n            this.switchingKernels.push(reason);\\r\\n          } else {\\r\\n            this.switchingKernels = [reason];\\r\\n          }\\r\\n        }\\r\\n        getVariablePrecisionString(textureSize = this.texSize, tactic = this.tactic, isInt = false) {\\r\\n          if (!tactic) {\\r\\n            if (!this.constructor.features.isSpeedTacticSupported) return 'highp';\\r\\n            const low = this.constructor.features[isInt ? 'lowIntPrecision' : 'lowFloatPrecision'];\\r\\n            const medium = this.constructor.features[isInt ? 'mediumIntPrecision' : 'mediumFloatPrecision'];\\r\\n            const high = this.constructor.features[isInt ? 'highIntPrecision' : 'highFloatPrecision'];\\r\\n            const requiredSize = Math.log2(textureSize[0] * textureSize[1]);\\r\\n            if (requiredSize <= low.rangeMax) {\\r\\n              return 'lowp';\\r\\n            } else if (requiredSize <= medium.rangeMax) {\\r\\n              return 'mediump';\\r\\n            } else if (requiredSize <= high.rangeMax) {\\r\\n              return 'highp';\\r\\n            } else {\\r\\n              throw new Error(`The required size exceeds that of the ability of your system`);\\r\\n            }\\r\\n          }\\r\\n          switch (tactic) {\\r\\n            case 'speed':\\r\\n              return 'lowp';\\r\\n            case 'balanced':\\r\\n              return 'mediump';\\r\\n            case 'precision':\\r\\n              return 'highp';\\r\\n            default:\\r\\n              throw new Error(`Unknown tactic \\\"${tactic}\\\" use \\\"speed\\\", \\\"balanced\\\", \\\"precision\\\", or empty for auto`);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        updateTextureArgumentRefs(kernelValue, arg) {\\r\\n          if (!this.immutable) return;\\r\\n          if (this.texture.texture === arg.texture) {\\r\\n            const { prevArg } = kernelValue;\\r\\n            if (prevArg) {\\r\\n              if (prevArg.texture._refs === 1) {\\r\\n                this.texture.delete();\\r\\n                this.texture = prevArg.clone();\\r\\n                this._textureSwitched = true;\\r\\n              }\\r\\n              prevArg.delete();\\r\\n            }\\r\\n            kernelValue.prevArg = arg.clone();\\r\\n          } else if (this.mappedTextures && this.mappedTextures.length > 0) {\\r\\n            const { mappedTextures } = this;\\r\\n            for (let i = 0; i < mappedTextures.length; i++) {\\r\\n              const mappedTexture = mappedTextures[i];\\r\\n              if (mappedTexture.texture === arg.texture) {\\r\\n                const { prevArg } = kernelValue;\\r\\n                if (prevArg) {\\r\\n                  if (prevArg.texture._refs === 1) {\\r\\n                    mappedTexture.delete();\\r\\n                    mappedTextures[i] = prevArg.clone();\\r\\n                    this._mappedTextureSwitched[i] = true;\\r\\n                  }\\r\\n                  prevArg.delete();\\r\\n                }\\r\\n                kernelValue.prevArg = arg.clone();\\r\\n                return;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        onActivate(previousKernel) {\\r\\n          this._textureSwitched = true;\\r\\n          this.texture = previousKernel.texture;\\r\\n          if (this.mappedTextures) {\\r\\n            for (let i = 0; i < this.mappedTextures.length; i++) {\\r\\n              this._mappedTextureSwitched[i] = true;\\r\\n            }\\r\\n            this.mappedTextures = previousKernel.mappedTextures;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        initCanvas() {}\\r\\n      }\\r\\n      \\r\\n      const typeMap = {\\r\\n        int: 'Integer',\\r\\n        float: 'Number',\\r\\n        vec2: 'Array(2)',\\r\\n        vec3: 'Array(3)',\\r\\n        vec4: 'Array(4)',\\r\\n      };\\r\\n      \\r\\n      module.exports = {\\r\\n        GLKernel\\r\\n      };\\r\\n      },{\\\"../../utils\\\":114,\\\"../kernel\\\":36,\\\"./texture/array-2-float\\\":16,\\\"./texture/array-2-float-2d\\\":14,\\\"./texture/array-2-float-3d\\\":15,\\\"./texture/array-3-float\\\":19,\\\"./texture/array-3-float-2d\\\":17,\\\"./texture/array-3-float-3d\\\":18,\\\"./texture/array-4-float\\\":22,\\\"./texture/array-4-float-2d\\\":20,\\\"./texture/array-4-float-3d\\\":21,\\\"./texture/float\\\":25,\\\"./texture/float-2d\\\":23,\\\"./texture/float-3d\\\":24,\\\"./texture/graphical\\\":26,\\\"./texture/memory-optimized\\\":30,\\\"./texture/memory-optimized-2d\\\":28,\\\"./texture/memory-optimized-3d\\\":29,\\\"./texture/unsigned\\\":33,\\\"./texture/unsigned-2d\\\":31,\\\"./texture/unsigned-3d\\\":32}],14:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureArray2Float2D extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(2)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureArray2Float2D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],15:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureArray2Float3D extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(2)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureArray2Float3D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],16:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureArray2Float extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(2)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erectArray2(this.renderValues(), this.output[0], this.output[1]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureArray2Float\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],17:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureArray3Float2D extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(3)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureArray3Float2D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],18:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureArray3Float3D extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(3)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureArray3Float3D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],19:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureArray3Float extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(3)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erectArray3(this.renderValues(), this.output[0]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureArray3Float\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],20:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureArray4Float2D extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(4)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureArray4Float2D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],21:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureArray4Float3D extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(4)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureArray4Float3D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],22:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureArray4Float extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(4)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erectArray4(this.renderValues(), this.output[0]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureArray4Float\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],23:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureFloat2D extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(1)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureFloat2D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],24:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureFloat3D extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(1)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureFloat3D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],25:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTexture } = require('./index');\\r\\n      \\r\\n      class GLTextureFloat extends GLTexture {\\r\\n        get textureType() {\\r\\n          return this.context.FLOAT;\\r\\n        }\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(1)';\\r\\n        }\\r\\n        renderRawOutput() {\\r\\n          const gl = this.context;\\r\\n          const size = this.size;\\r\\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\\r\\n          gl.framebufferTexture2D(\\r\\n            gl.FRAMEBUFFER,\\r\\n            gl.COLOR_ATTACHMENT0,\\r\\n            gl.TEXTURE_2D,\\r\\n            this.texture,\\r\\n            0\\r\\n          );\\r\\n          const result = new Float32Array(size[0] * size[1] * 4);\\r\\n          gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.FLOAT, result);\\r\\n          return result;\\r\\n        }\\r\\n        renderValues() {\\r\\n          if (this._deleted) return null;\\r\\n          return this.renderRawOutput();\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erectFloat(this.renderValues(), this.output[0]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureFloat\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./index\\\":27}],26:[function(require,module,exports){\\r\\n      const { GLTextureUnsigned } = require('./unsigned');\\r\\n      \\r\\n      class GLTextureGraphical extends GLTextureUnsigned {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'ArrayTexture(4)';\\r\\n        }\\r\\n        toArray() {\\r\\n          return this.renderValues();\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureGraphical\\r\\n      };\\r\\n      },{\\\"./unsigned\\\":33}],27:[function(require,module,exports){\\r\\n      const { Texture } = require('../../../texture');\\r\\n      \\r\\n      class GLTexture extends Texture {\\r\\n        get textureType() {\\r\\n          throw new Error(`\\\"textureType\\\" not implemented on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        clone() {\\r\\n          return new this.constructor(this);\\r\\n        }\\r\\n      \\r\\n        beforeMutate() {\\r\\n          if (this.texture._refs > 1) {\\r\\n            this.newTexture();\\r\\n            return true;\\r\\n          }\\r\\n          return false;\\r\\n        }\\r\\n      \\r\\n        cloneTexture() {\\r\\n          this.texture._refs--;\\r\\n          const { context: gl, size, texture, kernel } = this;\\r\\n          if (kernel.debug) {\\r\\n            console.warn('cloning internal texture');\\r\\n          }\\r\\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\\r\\n          selectTexture(gl, texture);\\r\\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\\r\\n          const target = gl.createTexture();\\r\\n          selectTexture(gl, target);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);\\r\\n          gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, size[0], size[1]);\\r\\n          target._refs = 1;\\r\\n          this.texture = target;\\r\\n        }\\r\\n      \\r\\n        newTexture() {\\r\\n          this.texture._refs--;\\r\\n          const gl = this.context;\\r\\n          const size = this.size;\\r\\n          const kernel = this.kernel;\\r\\n          if (kernel.debug) {\\r\\n            console.warn('new internal texture');\\r\\n          }\\r\\n          const target = gl.createTexture();\\r\\n          selectTexture(gl, target);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);\\r\\n          target._refs = 1;\\r\\n          this.texture = target;\\r\\n        }\\r\\n      \\r\\n        clear() {\\r\\n          if (this.texture._refs) {\\r\\n            this.texture._refs--;\\r\\n            const gl = this.context;\\r\\n            const target = this.texture = gl.createTexture();\\r\\n            selectTexture(gl, target);\\r\\n            const size = this.size;\\r\\n            target._refs = 1;\\r\\n            gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);\\r\\n          }\\r\\n          const { context: gl, texture } = this;\\r\\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\\r\\n          gl.bindTexture(gl.TEXTURE_2D, texture);\\r\\n          selectTexture(gl, texture);\\r\\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\\r\\n          gl.clearColor(0, 0, 0, 0);\\r\\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\\r\\n        }\\r\\n      \\r\\n        delete() {\\r\\n          if (this._deleted) return;\\r\\n          this._deleted = true;\\r\\n          if (this.texture._refs) {\\r\\n            this.texture._refs--;\\r\\n            if (this.texture._refs) return;\\r\\n          }\\r\\n          this.context.deleteTexture(this.texture);\\r\\n        }\\r\\n      \\r\\n        framebuffer() {\\r\\n          if (!this._framebuffer) {\\r\\n            this._framebuffer = this.kernel.getRawValueFramebuffer(this.size[0], this.size[1]);\\r\\n          }\\r\\n          return this._framebuffer;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      function selectTexture(gl, texture) {\\r\\n        gl.activeTexture(gl.TEXTURE15);\\r\\n        gl.bindTexture(gl.TEXTURE_2D, texture);\\r\\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\r\\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\r\\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\r\\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\r\\n      }\\r\\n      \\r\\n      module.exports = { GLTexture };\\r\\n      },{\\\"../../../texture\\\":113}],28:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureMemoryOptimized2D extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'MemoryOptimizedNumberTexture';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureMemoryOptimized2D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],29:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureMemoryOptimized3D extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'MemoryOptimizedNumberTexture';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureMemoryOptimized3D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],30:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureFloat } = require('./float');\\r\\n      \\r\\n      class GLTextureMemoryOptimized extends GLTextureFloat {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'MemoryOptimizedNumberTexture';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureMemoryOptimized\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./float\\\":25}],31:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureUnsigned } = require('./unsigned');\\r\\n      \\r\\n      class GLTextureUnsigned2D extends GLTextureUnsigned {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'NumberTexture';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureUnsigned2D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./unsigned\\\":33}],32:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTextureUnsigned } = require('./unsigned');\\r\\n      \\r\\n      class GLTextureUnsigned3D extends GLTextureUnsigned {\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'NumberTexture';\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureUnsigned3D\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./unsigned\\\":33}],33:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { GLTexture } = require('./index');\\r\\n      \\r\\n      class GLTextureUnsigned extends GLTexture {\\r\\n        get textureType() {\\r\\n          return this.context.UNSIGNED_BYTE;\\r\\n        }\\r\\n        constructor(settings) {\\r\\n          super(settings);\\r\\n          this.type = 'NumberTexture';\\r\\n        }\\r\\n        renderRawOutput() {\\r\\n          const { context: gl } = this;\\r\\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());\\r\\n          gl.framebufferTexture2D(\\r\\n            gl.FRAMEBUFFER,\\r\\n            gl.COLOR_ATTACHMENT0,\\r\\n            gl.TEXTURE_2D,\\r\\n            this.texture,\\r\\n            0\\r\\n          );\\r\\n          const result = new Uint8Array(this.size[0] * this.size[1] * 4);\\r\\n          gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);\\r\\n          return result;\\r\\n        }\\r\\n        renderValues() {\\r\\n          if (this._deleted) return null;\\r\\n          return new Float32Array(this.renderRawOutput().buffer);\\r\\n        }\\r\\n        toArray() {\\r\\n          return utils.erectPackedFloat(this.renderValues(), this.output[0]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GLTextureUnsigned\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./index\\\":27}],34:[function(require,module,exports){\\r\\n      const getContext = require('gl');\\r\\n      const { WebGLKernel } = require('../web-gl/kernel');\\r\\n      const { glKernelString } = require('../gl/kernel-string');\\r\\n      \\r\\n      let isSupported = null;\\r\\n      let testCanvas = null;\\r\\n      let testContext = null;\\r\\n      let testExtensions = null;\\r\\n      let features = null;\\r\\n      \\r\\n      class HeadlessGLKernel extends WebGLKernel {\\r\\n        static get isSupported() {\\r\\n          if (isSupported !== null) return isSupported;\\r\\n          this.setupFeatureChecks();\\r\\n          isSupported = testContext !== null;\\r\\n          return isSupported;\\r\\n        }\\r\\n      \\r\\n        static setupFeatureChecks() {\\r\\n          testCanvas = null;\\r\\n          testExtensions = null;\\r\\n          if (typeof getContext !== 'function') return;\\r\\n          try { \\r\\n            testContext = getContext(2, 2, {\\r\\n              preserveDrawingBuffer: true\\r\\n            });\\r\\n            if (!testContext || !testContext.getExtension) return;\\r\\n            testExtensions = {\\r\\n              STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),\\r\\n              STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),\\r\\n              OES_texture_float: testContext.getExtension('OES_texture_float'),\\r\\n              OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),\\r\\n              OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),\\r\\n              WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),\\r\\n              WEBGL_color_buffer_float: testContext.getExtension('WEBGL_color_buffer_float'),\\r\\n            };\\r\\n            features = this.getFeatures();\\r\\n          } catch (e) {\\r\\n            console.warn(e);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        static isContextMatch(context) {\\r\\n          try {\\r\\n            return context.getParameter(context.RENDERER) === 'ANGLE';\\r\\n          } catch (e) {\\r\\n            return false;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        static getIsTextureFloat() {\\r\\n          return Boolean(testExtensions.OES_texture_float);\\r\\n        }\\r\\n      \\r\\n        static getIsDrawBuffers() {\\r\\n          return Boolean(testExtensions.WEBGL_draw_buffers);\\r\\n        }\\r\\n      \\r\\n        static getChannelCount() {\\r\\n          return testExtensions.WEBGL_draw_buffers ?\\r\\n            testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :\\r\\n            1;\\r\\n        }\\r\\n      \\r\\n        static getMaxTextureSize() {\\r\\n          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);\\r\\n        }\\r\\n      \\r\\n        static get testCanvas() {\\r\\n          return testCanvas;\\r\\n        }\\r\\n      \\r\\n        static get testContext() {\\r\\n          return testContext;\\r\\n        }\\r\\n      \\r\\n        static get features() {\\r\\n          return features;\\r\\n        }\\r\\n      \\r\\n        initCanvas() {\\r\\n          return {};\\r\\n        }\\r\\n      \\r\\n        initContext() {\\r\\n          return getContext(2, 2, {\\r\\n            preserveDrawingBuffer: true\\r\\n          });\\r\\n        }\\r\\n      \\r\\n        initExtensions() {\\r\\n          this.extensions = {\\r\\n            STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),\\r\\n            STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),\\r\\n            OES_texture_float: this.context.getExtension('OES_texture_float'),\\r\\n            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),\\r\\n            OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),\\r\\n            WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),\\r\\n          };\\r\\n        }\\r\\n      \\r\\n        build() {\\r\\n          super.build.apply(this, arguments);\\r\\n          if (!this.fallbackRequested) {\\r\\n            this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        destroyExtensions() {\\r\\n          this.extensions.STACKGL_resize_drawingbuffer = null;\\r\\n          this.extensions.STACKGL_destroy_context = null;\\r\\n          this.extensions.OES_texture_float = null;\\r\\n          this.extensions.OES_texture_float_linear = null;\\r\\n          this.extensions.OES_element_index_uint = null;\\r\\n          this.extensions.WEBGL_draw_buffers = null;\\r\\n        }\\r\\n      \\r\\n        static destroyContext(context) {\\r\\n          const extension = context.getExtension('STACKGL_destroy_context');\\r\\n          if (extension && extension.destroy) {\\r\\n            extension.destroy();\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        toString() {\\r\\n          const setupContextString = `const gl = context || require('gl')(1, 1);\\\\n`;\\r\\n          const destroyContextString = `    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\\\\n`;\\r\\n          return glKernelString(this.constructor, arguments, this, setupContextString, destroyContextString);\\r\\n        }\\r\\n      \\r\\n        setOutput(output) {\\r\\n          super.setOutput(output);\\r\\n          if (this.graphical && this.extensions.STACKGL_resize_drawingbuffer) {\\r\\n            this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);\\r\\n          }\\r\\n          return this;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        HeadlessGLKernel\\r\\n      };\\r\\n      },{\\\"../gl/kernel-string\\\":12,\\\"../web-gl/kernel\\\":70,\\\"gl\\\":2}],35:[function(require,module,exports){\\r\\n      class KernelValue {\\r\\n        constructor(value, settings) {\\r\\n          const {\\r\\n            name,\\r\\n            kernel,\\r\\n            context,\\r\\n            checkContext,\\r\\n            onRequestContextHandle,\\r\\n            onUpdateValueMismatch,\\r\\n            origin,\\r\\n            strictIntegers,\\r\\n            type,\\r\\n            tactic,\\r\\n          } = settings;\\r\\n          if (!name) {\\r\\n            throw new Error('name not set');\\r\\n          }\\r\\n          if (!type) {\\r\\n            throw new Error('type not set');\\r\\n          }\\r\\n          if (!origin) {\\r\\n            throw new Error('origin not set');\\r\\n          }\\r\\n          if (origin !== 'user' && origin !== 'constants') {\\r\\n            throw new Error(`origin must be \\\"user\\\" or \\\"constants\\\" value is \\\"${ origin }\\\"`);\\r\\n          }\\r\\n          if (!onRequestContextHandle) {\\r\\n            throw new Error('onRequestContextHandle is not set');\\r\\n          }\\r\\n          this.name = name;\\r\\n          this.origin = origin;\\r\\n          this.tactic = tactic;\\r\\n          this.varName = origin === 'constants' ? `constants.${name}` : name;\\r\\n          this.kernel = kernel;\\r\\n          this.strictIntegers = strictIntegers;\\r\\n          this.type = value.type || type;\\r\\n          this.size = value.size || null;\\r\\n          this.index = null;\\r\\n          this.context = context;\\r\\n          this.checkContext = checkContext !== null && checkContext !== undefined ? checkContext : true;\\r\\n          this.contextHandle = null;\\r\\n          this.onRequestContextHandle = onRequestContextHandle;\\r\\n          this.onUpdateValueMismatch = onUpdateValueMismatch;\\r\\n          this.forceUploadEachRun = null;\\r\\n        }\\r\\n      \\r\\n        get id() {\\r\\n          return `${this.origin}_${name}`;\\r\\n        }\\r\\n      \\r\\n        getSource() {\\r\\n          throw new Error(`\\\"getSource\\\" not defined on ${ this.constructor.name }`);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          throw new Error(`\\\"updateValue\\\" not defined on ${ this.constructor.name }`);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        KernelValue\\r\\n      };\\r\\n      },{}],36:[function(require,module,exports){\\r\\n      const { utils } = require('../utils');\\r\\n      const { Input } = require('../input');\\r\\n      \\r\\n      class Kernel {\\r\\n        static get isSupported() {\\r\\n          throw new Error(`\\\"isSupported\\\" not implemented on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        static isContextMatch(context) {\\r\\n          throw new Error(`\\\"isContextMatch\\\" not implemented on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        static getFeatures() {\\r\\n          throw new Error(`\\\"getFeatures\\\" not implemented on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        static destroyContext(context) {\\r\\n          throw new Error(`\\\"destroyContext\\\" called on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        static nativeFunctionArguments() {\\r\\n          throw new Error(`\\\"nativeFunctionArguments\\\" called on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        static nativeFunctionReturnType() {\\r\\n          throw new Error(`\\\"nativeFunctionReturnType\\\" called on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        static combineKernels() {\\r\\n          throw new Error(`\\\"combineKernels\\\" called on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        constructor(source, settings) {\\r\\n          if (typeof source !== 'object') {\\r\\n            if (typeof source !== 'string') {\\r\\n              throw new Error('source not a string');\\r\\n            }\\r\\n            if (!utils.isFunctionString(source)) {\\r\\n              throw new Error('source not a function string');\\r\\n            }\\r\\n          }\\r\\n          this.useLegacyEncoder = false;\\r\\n          this.fallbackRequested = false;\\r\\n          this.onRequestFallback = null;\\r\\n      \\r\\n          this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;\\r\\n          this.argumentTypes = null;\\r\\n          this.argumentSizes = null;\\r\\n          this.argumentBitRatios = null;\\r\\n          this.kernelArguments = null;\\r\\n          this.kernelConstants = null;\\r\\n          this.forceUploadKernelConstants = null;\\r\\n      \\r\\n      \\r\\n          this.source = source;\\r\\n      \\r\\n          this.output = null;\\r\\n      \\r\\n          this.debug = false;\\r\\n      \\r\\n          this.graphical = false;\\r\\n      \\r\\n          this.loopMaxIterations = 0;\\r\\n      \\r\\n          this.constants = null;\\r\\n      \\r\\n          this.constantTypes = null;\\r\\n      \\r\\n          this.constantBitRatios = null;\\r\\n      \\r\\n          this.dynamicArguments = false;\\r\\n      \\r\\n          this.dynamicOutput = false;\\r\\n      \\r\\n          this.canvas = null;\\r\\n      \\r\\n          this.context = null;\\r\\n      \\r\\n          this.checkContext = null;\\r\\n      \\r\\n          this.gpu = null;\\r\\n      \\r\\n          this.functions = null;\\r\\n      \\r\\n          this.nativeFunctions = null;\\r\\n      \\r\\n          this.injectedNative = null;\\r\\n      \\r\\n          this.subKernels = null;\\r\\n      \\r\\n          this.validate = true;\\r\\n      \\r\\n          this.immutable = false;\\r\\n      \\r\\n          this.pipeline = false;\\r\\n      \\r\\n          this.precision = null;\\r\\n      \\r\\n          this.tactic = null;\\r\\n      \\r\\n          this.plugins = null;\\r\\n      \\r\\n          this.returnType = null;\\r\\n          this.leadingReturnStatement = null;\\r\\n          this.followingReturnStatement = null;\\r\\n          this.optimizeFloatMemory = null;\\r\\n          this.strictIntegers = false;\\r\\n          this.fixIntegerDivisionAccuracy = null;\\r\\n          this.built = false;\\r\\n          this.signature = null;\\r\\n        }\\r\\n      \\r\\n        mergeSettings(settings) {\\r\\n          for (let p in settings) {\\r\\n            if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;\\r\\n            switch (p) {\\r\\n              case 'output':\\r\\n                if (!Array.isArray(settings.output)) {\\r\\n                  this.setOutput(settings.output); \\r\\n                  continue;\\r\\n                }\\r\\n                break;\\r\\n              case 'functions':\\r\\n                this.functions = [];\\r\\n                for (let i = 0; i < settings.functions.length; i++) {\\r\\n                  this.addFunction(settings.functions[i]);\\r\\n                }\\r\\n                continue;\\r\\n              case 'graphical':\\r\\n                if (settings[p] && !settings.hasOwnProperty('precision')) {\\r\\n                  this.precision = 'unsigned';\\r\\n                }\\r\\n                this[p] = settings[p];\\r\\n                continue;\\r\\n              case 'nativeFunctions':\\r\\n                if (!settings.nativeFunctions) continue;\\r\\n                this.nativeFunctions = [];\\r\\n                for (let i = 0; i < settings.nativeFunctions.length; i++) {\\r\\n                  const s = settings.nativeFunctions[i];\\r\\n                  const { name, source } = s;\\r\\n                  this.addNativeFunction(name, source, s);\\r\\n                }\\r\\n                continue;\\r\\n            }\\r\\n            this[p] = settings[p];\\r\\n          }\\r\\n      \\r\\n          if (!this.canvas) this.canvas = this.initCanvas();\\r\\n          if (!this.context) this.context = this.initContext();\\r\\n          if (!this.plugins) this.plugins = this.initPlugins(settings);\\r\\n        }\\r\\n        build() {\\r\\n          throw new Error(`\\\"build\\\" not defined on ${ this.constructor.name }`);\\r\\n        }\\r\\n      \\r\\n        run() {\\r\\n          throw new Error(`\\\"run\\\" not defined on ${ this.constructor.name }`)\\r\\n        }\\r\\n      \\r\\n        initCanvas() {\\r\\n          throw new Error(`\\\"initCanvas\\\" not defined on ${ this.constructor.name }`);\\r\\n        }\\r\\n      \\r\\n        initContext() {\\r\\n          throw new Error(`\\\"initContext\\\" not defined on ${ this.constructor.name }`);\\r\\n        }\\r\\n      \\r\\n        initPlugins(settings) {\\r\\n          throw new Error(`\\\"initPlugins\\\" not defined on ${ this.constructor.name }`);\\r\\n        }\\r\\n      \\r\\n        addFunction(source, settings = {}) {\\r\\n          if (source.name && source.source && source.argumentTypes && 'returnType' in source) {\\r\\n            this.functions.push(source);\\r\\n          } else if ('settings' in source && 'source' in source) {\\r\\n            this.functions.push(this.functionToIGPUFunction(source.source, source.settings));\\r\\n          } else if (typeof source === 'string' || typeof source === 'function') {\\r\\n            this.functions.push(this.functionToIGPUFunction(source, settings));\\r\\n          } else {\\r\\n            throw new Error(`function not properly defined`);\\r\\n          }\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        addNativeFunction(name, source, settings = {}) {\\r\\n          const { argumentTypes, argumentNames } = settings.argumentTypes ?\\r\\n            splitArgumentTypes(settings.argumentTypes) :\\r\\n            this.constructor.nativeFunctionArguments(source) || {};\\r\\n          this.nativeFunctions.push({\\r\\n            name,\\r\\n            source,\\r\\n            settings,\\r\\n            argumentTypes,\\r\\n            argumentNames,\\r\\n            returnType: settings.returnType || this.constructor.nativeFunctionReturnType(source)\\r\\n          });\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setupArguments(args) {\\r\\n          this.kernelArguments = [];\\r\\n          if (!this.argumentTypes) {\\r\\n            if (!this.argumentTypes) {\\r\\n              this.argumentTypes = [];\\r\\n              for (let i = 0; i < args.length; i++) {\\r\\n                const argType = utils.getVariableType(args[i], this.strictIntegers);\\r\\n                const type = argType === 'Integer' ? 'Number' : argType;\\r\\n                this.argumentTypes.push(type);\\r\\n                this.kernelArguments.push({\\r\\n                  type\\r\\n                });\\r\\n              }\\r\\n            }\\r\\n          } else {\\r\\n            for (let i = 0; i < this.argumentTypes.length; i++) {\\r\\n              this.kernelArguments.push({\\r\\n                type: this.argumentTypes[i]\\r\\n              });\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          this.argumentSizes = new Array(args.length);\\r\\n          this.argumentBitRatios = new Int32Array(args.length);\\r\\n      \\r\\n          for (let i = 0; i < args.length; i++) {\\r\\n            const arg = args[i];\\r\\n            this.argumentSizes[i] = arg.constructor === Input ? arg.size : null;\\r\\n            this.argumentBitRatios[i] = this.getBitRatio(arg);\\r\\n          }\\r\\n      \\r\\n          if (this.argumentNames.length !== args.length) {\\r\\n            throw new Error(`arguments are miss-aligned`);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        setupConstants() {\\r\\n          this.kernelConstants = [];\\r\\n          let needsConstantTypes = this.constantTypes === null;\\r\\n          if (needsConstantTypes) {\\r\\n            this.constantTypes = {};\\r\\n          }\\r\\n          this.constantBitRatios = {};\\r\\n          if (this.constants) {\\r\\n            for (let name in this.constants) {\\r\\n              if (needsConstantTypes) {\\r\\n                const type = utils.getVariableType(this.constants[name], this.strictIntegers);\\r\\n                this.constantTypes[name] = type;\\r\\n                this.kernelConstants.push({\\r\\n                  name,\\r\\n                  type\\r\\n                });\\r\\n              } else {\\r\\n                this.kernelConstants.push({\\r\\n                  name,\\r\\n                  type: this.constantTypes[name]\\r\\n                });\\r\\n              }\\r\\n              this.constantBitRatios[name] = this.getBitRatio(this.constants[name]);\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        setOptimizeFloatMemory(flag) {\\r\\n          this.optimizeFloatMemory = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        toKernelOutput(output) {\\r\\n          if (output.hasOwnProperty('x')) {\\r\\n            if (output.hasOwnProperty('y')) {\\r\\n              if (output.hasOwnProperty('z')) {\\r\\n                return [output.x, output.y, output.z];\\r\\n              } else {\\r\\n                return [output.x, output.y];\\r\\n              }\\r\\n            } else {\\r\\n              return [output.x];\\r\\n            }\\r\\n          } else {\\r\\n            return output;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        setOutput(output) {\\r\\n          this.output = this.toKernelOutput(output);\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setDebug(flag) {\\r\\n          this.debug = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setGraphical(flag) {\\r\\n          this.graphical = flag;\\r\\n          this.precision = 'unsigned';\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setLoopMaxIterations(max) {\\r\\n          this.loopMaxIterations = max;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setConstants(constants) {\\r\\n          this.constants = constants;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setConstantTypes(constantTypes) {\\r\\n          this.constantTypes = constantTypes;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setFunctions(functions) {\\r\\n          for (let i = 0; i < functions.length; i++) {\\r\\n            this.addFunction(functions[i]);\\r\\n          }\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setNativeFunctions(nativeFunctions) {\\r\\n          for (let i = 0; i < nativeFunctions.length; i++) {\\r\\n            const settings = nativeFunctions[i];\\r\\n            const { name, source } = settings;\\r\\n            this.addNativeFunction(name, source, settings);\\r\\n          }\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setInjectedNative(injectedNative) {\\r\\n          this.injectedNative = injectedNative;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setPipeline(flag) {\\r\\n          this.pipeline = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setPrecision(flag) {\\r\\n          this.precision = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setDimensions(flag) {\\r\\n          utils.warnDeprecated('method', 'setDimensions', 'setOutput');\\r\\n          this.output = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setOutputToTexture(flag) {\\r\\n          utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');\\r\\n          this.pipeline = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setImmutable(flag) {\\r\\n          this.immutable = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setCanvas(canvas) {\\r\\n          this.canvas = canvas;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setStrictIntegers(flag) {\\r\\n          this.strictIntegers = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setDynamicOutput(flag) {\\r\\n          this.dynamicOutput = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setHardcodeConstants(flag) {\\r\\n          utils.warnDeprecated('method', 'setHardcodeConstants');\\r\\n          this.setDynamicOutput(flag);\\r\\n          this.setDynamicArguments(flag);\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setDynamicArguments(flag) {\\r\\n          this.dynamicArguments = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setUseLegacyEncoder(flag) {\\r\\n          this.useLegacyEncoder = flag;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setWarnVarUsage(flag) {\\r\\n          utils.warnDeprecated('method', 'setWarnVarUsage');\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        getCanvas() {\\r\\n          utils.warnDeprecated('method', 'getCanvas');\\r\\n          return this.canvas;\\r\\n        }\\r\\n      \\r\\n        getWebGl() {\\r\\n          utils.warnDeprecated('method', 'getWebGl');\\r\\n          return this.context;\\r\\n        }\\r\\n      \\r\\n        setContext(context) {\\r\\n          this.context = context;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setArgumentTypes(argumentTypes) {\\r\\n          if (Array.isArray(argumentTypes)) {\\r\\n            this.argumentTypes = argumentTypes;\\r\\n          } else {\\r\\n            this.argumentTypes = [];\\r\\n            for (const p in argumentTypes) {\\r\\n              if (!argumentTypes.hasOwnProperty(p)) continue;\\r\\n              const argumentIndex = this.argumentNames.indexOf(p);\\r\\n              if (argumentIndex === -1) throw new Error(`unable to find argument ${ p }`);\\r\\n              this.argumentTypes[argumentIndex] = argumentTypes[p];\\r\\n            }\\r\\n          }\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setTactic(tactic) {\\r\\n          this.tactic = tactic;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        requestFallback(args) {\\r\\n          if (!this.onRequestFallback) {\\r\\n            throw new Error(`\\\"onRequestFallback\\\" not defined on ${ this.constructor.name }`);\\r\\n          }\\r\\n          this.fallbackRequested = true;\\r\\n          return this.onRequestFallback(args);\\r\\n        }\\r\\n      \\r\\n        validateSettings() {\\r\\n          throw new Error(`\\\"validateSettings\\\" not defined on ${ this.constructor.name }`);\\r\\n        }\\r\\n      \\r\\n        addSubKernel(subKernel) {\\r\\n          if (this.subKernels === null) {\\r\\n            this.subKernels = [];\\r\\n          }\\r\\n          if (!subKernel.source) throw new Error('subKernel missing \\\"source\\\" property');\\r\\n          if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing \\\"property\\\" property');\\r\\n          if (!subKernel.name) throw new Error('subKernel missing \\\"name\\\" property');\\r\\n          this.subKernels.push(subKernel);\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        destroy(removeCanvasReferences) {\\r\\n          throw new Error(`\\\"destroy\\\" called on ${ this.constructor.name }`);\\r\\n        }\\r\\n      \\r\\n        getBitRatio(value) {\\r\\n          if (this.precision === 'single') {\\r\\n            return 4;\\r\\n          } else if (Array.isArray(value[0])) {\\r\\n            return this.getBitRatio(value[0]);\\r\\n          } else if (value.constructor === Input) {\\r\\n            return this.getBitRatio(value.value);\\r\\n          }\\r\\n          switch (value.constructor) {\\r\\n            case Uint8ClampedArray:\\r\\n            case Uint8Array:\\r\\n            case Int8Array:\\r\\n              return 1;\\r\\n            case Uint16Array:\\r\\n            case Int16Array:\\r\\n              return 2;\\r\\n            case Float32Array:\\r\\n            case Int32Array:\\r\\n            default:\\r\\n              return 4;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        getPixels(flip) {\\r\\n          throw new Error(`\\\"getPixels\\\" called on ${ this.constructor.name }`);\\r\\n        }\\r\\n      \\r\\n        checkOutput() {\\r\\n          if (!this.output || !utils.isArray(this.output)) throw new Error('kernel.output not an array');\\r\\n          if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');\\r\\n          for (let i = 0; i < this.output.length; i++) {\\r\\n            if (isNaN(this.output[i]) || this.output[i] < 1) {\\r\\n              throw new Error(`${ this.constructor.name }.output[${ i }] incorrectly defined as \\\\`${ this.output[i] }\\\\`, needs to be numeric, and greater than 0`);\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        prependString(value) {\\r\\n          throw new Error(`\\\"prependString\\\" called on ${ this.constructor.name }`);\\r\\n        }\\r\\n      \\r\\n        hasPrependString(value) {\\r\\n          throw new Error(`\\\"hasPrependString\\\" called on ${ this.constructor.name }`);\\r\\n        }\\r\\n      \\r\\n        toJSON() {\\r\\n          return {\\r\\n            settings: {\\r\\n              output: this.output,\\r\\n              pipeline: this.pipeline,\\r\\n              argumentNames: this.argumentNames,\\r\\n              argumentsTypes: this.argumentTypes,\\r\\n              constants: this.constants,\\r\\n              pluginNames: this.plugins ? this.plugins.map(plugin => plugin.name) : null,\\r\\n              returnType: this.returnType,\\r\\n            }\\r\\n          };\\r\\n        }\\r\\n      \\r\\n        buildSignature(args) {\\r\\n          const Constructor = this.constructor;\\r\\n          this.signature = Constructor.getSignature(this, Constructor.getArgumentTypes(this, args));\\r\\n        }\\r\\n      \\r\\n        static getArgumentTypes(kernel, args) {\\r\\n          const argumentTypes = new Array(args.length);\\r\\n          for (let i = 0; i < args.length; i++) {\\r\\n            const arg = args[i];\\r\\n            const type = kernel.argumentTypes[i];\\r\\n            if (arg.type) {\\r\\n              argumentTypes[i] = arg.type;\\r\\n            } else {\\r\\n              switch (type) {\\r\\n                case 'Number':\\r\\n                case 'Integer':\\r\\n                case 'Float':\\r\\n                case 'ArrayTexture(1)':\\r\\n                  argumentTypes[i] = utils.getVariableType(arg);\\r\\n                  break;\\r\\n                default:\\r\\n                  argumentTypes[i] = type;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n          return argumentTypes;\\r\\n        }\\r\\n      \\r\\n        static getSignature(kernel, argumentTypes) {\\r\\n          throw new Error(`\\\"getSignature\\\" not implemented on ${ this.name }`);\\r\\n        }\\r\\n      \\r\\n        functionToIGPUFunction(source, settings = {}) {\\r\\n          if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');\\r\\n          const sourceString = typeof source === 'string' ? source : source.toString();\\r\\n          let argumentTypes = [];\\r\\n      \\r\\n          if (Array.isArray(settings.argumentTypes)) {\\r\\n            argumentTypes = settings.argumentTypes;\\r\\n          } else if (typeof settings.argumentTypes === 'object') {\\r\\n            argumentTypes = utils.getArgumentNamesFromString(sourceString)\\r\\n              .map(name => settings.argumentTypes[name]) || [];\\r\\n          } else {\\r\\n            argumentTypes = settings.argumentTypes || [];\\r\\n          }\\r\\n      \\r\\n          return {\\r\\n            name: utils.getFunctionNameFromString(sourceString) || null,\\r\\n            source: sourceString,\\r\\n            argumentTypes,\\r\\n            returnType: settings.returnType || null,\\r\\n          };\\r\\n        }\\r\\n      \\r\\n        onActivate(previousKernel) {}\\r\\n      }\\r\\n      \\r\\n      function splitArgumentTypes(argumentTypesObject) {\\r\\n        const argumentNames = Object.keys(argumentTypesObject);\\r\\n        const argumentTypes = [];\\r\\n        for (let i = 0; i < argumentNames.length; i++) {\\r\\n          const argumentName = argumentNames[i];\\r\\n          argumentTypes.push(argumentTypesObject[argumentName]);\\r\\n        }\\r\\n        return { argumentTypes, argumentNames };\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        Kernel\\r\\n      };\\r\\n      },{\\\"../input\\\":110,\\\"../utils\\\":114}],37:[function(require,module,exports){\\r\\n      const fragmentShader = `__HEADER__;\\r\\n      __FLOAT_TACTIC_DECLARATION__;\\r\\n      __INT_TACTIC_DECLARATION__;\\r\\n      __SAMPLER_2D_TACTIC_DECLARATION__;\\r\\n      \\r\\n      const int LOOP_MAX = __LOOP_MAX__;\\r\\n      \\r\\n      __PLUGINS__;\\r\\n      __CONSTANTS__;\\r\\n      \\r\\n      varying vec2 vTexCoord;\\r\\n      \\r\\n      float acosh(float x) {\\r\\n        return log(x + sqrt(x * x - 1.0));\\r\\n      }\\r\\n      \\r\\n      float sinh(float x) {\\r\\n        return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;\\r\\n      }\\r\\n      \\r\\n      float asinh(float x) {\\r\\n        return log(x + sqrt(x * x + 1.0));\\r\\n      }\\r\\n      \\r\\n      float atan2(float v1, float v2) {\\r\\n        if (v1 == 0.0 || v2 == 0.0) return 0.0;\\r\\n        return atan(v1 / v2);\\r\\n      }\\r\\n      \\r\\n      float atanh(float x) {\\r\\n        x = (x + 1.0) / (x - 1.0);\\r\\n        if (x < 0.0) {\\r\\n          return 0.5 * log(-x);\\r\\n        }\\r\\n        return 0.5 * log(x);\\r\\n      }\\r\\n      \\r\\n      float cbrt(float x) {\\r\\n        if (x >= 0.0) {\\r\\n          return pow(x, 1.0 / 3.0);\\r\\n        } else {\\r\\n          return -pow(x, 1.0 / 3.0);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      float cosh(float x) {\\r\\n        return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; \\r\\n      }\\r\\n      \\r\\n      float expm1(float x) {\\r\\n        return pow(${Math.E}, x) - 1.0; \\r\\n      }\\r\\n      \\r\\n      float fround(highp float x) {\\r\\n        return x;\\r\\n      }\\r\\n      \\r\\n      float imul(float v1, float v2) {\\r\\n        return float(int(v1) * int(v2));\\r\\n      }\\r\\n      \\r\\n      float log10(float x) {\\r\\n        return log2(x) * (1.0 / log2(10.0));\\r\\n      }\\r\\n      \\r\\n      float log1p(float x) {\\r\\n        return log(1.0 + x);\\r\\n      }\\r\\n      \\r\\n      float _pow(float v1, float v2) {\\r\\n        if (v2 == 0.0) return 1.0;\\r\\n        return pow(v1, v2);\\r\\n      }\\r\\n      \\r\\n      float tanh(float x) {\\r\\n        float e = exp(2.0 * x);\\r\\n        return (e - 1.0) / (e + 1.0);\\r\\n      }\\r\\n      \\r\\n      float trunc(float x) {\\r\\n        if (x >= 0.0) {\\r\\n          return floor(x); \\r\\n        } else {\\r\\n          return ceil(x);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      vec4 _round(vec4 x) {\\r\\n        return floor(x + 0.5);\\r\\n      }\\r\\n      \\r\\n      float _round(float x) {\\r\\n        return floor(x + 0.5);\\r\\n      }\\r\\n      \\r\\n      const int BIT_COUNT = 32;\\r\\n      int modi(int x, int y) {\\r\\n        return x - y * (x / y);\\r\\n      }\\r\\n      \\r\\n      int bitwiseOr(int a, int b) {\\r\\n        int result = 0;\\r\\n        int n = 1;\\r\\n        \\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\\r\\n            result += n;\\r\\n          }\\r\\n          a = a / 2;\\r\\n          b = b / 2;\\r\\n          n = n * 2;\\r\\n          if(!(a > 0 || b > 0)) {\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      int bitwiseXOR(int a, int b) {\\r\\n        int result = 0;\\r\\n        int n = 1;\\r\\n        \\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\\r\\n            result += n;\\r\\n          }\\r\\n          a = a / 2;\\r\\n          b = b / 2;\\r\\n          n = n * 2;\\r\\n          if(!(a > 0 || b > 0)) {\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      int bitwiseAnd(int a, int b) {\\r\\n        int result = 0;\\r\\n        int n = 1;\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\\r\\n            result += n;\\r\\n          }\\r\\n          a = a / 2;\\r\\n          b = b / 2;\\r\\n          n = n * 2;\\r\\n          if(!(a > 0 && b > 0)) {\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      int bitwiseNot(int a) {\\r\\n        int result = 0;\\r\\n        int n = 1;\\r\\n        \\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (modi(a, 2) == 0) {\\r\\n            result += n;    \\r\\n          }\\r\\n          a = a / 2;\\r\\n          n = n * 2;\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      int bitwiseZeroFillLeftShift(int n, int shift) {\\r\\n        int maxBytes = BIT_COUNT;\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (maxBytes >= n) {\\r\\n            break;\\r\\n          }\\r\\n          maxBytes *= 2;\\r\\n        }\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (i >= shift) {\\r\\n            break;\\r\\n          }\\r\\n          n *= 2;\\r\\n        }\\r\\n      \\r\\n        int result = 0;\\r\\n        int byteVal = 1;\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (i >= maxBytes) break;\\r\\n          if (modi(n, 2) > 0) { result += byteVal; }\\r\\n          n = int(n / 2);\\r\\n          byteVal *= 2;\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      \\r\\n      int bitwiseSignedRightShift(int num, int shifts) {\\r\\n        return int(floor(float(num) / pow(2.0, float(shifts))));\\r\\n      }\\r\\n      \\r\\n      int bitwiseZeroFillRightShift(int n, int shift) {\\r\\n        int maxBytes = BIT_COUNT;\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (maxBytes >= n) {\\r\\n            break;\\r\\n          }\\r\\n          maxBytes *= 2;\\r\\n        }\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (i >= shift) {\\r\\n            break;\\r\\n          }\\r\\n          n /= 2;\\r\\n        }\\r\\n        int result = 0;\\r\\n        int byteVal = 1;\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (i >= maxBytes) break;\\r\\n          if (modi(n, 2) > 0) { result += byteVal; }\\r\\n          n = int(n / 2);\\r\\n          byteVal *= 2;\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      \\r\\n      vec2 integerMod(vec2 x, float y) {\\r\\n        vec2 res = floor(mod(x, y));\\r\\n        return res * step(1.0 - floor(y), -res);\\r\\n      }\\r\\n      \\r\\n      vec3 integerMod(vec3 x, float y) {\\r\\n        vec3 res = floor(mod(x, y));\\r\\n        return res * step(1.0 - floor(y), -res);\\r\\n      }\\r\\n      \\r\\n      vec4 integerMod(vec4 x, vec4 y) {\\r\\n        vec4 res = floor(mod(x, y));\\r\\n        return res * step(1.0 - floor(y), -res);\\r\\n      }\\r\\n      \\r\\n      float integerMod(float x, float y) {\\r\\n        float res = floor(mod(x, y));\\r\\n        return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\\r\\n      }\\r\\n      \\r\\n      int integerMod(int x, int y) {\\r\\n        return x - (y * int(x / y));\\r\\n      }\\r\\n      \\r\\n      __DIVIDE_WITH_INTEGER_CHECK__;\\r\\n      \\r\\n      // Here be dragons!\\r\\n      // DO NOT OPTIMIZE THIS CODE\\r\\n      // YOU WILL BREAK SOMETHING ON SOMEBODY\\\\'S MACHINE\\r\\n      // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\\r\\n      const vec2 MAGIC_VEC = vec2(1.0, -256.0);\\r\\n      const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\\r\\n      const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\\r\\n      float decode32(vec4 texel) {\\r\\n        __DECODE32_ENDIANNESS__;\\r\\n        texel *= 255.0;\\r\\n        vec2 gte128;\\r\\n        gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;\\r\\n        gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\\r\\n        float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\\r\\n        float res = exp2(_round(exponent));\\r\\n        texel.b = texel.b - 128.0 * gte128.x;\\r\\n        res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;\\r\\n        res *= gte128.y * -2.0 + 1.0;\\r\\n        return res;\\r\\n      }\\r\\n      \\r\\n      float decode16(vec4 texel, int index) {\\r\\n        int channel = integerMod(index, 2);\\r\\n        if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;\\r\\n        if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;\\r\\n        return 0.0;\\r\\n      }\\r\\n      \\r\\n      float decode8(vec4 texel, int index) {\\r\\n        int channel = integerMod(index, 4);\\r\\n        if (channel == 0) return texel.r * 255.0;\\r\\n        if (channel == 1) return texel.g * 255.0;\\r\\n        if (channel == 2) return texel.b * 255.0;\\r\\n        if (channel == 3) return texel.a * 255.0;\\r\\n        return 0.0;\\r\\n      }\\r\\n      \\r\\n      vec4 legacyEncode32(float f) {\\r\\n        float F = abs(f);\\r\\n        float sign = f < 0.0 ? 1.0 : 0.0;\\r\\n        float exponent = floor(log2(F));\\r\\n        float mantissa = (exp2(-exponent) * F);\\r\\n        // exponent += floor(log2(mantissa));\\r\\n        vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\\r\\n        texel.rg = integerMod(texel.rg, 256.0);\\r\\n        texel.b = integerMod(texel.b, 128.0);\\r\\n        texel.a = exponent*0.5 + 63.5;\\r\\n        texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\\r\\n        texel = floor(texel);\\r\\n        texel *= 0.003921569; // 1/255\\r\\n        __ENCODE32_ENDIANNESS__;\\r\\n        return texel;\\r\\n      }\\r\\n      \\r\\n      // https://github.com/gpujs/gpu.js/wiki/Encoder-details\\r\\n      vec4 encode32(float value) {\\r\\n        if (value == 0.0) return vec4(0, 0, 0, 0);\\r\\n      \\r\\n        float exponent;\\r\\n        float mantissa;\\r\\n        vec4  result;\\r\\n        float sgn;\\r\\n      \\r\\n        sgn = step(0.0, -value);\\r\\n        value = abs(value);\\r\\n      \\r\\n        exponent = floor(log2(value));\\r\\n      \\r\\n        mantissa = value*pow(2.0, -exponent)-1.0;\\r\\n        exponent = exponent+127.0;\\r\\n        result   = vec4(0,0,0,0);\\r\\n      \\r\\n        result.a = floor(exponent/2.0);\\r\\n        exponent = exponent - result.a*2.0;\\r\\n        result.a = result.a + 128.0*sgn;\\r\\n      \\r\\n        result.b = floor(mantissa * 128.0);\\r\\n        mantissa = mantissa - result.b / 128.0;\\r\\n        result.b = result.b + exponent*128.0;\\r\\n      \\r\\n        result.g = floor(mantissa*32768.0);\\r\\n        mantissa = mantissa - result.g/32768.0;\\r\\n      \\r\\n        result.r = floor(mantissa*8388608.0);\\r\\n        return result/255.0;\\r\\n      }\\r\\n      // Dragons end here\\r\\n      \\r\\n      int index;\\r\\n      ivec3 threadId;\\r\\n      \\r\\n      ivec3 indexTo3D(int idx, ivec3 texDim) {\\r\\n        int z = int(idx / (texDim.x * texDim.y));\\r\\n        idx -= z * int(texDim.x * texDim.y);\\r\\n        int y = int(idx / texDim.x);\\r\\n        int x = int(integerMod(idx, texDim.x));\\r\\n        return ivec3(x, y, z);\\r\\n      }\\r\\n      \\r\\n      float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + texDim.x * (y + texDim.y * z);\\r\\n        int w = texSize.x;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        vec4 texel = texture2D(tex, st / vec2(texSize));\\r\\n        return decode32(texel);\\r\\n      }\\r\\n      \\r\\n      float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + texDim.x * (y + texDim.y * z);\\r\\n        int w = texSize.x * 2;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));\\r\\n        return decode16(texel, index);\\r\\n      }\\r\\n      \\r\\n      float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + texDim.x * (y + texDim.y * z);\\r\\n        int w = texSize.x * 4;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));\\r\\n        return decode8(texel, index);\\r\\n      }\\r\\n      \\r\\n      float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + texDim.x * (y + texDim.y * z);\\r\\n        int channel = integerMod(index, 4);\\r\\n        index = index / 4;\\r\\n        int w = texSize.x;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        vec4 texel = texture2D(tex, st / vec2(texSize));\\r\\n        if (channel == 0) return texel.r;\\r\\n        if (channel == 1) return texel.g;\\r\\n        if (channel == 2) return texel.b;\\r\\n        if (channel == 3) return texel.a;\\r\\n        return 0.0;\\r\\n      }\\r\\n      \\r\\n      vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + texDim.x * (y + texDim.y * z);\\r\\n        int w = texSize.x;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        return texture2D(tex, st / vec2(texSize));\\r\\n      }\\r\\n      \\r\\n      float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\\r\\n        return result[0];\\r\\n      }\\r\\n      \\r\\n      vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\\r\\n        return vec2(result[0], result[1]);\\r\\n      }\\r\\n      \\r\\n      vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + (texDim.x * (y + (texDim.y * z)));\\r\\n        int channel = integerMod(index, 2);\\r\\n        index = index / 2;\\r\\n        int w = texSize.x;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        vec4 texel = texture2D(tex, st / vec2(texSize));\\r\\n        if (channel == 0) return vec2(texel.r, texel.g);\\r\\n        if (channel == 1) return vec2(texel.b, texel.a);\\r\\n        return vec2(0.0, 0.0);\\r\\n      }\\r\\n      \\r\\n      vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\\r\\n        return vec3(result[0], result[1], result[2]);\\r\\n      }\\r\\n      \\r\\n      vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));\\r\\n        int vectorIndex = fieldIndex / 4;\\r\\n        int vectorOffset = fieldIndex - vectorIndex * 4;\\r\\n        int readY = vectorIndex / texSize.x;\\r\\n        int readX = vectorIndex - readY * texSize.x;\\r\\n        vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));\\r\\n        \\r\\n        if (vectorOffset == 0) {\\r\\n          return tex1.xyz;\\r\\n        } else if (vectorOffset == 1) {\\r\\n          return tex1.yzw;\\r\\n        } else {\\r\\n          readX++;\\r\\n          if (readX >= texSize.x) {\\r\\n            readX = 0;\\r\\n            readY++;\\r\\n          }\\r\\n          vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));\\r\\n          if (vectorOffset == 2) {\\r\\n            return vec3(tex1.z, tex1.w, tex2.x);\\r\\n          } else {\\r\\n            return vec3(tex1.w, tex2.x, tex2.y);\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        return getImage2D(tex, texSize, texDim, z, y, x);\\r\\n      }\\r\\n      \\r\\n      vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + texDim.x * (y + texDim.y * z);\\r\\n        int channel = integerMod(index, 2);\\r\\n        int w = texSize.x;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        vec4 texel = texture2D(tex, st / vec2(texSize));\\r\\n        return vec4(texel.r, texel.g, texel.b, texel.a);\\r\\n      }\\r\\n      \\r\\n      vec4 actualColor;\\r\\n      void color(float r, float g, float b, float a) {\\r\\n        actualColor = vec4(r,g,b,a);\\r\\n      }\\r\\n      \\r\\n      void color(float r, float g, float b) {\\r\\n        color(r,g,b,1.0);\\r\\n      }\\r\\n      \\r\\n      void color(sampler2D image) {\\r\\n        actualColor = texture2D(image, vTexCoord);\\r\\n      }\\r\\n      \\r\\n      float modulo(float number, float divisor) {\\r\\n        if (number < 0.0) {\\r\\n          number = abs(number);\\r\\n          if (divisor < 0.0) {\\r\\n            divisor = abs(divisor);\\r\\n          }\\r\\n          return -mod(number, divisor);\\r\\n        }\\r\\n        if (divisor < 0.0) {\\r\\n          divisor = abs(divisor);\\r\\n        }\\r\\n        return mod(number, divisor);\\r\\n      }\\r\\n      \\r\\n      __INJECTED_NATIVE__;\\r\\n      __MAIN_CONSTANTS__;\\r\\n      __MAIN_ARGUMENTS__;\\r\\n      __KERNEL__;\\r\\n      \\r\\n      void main(void) {\\r\\n        index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\\r\\n        __MAIN_RESULT__;\\r\\n      }`;\\r\\n      \\r\\n      module.exports = {\\r\\n        fragmentShader\\r\\n      };\\r\\n      },{}],38:[function(require,module,exports){\\r\\n      const { utils } = require('../../utils');\\r\\n      const { FunctionNode } = require('../function-node');\\r\\n      \\r\\n      class WebGLFunctionNode extends FunctionNode {\\r\\n        constructor(source, settings) {\\r\\n          super(source, settings);\\r\\n          if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {\\r\\n            this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        astConditionalExpression(ast, retArr) {\\r\\n          if (ast.type !== 'ConditionalExpression') {\\r\\n            throw this.astErrorOutput('Not a conditional expression', ast);\\r\\n          }\\r\\n          const consequentType = this.getType(ast.consequent);\\r\\n          const alternateType = this.getType(ast.alternate);\\r\\n          if (consequentType === null && alternateType === null) {\\r\\n            retArr.push('if (');\\r\\n            this.astGeneric(ast.test, retArr);\\r\\n            retArr.push(') {');\\r\\n            this.astGeneric(ast.consequent, retArr);\\r\\n            retArr.push(';');\\r\\n            retArr.push('} else {');\\r\\n            this.astGeneric(ast.alternate, retArr);\\r\\n            retArr.push(';');\\r\\n            retArr.push('}');\\r\\n            return retArr;\\r\\n          }\\r\\n          retArr.push('(');\\r\\n          this.astGeneric(ast.test, retArr);\\r\\n          retArr.push('?');\\r\\n          this.astGeneric(ast.consequent, retArr);\\r\\n          retArr.push(':');\\r\\n          this.astGeneric(ast.alternate, retArr);\\r\\n          retArr.push(')');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astFunction(ast, retArr) {\\r\\n          if (this.isRootKernel) {\\r\\n            retArr.push('void');\\r\\n          } else {\\r\\n            if (!this.returnType) {\\r\\n              const lastReturn = this.findLastReturn();\\r\\n              if (lastReturn) {\\r\\n                this.returnType = this.getType(ast.body);\\r\\n                if (this.returnType === 'LiteralInteger') {\\r\\n                  this.returnType = 'Number';\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n      \\r\\n            const { returnType } = this;\\r\\n            if (!returnType) {\\r\\n              retArr.push('void');\\r\\n            } else {\\r\\n              const type = typeMap[returnType];\\r\\n              if (!type) {\\r\\n                throw new Error(`unknown type ${returnType}`);\\r\\n              }\\r\\n              retArr.push(type);\\r\\n            }\\r\\n          }\\r\\n          retArr.push(' ');\\r\\n          retArr.push(this.name);\\r\\n          retArr.push('(');\\r\\n      \\r\\n          if (!this.isRootKernel) {\\r\\n            for (let i = 0; i < this.argumentNames.length; ++i) {\\r\\n              const argumentName = this.argumentNames[i];\\r\\n      \\r\\n              if (i > 0) {\\r\\n                retArr.push(', ');\\r\\n              }\\r\\n              let argumentType = this.argumentTypes[this.argumentNames.indexOf(argumentName)];\\r\\n              if (!argumentType) {\\r\\n                throw this.astErrorOutput(`Unknown argument ${argumentName} type`, ast);\\r\\n              }\\r\\n              if (argumentType === 'LiteralInteger') {\\r\\n                this.argumentTypes[i] = argumentType = 'Number';\\r\\n              }\\r\\n              const type = typeMap[argumentType];\\r\\n              if (!type) {\\r\\n                throw this.astErrorOutput('Unexpected expression', ast);\\r\\n              }\\r\\n              const name = utils.sanitizeName(argumentName);\\r\\n              if (type === 'sampler2D' || type === 'sampler2DArray') {\\r\\n                retArr.push(`${type} user_${name},ivec2 user_${name}Size,ivec3 user_${name}Dim`);\\r\\n              } else {\\r\\n                retArr.push(`${type} user_${name}`);\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          retArr.push(') {\\\\n');\\r\\n      \\r\\n          for (let i = 0; i < ast.body.body.length; ++i) {\\r\\n            this.astGeneric(ast.body.body[i], retArr);\\r\\n            retArr.push('\\\\n');\\r\\n          }\\r\\n      \\r\\n          retArr.push('}\\\\n');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astReturnStatement(ast, retArr) {\\r\\n          if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);\\r\\n          this.pushState('skip-literal-correction');\\r\\n          const type = this.getType(ast.argument);\\r\\n          this.popState('skip-literal-correction');\\r\\n      \\r\\n          const result = [];\\r\\n      \\r\\n          if (!this.returnType) {\\r\\n            if (type === 'LiteralInteger' || type === 'Integer') {\\r\\n              this.returnType = 'Number';\\r\\n            } else {\\r\\n              this.returnType = type;\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          switch (this.returnType) {\\r\\n            case 'LiteralInteger':\\r\\n            case 'Number':\\r\\n            case 'Float':\\r\\n              switch (type) {\\r\\n                case 'Integer':\\r\\n                  result.push('float(');\\r\\n                  this.astGeneric(ast.argument, result);\\r\\n                  result.push(')');\\r\\n                  break;\\r\\n                case 'LiteralInteger':\\r\\n                  this.castLiteralToFloat(ast.argument, result);\\r\\n      \\r\\n                  if (this.getType(ast) === 'Integer') {\\r\\n                    result.unshift('float(');\\r\\n                    result.push(')');\\r\\n                  }\\r\\n                  break;\\r\\n                default:\\r\\n                  this.astGeneric(ast.argument, result);\\r\\n              }\\r\\n              break;\\r\\n            case 'Integer':\\r\\n              switch (type) {\\r\\n                case 'Float':\\r\\n                case 'Number':\\r\\n                  this.castValueToInteger(ast.argument, result);\\r\\n                  break;\\r\\n                case 'LiteralInteger':\\r\\n                  this.castLiteralToInteger(ast.argument, result);\\r\\n                  break;\\r\\n                default:\\r\\n                  this.astGeneric(ast.argument, result);\\r\\n              }\\r\\n              break;\\r\\n            case 'Array(4)':\\r\\n            case 'Array(3)':\\r\\n            case 'Array(2)':\\r\\n            case 'Matrix(2)':\\r\\n            case 'Matrix(3)':\\r\\n            case 'Matrix(4)':\\r\\n            case 'Input':\\r\\n              this.astGeneric(ast.argument, result);\\r\\n              break;\\r\\n            default:\\r\\n              throw this.astErrorOutput(`unhandled return type ${this.returnType}`, ast);\\r\\n          }\\r\\n      \\r\\n          if (this.isRootKernel) {\\r\\n            retArr.push(`kernelResult = ${ result.join('') };`);\\r\\n            retArr.push('return;');\\r\\n          } else if (this.isSubKernel) {\\r\\n            retArr.push(`subKernelResult_${ this.name } = ${ result.join('') };`);\\r\\n            retArr.push(`return subKernelResult_${ this.name };`);\\r\\n          } else {\\r\\n            retArr.push(`return ${ result.join('') };`);\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astLiteral(ast, retArr) {\\r\\n          if (isNaN(ast.value)) {\\r\\n            throw this.astErrorOutput(\\r\\n              'Non-numeric literal not supported : ' + ast.value,\\r\\n              ast\\r\\n            );\\r\\n          }\\r\\n      \\r\\n          const key = this.astKey(ast);\\r\\n          if (Number.isInteger(ast.value)) {\\r\\n            if (this.isState('casting-to-integer') || this.isState('building-integer')) {\\r\\n              this.literalTypes[key] = 'Integer';\\r\\n              retArr.push(`${ast.value}`);\\r\\n            } else if (this.isState('casting-to-float') || this.isState('building-float')) {\\r\\n              this.literalTypes[key] = 'Number';\\r\\n              retArr.push(`${ast.value}.0`);\\r\\n            } else {\\r\\n              this.literalTypes[key] = 'Number';\\r\\n              retArr.push(`${ast.value}.0`);\\r\\n            }\\r\\n          } else if (this.isState('casting-to-integer') || this.isState('building-integer')) {\\r\\n            this.literalTypes[key] = 'Integer';\\r\\n            retArr.push(Math.round(ast.value));\\r\\n          } else {\\r\\n            this.literalTypes[key] = 'Number';\\r\\n            retArr.push(`${ast.value}`);\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astBinaryExpression(ast, retArr) {\\r\\n          if (this.checkAndUpconvertOperator(ast, retArr)) {\\r\\n            return retArr;\\r\\n          }\\r\\n      \\r\\n          if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {\\r\\n            retArr.push('divWithIntCheck(');\\r\\n            this.pushState('building-float');\\r\\n            switch (this.getType(ast.left)) {\\r\\n              case 'Integer':\\r\\n                this.castValueToFloat(ast.left, retArr);\\r\\n                break;\\r\\n              case 'LiteralInteger':\\r\\n                this.castLiteralToFloat(ast.left, retArr);\\r\\n                break;\\r\\n              default:\\r\\n                this.astGeneric(ast.left, retArr);\\r\\n            }\\r\\n            retArr.push(', ');\\r\\n            switch (this.getType(ast.right)) {\\r\\n              case 'Integer':\\r\\n                this.castValueToFloat(ast.right, retArr);\\r\\n                break;\\r\\n              case 'LiteralInteger':\\r\\n                this.castLiteralToFloat(ast.right, retArr);\\r\\n                break;\\r\\n              default:\\r\\n                this.astGeneric(ast.right, retArr);\\r\\n            }\\r\\n            this.popState('building-float');\\r\\n            retArr.push(')');\\r\\n            return retArr;\\r\\n          }\\r\\n      \\r\\n          retArr.push('(');\\r\\n          const leftType = this.getType(ast.left) || 'Number';\\r\\n          const rightType = this.getType(ast.right) || 'Number';\\r\\n          if (!leftType || !rightType) {\\r\\n            throw this.astErrorOutput(`Unhandled binary expression`, ast);\\r\\n          }\\r\\n          const key = leftType + ' & ' + rightType;\\r\\n          switch (key) {\\r\\n            case 'Integer & Integer':\\r\\n              this.pushState('building-integer');\\r\\n              this.astGeneric(ast.left, retArr);\\r\\n              retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n              this.astGeneric(ast.right, retArr);\\r\\n              this.popState('building-integer');\\r\\n              break;\\r\\n            case 'Number & Float':\\r\\n            case 'Float & Number':\\r\\n            case 'Float & Float':\\r\\n            case 'Number & Number':\\r\\n              this.pushState('building-float');\\r\\n              this.astGeneric(ast.left, retArr);\\r\\n              retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n              this.astGeneric(ast.right, retArr);\\r\\n              this.popState('building-float');\\r\\n              break;\\r\\n            case 'LiteralInteger & LiteralInteger':\\r\\n              if (this.isState('casting-to-integer') || this.isState('building-integer')) {\\r\\n                this.pushState('building-integer');\\r\\n                this.astGeneric(ast.left, retArr);\\r\\n                retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n                this.astGeneric(ast.right, retArr);\\r\\n                this.popState('building-integer');\\r\\n              } else {\\r\\n                this.pushState('building-float');\\r\\n                this.castLiteralToFloat(ast.left, retArr);\\r\\n                retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n                this.castLiteralToFloat(ast.right, retArr);\\r\\n                this.popState('building-float');\\r\\n              }\\r\\n              break;\\r\\n      \\r\\n            case 'Integer & Float':\\r\\n            case 'Integer & Number':\\r\\n              if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {\\r\\n                if (!Number.isInteger(ast.right.value)) {\\r\\n                  this.pushState('building-float');\\r\\n                  this.castValueToFloat(ast.left, retArr);\\r\\n                  retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n                  this.astGeneric(ast.right, retArr);\\r\\n                  this.popState('building-float');\\r\\n                  break;\\r\\n                }\\r\\n              }\\r\\n              this.pushState('building-integer');\\r\\n              this.astGeneric(ast.left, retArr);\\r\\n              retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n              this.pushState('casting-to-integer');\\r\\n              if (ast.right.type === 'Literal') {\\r\\n                const literalResult = [];\\r\\n                this.astGeneric(ast.right, literalResult);\\r\\n                const literalType = this.getType(ast.right);\\r\\n                if (literalType === 'Integer') {\\r\\n                  retArr.push(literalResult.join(''));\\r\\n                } else {\\r\\n                  throw this.astErrorOutput(`Unhandled binary expression with literal`, ast);\\r\\n                }\\r\\n              } else {\\r\\n                retArr.push('int(');\\r\\n                this.astGeneric(ast.right, retArr);\\r\\n                retArr.push(')');\\r\\n              }\\r\\n              this.popState('casting-to-integer');\\r\\n              this.popState('building-integer');\\r\\n              break;\\r\\n            case 'Integer & LiteralInteger':\\r\\n              this.pushState('building-integer');\\r\\n              this.astGeneric(ast.left, retArr);\\r\\n              retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n              this.castLiteralToInteger(ast.right, retArr);\\r\\n              this.popState('building-integer');\\r\\n              break;\\r\\n      \\r\\n            case 'Number & Integer':\\r\\n              this.pushState('building-float');\\r\\n              this.astGeneric(ast.left, retArr);\\r\\n              retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n              this.castValueToFloat(ast.right, retArr);\\r\\n              this.popState('building-float');\\r\\n              break;\\r\\n            case 'Float & LiteralInteger':\\r\\n            case 'Number & LiteralInteger':\\r\\n              this.pushState('building-float');\\r\\n              this.astGeneric(ast.left, retArr);\\r\\n              retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n              this.castLiteralToFloat(ast.right, retArr);\\r\\n              this.popState('building-float');\\r\\n              break;\\r\\n            case 'LiteralInteger & Float':\\r\\n            case 'LiteralInteger & Number':\\r\\n              if (this.isState('casting-to-integer')) {\\r\\n                this.pushState('building-integer');\\r\\n                this.castLiteralToInteger(ast.left, retArr);\\r\\n                retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n                this.castValueToInteger(ast.right, retArr);\\r\\n                this.popState('building-integer');\\r\\n              } else {\\r\\n                this.pushState('building-float');\\r\\n                this.astGeneric(ast.left, retArr);\\r\\n                retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n                this.pushState('casting-to-float');\\r\\n                this.astGeneric(ast.right, retArr);\\r\\n                this.popState('casting-to-float');\\r\\n                this.popState('building-float');\\r\\n              }\\r\\n              break;\\r\\n            case 'LiteralInteger & Integer':\\r\\n              this.pushState('building-integer');\\r\\n              this.castLiteralToInteger(ast.left, retArr);\\r\\n              retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n              this.astGeneric(ast.right, retArr);\\r\\n              this.popState('building-integer');\\r\\n              break;\\r\\n      \\r\\n            case 'Boolean & Boolean':\\r\\n              this.pushState('building-boolean');\\r\\n              this.astGeneric(ast.left, retArr);\\r\\n              retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n              this.astGeneric(ast.right, retArr);\\r\\n              this.popState('building-boolean');\\r\\n              break;\\r\\n      \\r\\n            case 'Float & Integer':\\r\\n              this.pushState('building-float');\\r\\n              this.astGeneric(ast.left, retArr);\\r\\n              retArr.push(operatorMap[ast.operator] || ast.operator);\\r\\n              this.castValueToFloat(ast.right, retArr);\\r\\n              this.popState('building-float');\\r\\n              break;\\r\\n      \\r\\n            default:\\r\\n              throw this.astErrorOutput(`Unhandled binary expression between ${key}`, ast);\\r\\n          }\\r\\n          retArr.push(')');\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        checkAndUpconvertOperator(ast, retArr) {\\r\\n          const bitwiseResult = this.checkAndUpconvertBitwiseOperators(ast, retArr);\\r\\n          if (bitwiseResult) {\\r\\n            return bitwiseResult;\\r\\n          }\\r\\n          const upconvertableOperators = {\\r\\n            '%': this.fixIntegerDivisionAccuracy ? 'integerCorrectionModulo' : 'modulo',\\r\\n            '**': 'pow',\\r\\n          };\\r\\n          const foundOperator = upconvertableOperators[ast.operator];\\r\\n          if (!foundOperator) return null;\\r\\n          retArr.push(foundOperator);\\r\\n          retArr.push('(');\\r\\n          switch (this.getType(ast.left)) {\\r\\n            case 'Integer':\\r\\n              this.castValueToFloat(ast.left, retArr);\\r\\n              break;\\r\\n            case 'LiteralInteger':\\r\\n              this.castLiteralToFloat(ast.left, retArr);\\r\\n              break;\\r\\n            default:\\r\\n              this.astGeneric(ast.left, retArr);\\r\\n          }\\r\\n          retArr.push(',');\\r\\n          switch (this.getType(ast.right)) {\\r\\n            case 'Integer':\\r\\n              this.castValueToFloat(ast.right, retArr);\\r\\n              break;\\r\\n            case 'LiteralInteger':\\r\\n              this.castLiteralToFloat(ast.right, retArr);\\r\\n              break;\\r\\n            default:\\r\\n              this.astGeneric(ast.right, retArr);\\r\\n          }\\r\\n          retArr.push(')');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        checkAndUpconvertBitwiseOperators(ast, retArr) {\\r\\n          const upconvertableOperators = {\\r\\n            '&': 'bitwiseAnd',\\r\\n            '|': 'bitwiseOr',\\r\\n            '^': 'bitwiseXOR',\\r\\n            '<<': 'bitwiseZeroFillLeftShift',\\r\\n            '>>': 'bitwiseSignedRightShift',\\r\\n            '>>>': 'bitwiseZeroFillRightShift',\\r\\n          };\\r\\n          const foundOperator = upconvertableOperators[ast.operator];\\r\\n          if (!foundOperator) return null;\\r\\n          retArr.push(foundOperator);\\r\\n          retArr.push('(');\\r\\n          const leftType = this.getType(ast.left);\\r\\n          switch (leftType) {\\r\\n            case 'Number':\\r\\n            case 'Float':\\r\\n              this.castValueToInteger(ast.left, retArr);\\r\\n              break;\\r\\n            case 'LiteralInteger':\\r\\n              this.castLiteralToInteger(ast.left, retArr);\\r\\n              break;\\r\\n            default:\\r\\n              this.astGeneric(ast.left, retArr);\\r\\n          }\\r\\n          retArr.push(',');\\r\\n          const rightType = this.getType(ast.right);\\r\\n          switch (rightType) {\\r\\n            case 'Number':\\r\\n            case 'Float':\\r\\n              this.castValueToInteger(ast.right, retArr);\\r\\n              break;\\r\\n            case 'LiteralInteger':\\r\\n              this.castLiteralToInteger(ast.right, retArr);\\r\\n              break;\\r\\n            default:\\r\\n              this.astGeneric(ast.right, retArr);\\r\\n          }\\r\\n          retArr.push(')');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        checkAndUpconvertBitwiseUnary(ast, retArr) {\\r\\n          const upconvertableOperators = {\\r\\n            '~': 'bitwiseNot',\\r\\n          };\\r\\n          const foundOperator = upconvertableOperators[ast.operator];\\r\\n          if (!foundOperator) return null;\\r\\n          retArr.push(foundOperator);\\r\\n          retArr.push('(');\\r\\n          switch (this.getType(ast.argument)) {\\r\\n            case 'Number':\\r\\n            case 'Float':\\r\\n              this.castValueToInteger(ast.argument, retArr);\\r\\n              break;\\r\\n            case 'LiteralInteger':\\r\\n              this.castLiteralToInteger(ast.argument, retArr);\\r\\n              break;\\r\\n            default:\\r\\n              this.astGeneric(ast.argument, retArr);\\r\\n          }\\r\\n          retArr.push(')');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        castLiteralToInteger(ast, retArr) {\\r\\n          this.pushState('casting-to-integer');\\r\\n          this.astGeneric(ast, retArr);\\r\\n          this.popState('casting-to-integer');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        castLiteralToFloat(ast, retArr) {\\r\\n          this.pushState('casting-to-float');\\r\\n          this.astGeneric(ast, retArr);\\r\\n          this.popState('casting-to-float');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        castValueToInteger(ast, retArr) {\\r\\n          this.pushState('casting-to-integer');\\r\\n          retArr.push('int(');\\r\\n          this.astGeneric(ast, retArr);\\r\\n          retArr.push(')');\\r\\n          this.popState('casting-to-integer');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        castValueToFloat(ast, retArr) {\\r\\n          this.pushState('casting-to-float');\\r\\n          retArr.push('float(');\\r\\n          this.astGeneric(ast, retArr);\\r\\n          retArr.push(')');\\r\\n          this.popState('casting-to-float');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astIdentifierExpression(idtNode, retArr) {\\r\\n          if (idtNode.type !== 'Identifier') {\\r\\n            throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);\\r\\n          }\\r\\n      \\r\\n          const type = this.getType(idtNode);\\r\\n      \\r\\n          const name = utils.sanitizeName(idtNode.name);\\r\\n          if (idtNode.name === 'Infinity') {\\r\\n            retArr.push('3.402823466e+38');\\r\\n          } else if (type === 'Boolean') {\\r\\n            if (this.argumentNames.indexOf(name) > -1) {\\r\\n              retArr.push(`bool(user_${name})`);\\r\\n            } else {\\r\\n              retArr.push(`user_${name}`);\\r\\n            }\\r\\n          } else {\\r\\n            retArr.push(`user_${name}`);\\r\\n          }\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astForStatement(forNode, retArr) {\\r\\n          if (forNode.type !== 'ForStatement') {\\r\\n            throw this.astErrorOutput('Invalid for statement', forNode);\\r\\n          }\\r\\n      \\r\\n          const initArr = [];\\r\\n          const testArr = [];\\r\\n          const updateArr = [];\\r\\n          const bodyArr = [];\\r\\n          let isSafe = null;\\r\\n      \\r\\n          if (forNode.init) {\\r\\n            const { declarations } = forNode.init;\\r\\n            if (declarations.length > 1) {\\r\\n              isSafe = false;\\r\\n            }\\r\\n            this.astGeneric(forNode.init, initArr);\\r\\n            for (let i = 0; i < declarations.length; i++) {\\r\\n              if (declarations[i].init && declarations[i].init.type !== 'Literal') {\\r\\n                isSafe = false;\\r\\n              }\\r\\n            }\\r\\n          } else {\\r\\n            isSafe = false;\\r\\n          }\\r\\n      \\r\\n          if (forNode.test) {\\r\\n            this.astGeneric(forNode.test, testArr);\\r\\n          } else {\\r\\n            isSafe = false;\\r\\n          }\\r\\n      \\r\\n          if (forNode.update) {\\r\\n            this.astGeneric(forNode.update, updateArr);\\r\\n          } else {\\r\\n            isSafe = false;\\r\\n          }\\r\\n      \\r\\n          if (forNode.body) {\\r\\n            this.pushState('loop-body');\\r\\n            this.astGeneric(forNode.body, bodyArr);\\r\\n            this.popState('loop-body');\\r\\n          }\\r\\n      \\r\\n          if (isSafe === null) {\\r\\n            isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);\\r\\n          }\\r\\n      \\r\\n          if (isSafe) {\\r\\n            const initString = initArr.join('');\\r\\n            const initNeedsSemiColon = initString[initString.length - 1] !== ';';\\r\\n            retArr.push(`for (${initString}${initNeedsSemiColon ? ';' : ''}${testArr.join('')};${updateArr.join('')}){\\\\n`);\\r\\n            retArr.push(bodyArr.join(''));\\r\\n            retArr.push('}\\\\n');\\r\\n          } else {\\r\\n            const iVariableName = this.getInternalVariableName('safeI');\\r\\n            if (initArr.length > 0) {\\r\\n              retArr.push(initArr.join(''), '\\\\n');\\r\\n            }\\r\\n            retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\\\n`);\\r\\n            if (testArr.length > 0) {\\r\\n              retArr.push(`if (!${testArr.join('')}) break;\\\\n`);\\r\\n            }\\r\\n            retArr.push(bodyArr.join(''));\\r\\n            retArr.push(`\\\\n${updateArr.join('')};`);\\r\\n            retArr.push('}\\\\n');\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astWhileStatement(whileNode, retArr) {\\r\\n          if (whileNode.type !== 'WhileStatement') {\\r\\n            throw this.astErrorOutput('Invalid while statement', whileNode);\\r\\n          }\\r\\n      \\r\\n          const iVariableName = this.getInternalVariableName('safeI');\\r\\n          retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\\\n`);\\r\\n          retArr.push('if (!');\\r\\n          this.astGeneric(whileNode.test, retArr);\\r\\n          retArr.push(') break;\\\\n');\\r\\n          this.astGeneric(whileNode.body, retArr);\\r\\n          retArr.push('}\\\\n');\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astDoWhileStatement(doWhileNode, retArr) {\\r\\n          if (doWhileNode.type !== 'DoWhileStatement') {\\r\\n            throw this.astErrorOutput('Invalid while statement', doWhileNode);\\r\\n          }\\r\\n      \\r\\n          const iVariableName = this.getInternalVariableName('safeI');\\r\\n          retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\\\\n`);\\r\\n          this.astGeneric(doWhileNode.body, retArr);\\r\\n          retArr.push('if (!');\\r\\n          this.astGeneric(doWhileNode.test, retArr);\\r\\n          retArr.push(') break;\\\\n');\\r\\n          retArr.push('}\\\\n');\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n      \\r\\n        astAssignmentExpression(assNode, retArr) {\\r\\n          if (assNode.operator === '%=') {\\r\\n            this.astGeneric(assNode.left, retArr);\\r\\n            retArr.push('=');\\r\\n            retArr.push('mod(');\\r\\n            this.astGeneric(assNode.left, retArr);\\r\\n            retArr.push(',');\\r\\n            this.astGeneric(assNode.right, retArr);\\r\\n            retArr.push(')');\\r\\n          } else if (assNode.operator === '**=') {\\r\\n            this.astGeneric(assNode.left, retArr);\\r\\n            retArr.push('=');\\r\\n            retArr.push('pow(');\\r\\n            this.astGeneric(assNode.left, retArr);\\r\\n            retArr.push(',');\\r\\n            this.astGeneric(assNode.right, retArr);\\r\\n            retArr.push(')');\\r\\n          } else {\\r\\n            const leftType = this.getType(assNode.left);\\r\\n            const rightType = this.getType(assNode.right);\\r\\n            this.astGeneric(assNode.left, retArr);\\r\\n            retArr.push(assNode.operator);\\r\\n            if (leftType !== 'Integer' && rightType === 'Integer') {\\r\\n              retArr.push('float(');\\r\\n              this.astGeneric(assNode.right, retArr);\\r\\n              retArr.push(')');\\r\\n            } else {\\r\\n              this.astGeneric(assNode.right, retArr);\\r\\n            }\\r\\n            return retArr;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        astBlockStatement(bNode, retArr) {\\r\\n          if (this.isState('loop-body')) {\\r\\n            this.pushState('block-body'); \\r\\n            for (let i = 0; i < bNode.body.length; i++) {\\r\\n              this.astGeneric(bNode.body[i], retArr);\\r\\n            }\\r\\n            this.popState('block-body');\\r\\n          } else {\\r\\n            retArr.push('{\\\\n');\\r\\n            for (let i = 0; i < bNode.body.length; i++) {\\r\\n              this.astGeneric(bNode.body[i], retArr);\\r\\n            }\\r\\n            retArr.push('}\\\\n');\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astVariableDeclaration(varDecNode, retArr) {\\r\\n          const declarations = varDecNode.declarations;\\r\\n          if (!declarations || !declarations[0] || !declarations[0].init) {\\r\\n            throw this.astErrorOutput('Unexpected expression', varDecNode);\\r\\n          }\\r\\n          const result = [];\\r\\n          let lastType = null;\\r\\n          const declarationSets = [];\\r\\n          let declarationSet = [];\\r\\n          for (let i = 0; i < declarations.length; i++) {\\r\\n            const declaration = declarations[i];\\r\\n            const init = declaration.init;\\r\\n            const info = this.getDeclaration(declaration.id);\\r\\n            const actualType = this.getType(declaration.init);\\r\\n            let type = actualType;\\r\\n            if (type === 'LiteralInteger') {\\r\\n              if (info.suggestedType === 'Integer') {\\r\\n                type = 'Integer';\\r\\n              } else {\\r\\n                type = 'Number';\\r\\n              }\\r\\n            }\\r\\n            const markupType = typeMap[type];\\r\\n            if (!markupType) {\\r\\n              throw this.astErrorOutput(`Markup type ${ type } not handled`, varDecNode);\\r\\n            }\\r\\n            const declarationResult = [];\\r\\n            if (actualType === 'Integer' && type === 'Integer') {\\r\\n              info.valueType = 'Number';\\r\\n              if (i === 0 || lastType === null) {\\r\\n                declarationResult.push('float ');\\r\\n              } else if (type !== lastType) {\\r\\n                throw new Error('Unhandled declaration');\\r\\n              }\\r\\n              lastType = type;\\r\\n              declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);\\r\\n              declarationResult.push('float(');\\r\\n              this.astGeneric(init, declarationResult);\\r\\n              declarationResult.push(')');\\r\\n            } else {\\r\\n              info.valueType = type;\\r\\n              if (i === 0 || lastType === null) {\\r\\n                declarationResult.push(`${markupType} `);\\r\\n              } else if (type !== lastType) {\\r\\n                declarationSets.push(declarationSet.join(','));\\r\\n                declarationSet = [];\\r\\n                declarationResult.push(`${markupType} `);\\r\\n              }\\r\\n              lastType = type;\\r\\n              declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);\\r\\n              if (actualType === 'Number' && type === 'Integer') {\\r\\n                if (init.left && init.left.type === 'Literal') {\\r\\n                  this.astGeneric(init, declarationResult);\\r\\n                } else {\\r\\n                  declarationResult.push('int(');\\r\\n                  this.astGeneric(init, declarationResult);\\r\\n                  declarationResult.push(')');\\r\\n                }\\r\\n              } else if (actualType === 'LiteralInteger' && type === 'Integer') {\\r\\n                this.castLiteralToInteger(init, declarationResult);\\r\\n              } else {\\r\\n                this.astGeneric(init, declarationResult);\\r\\n              }\\r\\n            }\\r\\n            declarationSet.push(declarationResult.join(''));\\r\\n          }\\r\\n      \\r\\n          if (declarationSet.length > 0) {\\r\\n            declarationSets.push(declarationSet.join(','));\\r\\n          }\\r\\n      \\r\\n          result.push(declarationSets.join(';'));\\r\\n      \\r\\n          retArr.push(result.join(''));\\r\\n          retArr.push(';');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astIfStatement(ifNode, retArr) {\\r\\n          retArr.push('if (');\\r\\n          this.astGeneric(ifNode.test, retArr);\\r\\n          retArr.push(')');\\r\\n          if (ifNode.consequent.type === 'BlockStatement') {\\r\\n            this.astGeneric(ifNode.consequent, retArr);\\r\\n          } else {\\r\\n            retArr.push(' {\\\\n');\\r\\n            this.astGeneric(ifNode.consequent, retArr);\\r\\n            retArr.push('\\\\n}\\\\n');\\r\\n          }\\r\\n      \\r\\n          if (ifNode.alternate) {\\r\\n            retArr.push('else ');\\r\\n            if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {\\r\\n              this.astGeneric(ifNode.alternate, retArr);\\r\\n            } else {\\r\\n              retArr.push(' {\\\\n');\\r\\n              this.astGeneric(ifNode.alternate, retArr);\\r\\n              retArr.push('\\\\n}\\\\n');\\r\\n            }\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astSwitchStatement(ast, retArr) {\\r\\n          if (ast.type !== 'SwitchStatement') {\\r\\n            throw this.astErrorOutput('Invalid switch statement', ast);\\r\\n          }\\r\\n          const { discriminant, cases } = ast;\\r\\n          const type = this.getType(discriminant);\\r\\n          const varName = `switchDiscriminant${this.astKey(ast, '_')}`;\\r\\n          switch (type) {\\r\\n            case 'Float':\\r\\n            case 'Number':\\r\\n              retArr.push(`float ${varName} = `);\\r\\n              this.astGeneric(discriminant, retArr);\\r\\n              retArr.push(';\\\\n');\\r\\n              break;\\r\\n            case 'Integer':\\r\\n              retArr.push(`int ${varName} = `);\\r\\n              this.astGeneric(discriminant, retArr);\\r\\n              retArr.push(';\\\\n');\\r\\n              break;\\r\\n          }\\r\\n          if (cases.length === 1 && !cases[0].test) {\\r\\n            this.astGeneric(cases[0].consequent, retArr);\\r\\n            return retArr;\\r\\n          }\\r\\n      \\r\\n          let fallingThrough = false;\\r\\n          let defaultResult = [];\\r\\n          let movingDefaultToEnd = false;\\r\\n          let pastFirstIf = false;\\r\\n          for (let i = 0; i < cases.length; i++) {\\r\\n            if (!cases[i].test) {\\r\\n              if (cases.length > i + 1) {\\r\\n                movingDefaultToEnd = true;\\r\\n                this.astGeneric(cases[i].consequent, defaultResult);\\r\\n                continue;\\r\\n              } else {\\r\\n                retArr.push(' else {\\\\n');\\r\\n              }\\r\\n            } else {\\r\\n              if (i === 0 || !pastFirstIf) {\\r\\n                pastFirstIf = true;\\r\\n                retArr.push(`if (${varName} == `);\\r\\n              } else {\\r\\n                if (fallingThrough) {\\r\\n                  retArr.push(`${varName} == `);\\r\\n                  fallingThrough = false;\\r\\n                } else {\\r\\n                  retArr.push(` else if (${varName} == `);\\r\\n                }\\r\\n              }\\r\\n              if (type === 'Integer') {\\r\\n                const testType = this.getType(cases[i].test);\\r\\n                switch (testType) {\\r\\n                  case 'Number':\\r\\n                  case 'Float':\\r\\n                    this.castValueToInteger(cases[i].test, retArr);\\r\\n                    break;\\r\\n                  case 'LiteralInteger':\\r\\n                    this.castLiteralToInteger(cases[i].test, retArr);\\r\\n                    break;\\r\\n                }\\r\\n              } else if (type === 'Float') {\\r\\n                const testType = this.getType(cases[i].test);\\r\\n                switch (testType) {\\r\\n                  case 'LiteralInteger':\\r\\n                    this.castLiteralToFloat(cases[i].test, retArr);\\r\\n                    break;\\r\\n                  case 'Integer':\\r\\n                    this.castValueToFloat(cases[i].test, retArr);\\r\\n                    break;\\r\\n                }\\r\\n              } else {\\r\\n                throw new Error('unhanlded');\\r\\n              }\\r\\n              if (!cases[i].consequent || cases[i].consequent.length === 0) {\\r\\n                fallingThrough = true;\\r\\n                retArr.push(' || ');\\r\\n                continue;\\r\\n              }\\r\\n              retArr.push(`) {\\\\n`);\\r\\n            }\\r\\n            this.astGeneric(cases[i].consequent, retArr);\\r\\n            retArr.push('\\\\n}');\\r\\n          }\\r\\n          if (movingDefaultToEnd) {\\r\\n            retArr.push(' else {');\\r\\n            retArr.push(defaultResult.join(''));\\r\\n            retArr.push('}');\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astThisExpression(tNode, retArr) {\\r\\n          retArr.push('this');\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astMemberExpression(mNode, retArr) {\\r\\n          const {\\r\\n            property,\\r\\n            name,\\r\\n            signature,\\r\\n            origin,\\r\\n            type,\\r\\n            xProperty,\\r\\n            yProperty,\\r\\n            zProperty\\r\\n          } = this.getMemberExpressionDetails(mNode);\\r\\n          switch (signature) {\\r\\n            case 'value.thread.value':\\r\\n            case 'this.thread.value':\\r\\n              if (name !== 'x' && name !== 'y' && name !== 'z') {\\r\\n                throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);\\r\\n              }\\r\\n              retArr.push(`threadId.${name}`);\\r\\n              return retArr;\\r\\n            case 'this.output.value':\\r\\n              if (this.dynamicOutput) {\\r\\n                switch (name) {\\r\\n                  case 'x':\\r\\n                    if (this.isState('casting-to-float')) {\\r\\n                      retArr.push('float(uOutputDim.x)');\\r\\n                    } else {\\r\\n                      retArr.push('uOutputDim.x');\\r\\n                    }\\r\\n                    break;\\r\\n                  case 'y':\\r\\n                    if (this.isState('casting-to-float')) {\\r\\n                      retArr.push('float(uOutputDim.y)');\\r\\n                    } else {\\r\\n                      retArr.push('uOutputDim.y');\\r\\n                    }\\r\\n                    break;\\r\\n                  case 'z':\\r\\n                    if (this.isState('casting-to-float')) {\\r\\n                      retArr.push('float(uOutputDim.z)');\\r\\n                    } else {\\r\\n                      retArr.push('uOutputDim.z');\\r\\n                    }\\r\\n                    break;\\r\\n                  default:\\r\\n                    throw this.astErrorOutput('Unexpected expression', mNode);\\r\\n                }\\r\\n              } else {\\r\\n                switch (name) {\\r\\n                  case 'x':\\r\\n                    if (this.isState('casting-to-integer')) {\\r\\n                      retArr.push(this.output[0]);\\r\\n                    } else {\\r\\n                      retArr.push(this.output[0], '.0');\\r\\n                    }\\r\\n                    break;\\r\\n                  case 'y':\\r\\n                    if (this.isState('casting-to-integer')) {\\r\\n                      retArr.push(this.output[1]);\\r\\n                    } else {\\r\\n                      retArr.push(this.output[1], '.0');\\r\\n                    }\\r\\n                    break;\\r\\n                  case 'z':\\r\\n                    if (this.isState('casting-to-integer')) {\\r\\n                      retArr.push(this.output[2]);\\r\\n                    } else {\\r\\n                      retArr.push(this.output[2], '.0');\\r\\n                    }\\r\\n                    break;\\r\\n                  default:\\r\\n                    throw this.astErrorOutput('Unexpected expression', mNode);\\r\\n                }\\r\\n              }\\r\\n              return retArr;\\r\\n            case 'value':\\r\\n              throw this.astErrorOutput('Unexpected expression', mNode);\\r\\n            case 'value[]':\\r\\n            case 'value[][]':\\r\\n            case 'value[][][]':\\r\\n            case 'value[][][][]':\\r\\n            case 'value.value':\\r\\n              if (origin === 'Math') {\\r\\n                retArr.push(Math[name]);\\r\\n                return retArr;\\r\\n              }\\r\\n              const cleanName = utils.sanitizeName(name);\\r\\n              switch (property) {\\r\\n                case 'r':\\r\\n                  retArr.push(`user_${ cleanName }.r`);\\r\\n                  return retArr;\\r\\n                case 'g':\\r\\n                  retArr.push(`user_${ cleanName }.g`);\\r\\n                  return retArr;\\r\\n                case 'b':\\r\\n                  retArr.push(`user_${ cleanName }.b`);\\r\\n                  return retArr;\\r\\n                case 'a':\\r\\n                  retArr.push(`user_${ cleanName }.a`);\\r\\n                  return retArr;\\r\\n              }\\r\\n              break;\\r\\n            case 'this.constants.value':\\r\\n              if (typeof xProperty === 'undefined') {\\r\\n                switch (type) {\\r\\n                  case 'Array(2)':\\r\\n                  case 'Array(3)':\\r\\n                  case 'Array(4)':\\r\\n                    retArr.push(`constants_${ utils.sanitizeName(name) }`);\\r\\n                    return retArr;\\r\\n                }\\r\\n              }\\r\\n              case 'this.constants.value[]':\\r\\n              case 'this.constants.value[][]':\\r\\n              case 'this.constants.value[][][]':\\r\\n              case 'this.constants.value[][][][]':\\r\\n                break;\\r\\n              case 'fn()[]':\\r\\n                this.astCallExpression(mNode.object, retArr);\\r\\n                retArr.push('[');\\r\\n                retArr.push(this.memberExpressionPropertyMarkup(property));\\r\\n                retArr.push(']');\\r\\n                return retArr;\\r\\n              case 'fn()[][]':\\r\\n                this.astCallExpression(mNode.object.object, retArr);\\r\\n                retArr.push('[');\\r\\n                retArr.push(this.memberExpressionPropertyMarkup(mNode.object.property));\\r\\n                retArr.push(']');\\r\\n                retArr.push('[');\\r\\n                retArr.push(this.memberExpressionPropertyMarkup(mNode.property));\\r\\n                retArr.push(']');\\r\\n                return retArr;\\r\\n              case '[][]':\\r\\n                this.astArrayExpression(mNode.object, retArr);\\r\\n                retArr.push('[');\\r\\n                retArr.push(this.memberExpressionPropertyMarkup(property));\\r\\n                retArr.push(']');\\r\\n                return retArr;\\r\\n              default:\\r\\n                throw this.astErrorOutput('Unexpected expression', mNode);\\r\\n          }\\r\\n      \\r\\n          if (mNode.computed === false) {\\r\\n            switch (type) {\\r\\n              case 'Number':\\r\\n              case 'Integer':\\r\\n              case 'Float':\\r\\n              case 'Boolean':\\r\\n                retArr.push(`${origin}_${utils.sanitizeName(name)}`);\\r\\n                return retArr;\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          const markupName = `${origin}_${utils.sanitizeName(name)}`;\\r\\n      \\r\\n          switch (type) {\\r\\n            case 'Array(2)':\\r\\n            case 'Array(3)':\\r\\n            case 'Array(4)':\\r\\n              this.astGeneric(mNode.object, retArr);\\r\\n              retArr.push('[');\\r\\n              retArr.push(this.memberExpressionPropertyMarkup(xProperty));\\r\\n              retArr.push(']');\\r\\n              break;\\r\\n            case 'HTMLImageArray':\\r\\n              retArr.push(`getImage3D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\\r\\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\\r\\n              retArr.push(')');\\r\\n              break;\\r\\n            case 'ArrayTexture(1)':\\r\\n              retArr.push(`getFloatFromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\\r\\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\\r\\n              retArr.push(')');\\r\\n              break;\\r\\n            case 'Array1D(2)':\\r\\n            case 'Array2D(2)':\\r\\n            case 'Array3D(2)':\\r\\n              retArr.push(`getMemoryOptimizedVec2(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\\r\\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\\r\\n              retArr.push(')');\\r\\n              break;\\r\\n            case 'ArrayTexture(2)':\\r\\n              retArr.push(`getVec2FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\\r\\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\\r\\n              retArr.push(')');\\r\\n              break;\\r\\n            case 'Array1D(3)':\\r\\n            case 'Array2D(3)':\\r\\n            case 'Array3D(3)':\\r\\n              retArr.push(`getMemoryOptimizedVec3(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\\r\\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\\r\\n              retArr.push(')');\\r\\n              break;\\r\\n            case 'ArrayTexture(3)':\\r\\n              retArr.push(`getVec3FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\\r\\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\\r\\n              retArr.push(')');\\r\\n              break;\\r\\n            case 'Array1D(4)':\\r\\n            case 'Array2D(4)':\\r\\n            case 'Array3D(4)':\\r\\n              retArr.push(`getMemoryOptimizedVec4(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\\r\\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\\r\\n              retArr.push(')');\\r\\n              break;\\r\\n            case 'ArrayTexture(4)':\\r\\n            case 'HTMLCanvas':\\r\\n            case 'HTMLImage':\\r\\n            case 'HTMLVideo':\\r\\n              retArr.push(`getVec4FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\\r\\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\\r\\n              retArr.push(')');\\r\\n              break;\\r\\n            case 'NumberTexture':\\r\\n            case 'Array':\\r\\n            case 'Array2D':\\r\\n            case 'Array3D':\\r\\n            case 'Array4D':\\r\\n            case 'Input':\\r\\n            case 'Number':\\r\\n            case 'Float':\\r\\n            case 'Integer':\\r\\n              if (this.precision === 'single') {\\r\\n                retArr.push(`getMemoryOptimized32(${markupName}, ${markupName}Size, ${markupName}Dim, `);\\r\\n                this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\\r\\n                retArr.push(')');\\r\\n              } else {\\r\\n                const bitRatio = (origin === 'user' ?\\r\\n                  this.lookupFunctionArgumentBitRatio(this.name, name) :\\r\\n                  this.constantBitRatios[name]\\r\\n                );\\r\\n                switch (bitRatio) {\\r\\n                  case 1:\\r\\n                    retArr.push(`get8(${markupName}, ${markupName}Size, ${markupName}Dim, `);\\r\\n                    break;\\r\\n                  case 2:\\r\\n                    retArr.push(`get16(${markupName}, ${markupName}Size, ${markupName}Dim, `);\\r\\n                    break;\\r\\n                  case 4:\\r\\n                  case 0:\\r\\n                    retArr.push(`get32(${markupName}, ${markupName}Size, ${markupName}Dim, `);\\r\\n                    break;\\r\\n                  default:\\r\\n                    throw new Error(`unhandled bit ratio of ${bitRatio}`);\\r\\n                }\\r\\n                this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\\r\\n                retArr.push(')');\\r\\n              }\\r\\n              break;\\r\\n            case 'MemoryOptimizedNumberTexture':\\r\\n              retArr.push(`getMemoryOptimized32(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);\\r\\n              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);\\r\\n              retArr.push(')');\\r\\n              break;\\r\\n            case 'Matrix(2)':\\r\\n            case 'Matrix(3)':\\r\\n            case 'Matrix(4)':\\r\\n              retArr.push(`${markupName}[${this.memberExpressionPropertyMarkup(yProperty)}]`);\\r\\n              if (yProperty) {\\r\\n                retArr.push(`[${this.memberExpressionPropertyMarkup(xProperty)}]`);\\r\\n              }\\r\\n              break;\\r\\n            default:\\r\\n              throw new Error(`unhandled member expression \\\"${ type }\\\"`);\\r\\n          }\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astCallExpression(ast, retArr) {\\r\\n          if (!ast.callee) {\\r\\n            throw this.astErrorOutput('Unknown CallExpression', ast);\\r\\n          }\\r\\n      \\r\\n          let functionName = null;\\r\\n          const isMathFunction = this.isAstMathFunction(ast);\\r\\n      \\r\\n          if (isMathFunction || (ast.callee.object && ast.callee.object.type === 'ThisExpression')) {\\r\\n            functionName = ast.callee.property.name;\\r\\n          }\\r\\n          else if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[0].type === 'Literal' && !isNaN(ast.callee.expressions[0].raw)) {\\r\\n            functionName = ast.callee.expressions[1].property.name;\\r\\n          } else {\\r\\n            functionName = ast.callee.name;\\r\\n          }\\r\\n      \\r\\n          if (!functionName) {\\r\\n            throw this.astErrorOutput(`Unhandled function, couldn't find name`, ast);\\r\\n          }\\r\\n      \\r\\n          switch (functionName) {\\r\\n            case 'pow':\\r\\n              functionName = '_pow';\\r\\n              break;\\r\\n            case 'round':\\r\\n              functionName = '_round';\\r\\n              break;\\r\\n          }\\r\\n      \\r\\n          if (this.calledFunctions.indexOf(functionName) < 0) {\\r\\n            this.calledFunctions.push(functionName);\\r\\n          }\\r\\n      \\r\\n          if (functionName === 'random' && this.plugins && this.plugins.length > 0) {\\r\\n            for (let i = 0; i < this.plugins.length; i++) {\\r\\n              const plugin = this.plugins[i];\\r\\n              if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {\\r\\n                retArr.push(plugin.functionReplace);\\r\\n                return retArr;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          if (this.onFunctionCall) {\\r\\n            this.onFunctionCall(this.name, functionName, ast.arguments);\\r\\n          }\\r\\n      \\r\\n          retArr.push(functionName);\\r\\n      \\r\\n          retArr.push('(');\\r\\n      \\r\\n          if (isMathFunction) {\\r\\n            for (let i = 0; i < ast.arguments.length; ++i) {\\r\\n              const argument = ast.arguments[i];\\r\\n              const argumentType = this.getType(argument);\\r\\n              if (i > 0) {\\r\\n                retArr.push(', ');\\r\\n              }\\r\\n      \\r\\n              switch (argumentType) {\\r\\n                case 'Integer':\\r\\n                  this.castValueToFloat(argument, retArr);\\r\\n                  break;\\r\\n                default:\\r\\n                  this.astGeneric(argument, retArr);\\r\\n                  break;\\r\\n              }\\r\\n            }\\r\\n          } else {\\r\\n            const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];\\r\\n            for (let i = 0; i < ast.arguments.length; ++i) {\\r\\n              const argument = ast.arguments[i];\\r\\n              let targetType = targetTypes[i];\\r\\n              if (i > 0) {\\r\\n                retArr.push(', ');\\r\\n              }\\r\\n              const argumentType = this.getType(argument);\\r\\n              if (!targetType) {\\r\\n                this.triggerImplyArgumentType(functionName, i, argumentType, this);\\r\\n                targetType = argumentType;\\r\\n              }\\r\\n              switch (argumentType) {\\r\\n                case 'Boolean':\\r\\n                  this.astGeneric(argument, retArr);\\r\\n                  continue;\\r\\n                case 'Number':\\r\\n                case 'Float':\\r\\n                  if (targetType === 'Integer') {\\r\\n                    retArr.push('int(');\\r\\n                    this.astGeneric(argument, retArr);\\r\\n                    retArr.push(')');\\r\\n                    continue;\\r\\n                  } else if (targetType === 'Number' || targetType === 'Float') {\\r\\n                    this.astGeneric(argument, retArr);\\r\\n                    continue;\\r\\n                  } else if (targetType === 'LiteralInteger') {\\r\\n                    this.castLiteralToFloat(argument, retArr);\\r\\n                    continue;\\r\\n                  }\\r\\n                  break;\\r\\n                case 'Integer':\\r\\n                  if (targetType === 'Number' || targetType === 'Float') {\\r\\n                    retArr.push('float(');\\r\\n                    this.astGeneric(argument, retArr);\\r\\n                    retArr.push(')');\\r\\n                    continue;\\r\\n                  } else if (targetType === 'Integer') {\\r\\n                    this.astGeneric(argument, retArr);\\r\\n                    continue;\\r\\n                  }\\r\\n                  break;\\r\\n                case 'LiteralInteger':\\r\\n                  if (targetType === 'Integer') {\\r\\n                    this.castLiteralToInteger(argument, retArr);\\r\\n                    continue;\\r\\n                  } else if (targetType === 'Number' || targetType === 'Float') {\\r\\n                    this.castLiteralToFloat(argument, retArr);\\r\\n                    continue;\\r\\n                  } else if (targetType === 'LiteralInteger') {\\r\\n                    this.astGeneric(argument, retArr);\\r\\n                    continue;\\r\\n                  }\\r\\n                  break;\\r\\n                case 'Array(2)':\\r\\n                case 'Array(3)':\\r\\n                case 'Array(4)':\\r\\n                  if (targetType === argumentType) {\\r\\n                    if (argument.type === 'Identifier') {\\r\\n                      retArr.push(`user_${utils.sanitizeName(argument.name)}`);\\r\\n                    } else if (argument.type === 'ArrayExpression' || argument.type === 'MemberExpression' || argument.type === 'CallExpression') {\\r\\n                      this.astGeneric(argument, retArr);\\r\\n                    } else {\\r\\n                      throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);\\r\\n                    }\\r\\n                    continue;\\r\\n                  }\\r\\n                  break;\\r\\n                case 'HTMLCanvas':\\r\\n                case 'HTMLImage':\\r\\n                case 'HTMLImageArray':\\r\\n                case 'HTMLVideo':\\r\\n                case 'ArrayTexture(1)':\\r\\n                case 'ArrayTexture(2)':\\r\\n                case 'ArrayTexture(3)':\\r\\n                case 'ArrayTexture(4)':\\r\\n                case 'Array':\\r\\n                case 'Input':\\r\\n                  if (targetType === argumentType) {\\r\\n                    if (argument.type !== 'Identifier') throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);\\r\\n                    this.triggerImplyArgumentBitRatio(this.name, argument.name, functionName, i);\\r\\n                    const name = utils.sanitizeName(argument.name);\\r\\n                    retArr.push(`user_${name},user_${name}Size,user_${name}Dim`);\\r\\n                    continue;\\r\\n                  }\\r\\n                  break;\\r\\n              }\\r\\n              throw this.astErrorOutput(`Unhandled argument combination of ${ argumentType } and ${ targetType } for argument named \\\"${ argument.name }\\\"`, ast);\\r\\n            }\\r\\n          }\\r\\n          retArr.push(')');\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        astArrayExpression(arrNode, retArr) {\\r\\n          const returnType = this.getType(arrNode);\\r\\n      \\r\\n          const arrLen = arrNode.elements.length;\\r\\n      \\r\\n          switch (returnType) {\\r\\n            case 'Matrix(2)':\\r\\n            case 'Matrix(3)':\\r\\n            case 'Matrix(4)':\\r\\n              retArr.push(`mat${arrLen}(`);\\r\\n              break;\\r\\n            default:\\r\\n              retArr.push(`vec${arrLen}(`);\\r\\n          }\\r\\n          for (let i = 0; i < arrLen; ++i) {\\r\\n            if (i > 0) {\\r\\n              retArr.push(', ');\\r\\n            }\\r\\n            const subNode = arrNode.elements[i];\\r\\n            this.astGeneric(subNode, retArr)\\r\\n          }\\r\\n          retArr.push(')');\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        memberExpressionXYZ(x, y, z, retArr) {\\r\\n          if (z) {\\r\\n            retArr.push(this.memberExpressionPropertyMarkup(z), ', ');\\r\\n          } else {\\r\\n            retArr.push('0, ');\\r\\n          }\\r\\n          if (y) {\\r\\n            retArr.push(this.memberExpressionPropertyMarkup(y), ', ');\\r\\n          } else {\\r\\n            retArr.push('0, ');\\r\\n          }\\r\\n          retArr.push(this.memberExpressionPropertyMarkup(x));\\r\\n          return retArr;\\r\\n        }\\r\\n      \\r\\n        memberExpressionPropertyMarkup(property) {\\r\\n          if (!property) {\\r\\n            throw new Error('Property not set');\\r\\n          }\\r\\n          const type = this.getType(property);\\r\\n          const result = [];\\r\\n          switch (type) {\\r\\n            case 'Number':\\r\\n            case 'Float':\\r\\n              this.castValueToInteger(property, result);\\r\\n              break;\\r\\n            case 'LiteralInteger':\\r\\n              this.castLiteralToInteger(property, result);\\r\\n              break;\\r\\n            default:\\r\\n              this.astGeneric(property, result);\\r\\n          }\\r\\n          return result.join('');\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      const typeMap = {\\r\\n        'Array': 'sampler2D',\\r\\n        'Array(2)': 'vec2',\\r\\n        'Array(3)': 'vec3',\\r\\n        'Array(4)': 'vec4',\\r\\n        'Matrix(2)': 'mat2',\\r\\n        'Matrix(3)': 'mat3',\\r\\n        'Matrix(4)': 'mat4',\\r\\n        'Array2D': 'sampler2D',\\r\\n        'Array3D': 'sampler2D',\\r\\n        'Boolean': 'bool',\\r\\n        'Float': 'float',\\r\\n        'Input': 'sampler2D',\\r\\n        'Integer': 'int',\\r\\n        'Number': 'float',\\r\\n        'LiteralInteger': 'float',\\r\\n        'NumberTexture': 'sampler2D',\\r\\n        'MemoryOptimizedNumberTexture': 'sampler2D',\\r\\n        'ArrayTexture(1)': 'sampler2D',\\r\\n        'ArrayTexture(2)': 'sampler2D',\\r\\n        'ArrayTexture(3)': 'sampler2D',\\r\\n        'ArrayTexture(4)': 'sampler2D',\\r\\n        'HTMLVideo': 'sampler2D',\\r\\n        'HTMLCanvas': 'sampler2D',\\r\\n        'HTMLImage': 'sampler2D',\\r\\n        'HTMLImageArray': 'sampler2DArray',\\r\\n      };\\r\\n      \\r\\n      const operatorMap = {\\r\\n        '===': '==',\\r\\n        '!==': '!='\\r\\n      };\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLFunctionNode\\r\\n      };\\r\\n      },{\\\"../../utils\\\":114,\\\"../function-node\\\":10}],39:[function(require,module,exports){\\r\\n      const { WebGLKernelValueBoolean } = require('./kernel-value/boolean');\\r\\n      const { WebGLKernelValueFloat } = require('./kernel-value/float');\\r\\n      const { WebGLKernelValueInteger } = require('./kernel-value/integer');\\r\\n      \\r\\n      const { WebGLKernelValueHTMLImage } = require('./kernel-value/html-image');\\r\\n      const { WebGLKernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');\\r\\n      \\r\\n      const { WebGLKernelValueHTMLVideo } = require('./kernel-value/html-video');\\r\\n      const { WebGLKernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');\\r\\n      \\r\\n      const { WebGLKernelValueSingleInput } = require('./kernel-value/single-input');\\r\\n      const { WebGLKernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');\\r\\n      \\r\\n      const { WebGLKernelValueUnsignedInput } = require('./kernel-value/unsigned-input');\\r\\n      const { WebGLKernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');\\r\\n      \\r\\n      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');\\r\\n      const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');\\r\\n      \\r\\n      const { WebGLKernelValueNumberTexture } = require('./kernel-value/number-texture');\\r\\n      const { WebGLKernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');\\r\\n      \\r\\n      const { WebGLKernelValueSingleArray } = require('./kernel-value/single-array');\\r\\n      const { WebGLKernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');\\r\\n      \\r\\n      const { WebGLKernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');\\r\\n      const { WebGLKernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');\\r\\n      \\r\\n      const { WebGLKernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');\\r\\n      const { WebGLKernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');\\r\\n      \\r\\n      const { WebGLKernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');\\r\\n      const { WebGLKernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');\\r\\n      \\r\\n      const { WebGLKernelValueSingleArray2 } = require('./kernel-value/single-array2');\\r\\n      const { WebGLKernelValueSingleArray3 } = require('./kernel-value/single-array3');\\r\\n      const { WebGLKernelValueSingleArray4 } = require('./kernel-value/single-array4');\\r\\n      \\r\\n      const { WebGLKernelValueUnsignedArray } = require('./kernel-value/unsigned-array');\\r\\n      const { WebGLKernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');\\r\\n      \\r\\n      const kernelValueMaps = {\\r\\n        unsigned: {\\r\\n          dynamic: {\\r\\n            'Boolean': WebGLKernelValueBoolean,\\r\\n            'Integer': WebGLKernelValueInteger,\\r\\n            'Float': WebGLKernelValueFloat,\\r\\n            'Array': WebGLKernelValueDynamicUnsignedArray,\\r\\n            'Array(2)': false,\\r\\n            'Array(3)': false,\\r\\n            'Array(4)': false,\\r\\n            'Array1D(2)': false,\\r\\n            'Array1D(3)': false,\\r\\n            'Array1D(4)': false,\\r\\n            'Array2D(2)': false,\\r\\n            'Array2D(3)': false,\\r\\n            'Array2D(4)': false,\\r\\n            'Array3D(2)': false,\\r\\n            'Array3D(3)': false,\\r\\n            'Array3D(4)': false,\\r\\n            'Input': WebGLKernelValueDynamicUnsignedInput,\\r\\n            'NumberTexture': WebGLKernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,\\r\\n            'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,\\r\\n            'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,\\r\\n            'HTMLImage': WebGLKernelValueDynamicHTMLImage,\\r\\n            'HTMLImageArray': false,\\r\\n            'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,\\r\\n          },\\r\\n          static: {\\r\\n            'Boolean': WebGLKernelValueBoolean,\\r\\n            'Float': WebGLKernelValueFloat,\\r\\n            'Integer': WebGLKernelValueInteger,\\r\\n            'Array': WebGLKernelValueUnsignedArray,\\r\\n            'Array(2)': false,\\r\\n            'Array(3)': false,\\r\\n            'Array(4)': false,\\r\\n            'Array1D(2)': false,\\r\\n            'Array1D(3)': false,\\r\\n            'Array1D(4)': false,\\r\\n            'Array2D(2)': false,\\r\\n            'Array2D(3)': false,\\r\\n            'Array2D(4)': false,\\r\\n            'Array3D(2)': false,\\r\\n            'Array3D(3)': false,\\r\\n            'Array3D(4)': false,\\r\\n            'Input': WebGLKernelValueUnsignedInput,\\r\\n            'NumberTexture': WebGLKernelValueNumberTexture,\\r\\n            'ArrayTexture(1)': WebGLKernelValueNumberTexture,\\r\\n            'ArrayTexture(2)': WebGLKernelValueNumberTexture,\\r\\n            'ArrayTexture(3)': WebGLKernelValueNumberTexture,\\r\\n            'ArrayTexture(4)': WebGLKernelValueNumberTexture,\\r\\n            'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,\\r\\n            'HTMLCanvas': WebGLKernelValueHTMLImage,\\r\\n            'HTMLImage': WebGLKernelValueHTMLImage,\\r\\n            'HTMLImageArray': false,\\r\\n            'HTMLVideo': WebGLKernelValueHTMLVideo,\\r\\n          }\\r\\n        },\\r\\n        single: {\\r\\n          dynamic: {\\r\\n            'Boolean': WebGLKernelValueBoolean,\\r\\n            'Integer': WebGLKernelValueInteger,\\r\\n            'Float': WebGLKernelValueFloat,\\r\\n            'Array': WebGLKernelValueDynamicSingleArray,\\r\\n            'Array(2)': WebGLKernelValueSingleArray2,\\r\\n            'Array(3)': WebGLKernelValueSingleArray3,\\r\\n            'Array(4)': WebGLKernelValueSingleArray4,\\r\\n            'Array1D(2)': WebGLKernelValueDynamicSingleArray1DI,\\r\\n            'Array1D(3)': WebGLKernelValueDynamicSingleArray1DI,\\r\\n            'Array1D(4)': WebGLKernelValueDynamicSingleArray1DI,\\r\\n            'Array2D(2)': WebGLKernelValueDynamicSingleArray2DI,\\r\\n            'Array2D(3)': WebGLKernelValueDynamicSingleArray2DI,\\r\\n            'Array2D(4)': WebGLKernelValueDynamicSingleArray2DI,\\r\\n            'Array3D(2)': WebGLKernelValueDynamicSingleArray3DI,\\r\\n            'Array3D(3)': WebGLKernelValueDynamicSingleArray3DI,\\r\\n            'Array3D(4)': WebGLKernelValueDynamicSingleArray3DI,\\r\\n            'Input': WebGLKernelValueDynamicSingleInput,\\r\\n            'NumberTexture': WebGLKernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,\\r\\n            'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,\\r\\n            'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,\\r\\n            'HTMLImage': WebGLKernelValueDynamicHTMLImage,\\r\\n            'HTMLImageArray': false,\\r\\n            'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,\\r\\n          },\\r\\n          static: {\\r\\n            'Boolean': WebGLKernelValueBoolean,\\r\\n            'Float': WebGLKernelValueFloat,\\r\\n            'Integer': WebGLKernelValueInteger,\\r\\n            'Array': WebGLKernelValueSingleArray,\\r\\n            'Array(2)': WebGLKernelValueSingleArray2,\\r\\n            'Array(3)': WebGLKernelValueSingleArray3,\\r\\n            'Array(4)': WebGLKernelValueSingleArray4,\\r\\n            'Array1D(2)': WebGLKernelValueSingleArray1DI,\\r\\n            'Array1D(3)': WebGLKernelValueSingleArray1DI,\\r\\n            'Array1D(4)': WebGLKernelValueSingleArray1DI,\\r\\n            'Array2D(2)': WebGLKernelValueSingleArray2DI,\\r\\n            'Array2D(3)': WebGLKernelValueSingleArray2DI,\\r\\n            'Array2D(4)': WebGLKernelValueSingleArray2DI,\\r\\n            'Array3D(2)': WebGLKernelValueSingleArray3DI,\\r\\n            'Array3D(3)': WebGLKernelValueSingleArray3DI,\\r\\n            'Array3D(4)': WebGLKernelValueSingleArray3DI,\\r\\n            'Input': WebGLKernelValueSingleInput,\\r\\n            'NumberTexture': WebGLKernelValueNumberTexture,\\r\\n            'ArrayTexture(1)': WebGLKernelValueNumberTexture,\\r\\n            'ArrayTexture(2)': WebGLKernelValueNumberTexture,\\r\\n            'ArrayTexture(3)': WebGLKernelValueNumberTexture,\\r\\n            'ArrayTexture(4)': WebGLKernelValueNumberTexture,\\r\\n            'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,\\r\\n            'HTMLCanvas': WebGLKernelValueHTMLImage,\\r\\n            'HTMLImage': WebGLKernelValueHTMLImage,\\r\\n            'HTMLImageArray': false,\\r\\n            'HTMLVideo': WebGLKernelValueHTMLVideo,\\r\\n          }\\r\\n        },\\r\\n      };\\r\\n      \\r\\n      function lookupKernelValueType(type, dynamic, precision, value) {\\r\\n        if (!type) {\\r\\n          throw new Error('type missing');\\r\\n        }\\r\\n        if (!dynamic) {\\r\\n          throw new Error('dynamic missing');\\r\\n        }\\r\\n        if (!precision) {\\r\\n          throw new Error('precision missing');\\r\\n        }\\r\\n        if (value.type) {\\r\\n          type = value.type;\\r\\n        }\\r\\n        const types = kernelValueMaps[precision][dynamic];\\r\\n        if (types[type] === false) {\\r\\n          return null;\\r\\n        } else if (types[type] === undefined) {\\r\\n          throw new Error(`Could not find a KernelValue for ${ type }`);\\r\\n        }\\r\\n        return types[type];\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        lookupKernelValueType,\\r\\n        kernelValueMaps,\\r\\n      };\\r\\n      },{\\\"./kernel-value/boolean\\\":41,\\\"./kernel-value/dynamic-html-image\\\":42,\\\"./kernel-value/dynamic-html-video\\\":43,\\\"./kernel-value/dynamic-memory-optimized-number-texture\\\":44,\\\"./kernel-value/dynamic-number-texture\\\":45,\\\"./kernel-value/dynamic-single-array\\\":46,\\\"./kernel-value/dynamic-single-array1d-i\\\":47,\\\"./kernel-value/dynamic-single-array2d-i\\\":48,\\\"./kernel-value/dynamic-single-array3d-i\\\":49,\\\"./kernel-value/dynamic-single-input\\\":50,\\\"./kernel-value/dynamic-unsigned-array\\\":51,\\\"./kernel-value/dynamic-unsigned-input\\\":52,\\\"./kernel-value/float\\\":53,\\\"./kernel-value/html-image\\\":54,\\\"./kernel-value/html-video\\\":55,\\\"./kernel-value/integer\\\":57,\\\"./kernel-value/memory-optimized-number-texture\\\":58,\\\"./kernel-value/number-texture\\\":59,\\\"./kernel-value/single-array\\\":60,\\\"./kernel-value/single-array1d-i\\\":61,\\\"./kernel-value/single-array2\\\":62,\\\"./kernel-value/single-array2d-i\\\":63,\\\"./kernel-value/single-array3\\\":64,\\\"./kernel-value/single-array3d-i\\\":65,\\\"./kernel-value/single-array4\\\":66,\\\"./kernel-value/single-input\\\":67,\\\"./kernel-value/unsigned-array\\\":68,\\\"./kernel-value/unsigned-input\\\":69}],40:[function(require,module,exports){\\r\\n      const { WebGLKernelValue } = require('./index');\\r\\n      const { Input } = require('../../../input');\\r\\n      \\r\\n      class WebGLKernelArray extends WebGLKernelValue {\\r\\n        checkSize(width, height) {\\r\\n          if (!this.kernel.validate) return;\\r\\n          const { maxTextureSize } = this.kernel.constructor.features;\\r\\n          if (width > maxTextureSize || height > maxTextureSize) {\\r\\n            if (width > height) {\\r\\n              throw new Error(`Argument texture width of ${width} larger than maximum size of ${maxTextureSize} for your GPU`);\\r\\n            } else if (width < height) {\\r\\n              throw new Error(`Argument texture height of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);\\r\\n            } else {\\r\\n              throw new Error(`Argument texture height and width of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        setup() {\\r\\n          this.requestTexture();\\r\\n          this.setupTexture();\\r\\n          this.defineTexture();\\r\\n        }\\r\\n      \\r\\n        requestTexture() {\\r\\n          this.texture = this.onRequestTexture();\\r\\n        }\\r\\n      \\r\\n        defineTexture() {\\r\\n          const { context: gl } = this;\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\r\\n        }\\r\\n      \\r\\n        setupTexture() {\\r\\n          this.contextHandle = this.onRequestContextHandle();\\r\\n          this.index = this.onRequestIndex();\\r\\n          this.dimensionsId = this.id + 'Dim';\\r\\n          this.sizeId = this.id + 'Size';\\r\\n        }\\r\\n      \\r\\n        getBitRatio(value) {\\r\\n          if (Array.isArray(value[0])) {\\r\\n            return this.getBitRatio(value[0]);\\r\\n          } else if (value.constructor === Input) {\\r\\n            return this.getBitRatio(value.value);\\r\\n          }\\r\\n          switch (value.constructor) {\\r\\n            case Uint8ClampedArray:\\r\\n            case Uint8Array:\\r\\n            case Int8Array:\\r\\n              return 1;\\r\\n            case Uint16Array:\\r\\n            case Int16Array:\\r\\n              return 2;\\r\\n            case Float32Array:\\r\\n            case Int32Array:\\r\\n            default:\\r\\n              return 4;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        destroy() {\\r\\n          if (this.prevArg) {\\r\\n            this.prevArg.delete();\\r\\n          }\\r\\n          this.context.deleteTexture(this.texture);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelArray\\r\\n      };\\r\\n      },{\\\"../../../input\\\":110,\\\"./index\\\":56}],41:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValue } = require('./index');\\r\\n      \\r\\n      class WebGLKernelValueBoolean extends WebGLKernelValue {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.uploadValue = value;\\r\\n        }\\r\\n        getSource(value) {\\r\\n          if (this.origin === 'constants') {\\r\\n            return `const bool ${this.id} = ${value};\\\\n`;\\r\\n          }\\r\\n          return `uniform bool ${this.id};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return `const uploadValue_${this.name} = ${this.varName};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (this.origin === 'constants') return;\\r\\n          this.kernel.setUniform1i(this.id, this.uploadValue = value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueBoolean\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./index\\\":56}],42:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueHTMLImage } = require('./html-image');\\r\\n      \\r\\n      class WebGLKernelValueDynamicHTMLImage extends WebGLKernelValueHTMLImage {\\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `uniform ivec2 ${this.sizeId}`,\\r\\n            `uniform ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          const { width, height } = value;\\r\\n          this.checkSize(width, height);\\r\\n          this.dimensions = [width, height, 1];\\r\\n          this.textureSize = [width, height];\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueDynamicHTMLImage\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./html-image\\\":54}],43:[function(require,module,exports){\\r\\n      const { WebGLKernelValueDynamicHTMLImage } = require('./dynamic-html-image');\\r\\n      \\r\\n      class WebGLKernelValueDynamicHTMLVideo extends WebGLKernelValueDynamicHTMLImage {}\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueDynamicHTMLVideo\\r\\n      };\\r\\n      },{\\\"./dynamic-html-image\\\":42}],44:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./memory-optimized-number-texture');\\r\\n      \\r\\n      class WebGLKernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {\\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `uniform ivec2 ${this.sizeId}`,\\r\\n            `uniform ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(inputTexture) {\\r\\n          this.dimensions = inputTexture.dimensions;\\r\\n          this.checkSize(inputTexture.size[0], inputTexture.size[1]);\\r\\n          this.textureSize = inputTexture.size;\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(inputTexture);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueDynamicMemoryOptimizedNumberTexture\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./memory-optimized-number-texture\\\":58}],45:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueNumberTexture } = require('./number-texture');\\r\\n      \\r\\n      class WebGLKernelValueDynamicNumberTexture extends WebGLKernelValueNumberTexture {\\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `uniform ivec2 ${this.sizeId}`,\\r\\n            `uniform ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          this.dimensions = value.dimensions;\\r\\n          this.checkSize(value.size[0], value.size[1]);\\r\\n          this.textureSize = value.size;\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueDynamicNumberTexture\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./number-texture\\\":59}],46:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueSingleArray } = require('./single-array');\\r\\n      \\r\\n      class WebGLKernelValueDynamicSingleArray extends WebGLKernelValueSingleArray {\\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `uniform ivec2 ${this.sizeId}`,\\r\\n            `uniform ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          this.dimensions = utils.getDimensions(value, true);\\r\\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueDynamicSingleArray\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./single-array\\\":60}],47:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueSingleArray1DI } = require('./single-array1d-i');\\r\\n      \\r\\n      class WebGLKernelValueDynamicSingleArray1DI extends WebGLKernelValueSingleArray1DI {\\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `uniform ivec2 ${this.sizeId}`,\\r\\n            `uniform ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          this.setShape(value);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueDynamicSingleArray1DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./single-array1d-i\\\":61}],48:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueSingleArray2DI } = require('./single-array2d-i');\\r\\n      \\r\\n      class WebGLKernelValueDynamicSingleArray2DI extends WebGLKernelValueSingleArray2DI {\\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `uniform ivec2 ${this.sizeId}`,\\r\\n            `uniform ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          this.setShape(value);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueDynamicSingleArray2DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./single-array2d-i\\\":63}],49:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueSingleArray3DI } = require('./single-array3d-i');\\r\\n      \\r\\n      class WebGLKernelValueDynamicSingleArray3DI extends WebGLKernelValueSingleArray3DI {\\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `uniform ivec2 ${this.sizeId}`,\\r\\n            `uniform ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          this.setShape(value);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueDynamicSingleArray3DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./single-array3d-i\\\":65}],50:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueSingleInput } = require('./single-input');\\r\\n      \\r\\n      class WebGLKernelValueDynamicSingleInput extends WebGLKernelValueSingleInput {\\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `uniform ivec2 ${this.sizeId}`,\\r\\n            `uniform ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          let [w, h, d] = value.size;\\r\\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\\r\\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueDynamicSingleInput\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./single-input\\\":67}],51:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueUnsignedArray } = require('./unsigned-array');\\r\\n      \\r\\n      class WebGLKernelValueDynamicUnsignedArray extends WebGLKernelValueUnsignedArray {\\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `uniform ivec2 ${this.sizeId}`,\\r\\n            `uniform ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          this.dimensions = utils.getDimensions(value, true);\\r\\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          const Type = this.getTransferArrayType(value);\\r\\n          this.preUploadValue = new Type(this.uploadArrayLength);\\r\\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueDynamicUnsignedArray\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./unsigned-array\\\":68}],52:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueUnsignedInput } = require('./unsigned-input');\\r\\n      \\r\\n      class WebGLKernelValueDynamicUnsignedInput extends WebGLKernelValueUnsignedInput {\\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `uniform ivec2 ${this.sizeId}`,\\r\\n            `uniform ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          let [w, h, d] = value.size;\\r\\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\\r\\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          const Type = this.getTransferArrayType(value.value);\\r\\n          this.preUploadValue = new Type(this.uploadArrayLength);\\r\\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueDynamicUnsignedInput\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./unsigned-input\\\":69}],53:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValue } = require('./index');\\r\\n      \\r\\n      class WebGLKernelValueFloat extends WebGLKernelValue {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.uploadValue = value;\\r\\n        }\\r\\n        getStringValueHandler() {\\r\\n          return `const uploadValue_${this.name} = ${this.varName};\\\\n`;\\r\\n        }\\r\\n        getSource(value) {\\r\\n          if (this.origin === 'constants') {\\r\\n            if (Number.isInteger(value)) {\\r\\n              return `const float ${this.id} = ${value}.0;\\\\n`;\\r\\n            }\\r\\n            return `const float ${this.id} = ${value};\\\\n`;\\r\\n          }\\r\\n          return `uniform float ${this.id};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (this.origin === 'constants') return;\\r\\n          this.kernel.setUniform1f(this.id, this.uploadValue = value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueFloat\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./index\\\":56}],54:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelArray } = require('./array');\\r\\n      \\r\\n      class WebGLKernelValueHTMLImage extends WebGLKernelArray {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          const { width, height } = value;\\r\\n          this.checkSize(width, height);\\r\\n          this.dimensions = [width, height, 1];\\r\\n          this.textureSize = [width, height];\\r\\n          this.uploadValue = value;\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return `const uploadValue_${this.name} = ${this.varName};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(inputImage) {\\r\\n          if (inputImage.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(inputImage.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = inputImage);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueHTMLImage\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./array\\\":40}],55:[function(require,module,exports){\\r\\n      const { WebGLKernelValueHTMLImage } = require('./html-image');\\r\\n      \\r\\n      class WebGLKernelValueHTMLVideo extends WebGLKernelValueHTMLImage {}\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueHTMLVideo\\r\\n      };\\r\\n      },{\\\"./html-image\\\":54}],56:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { KernelValue } = require('../../kernel-value');\\r\\n      \\r\\n      class WebGLKernelValue extends KernelValue {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.dimensionsId = null;\\r\\n          this.sizeId = null;\\r\\n          this.initialValueConstructor = value.constructor;\\r\\n          this.onRequestTexture = settings.onRequestTexture;\\r\\n          this.onRequestIndex = settings.onRequestIndex;\\r\\n          this.uploadValue = null;\\r\\n          this.textureSize = null;\\r\\n          this.bitRatio = null;\\r\\n          this.prevArg = null;\\r\\n        }\\r\\n      \\r\\n        get id() {\\r\\n          return `${this.origin}_${utils.sanitizeName(this.name)}`;\\r\\n        }\\r\\n      \\r\\n        setup() {}\\r\\n      \\r\\n        getTransferArrayType(value) {\\r\\n          if (Array.isArray(value[0])) {\\r\\n            return this.getTransferArrayType(value[0]);\\r\\n          }\\r\\n          switch (value.constructor) {\\r\\n            case Array:\\r\\n            case Int32Array:\\r\\n            case Int16Array:\\r\\n            case Int8Array:\\r\\n              return Float32Array;\\r\\n            case Uint8ClampedArray:\\r\\n            case Uint8Array:\\r\\n            case Uint16Array:\\r\\n            case Uint32Array:\\r\\n            case Float32Array:\\r\\n            case Float64Array:\\r\\n              return value.constructor;\\r\\n          }\\r\\n          console.warn('Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros');\\r\\n          return value.constructor;\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          throw new Error(`\\\"getStringValueHandler\\\" not implemented on ${this.constructor.name}`);\\r\\n        }\\r\\n      \\r\\n        getVariablePrecisionString() {\\r\\n          return this.kernel.getVariablePrecisionString(this.textureSize || undefined, this.tactic || undefined);\\r\\n        }\\r\\n      \\r\\n        destroy() {}\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValue\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../kernel-value\\\":35}],57:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValue } = require('./index');\\r\\n      \\r\\n      class WebGLKernelValueInteger extends WebGLKernelValue {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.uploadValue = value;\\r\\n        }\\r\\n        getStringValueHandler() {\\r\\n          return `const uploadValue_${this.name} = ${this.varName};\\\\n`;\\r\\n        }\\r\\n        getSource(value) {\\r\\n          if (this.origin === 'constants') {\\r\\n            return `const int ${this.id} = ${ parseInt(value) };\\\\n`;\\r\\n          }\\r\\n          return `uniform int ${this.id};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (this.origin === 'constants') return;\\r\\n          this.kernel.setUniform1i(this.id, this.uploadValue = value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueInteger\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./index\\\":56}],58:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelArray } = require('./array');\\r\\n      \\r\\n      const sameError = `Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()`;\\r\\n      \\r\\n      class WebGLKernelValueMemoryOptimizedNumberTexture extends WebGLKernelArray {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          const [width, height] = value.size;\\r\\n          this.checkSize(width, height);\\r\\n          this.dimensions = value.dimensions;\\r\\n          this.textureSize = value.size;\\r\\n          this.uploadValue = value.texture;\\r\\n          this.forceUploadEachRun = true;\\r\\n        }\\r\\n      \\r\\n        setup() {\\r\\n          this.setupTexture();\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return `const uploadValue_${this.name} = ${this.varName}.texture;\\\\n`;\\r\\n        }\\r\\n      \\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(inputTexture) {\\r\\n          if (inputTexture.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(inputTexture.constructor);\\r\\n            return;\\r\\n          }\\r\\n          if (this.checkContext && inputTexture.context !== this.context) {\\r\\n            throw new Error(`Value ${this.name} (${this.type}) must be from same context`);\\r\\n          }\\r\\n      \\r\\n          const { kernel, context: gl } = this;\\r\\n          if (kernel.pipeline) {\\r\\n            if (kernel.immutable) {\\r\\n              kernel.updateTextureArgumentRefs(this, inputTexture);\\r\\n            } else {\\r\\n              if (kernel.texture.texture === inputTexture.texture) {\\r\\n                throw new Error(sameError);\\r\\n              } else if (kernel.mappedTextures) {\\r\\n                const { mappedTextures } = kernel;\\r\\n                for (let i = 0; i < mappedTextures.length; i++) {\\r\\n                  if (mappedTextures[i].texture === inputTexture.texture) {\\r\\n                    throw new Error(sameError);\\r\\n                  }\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueMemoryOptimizedNumberTexture,\\r\\n        sameError\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./array\\\":40}],59:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelArray } = require('./array');\\r\\n      const { sameError } = require('./memory-optimized-number-texture');\\r\\n      \\r\\n      class WebGLKernelValueNumberTexture extends WebGLKernelArray {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          const [width, height] = value.size;\\r\\n          this.checkSize(width, height);\\r\\n          const { size: textureSize, dimensions } = value;\\r\\n          this.bitRatio = this.getBitRatio(value);\\r\\n          this.dimensions = dimensions;\\r\\n          this.textureSize = textureSize;\\r\\n          this.uploadValue = value.texture;\\r\\n          this.forceUploadEachRun = true;\\r\\n        }\\r\\n      \\r\\n        setup() {\\r\\n          this.setupTexture();\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return `const uploadValue_${this.name} = ${this.varName}.texture;\\\\n`;\\r\\n        }\\r\\n      \\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(inputTexture) {\\r\\n          if (inputTexture.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(inputTexture.constructor);\\r\\n            return;\\r\\n          }\\r\\n          if (this.checkContext && inputTexture.context !== this.context) {\\r\\n            throw new Error(`Value ${this.name} (${this.type}) must be from same context`);\\r\\n          }\\r\\n      \\r\\n          const { kernel, context: gl } = this;\\r\\n          if (kernel.pipeline) {\\r\\n            if (kernel.immutable) {\\r\\n              kernel.updateTextureArgumentRefs(this, inputTexture);\\r\\n            } else {\\r\\n              if (kernel.texture.texture === inputTexture.texture) {\\r\\n                throw new Error(sameError);\\r\\n              } else if (kernel.mappedTextures) {\\r\\n                const { mappedTextures } = kernel;\\r\\n                for (let i = 0; i < mappedTextures.length; i++) {\\r\\n                  if (mappedTextures[i].texture === inputTexture.texture) {\\r\\n                    throw new Error(sameError);\\r\\n                  }\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueNumberTexture\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./array\\\":40,\\\"./memory-optimized-number-texture\\\":58}],60:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelArray } = require('./array');\\r\\n      \\r\\n      class WebGLKernelValueSingleArray extends WebGLKernelArray {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.bitRatio = 4;\\r\\n          this.dimensions = utils.getDimensions(value, true);\\r\\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return utils.linesToString([\\r\\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\\r\\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (value.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(value.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          utils.flattenTo(value, this.uploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueSingleArray\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./array\\\":40}],61:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelArray } = require('./array');\\r\\n      \\r\\n      class WebGLKernelValueSingleArray1DI extends WebGLKernelArray {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.bitRatio = 4;\\r\\n          this.setShape(value);\\r\\n        }\\r\\n      \\r\\n        setShape(value) {\\r\\n          const valueDimensions = utils.getDimensions(value, true);\\r\\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);\\r\\n          this.dimensions = new Int32Array([valueDimensions[1], 1, 1]);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return utils.linesToString([\\r\\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\\r\\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (value.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(value.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          utils.flatten2dArrayTo(value, this.uploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueSingleArray1DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./array\\\":40}],62:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValue } = require('./index');\\r\\n      \\r\\n      class WebGLKernelValueSingleArray2 extends WebGLKernelValue {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.uploadValue = value;\\r\\n        }\\r\\n        getSource(value) {\\r\\n          if (this.origin === 'constants') {\\r\\n            return `const vec2 ${this.id} = vec2(${value[0]},${value[1]});\\\\n`;\\r\\n          }\\r\\n          return `uniform vec2 ${this.id};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          if (this.origin === 'constants') return '';\\r\\n          return `const uploadValue_${this.name} = ${this.varName};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (this.origin === 'constants') return;\\r\\n          this.kernel.setUniform2fv(this.id, this.uploadValue = value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueSingleArray2\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./index\\\":56}],63:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelArray } = require('./array');\\r\\n      \\r\\n      class WebGLKernelValueSingleArray2DI extends WebGLKernelArray {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.bitRatio = 4;\\r\\n          this.setShape(value);\\r\\n        }\\r\\n      \\r\\n        setShape(value) {\\r\\n          const valueDimensions = utils.getDimensions(value, true);\\r\\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);\\r\\n          this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], 1]);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return utils.linesToString([\\r\\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\\r\\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (value.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(value.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          utils.flatten3dArrayTo(value, this.uploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueSingleArray2DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./array\\\":40}],64:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValue } = require('./index');\\r\\n      \\r\\n      class WebGLKernelValueSingleArray3 extends WebGLKernelValue {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.uploadValue = value;\\r\\n        }\\r\\n        getSource(value) {\\r\\n          if (this.origin === 'constants') {\\r\\n            return `const vec3 ${this.id} = vec3(${value[0]},${value[1]},${value[2]});\\\\n`;\\r\\n          }\\r\\n          return `uniform vec3 ${this.id};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          if (this.origin === 'constants') return '';\\r\\n          return `const uploadValue_${this.name} = ${this.varName};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (this.origin === 'constants') return;\\r\\n          this.kernel.setUniform3fv(this.id, this.uploadValue = value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueSingleArray3\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./index\\\":56}],65:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelArray } = require('./array');\\r\\n      \\r\\n      class WebGLKernelValueSingleArray3DI extends WebGLKernelArray {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.bitRatio = 4;\\r\\n          this.setShape(value);\\r\\n        }\\r\\n      \\r\\n        setShape(value) {\\r\\n          const valueDimensions = utils.getDimensions(value, true);\\r\\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);\\r\\n          this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], valueDimensions[3]]);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return utils.linesToString([\\r\\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\\r\\n            `flattenTo(${this.varName}, uploadValue_${this.name})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (value.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(value.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          utils.flatten4dArrayTo(value, this.uploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueSingleArray3DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./array\\\":40}],66:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValue } = require('./index');\\r\\n      \\r\\n      class WebGLKernelValueSingleArray4 extends WebGLKernelValue {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.uploadValue = value;\\r\\n        }\\r\\n        getSource(value) {\\r\\n          if (this.origin === 'constants') {\\r\\n            return `const vec4 ${this.id} = vec4(${value[0]},${value[1]},${value[2]},${value[3]});\\\\n`;\\r\\n          }\\r\\n          return `uniform vec4 ${this.id};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          if (this.origin === 'constants') return '';\\r\\n          return `const uploadValue_${this.name} = ${this.varName};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (this.origin === 'constants') return;\\r\\n          this.kernel.setUniform4fv(this.id, this.uploadValue = value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueSingleArray4\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./index\\\":56}],67:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelArray } = require('./array');\\r\\n      \\r\\n      class WebGLKernelValueSingleInput extends WebGLKernelArray {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.bitRatio = 4;\\r\\n          let [w, h, d] = value.size;\\r\\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\\r\\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return utils.linesToString([\\r\\n            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,\\r\\n            `flattenTo(${this.varName}.value, uploadValue_${this.name})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(input) {\\r\\n          if (input.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(input.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          utils.flattenTo(input.value, this.uploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueSingleInput\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./array\\\":40}],68:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelArray } = require('./array');\\r\\n      \\r\\n      class WebGLKernelValueUnsignedArray extends WebGLKernelArray {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.bitRatio = this.getBitRatio(value);\\r\\n          this.dimensions = utils.getDimensions(value, true);\\r\\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          this.TranserArrayType = this.getTransferArrayType(value);\\r\\n          this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);\\r\\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return utils.linesToString([\\r\\n            `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,\\r\\n            `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,\\r\\n            `flattenTo(${this.varName}, preUploadValue_${this.name})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (value.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(value.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          utils.flattenTo(value, this.preUploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueUnsignedArray\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./array\\\":40}],69:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelArray } = require('./array');\\r\\n      \\r\\n      class WebGLKernelValueUnsignedInput extends WebGLKernelArray {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.bitRatio = this.getBitRatio(value);\\r\\n          const [w, h, d] = value.size;\\r\\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\\r\\n          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          this.TranserArrayType = this.getTransferArrayType(value.value);\\r\\n          this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);\\r\\n          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return utils.linesToString([\\r\\n            `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,\\r\\n            `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,\\r\\n            `flattenTo(${this.varName}.value, preUploadValue_${this.name})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(input) {\\r\\n          if (input.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(value.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          utils.flattenTo(input.value, this.preUploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernelValueUnsignedInput\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./array\\\":40}],70:[function(require,module,exports){\\r\\n      const { GLKernel } = require('../gl/kernel');\\r\\n      const { FunctionBuilder } = require('../function-builder');\\r\\n      const { WebGLFunctionNode } = require('./function-node');\\r\\n      const { utils } = require('../../utils');\\r\\n      const mrud = require('../../plugins/math-random-uniformly-distributed');\\r\\n      const { fragmentShader } = require('./fragment-shader');\\r\\n      const { vertexShader } = require('./vertex-shader');\\r\\n      const { glKernelString } = require('../gl/kernel-string');\\r\\n      const { lookupKernelValueType } = require('./kernel-value-maps');\\r\\n      \\r\\n      let isSupported = null;\\r\\n      let testCanvas = null;\\r\\n      let testContext = null;\\r\\n      let testExtensions = null;\\r\\n      let features = null;\\r\\n      \\r\\n      const plugins = [mrud];\\r\\n      const canvases = [];\\r\\n      const maxTexSizes = {};\\r\\n      \\r\\n      \\r\\n      class WebGLKernel extends GLKernel {\\r\\n        static get isSupported() {\\r\\n          if (isSupported !== null) {\\r\\n            return isSupported;\\r\\n          }\\r\\n          this.setupFeatureChecks();\\r\\n          isSupported = this.isContextMatch(testContext);\\r\\n          return isSupported;\\r\\n        }\\r\\n      \\r\\n        static setupFeatureChecks() {\\r\\n          if (typeof document !== 'undefined') {\\r\\n            testCanvas = document.createElement('canvas');\\r\\n          } else if (typeof OffscreenCanvas !== 'undefined') {\\r\\n            testCanvas = new OffscreenCanvas(0, 0);\\r\\n          }\\r\\n          if (!testCanvas) return;\\r\\n          testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');\\r\\n          if (!testContext || !testContext.getExtension) return;\\r\\n          testExtensions = {\\r\\n            OES_texture_float: testContext.getExtension('OES_texture_float'),\\r\\n            OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),\\r\\n            OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),\\r\\n            WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),\\r\\n          };\\r\\n          features = this.getFeatures();\\r\\n        }\\r\\n      \\r\\n        static isContextMatch(context) {\\r\\n          if (typeof WebGLRenderingContext !== 'undefined') {\\r\\n            return context instanceof WebGLRenderingContext;\\r\\n          }\\r\\n          return false;\\r\\n        }\\r\\n      \\r\\n        static getIsTextureFloat() {\\r\\n          return Boolean(testExtensions.OES_texture_float);\\r\\n        }\\r\\n      \\r\\n        static getIsDrawBuffers() {\\r\\n          return Boolean(testExtensions.WEBGL_draw_buffers);\\r\\n        }\\r\\n      \\r\\n        static getChannelCount() {\\r\\n          return testExtensions.WEBGL_draw_buffers ?\\r\\n            testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :\\r\\n            1;\\r\\n        }\\r\\n      \\r\\n        static getMaxTextureSize() {\\r\\n          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);\\r\\n        }\\r\\n      \\r\\n        static lookupKernelValueType(type, dynamic, precision, value) {\\r\\n          return lookupKernelValueType(type, dynamic, precision, value);\\r\\n        }\\r\\n      \\r\\n        static get testCanvas() {\\r\\n          return testCanvas;\\r\\n        }\\r\\n      \\r\\n        static get testContext() {\\r\\n          return testContext;\\r\\n        }\\r\\n      \\r\\n        static get features() {\\r\\n          return features;\\r\\n        }\\r\\n      \\r\\n        static get fragmentShader() {\\r\\n          return fragmentShader;\\r\\n        }\\r\\n      \\r\\n        static get vertexShader() {\\r\\n          return vertexShader;\\r\\n        }\\r\\n      \\r\\n        constructor(source, settings) {\\r\\n          super(source, settings);\\r\\n          this.program = null;\\r\\n          this.pipeline = settings.pipeline;\\r\\n          this.endianness = utils.systemEndianness();\\r\\n          this.extensions = {};\\r\\n          this.argumentTextureCount = 0;\\r\\n          this.constantTextureCount = 0;\\r\\n          this.fragShader = null;\\r\\n          this.vertShader = null;\\r\\n          this.drawBuffersMap = null;\\r\\n      \\r\\n          this.maxTexSize = null;\\r\\n          this.onRequestSwitchKernel = null;\\r\\n      \\r\\n          this.texture = null;\\r\\n          this.mappedTextures = null;\\r\\n          this.mergeSettings(source.settings || settings);\\r\\n      \\r\\n          this.threadDim = null;\\r\\n          this.framebuffer = null;\\r\\n          this.buffer = null;\\r\\n      \\r\\n          this.textureCache = [];\\r\\n          this.programUniformLocationCache = {};\\r\\n          this.uniform1fCache = {};\\r\\n          this.uniform1iCache = {};\\r\\n          this.uniform2fCache = {};\\r\\n          this.uniform2fvCache = {};\\r\\n          this.uniform2ivCache = {};\\r\\n          this.uniform3fvCache = {};\\r\\n          this.uniform3ivCache = {};\\r\\n          this.uniform4fvCache = {};\\r\\n          this.uniform4ivCache = {};\\r\\n        }\\r\\n      \\r\\n        initCanvas() {\\r\\n          if (typeof document !== 'undefined') {\\r\\n            const canvas = document.createElement('canvas');\\r\\n            canvas.width = 2;\\r\\n            canvas.height = 2;\\r\\n            return canvas;\\r\\n          } else if (typeof OffscreenCanvas !== 'undefined') {\\r\\n            return new OffscreenCanvas(0, 0);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        initContext() {\\r\\n          const settings = {\\r\\n            alpha: false,\\r\\n            depth: false,\\r\\n            antialias: false\\r\\n          };\\r\\n          return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);\\r\\n        }\\r\\n      \\r\\n        initPlugins(settings) {\\r\\n          const pluginsToUse = [];\\r\\n          const { source } = this;\\r\\n          if (typeof source === 'string') {\\r\\n            for (let i = 0; i < plugins.length; i++) {\\r\\n              const plugin = plugins[i];\\r\\n              if (source.match(plugin.functionMatch)) {\\r\\n                pluginsToUse.push(plugin);\\r\\n              }\\r\\n            }\\r\\n          } else if (typeof source === 'object') {\\r\\n            if (settings.pluginNames) { \\r\\n              for (let i = 0; i < plugins.length; i++) {\\r\\n                const plugin = plugins[i];\\r\\n                const usePlugin = settings.pluginNames.some(pluginName => pluginName === plugin.name);\\r\\n                if (usePlugin) {\\r\\n                  pluginsToUse.push(plugin);\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n          return pluginsToUse;\\r\\n        }\\r\\n      \\r\\n        initExtensions() {\\r\\n          this.extensions = {\\r\\n            OES_texture_float: this.context.getExtension('OES_texture_float'),\\r\\n            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),\\r\\n            OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),\\r\\n            WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),\\r\\n            WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float'),\\r\\n          };\\r\\n        }\\r\\n      \\r\\n        validateSettings(args) {\\r\\n          if (!this.validate) {\\r\\n            this.texSize = utils.getKernelTextureSize({\\r\\n              optimizeFloatMemory: this.optimizeFloatMemory,\\r\\n              precision: this.precision,\\r\\n            }, this.output);\\r\\n            return;\\r\\n          }\\r\\n      \\r\\n          const { features } = this.constructor;\\r\\n      \\r\\n          if (this.optimizeFloatMemory === true && !features.isTextureFloat) {\\r\\n            throw new Error('Float textures are not supported');\\r\\n          } else if (this.precision === 'single' && !features.isFloatRead) {\\r\\n            throw new Error('Single precision not supported');\\r\\n          } else if (!this.graphical && this.precision === null && features.isTextureFloat) {\\r\\n            this.precision = features.isFloatRead ? 'single' : 'unsigned';\\r\\n          }\\r\\n      \\r\\n          if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {\\r\\n            throw new Error('could not instantiate draw buffers extension');\\r\\n          }\\r\\n      \\r\\n          if (this.fixIntegerDivisionAccuracy === null) {\\r\\n            this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;\\r\\n          } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {\\r\\n            this.fixIntegerDivisionAccuracy = false;\\r\\n          }\\r\\n      \\r\\n          this.checkOutput();\\r\\n      \\r\\n          if (!this.output || this.output.length === 0) {\\r\\n            if (args.length !== 1) {\\r\\n              throw new Error('Auto output only supported for kernels with only one input');\\r\\n            }\\r\\n      \\r\\n            const argType = utils.getVariableType(args[0], this.strictIntegers);\\r\\n            switch (argType) {\\r\\n              case 'Array':\\r\\n                this.output = utils.getDimensions(argType);\\r\\n                break;\\r\\n              case 'NumberTexture':\\r\\n              case 'MemoryOptimizedNumberTexture':\\r\\n              case 'ArrayTexture(1)':\\r\\n              case 'ArrayTexture(2)':\\r\\n              case 'ArrayTexture(3)':\\r\\n              case 'ArrayTexture(4)':\\r\\n                this.output = args[0].output;\\r\\n                break;\\r\\n              default:\\r\\n                throw new Error('Auto output not supported for input type: ' + argType);\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          if (this.graphical) {\\r\\n            if (this.output.length !== 2) {\\r\\n              throw new Error('Output must have 2 dimensions on graphical mode');\\r\\n            }\\r\\n      \\r\\n            if (this.precision === 'precision') {\\r\\n              this.precision = 'unsigned';\\r\\n              console.warn('Cannot use graphical mode and single precision at the same time');\\r\\n            }\\r\\n      \\r\\n            this.texSize = utils.clone(this.output);\\r\\n            return;\\r\\n          } else if (this.precision === null && features.isTextureFloat) {\\r\\n            this.precision = 'single';\\r\\n          }\\r\\n      \\r\\n          this.texSize = utils.getKernelTextureSize({\\r\\n            optimizeFloatMemory: this.optimizeFloatMemory,\\r\\n            precision: this.precision,\\r\\n          }, this.output);\\r\\n      \\r\\n          this.checkTextureSize();\\r\\n        }\\r\\n      \\r\\n        updateMaxTexSize() {\\r\\n          const { texSize, canvas } = this;\\r\\n          if (this.maxTexSize === null) {\\r\\n            let canvasIndex = canvases.indexOf(canvas);\\r\\n            if (canvasIndex === -1) {\\r\\n              canvasIndex = canvases.length;\\r\\n              canvases.push(canvas);\\r\\n              maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];\\r\\n            }\\r\\n            this.maxTexSize = maxTexSizes[canvasIndex];\\r\\n          }\\r\\n          if (this.maxTexSize[0] < texSize[0]) {\\r\\n            this.maxTexSize[0] = texSize[0];\\r\\n          }\\r\\n          if (this.maxTexSize[1] < texSize[1]) {\\r\\n            this.maxTexSize[1] = texSize[1];\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        setupArguments(args) {\\r\\n          this.kernelArguments = [];\\r\\n          this.argumentTextureCount = 0;\\r\\n          const needsArgumentTypes = this.argumentTypes === null;\\r\\n          if (needsArgumentTypes) {\\r\\n            this.argumentTypes = [];\\r\\n          }\\r\\n          this.argumentSizes = [];\\r\\n          this.argumentBitRatios = [];\\r\\n      \\r\\n          if (args.length < this.argumentNames.length) {\\r\\n            throw new Error('not enough arguments for kernel');\\r\\n          } else if (args.length > this.argumentNames.length) {\\r\\n            throw new Error('too many arguments for kernel');\\r\\n          }\\r\\n      \\r\\n          const { context: gl } = this;\\r\\n          let textureIndexes = 0;\\r\\n      \\r\\n          const onRequestTexture = () => {\\r\\n            return this.createTexture();\\r\\n          };\\r\\n          const onRequestIndex = () => {\\r\\n            return this.constantTextureCount + textureIndexes++;\\r\\n          };\\r\\n          const onUpdateValueMismatch = (constructor) => {\\r\\n            this.switchKernels({\\r\\n              type: 'argumentMismatch',\\r\\n              needed: constructor\\r\\n            });\\r\\n          };\\r\\n          const onRequestContextHandle = () => {\\r\\n            return gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;\\r\\n          };\\r\\n      \\r\\n          for (let index = 0; index < args.length; index++) {\\r\\n            const value = args[index];\\r\\n            const name = this.argumentNames[index];\\r\\n            let type;\\r\\n            if (needsArgumentTypes) {\\r\\n              type = utils.getVariableType(value, this.strictIntegers);\\r\\n              this.argumentTypes.push(type);\\r\\n            } else {\\r\\n              type = this.argumentTypes[index];\\r\\n            }\\r\\n            const KernelValue = this.constructor.lookupKernelValueType(type, this.dynamicArguments ? 'dynamic' : 'static', this.precision, args[index]);\\r\\n            if (KernelValue === null) {\\r\\n              return this.requestFallback(args);\\r\\n            }\\r\\n            const kernelArgument = new KernelValue(value, {\\r\\n              name,\\r\\n              type,\\r\\n              tactic: this.tactic,\\r\\n              origin: 'user',\\r\\n              context: gl,\\r\\n              checkContext: this.checkContext,\\r\\n              kernel: this,\\r\\n              strictIntegers: this.strictIntegers,\\r\\n              onRequestTexture,\\r\\n              onRequestIndex,\\r\\n              onUpdateValueMismatch,\\r\\n              onRequestContextHandle,\\r\\n            });\\r\\n            this.kernelArguments.push(kernelArgument);\\r\\n            kernelArgument.setup();\\r\\n            this.argumentSizes.push(kernelArgument.textureSize);\\r\\n            this.argumentBitRatios[index] = kernelArgument.bitRatio;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        createTexture() {\\r\\n          const texture = this.context.createTexture();\\r\\n          this.textureCache.push(texture);\\r\\n          return texture;\\r\\n        }\\r\\n      \\r\\n        setupConstants(args) {\\r\\n          const { context: gl } = this;\\r\\n          this.kernelConstants = [];\\r\\n          this.forceUploadKernelConstants = [];\\r\\n          let needsConstantTypes = this.constantTypes === null;\\r\\n          if (needsConstantTypes) {\\r\\n            this.constantTypes = {};\\r\\n          }\\r\\n          this.constantBitRatios = {};\\r\\n          let textureIndexes = 0;\\r\\n          for (const name in this.constants) {\\r\\n            const value = this.constants[name];\\r\\n            let type;\\r\\n            if (needsConstantTypes) {\\r\\n              type = utils.getVariableType(value, this.strictIntegers);\\r\\n              this.constantTypes[name] = type;\\r\\n            } else {\\r\\n              type = this.constantTypes[name];\\r\\n            }\\r\\n            const KernelValue = this.constructor.lookupKernelValueType(type, 'static', this.precision, value);\\r\\n            if (KernelValue === null) {\\r\\n              return this.requestFallback(args);\\r\\n            }\\r\\n            const kernelValue = new KernelValue(value, {\\r\\n              name,\\r\\n              type,\\r\\n              tactic: this.tactic,\\r\\n              origin: 'constants',\\r\\n              context: this.context,\\r\\n              checkContext: this.checkContext,\\r\\n              kernel: this,\\r\\n              strictIntegers: this.strictIntegers,\\r\\n              onRequestTexture: () => {\\r\\n                return this.createTexture();\\r\\n              },\\r\\n              onRequestIndex: () => {\\r\\n                return textureIndexes++;\\r\\n              },\\r\\n              onRequestContextHandle: () => {\\r\\n                return gl.TEXTURE0 + this.constantTextureCount++;\\r\\n              }\\r\\n            });\\r\\n            this.constantBitRatios[name] = kernelValue.bitRatio;\\r\\n            this.kernelConstants.push(kernelValue);\\r\\n            kernelValue.setup();\\r\\n            if (kernelValue.forceUploadEachRun) {\\r\\n              this.forceUploadKernelConstants.push(kernelValue);\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        build() {\\r\\n          if (this.built) return;\\r\\n          this.initExtensions();\\r\\n          this.validateSettings(arguments);\\r\\n          this.setupConstants(arguments);\\r\\n          if (this.fallbackRequested) return;\\r\\n          this.setupArguments(arguments);\\r\\n          if (this.fallbackRequested) return;\\r\\n          this.updateMaxTexSize();\\r\\n          this.translateSource();\\r\\n          const failureResult = this.pickRenderStrategy(arguments);\\r\\n          if (failureResult) {\\r\\n            return failureResult;\\r\\n          }\\r\\n          const { texSize, context: gl, canvas } = this;\\r\\n          gl.enable(gl.SCISSOR_TEST);\\r\\n          if (this.pipeline && this.precision === 'single') {\\r\\n            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);\\r\\n            canvas.width = this.maxTexSize[0];\\r\\n            canvas.height = this.maxTexSize[1];\\r\\n          } else {\\r\\n            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);\\r\\n            canvas.width = this.maxTexSize[0];\\r\\n            canvas.height = this.maxTexSize[1];\\r\\n          }\\r\\n          const threadDim = this.threadDim = Array.from(this.output);\\r\\n          while (threadDim.length < 3) {\\r\\n            threadDim.push(1);\\r\\n          }\\r\\n      \\r\\n          const compiledVertexShader = this.getVertexShader(arguments);\\r\\n          const vertShader = gl.createShader(gl.VERTEX_SHADER);\\r\\n          gl.shaderSource(vertShader, compiledVertexShader);\\r\\n          gl.compileShader(vertShader);\\r\\n          this.vertShader = vertShader;\\r\\n      \\r\\n          const compiledFragmentShader = this.getFragmentShader(arguments);\\r\\n          const fragShader = gl.createShader(gl.FRAGMENT_SHADER);\\r\\n          gl.shaderSource(fragShader, compiledFragmentShader);\\r\\n          gl.compileShader(fragShader);\\r\\n          this.fragShader = fragShader;\\r\\n      \\r\\n          if (this.debug) {\\r\\n            console.log('GLSL Shader Output:');\\r\\n            console.log(compiledFragmentShader);\\r\\n          }\\r\\n      \\r\\n          if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {\\r\\n            throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));\\r\\n          }\\r\\n          if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {\\r\\n            throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));\\r\\n          }\\r\\n      \\r\\n          const program = this.program = gl.createProgram();\\r\\n          gl.attachShader(program, vertShader);\\r\\n          gl.attachShader(program, fragShader);\\r\\n          gl.linkProgram(program);\\r\\n          this.framebuffer = gl.createFramebuffer();\\r\\n          this.framebuffer.width = texSize[0];\\r\\n          this.framebuffer.height = texSize[1];\\r\\n          this.rawValueFramebuffers = {};\\r\\n      \\r\\n          const vertices = new Float32Array([-1, -1,\\r\\n            1, -1, -1, 1,\\r\\n            1, 1\\r\\n          ]);\\r\\n          const texCoords = new Float32Array([\\r\\n            0, 0,\\r\\n            1, 0,\\r\\n            0, 1,\\r\\n            1, 1\\r\\n          ]);\\r\\n      \\r\\n          const texCoordOffset = vertices.byteLength;\\r\\n      \\r\\n          let buffer = this.buffer;\\r\\n          if (!buffer) {\\r\\n            buffer = this.buffer = gl.createBuffer();\\r\\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\\r\\n            gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);\\r\\n          } else {\\r\\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\\r\\n          }\\r\\n      \\r\\n          gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);\\r\\n          gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);\\r\\n      \\r\\n          const aPosLoc = gl.getAttribLocation(this.program, 'aPos');\\r\\n          gl.enableVertexAttribArray(aPosLoc);\\r\\n          gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);\\r\\n          const aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');\\r\\n          gl.enableVertexAttribArray(aTexCoordLoc);\\r\\n          gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);\\r\\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\\r\\n      \\r\\n          let i = 0;\\r\\n          gl.useProgram(this.program);\\r\\n          for (let p in this.constants) {\\r\\n            this.kernelConstants[i++].updateValue(this.constants[p]);\\r\\n          }\\r\\n      \\r\\n          this._setupOutputTexture();\\r\\n          if (\\r\\n            this.subKernels !== null &&\\r\\n            this.subKernels.length > 0\\r\\n          ) {\\r\\n            this._mappedTextureSwitched = {};\\r\\n            this._setupSubOutputTextures();\\r\\n          }\\r\\n          this.buildSignature(arguments);\\r\\n          this.built = true;\\r\\n        }\\r\\n      \\r\\n        translateSource() {\\r\\n          const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {\\r\\n            fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy\\r\\n          });\\r\\n          this.translatedSource = functionBuilder.getPrototypeString('kernel');\\r\\n          this.setupReturnTypes(functionBuilder);\\r\\n        }\\r\\n      \\r\\n        setupReturnTypes(functionBuilder) {\\r\\n          if (!this.graphical && !this.returnType) {\\r\\n            this.returnType = functionBuilder.getKernelResultType();\\r\\n          }\\r\\n      \\r\\n          if (this.subKernels && this.subKernels.length > 0) {\\r\\n            for (let i = 0; i < this.subKernels.length; i++) {\\r\\n              const subKernel = this.subKernels[i];\\r\\n              if (!subKernel.returnType) {\\r\\n                subKernel.returnType = functionBuilder.getSubKernelResultType(i);\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        run() {\\r\\n          const { kernelArguments, texSize, forceUploadKernelConstants, context: gl } = this;\\r\\n      \\r\\n          gl.useProgram(this.program);\\r\\n          gl.scissor(0, 0, texSize[0], texSize[1]);\\r\\n          if (this.dynamicOutput) {\\r\\n            this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));\\r\\n            this.setUniform2iv('uTexSize', texSize);\\r\\n          }\\r\\n      \\r\\n          this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);\\r\\n      \\r\\n          for (let i = 0; i < forceUploadKernelConstants.length; i++) {\\r\\n            const constant = forceUploadKernelConstants[i];\\r\\n            constant.updateValue(this.constants[constant.name]);\\r\\n            if (this.switchingKernels) return;\\r\\n          }\\r\\n          for (let i = 0; i < kernelArguments.length; i++) {\\r\\n            kernelArguments[i].updateValue(arguments[i]);\\r\\n            if (this.switchingKernels) return;\\r\\n          }\\r\\n      \\r\\n          if (this.plugins) {\\r\\n            for (let i = 0; i < this.plugins.length; i++) {\\r\\n              const plugin = this.plugins[i];\\r\\n              if (plugin.onBeforeRun) {\\r\\n                plugin.onBeforeRun(this);\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          if (this.graphical) {\\r\\n            if (this.pipeline) {\\r\\n              gl.bindRenderbuffer(gl.RENDERBUFFER, null);\\r\\n              gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\\r\\n              if (this.immutable) {\\r\\n                this._replaceOutputTexture();\\r\\n              }\\r\\n              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\\r\\n              return this.immutable ? this.texture.clone() : this.texture;\\r\\n            }\\r\\n            gl.bindRenderbuffer(gl.RENDERBUFFER, null);\\r\\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\\r\\n            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\\r\\n            return;\\r\\n          }\\r\\n      \\r\\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\\r\\n          if (this.immutable) {\\r\\n            this._replaceOutputTexture();\\r\\n          }\\r\\n      \\r\\n          if (this.subKernels !== null) {\\r\\n            if (this.immutable) {\\r\\n              this._replaceSubOutputTextures();\\r\\n            }\\r\\n            this.drawBuffers();\\r\\n          }\\r\\n      \\r\\n          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\\r\\n        }\\r\\n      \\r\\n        drawBuffers() {\\r\\n          this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);\\r\\n        }\\r\\n      \\r\\n        getInternalFormat() {\\r\\n          return this.context.RGBA;\\r\\n        }\\r\\n        getTextureFormat() {\\r\\n          const { context: gl } = this;\\r\\n          switch (this.getInternalFormat()) {\\r\\n            case gl.RGBA:\\r\\n              return gl.RGBA;\\r\\n            default:\\r\\n              throw new Error('Unknown internal format');\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        _replaceOutputTexture() {\\r\\n          if (this.texture.beforeMutate() || this._textureSwitched) {\\r\\n            const gl = this.context;\\r\\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);\\r\\n            this._textureSwitched = false;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        _setupOutputTexture() {\\r\\n          const gl = this.context;\\r\\n          const texSize = this.texSize;\\r\\n          if (this.texture) {\\r\\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);\\r\\n            return;\\r\\n          }\\r\\n          const texture = this.createTexture();\\r\\n          gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, texture);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\r\\n          const format = this.getInternalFormat();\\r\\n          if (this.precision === 'single') {\\r\\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);\\r\\n          } else {\\r\\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);\\r\\n          }\\r\\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\\r\\n          this.texture = new this.TextureConstructor({\\r\\n            texture,\\r\\n            size: texSize,\\r\\n            dimensions: this.threadDim,\\r\\n            output: this.output,\\r\\n            context: this.context,\\r\\n            internalFormat: this.getInternalFormat(),\\r\\n            textureFormat: this.getTextureFormat(),\\r\\n            kernel: this,\\r\\n          });\\r\\n        }\\r\\n      \\r\\n        _replaceSubOutputTextures() {\\r\\n          const gl = this.context;\\r\\n          for (let i = 0; i < this.mappedTextures.length; i++) {\\r\\n            const mappedTexture = this.mappedTextures[i];\\r\\n            if (mappedTexture.beforeMutate() || this._mappedTextureSwitched[i]) {\\r\\n              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, mappedTexture.texture, 0);\\r\\n              this._mappedTextureSwitched[i] = false;\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        _setupSubOutputTextures() {\\r\\n          const gl = this.context;\\r\\n          if (this.mappedTextures) {\\r\\n            for (let i = 0; i < this.subKernels.length; i++) {\\r\\n              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);\\r\\n            }\\r\\n            return;\\r\\n          }\\r\\n          const texSize = this.texSize;\\r\\n          this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];\\r\\n          this.mappedTextures = [];\\r\\n          for (let i = 0; i < this.subKernels.length; i++) {\\r\\n            const texture = this.createTexture();\\r\\n            this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);\\r\\n            gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);\\r\\n            gl.bindTexture(gl.TEXTURE_2D, texture);\\r\\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\r\\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\r\\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\r\\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\r\\n            if (this.precision === 'single') {\\r\\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);\\r\\n            } else {\\r\\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\\r\\n            }\\r\\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);\\r\\n      \\r\\n            this.mappedTextures.push(new this.TextureConstructor({\\r\\n              texture,\\r\\n              size: texSize,\\r\\n              dimensions: this.threadDim,\\r\\n              output: this.output,\\r\\n              context: this.context,\\r\\n              internalFormat: this.getInternalFormat(),\\r\\n              textureFormat: this.getTextureFormat(),\\r\\n              kernel: this,\\r\\n            }));\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        setUniform1f(name, value) {\\r\\n          if (this.uniform1fCache.hasOwnProperty(name)) {\\r\\n            const cache = this.uniform1fCache[name];\\r\\n            if (value === cache) {\\r\\n              return;\\r\\n            }\\r\\n          }\\r\\n          this.uniform1fCache[name] = value;\\r\\n          const loc = this.getUniformLocation(name);\\r\\n          this.context.uniform1f(loc, value);\\r\\n        }\\r\\n      \\r\\n        setUniform1i(name, value) {\\r\\n          if (this.uniform1iCache.hasOwnProperty(name)) {\\r\\n            const cache = this.uniform1iCache[name];\\r\\n            if (value === cache) {\\r\\n              return;\\r\\n            }\\r\\n          }\\r\\n          this.uniform1iCache[name] = value;\\r\\n          const loc = this.getUniformLocation(name);\\r\\n          this.context.uniform1i(loc, value);\\r\\n        }\\r\\n      \\r\\n        setUniform2f(name, value1, value2) {\\r\\n          if (this.uniform2fCache.hasOwnProperty(name)) {\\r\\n            const cache = this.uniform2fCache[name];\\r\\n            if (\\r\\n              value1 === cache[0] &&\\r\\n              value2 === cache[1]\\r\\n            ) {\\r\\n              return;\\r\\n            }\\r\\n          }\\r\\n          this.uniform2fCache[name] = [value1, value2];\\r\\n          const loc = this.getUniformLocation(name);\\r\\n          this.context.uniform2f(loc, value1, value2);\\r\\n        }\\r\\n      \\r\\n        setUniform2fv(name, value) {\\r\\n          if (this.uniform2fvCache.hasOwnProperty(name)) {\\r\\n            const cache = this.uniform2fvCache[name];\\r\\n            if (\\r\\n              value[0] === cache[0] &&\\r\\n              value[1] === cache[1]\\r\\n            ) {\\r\\n              return;\\r\\n            }\\r\\n          }\\r\\n          this.uniform2fvCache[name] = value;\\r\\n          const loc = this.getUniformLocation(name);\\r\\n          this.context.uniform2fv(loc, value);\\r\\n        }\\r\\n      \\r\\n        setUniform2iv(name, value) {\\r\\n          if (this.uniform2ivCache.hasOwnProperty(name)) {\\r\\n            const cache = this.uniform2ivCache[name];\\r\\n            if (\\r\\n              value[0] === cache[0] &&\\r\\n              value[1] === cache[1]\\r\\n            ) {\\r\\n              return;\\r\\n            }\\r\\n          }\\r\\n          this.uniform2ivCache[name] = value;\\r\\n          const loc = this.getUniformLocation(name);\\r\\n          this.context.uniform2iv(loc, value);\\r\\n        }\\r\\n      \\r\\n        setUniform3fv(name, value) {\\r\\n          if (this.uniform3fvCache.hasOwnProperty(name)) {\\r\\n            const cache = this.uniform3fvCache[name];\\r\\n            if (\\r\\n              value[0] === cache[0] &&\\r\\n              value[1] === cache[1] &&\\r\\n              value[2] === cache[2]\\r\\n            ) {\\r\\n              return;\\r\\n            }\\r\\n          }\\r\\n          this.uniform3fvCache[name] = value;\\r\\n          const loc = this.getUniformLocation(name);\\r\\n          this.context.uniform3fv(loc, value);\\r\\n        }\\r\\n      \\r\\n        setUniform3iv(name, value) {\\r\\n          if (this.uniform3ivCache.hasOwnProperty(name)) {\\r\\n            const cache = this.uniform3ivCache[name];\\r\\n            if (\\r\\n              value[0] === cache[0] &&\\r\\n              value[1] === cache[1] &&\\r\\n              value[2] === cache[2]\\r\\n            ) {\\r\\n              return;\\r\\n            }\\r\\n          }\\r\\n          this.uniform3ivCache[name] = value;\\r\\n          const loc = this.getUniformLocation(name);\\r\\n          this.context.uniform3iv(loc, value);\\r\\n        }\\r\\n      \\r\\n        setUniform4fv(name, value) {\\r\\n          if (this.uniform4fvCache.hasOwnProperty(name)) {\\r\\n            const cache = this.uniform4fvCache[name];\\r\\n            if (\\r\\n              value[0] === cache[0] &&\\r\\n              value[1] === cache[1] &&\\r\\n              value[2] === cache[2] &&\\r\\n              value[3] === cache[3]\\r\\n            ) {\\r\\n              return;\\r\\n            }\\r\\n          }\\r\\n          this.uniform4fvCache[name] = value;\\r\\n          const loc = this.getUniformLocation(name);\\r\\n          this.context.uniform4fv(loc, value);\\r\\n        }\\r\\n      \\r\\n        setUniform4iv(name, value) {\\r\\n          if (this.uniform4ivCache.hasOwnProperty(name)) {\\r\\n            const cache = this.uniform4ivCache[name];\\r\\n            if (\\r\\n              value[0] === cache[0] &&\\r\\n              value[1] === cache[1] &&\\r\\n              value[2] === cache[2] &&\\r\\n              value[3] === cache[3]\\r\\n            ) {\\r\\n              return;\\r\\n            }\\r\\n          }\\r\\n          this.uniform4ivCache[name] = value;\\r\\n          const loc = this.getUniformLocation(name);\\r\\n          this.context.uniform4iv(loc, value);\\r\\n        }\\r\\n      \\r\\n        getUniformLocation(name) {\\r\\n          if (this.programUniformLocationCache.hasOwnProperty(name)) {\\r\\n            return this.programUniformLocationCache[name];\\r\\n          }\\r\\n          return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);\\r\\n        }\\r\\n      \\r\\n        _getFragShaderArtifactMap(args) {\\r\\n          return {\\r\\n            HEADER: this._getHeaderString(),\\r\\n            LOOP_MAX: this._getLoopMaxString(),\\r\\n            PLUGINS: this._getPluginsString(),\\r\\n            CONSTANTS: this._getConstantsString(),\\r\\n            DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),\\r\\n            ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),\\r\\n            DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),\\r\\n            INJECTED_NATIVE: this._getInjectedNative(),\\r\\n            MAIN_CONSTANTS: this._getMainConstantsString(),\\r\\n            MAIN_ARGUMENTS: this._getMainArgumentsString(args),\\r\\n            KERNEL: this.getKernelString(),\\r\\n            MAIN_RESULT: this.getMainResultString(),\\r\\n            FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),\\r\\n            INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),\\r\\n            SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),\\r\\n            SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),\\r\\n          };\\r\\n        }\\r\\n      \\r\\n        _getVertShaderArtifactMap(args) {\\r\\n          return {\\r\\n            FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),\\r\\n            INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),\\r\\n            SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),\\r\\n            SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),\\r\\n          };\\r\\n        }\\r\\n      \\r\\n        _getHeaderString() {\\r\\n          return (\\r\\n            this.subKernels !== null ?\\r\\n            '#extension GL_EXT_draw_buffers : require\\\\n' :\\r\\n            ''\\r\\n          );\\r\\n        }\\r\\n      \\r\\n        _getLoopMaxString() {\\r\\n          return (\\r\\n            this.loopMaxIterations ?\\r\\n            ` ${parseInt(this.loopMaxIterations)};\\\\n` :\\r\\n            ' 1000;\\\\n'\\r\\n          );\\r\\n        }\\r\\n      \\r\\n        _getPluginsString() {\\r\\n          if (!this.plugins) return '\\\\n';\\r\\n          return this.plugins.map(plugin => plugin.source && this.source.match(plugin.functionMatch) ? plugin.source : '').join('\\\\n');\\r\\n        }\\r\\n      \\r\\n        _getConstantsString() {\\r\\n          const result = [];\\r\\n          const { threadDim, texSize } = this;\\r\\n          if (this.dynamicOutput) {\\r\\n            result.push(\\r\\n              'uniform ivec3 uOutputDim',\\r\\n              'uniform ivec2 uTexSize'\\r\\n            );\\r\\n          } else {\\r\\n            result.push(\\r\\n              `ivec3 uOutputDim = ivec3(${threadDim[0]}, ${threadDim[1]}, ${threadDim[2]})`,\\r\\n              `ivec2 uTexSize = ivec2(${texSize[0]}, ${texSize[1]})`\\r\\n            );\\r\\n          }\\r\\n          return utils.linesToString(result);\\r\\n        }\\r\\n      \\r\\n        _getTextureCoordinate() {\\r\\n          const subKernels = this.subKernels;\\r\\n          if (subKernels === null || subKernels.length < 1) {\\r\\n            return 'varying vec2 vTexCoord;\\\\n';\\r\\n          } else {\\r\\n            return 'out vec2 vTexCoord;\\\\n';\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        _getDecode32EndiannessString() {\\r\\n          return (\\r\\n            this.endianness === 'LE' ?\\r\\n            '' :\\r\\n            '  texel.rgba = texel.abgr;\\\\n'\\r\\n          );\\r\\n        }\\r\\n      \\r\\n        _getEncode32EndiannessString() {\\r\\n          return (\\r\\n            this.endianness === 'LE' ?\\r\\n            '' :\\r\\n            '  texel.rgba = texel.abgr;\\\\n'\\r\\n          );\\r\\n        }\\r\\n      \\r\\n        _getDivideWithIntegerCheckString() {\\r\\n          return this.fixIntegerDivisionAccuracy ?\\r\\n            `float divWithIntCheck(float x, float y) {\\r\\n        if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {\\r\\n          return float(int(x) / int(y));\\r\\n        }\\r\\n        return x / y;\\r\\n      }\\r\\n      \\r\\n      float integerCorrectionModulo(float number, float divisor) {\\r\\n        if (number < 0.0) {\\r\\n          number = abs(number);\\r\\n          if (divisor < 0.0) {\\r\\n            divisor = abs(divisor);\\r\\n          }\\r\\n          return -(number - (divisor * floor(divWithIntCheck(number, divisor))));\\r\\n        }\\r\\n        if (divisor < 0.0) {\\r\\n          divisor = abs(divisor);\\r\\n        }\\r\\n        return number - (divisor * floor(divWithIntCheck(number, divisor)));\\r\\n      }` :\\r\\n            '';\\r\\n        }\\r\\n      \\r\\n        _getMainArgumentsString(args) {\\r\\n          const results = [];\\r\\n          const { argumentNames } = this;\\r\\n          for (let i = 0; i < argumentNames.length; i++) {\\r\\n            results.push(this.kernelArguments[i].getSource(args[i]));\\r\\n          }\\r\\n          return results.join('');\\r\\n        }\\r\\n      \\r\\n        _getInjectedNative() {\\r\\n          return this.injectedNative || '';\\r\\n        }\\r\\n      \\r\\n        _getMainConstantsString() {\\r\\n          const result = [];\\r\\n          const { constants } = this;\\r\\n          if (constants) {\\r\\n            let i = 0;\\r\\n            for (const name in constants) {\\r\\n              if (!this.constants.hasOwnProperty(name)) continue;\\r\\n              result.push(this.kernelConstants[i++].getSource(this.constants[name]));\\r\\n            }\\r\\n          }\\r\\n          return result.join('');\\r\\n        }\\r\\n      \\r\\n        getRawValueFramebuffer(width, height) {\\r\\n          if (!this.rawValueFramebuffers[width]) {\\r\\n            this.rawValueFramebuffers[width] = {};\\r\\n          }\\r\\n          if (!this.rawValueFramebuffers[width][height]) {\\r\\n            const framebuffer = this.context.createFramebuffer();\\r\\n            framebuffer.width = width;\\r\\n            framebuffer.height = height;\\r\\n            this.rawValueFramebuffers[width][height] = framebuffer;\\r\\n          }\\r\\n          return this.rawValueFramebuffers[width][height];\\r\\n        }\\r\\n      \\r\\n        getKernelResultDeclaration() {\\r\\n          switch (this.returnType) {\\r\\n            case 'Array(2)':\\r\\n              return 'vec2 kernelResult';\\r\\n            case 'Array(3)':\\r\\n              return 'vec3 kernelResult';\\r\\n            case 'Array(4)':\\r\\n              return 'vec4 kernelResult';\\r\\n            case 'LiteralInteger':\\r\\n            case 'Float':\\r\\n            case 'Number':\\r\\n            case 'Integer':\\r\\n              return 'float kernelResult';\\r\\n            default:\\r\\n              if (this.graphical) {\\r\\n                return 'float kernelResult';\\r\\n              } else {\\r\\n                throw new Error(`unrecognized output type \\\"${ this.returnType }\\\"`);\\r\\n              }\\r\\n          }\\r\\n        }\\r\\n        getKernelString() {\\r\\n          const result = [this.getKernelResultDeclaration()];\\r\\n          const { subKernels } = this;\\r\\n          if (subKernels !== null) {\\r\\n            switch (this.returnType) {\\r\\n              case 'Number':\\r\\n              case 'Float':\\r\\n              case 'Integer':\\r\\n                for (let i = 0; i < subKernels.length; i++) {\\r\\n                  const subKernel = subKernels[i];\\r\\n                  result.push(\\r\\n                    subKernel.returnType === 'Integer' ?\\r\\n                    `int subKernelResult_${ subKernel.name } = 0` :\\r\\n                    `float subKernelResult_${ subKernel.name } = 0.0`\\r\\n                  );\\r\\n                }\\r\\n                break;\\r\\n              case 'Array(2)':\\r\\n                for (let i = 0; i < subKernels.length; i++) {\\r\\n                  result.push(\\r\\n                    `vec2 subKernelResult_${ subKernels[i].name }`\\r\\n                  );\\r\\n                }\\r\\n                break;\\r\\n              case 'Array(3)':\\r\\n                for (let i = 0; i < subKernels.length; i++) {\\r\\n                  result.push(\\r\\n                    `vec3 subKernelResult_${ subKernels[i].name }`\\r\\n                  );\\r\\n                }\\r\\n                break;\\r\\n              case 'Array(4)':\\r\\n                for (let i = 0; i < subKernels.length; i++) {\\r\\n                  result.push(\\r\\n                    `vec4 subKernelResult_${ subKernels[i].name }`\\r\\n                  );\\r\\n                }\\r\\n                break;\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          return utils.linesToString(result) + this.translatedSource;\\r\\n        }\\r\\n      \\r\\n        getMainResultGraphical() {\\r\\n          return utils.linesToString([\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            '  gl_FragColor = actualColor',\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        getMainResultPackedPixels() {\\r\\n          switch (this.returnType) {\\r\\n            case 'LiteralInteger':\\r\\n            case 'Number':\\r\\n            case 'Integer':\\r\\n            case 'Float':\\r\\n              return this.getMainResultKernelPackedPixels() +\\r\\n                this.getMainResultSubKernelPackedPixels();\\r\\n            default:\\r\\n              throw new Error(`packed output only usable with Numbers, \\\"${this.returnType}\\\" specified`);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelPackedPixels() {\\r\\n          return utils.linesToString([\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            `  gl_FragData[0] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelPackedPixels() {\\r\\n          const result = [];\\r\\n          if (!this.subKernels) return '';\\r\\n          for (let i = 0; i < this.subKernels.length; i++) {\\r\\n            const subKernel = this.subKernels[i];\\r\\n            if (subKernel.returnType === 'Integer') {\\r\\n              result.push(\\r\\n                `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`\\r\\n              );\\r\\n            } else {\\r\\n              result.push(\\r\\n                `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`\\r\\n              );\\r\\n            }\\r\\n          }\\r\\n          return utils.linesToString(result);\\r\\n        }\\r\\n      \\r\\n        getMainResultMemoryOptimizedFloats() {\\r\\n          const result = [\\r\\n            '  index *= 4',\\r\\n          ];\\r\\n      \\r\\n          switch (this.returnType) {\\r\\n            case 'Number':\\r\\n            case 'Integer':\\r\\n            case 'Float':\\r\\n              const channels = ['r', 'g', 'b', 'a'];\\r\\n              for (let i = 0; i < channels.length; i++) {\\r\\n                const channel = channels[i];\\r\\n                this.getMainResultKernelMemoryOptimizedFloats(result, channel);\\r\\n                this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);\\r\\n                if (i + 1 < channels.length) {\\r\\n                  result.push('  index += 1');\\r\\n                }\\r\\n              }\\r\\n              break;\\r\\n            default:\\r\\n              throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);\\r\\n          }\\r\\n      \\r\\n          return utils.linesToString(result);\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelMemoryOptimizedFloats(result, channel) {\\r\\n          result.push(\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            `  gl_FragData[0].${channel} = kernelResult`\\r\\n          );\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelMemoryOptimizedFloats(result, channel) {\\r\\n          if (!this.subKernels) return result;\\r\\n          for (let i = 0; i < this.subKernels.length; i++) {\\r\\n            const subKernel = this.subKernels[i];\\r\\n            if (subKernel.returnType === 'Integer') {\\r\\n              result.push(\\r\\n                `  gl_FragData[${i + 1}].${channel} = float(subKernelResult_${this.subKernels[i].name})`\\r\\n              );\\r\\n            } else {\\r\\n              result.push(\\r\\n                `  gl_FragData[${i + 1}].${channel} = subKernelResult_${this.subKernels[i].name}`\\r\\n              );\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelNumberTexture() {\\r\\n          return [\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            '  gl_FragData[0][0] = kernelResult',\\r\\n          ];\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelNumberTexture() {\\r\\n          const result = [];\\r\\n          if (!this.subKernels) return result;\\r\\n          for (let i = 0; i < this.subKernels.length; ++i) {\\r\\n            const subKernel = this.subKernels[i];\\r\\n            if (subKernel.returnType === 'Integer') {\\r\\n              result.push(\\r\\n                `  gl_FragData[${i + 1}][0] = float(subKernelResult_${subKernel.name})`\\r\\n              );\\r\\n            } else {\\r\\n              result.push(\\r\\n                `  gl_FragData[${i + 1}][0] = subKernelResult_${subKernel.name}`\\r\\n              );\\r\\n            }\\r\\n          }\\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelArray2Texture() {\\r\\n          return [\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            '  gl_FragData[0][0] = kernelResult[0]',\\r\\n            '  gl_FragData[0][1] = kernelResult[1]',\\r\\n          ];\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelArray2Texture() {\\r\\n          const result = [];\\r\\n          if (!this.subKernels) return result;\\r\\n          for (let i = 0; i < this.subKernels.length; ++i) {\\r\\n            result.push(\\r\\n              `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\\r\\n              `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`\\r\\n            );\\r\\n          }\\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelArray3Texture() {\\r\\n          return [\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            '  gl_FragData[0][0] = kernelResult[0]',\\r\\n            '  gl_FragData[0][1] = kernelResult[1]',\\r\\n            '  gl_FragData[0][2] = kernelResult[2]',\\r\\n          ];\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelArray3Texture() {\\r\\n          const result = [];\\r\\n          if (!this.subKernels) return result;\\r\\n          for (let i = 0; i < this.subKernels.length; ++i) {\\r\\n            result.push(\\r\\n              `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\\r\\n              `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,\\r\\n              `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`\\r\\n            );\\r\\n          }\\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelArray4Texture() {\\r\\n          return [\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            '  gl_FragData[0] = kernelResult',\\r\\n          ];\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelArray4Texture() {\\r\\n          const result = [];\\r\\n          if (!this.subKernels) return result;\\r\\n          switch (this.returnType) {\\r\\n            case 'Number':\\r\\n            case 'Float':\\r\\n            case 'Integer':\\r\\n              for (let i = 0; i < this.subKernels.length; ++i) {\\r\\n                const subKernel = this.subKernels[i];\\r\\n                if (subKernel.returnType === 'Integer') {\\r\\n                  result.push(\\r\\n                    `  gl_FragData[${i + 1}] = float(subKernelResult_${this.subKernels[i].name})`\\r\\n                  );\\r\\n                } else {\\r\\n                  result.push(\\r\\n                    `  gl_FragData[${i + 1}] = subKernelResult_${this.subKernels[i].name}`\\r\\n                  );\\r\\n                }\\r\\n              }\\r\\n              break;\\r\\n            case 'Array(2)':\\r\\n              for (let i = 0; i < this.subKernels.length; ++i) {\\r\\n                result.push(\\r\\n                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\\r\\n                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`\\r\\n                );\\r\\n              }\\r\\n              break;\\r\\n            case 'Array(3)':\\r\\n              for (let i = 0; i < this.subKernels.length; ++i) {\\r\\n                result.push(\\r\\n                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\\r\\n                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,\\r\\n                  `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`\\r\\n                );\\r\\n              }\\r\\n              break;\\r\\n            case 'Array(4)':\\r\\n              for (let i = 0; i < this.subKernels.length; ++i) {\\r\\n                result.push(\\r\\n                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,\\r\\n                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,\\r\\n                  `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,\\r\\n                  `  gl_FragData[${i + 1}][3] = subKernelResult_${this.subKernels[i].name}[3]`\\r\\n                );\\r\\n              }\\r\\n              break;\\r\\n          }\\r\\n      \\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        replaceArtifacts(src, map) {\\r\\n          return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\\\\n/g, (match, artifact) => {\\r\\n            if (map.hasOwnProperty(artifact)) {\\r\\n              return map[artifact];\\r\\n            }\\r\\n            throw `unhandled artifact ${artifact}`;\\r\\n          });\\r\\n        }\\r\\n      \\r\\n        getFragmentShader(args) {\\r\\n          if (this.compiledFragmentShader !== null) {\\r\\n            return this.compiledFragmentShader;\\r\\n          }\\r\\n          return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));\\r\\n        }\\r\\n      \\r\\n        getVertexShader(args) {\\r\\n          if (this.compiledVertexShader !== null) {\\r\\n            return this.compiledVertexShader;\\r\\n          }\\r\\n          return this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(args));\\r\\n        }\\r\\n      \\r\\n        toString() {\\r\\n          const setupContextString = utils.linesToString([\\r\\n            `const gl = context`,\\r\\n          ]);\\r\\n          return glKernelString(this.constructor, arguments, this, setupContextString);\\r\\n        }\\r\\n      \\r\\n        destroy(removeCanvasReferences) {\\r\\n          if (!this.context) return;\\r\\n          if (this.buffer) {\\r\\n            this.context.deleteBuffer(this.buffer);\\r\\n          }\\r\\n          if (this.framebuffer) {\\r\\n            this.context.deleteFramebuffer(this.framebuffer);\\r\\n          }\\r\\n          for (const width in this.rawValueFramebuffers) {\\r\\n            for (const height in this.rawValueFramebuffers[width]) {\\r\\n              this.context.deleteFramebuffer(this.rawValueFramebuffers[width][height]);\\r\\n              delete this.rawValueFramebuffers[width][height];\\r\\n            }\\r\\n            delete this.rawValueFramebuffers[width];\\r\\n          }\\r\\n          if (this.vertShader) {\\r\\n            this.context.deleteShader(this.vertShader);\\r\\n          }\\r\\n          if (this.fragShader) {\\r\\n            this.context.deleteShader(this.fragShader);\\r\\n          }\\r\\n          if (this.program) {\\r\\n            this.context.deleteProgram(this.program);\\r\\n          }\\r\\n          if (this.texture) {\\r\\n            this.texture.delete();\\r\\n            const textureCacheIndex = this.textureCache.indexOf(this.texture.texture);\\r\\n            if (textureCacheIndex > -1) {\\r\\n              this.textureCache.splice(textureCacheIndex, 1);\\r\\n            }\\r\\n            this.texture = null;\\r\\n          }\\r\\n          if (this.mappedTextures && this.mappedTextures.length) {\\r\\n            for (let i = 0; i < this.mappedTextures.length; i++) {\\r\\n              const mappedTexture = this.mappedTextures[i];\\r\\n              mappedTexture.delete();\\r\\n              const textureCacheIndex = this.textureCache.indexOf(mappedTexture.texture);\\r\\n              if (textureCacheIndex > -1) {\\r\\n                this.textureCache.splice(textureCacheIndex, 1);\\r\\n              }\\r\\n            }\\r\\n            this.mappedTextures = null;\\r\\n          }\\r\\n          if (this.kernelArguments) {\\r\\n            for (let i = 0; i < this.kernelArguments.length; i++) {\\r\\n              this.kernelArguments[i].destroy();\\r\\n            }\\r\\n          }\\r\\n          if (this.kernelConstants) {\\r\\n            for (let i = 0; i < this.kernelConstants.length; i++) {\\r\\n              this.kernelConstants[i].destroy();\\r\\n            }\\r\\n          }\\r\\n          while (this.textureCache.length > 0) {\\r\\n            const texture = this.textureCache.pop();\\r\\n            this.context.deleteTexture(texture);\\r\\n          }\\r\\n          if (removeCanvasReferences) {\\r\\n            const idx = canvases.indexOf(this.canvas);\\r\\n            if (idx >= 0) {\\r\\n              canvases[idx] = null;\\r\\n              maxTexSizes[idx] = null;\\r\\n            }\\r\\n          }\\r\\n          this.destroyExtensions();\\r\\n          delete this.context;\\r\\n          delete this.canvas;\\r\\n          if (!this.gpu) return;\\r\\n          const i = this.gpu.kernels.indexOf(this);\\r\\n          if (i === -1) return;\\r\\n          this.gpu.kernels.splice(i, 1);\\r\\n        }\\r\\n      \\r\\n        destroyExtensions() {\\r\\n          this.extensions.OES_texture_float = null;\\r\\n          this.extensions.OES_texture_float_linear = null;\\r\\n          this.extensions.OES_element_index_uint = null;\\r\\n          this.extensions.WEBGL_draw_buffers = null;\\r\\n        }\\r\\n      \\r\\n        static destroyContext(context) {\\r\\n          const extension = context.getExtension('WEBGL_lose_context');\\r\\n          if (extension) {\\r\\n            extension.loseContext();\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        toJSON() {\\r\\n          const json = super.toJSON();\\r\\n          json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();\\r\\n          json.settings.threadDim = this.threadDim;\\r\\n          return json;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGLKernel\\r\\n      };\\r\\n      },{\\\"../../plugins/math-random-uniformly-distributed\\\":112,\\\"../../utils\\\":114,\\\"../function-builder\\\":9,\\\"../gl/kernel\\\":13,\\\"../gl/kernel-string\\\":12,\\\"./fragment-shader\\\":37,\\\"./function-node\\\":38,\\\"./kernel-value-maps\\\":39,\\\"./vertex-shader\\\":71}],71:[function(require,module,exports){\\r\\n      const vertexShader = `__FLOAT_TACTIC_DECLARATION__;\\r\\n      __INT_TACTIC_DECLARATION__;\\r\\n      __SAMPLER_2D_TACTIC_DECLARATION__;\\r\\n      \\r\\n      attribute vec2 aPos;\\r\\n      attribute vec2 aTexCoord;\\r\\n      \\r\\n      varying vec2 vTexCoord;\\r\\n      uniform vec2 ratio;\\r\\n      \\r\\n      void main(void) {\\r\\n        gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\\r\\n        vTexCoord = aTexCoord;\\r\\n      }`;\\r\\n      \\r\\n      module.exports = {\\r\\n        vertexShader\\r\\n      };\\r\\n      },{}],72:[function(require,module,exports){\\r\\n      const fragmentShader = `#version 300 es\\r\\n      __HEADER__;\\r\\n      __FLOAT_TACTIC_DECLARATION__;\\r\\n      __INT_TACTIC_DECLARATION__;\\r\\n      __SAMPLER_2D_TACTIC_DECLARATION__;\\r\\n      __SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;\\r\\n      \\r\\n      const int LOOP_MAX = __LOOP_MAX__;\\r\\n      \\r\\n      __PLUGINS__;\\r\\n      __CONSTANTS__;\\r\\n      \\r\\n      in vec2 vTexCoord;\\r\\n      \\r\\n      float atan2(float v1, float v2) {\\r\\n        if (v1 == 0.0 || v2 == 0.0) return 0.0;\\r\\n        return atan(v1 / v2);\\r\\n      }\\r\\n      \\r\\n      float cbrt(float x) {\\r\\n        if (x >= 0.0) {\\r\\n          return pow(x, 1.0 / 3.0);\\r\\n        } else {\\r\\n          return -pow(x, 1.0 / 3.0);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      float expm1(float x) {\\r\\n        return pow(${Math.E}, x) - 1.0; \\r\\n      }\\r\\n      \\r\\n      float fround(highp float x) {\\r\\n        return x;\\r\\n      }\\r\\n      \\r\\n      float imul(float v1, float v2) {\\r\\n        return float(int(v1) * int(v2));\\r\\n      }\\r\\n      \\r\\n      float log10(float x) {\\r\\n        return log2(x) * (1.0 / log2(10.0));\\r\\n      }\\r\\n      \\r\\n      float log1p(float x) {\\r\\n        return log(1.0 + x);\\r\\n      }\\r\\n      \\r\\n      float _pow(float v1, float v2) {\\r\\n        if (v2 == 0.0) return 1.0;\\r\\n        return pow(v1, v2);\\r\\n      }\\r\\n      \\r\\n      float _round(float x) {\\r\\n        return floor(x + 0.5);\\r\\n      }\\r\\n      \\r\\n      \\r\\n      const int BIT_COUNT = 32;\\r\\n      int modi(int x, int y) {\\r\\n        return x - y * (x / y);\\r\\n      }\\r\\n      \\r\\n      int bitwiseOr(int a, int b) {\\r\\n        int result = 0;\\r\\n        int n = 1;\\r\\n        \\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {\\r\\n            result += n;\\r\\n          }\\r\\n          a = a / 2;\\r\\n          b = b / 2;\\r\\n          n = n * 2;\\r\\n          if(!(a > 0 || b > 0)) {\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      int bitwiseXOR(int a, int b) {\\r\\n        int result = 0;\\r\\n        int n = 1;\\r\\n        \\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {\\r\\n            result += n;\\r\\n          }\\r\\n          a = a / 2;\\r\\n          b = b / 2;\\r\\n          n = n * 2;\\r\\n          if(!(a > 0 || b > 0)) {\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      int bitwiseAnd(int a, int b) {\\r\\n        int result = 0;\\r\\n        int n = 1;\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {\\r\\n            result += n;\\r\\n          }\\r\\n          a = a / 2;\\r\\n          b = b / 2;\\r\\n          n = n * 2;\\r\\n          if(!(a > 0 && b > 0)) {\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      int bitwiseNot(int a) {\\r\\n        int result = 0;\\r\\n        int n = 1;\\r\\n        \\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (modi(a, 2) == 0) {\\r\\n            result += n;    \\r\\n          }\\r\\n          a = a / 2;\\r\\n          n = n * 2;\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      int bitwiseZeroFillLeftShift(int n, int shift) {\\r\\n        int maxBytes = BIT_COUNT;\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (maxBytes >= n) {\\r\\n            break;\\r\\n          }\\r\\n          maxBytes *= 2;\\r\\n        }\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (i >= shift) {\\r\\n            break;\\r\\n          }\\r\\n          n *= 2;\\r\\n        }\\r\\n      \\r\\n        int result = 0;\\r\\n        int byteVal = 1;\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (i >= maxBytes) break;\\r\\n          if (modi(n, 2) > 0) { result += byteVal; }\\r\\n          n = int(n / 2);\\r\\n          byteVal *= 2;\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      \\r\\n      int bitwiseSignedRightShift(int num, int shifts) {\\r\\n        return int(floor(float(num) / pow(2.0, float(shifts))));\\r\\n      }\\r\\n      \\r\\n      int bitwiseZeroFillRightShift(int n, int shift) {\\r\\n        int maxBytes = BIT_COUNT;\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (maxBytes >= n) {\\r\\n            break;\\r\\n          }\\r\\n          maxBytes *= 2;\\r\\n        }\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (i >= shift) {\\r\\n            break;\\r\\n          }\\r\\n          n /= 2;\\r\\n        }\\r\\n        int result = 0;\\r\\n        int byteVal = 1;\\r\\n        for (int i = 0; i < BIT_COUNT; i++) {\\r\\n          if (i >= maxBytes) break;\\r\\n          if (modi(n, 2) > 0) { result += byteVal; }\\r\\n          n = int(n / 2);\\r\\n          byteVal *= 2;\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n      \\r\\n      vec2 integerMod(vec2 x, float y) {\\r\\n        vec2 res = floor(mod(x, y));\\r\\n        return res * step(1.0 - floor(y), -res);\\r\\n      }\\r\\n      \\r\\n      vec3 integerMod(vec3 x, float y) {\\r\\n        vec3 res = floor(mod(x, y));\\r\\n        return res * step(1.0 - floor(y), -res);\\r\\n      }\\r\\n      \\r\\n      vec4 integerMod(vec4 x, vec4 y) {\\r\\n        vec4 res = floor(mod(x, y));\\r\\n        return res * step(1.0 - floor(y), -res);\\r\\n      }\\r\\n      \\r\\n      float integerMod(float x, float y) {\\r\\n        float res = floor(mod(x, y));\\r\\n        return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);\\r\\n      }\\r\\n      \\r\\n      int integerMod(int x, int y) {\\r\\n        return x - (y * int(x/y));\\r\\n      }\\r\\n      \\r\\n      __DIVIDE_WITH_INTEGER_CHECK__;\\r\\n      \\r\\n      // Here be dragons!\\r\\n      // DO NOT OPTIMIZE THIS CODE\\r\\n      // YOU WILL BREAK SOMETHING ON SOMEBODY\\\\'S MACHINE\\r\\n      // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME\\r\\n      const vec2 MAGIC_VEC = vec2(1.0, -256.0);\\r\\n      const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);\\r\\n      const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536\\r\\n      float decode32(vec4 texel) {\\r\\n        __DECODE32_ENDIANNESS__;\\r\\n        texel *= 255.0;\\r\\n        vec2 gte128;\\r\\n        gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;\\r\\n        gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;\\r\\n        float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);\\r\\n        float res = exp2(round(exponent));\\r\\n        texel.b = texel.b - 128.0 * gte128.x;\\r\\n        res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;\\r\\n        res *= gte128.y * -2.0 + 1.0;\\r\\n        return res;\\r\\n      }\\r\\n      \\r\\n      float decode16(vec4 texel, int index) {\\r\\n        int channel = integerMod(index, 2);\\r\\n        return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;\\r\\n      }\\r\\n      \\r\\n      float decode8(vec4 texel, int index) {\\r\\n        int channel = integerMod(index, 4);\\r\\n        return texel[channel] * 255.0;\\r\\n      }\\r\\n      \\r\\n      vec4 legacyEncode32(float f) {\\r\\n        float F = abs(f);\\r\\n        float sign = f < 0.0 ? 1.0 : 0.0;\\r\\n        float exponent = floor(log2(F));\\r\\n        float mantissa = (exp2(-exponent) * F);\\r\\n        // exponent += floor(log2(mantissa));\\r\\n        vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;\\r\\n        texel.rg = integerMod(texel.rg, 256.0);\\r\\n        texel.b = integerMod(texel.b, 128.0);\\r\\n        texel.a = exponent*0.5 + 63.5;\\r\\n        texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;\\r\\n        texel = floor(texel);\\r\\n        texel *= 0.003921569; // 1/255\\r\\n        __ENCODE32_ENDIANNESS__;\\r\\n        return texel;\\r\\n      }\\r\\n      \\r\\n      // https://github.com/gpujs/gpu.js/wiki/Encoder-details\\r\\n      vec4 encode32(float value) {\\r\\n        if (value == 0.0) return vec4(0, 0, 0, 0);\\r\\n      \\r\\n        float exponent;\\r\\n        float mantissa;\\r\\n        vec4  result;\\r\\n        float sgn;\\r\\n      \\r\\n        sgn = step(0.0, -value);\\r\\n        value = abs(value);\\r\\n      \\r\\n        exponent = floor(log2(value));\\r\\n      \\r\\n        mantissa = value*pow(2.0, -exponent)-1.0;\\r\\n        exponent = exponent+127.0;\\r\\n        result   = vec4(0,0,0,0);\\r\\n      \\r\\n        result.a = floor(exponent/2.0);\\r\\n        exponent = exponent - result.a*2.0;\\r\\n        result.a = result.a + 128.0*sgn;\\r\\n      \\r\\n        result.b = floor(mantissa * 128.0);\\r\\n        mantissa = mantissa - result.b / 128.0;\\r\\n        result.b = result.b + exponent*128.0;\\r\\n      \\r\\n        result.g = floor(mantissa*32768.0);\\r\\n        mantissa = mantissa - result.g/32768.0;\\r\\n      \\r\\n        result.r = floor(mantissa*8388608.0);\\r\\n        return result/255.0;\\r\\n      }\\r\\n      // Dragons end here\\r\\n      \\r\\n      int index;\\r\\n      ivec3 threadId;\\r\\n      \\r\\n      ivec3 indexTo3D(int idx, ivec3 texDim) {\\r\\n        int z = int(idx / (texDim.x * texDim.y));\\r\\n        idx -= z * int(texDim.x * texDim.y);\\r\\n        int y = int(idx / texDim.x);\\r\\n        int x = int(integerMod(idx, texDim.x));\\r\\n        return ivec3(x, y, z);\\r\\n      }\\r\\n      \\r\\n      float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + texDim.x * (y + texDim.y * z);\\r\\n        int w = texSize.x;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        vec4 texel = texture(tex, st / vec2(texSize));\\r\\n        return decode32(texel);\\r\\n      }\\r\\n      \\r\\n      float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + (texDim.x * (y + (texDim.y * z)));\\r\\n        int w = texSize.x * 2;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));\\r\\n        return decode16(texel, index);\\r\\n      }\\r\\n      \\r\\n      float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + (texDim.x * (y + (texDim.y * z)));\\r\\n        int w = texSize.x * 4;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));\\r\\n        return decode8(texel, index);\\r\\n      }\\r\\n      \\r\\n      float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + (texDim.x * (y + (texDim.y * z)));\\r\\n        int channel = integerMod(index, 4);\\r\\n        index = index / 4;\\r\\n        int w = texSize.x;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        index = index / 4;\\r\\n        vec4 texel = texture(tex, st / vec2(texSize));\\r\\n        return texel[channel];\\r\\n      }\\r\\n      \\r\\n      vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + texDim.x * (y + texDim.y * z);\\r\\n        int w = texSize.x;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        return texture(tex, st / vec2(texSize));\\r\\n      }\\r\\n      \\r\\n      vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + texDim.x * (y + texDim.y * z);\\r\\n        int w = texSize.x;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        return texture(tex, vec3(st / vec2(texSize), z));\\r\\n      }\\r\\n      \\r\\n      float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\\r\\n        return result[0];\\r\\n      }\\r\\n      \\r\\n      vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\\r\\n        return vec2(result[0], result[1]);\\r\\n      }\\r\\n      \\r\\n      vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + texDim.x * (y + texDim.y * z);\\r\\n        int channel = integerMod(index, 2);\\r\\n        index = index / 2;\\r\\n        int w = texSize.x;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        vec4 texel = texture(tex, st / vec2(texSize));\\r\\n        if (channel == 0) return vec2(texel.r, texel.g);\\r\\n        if (channel == 1) return vec2(texel.b, texel.a);\\r\\n        return vec2(0.0, 0.0);\\r\\n      }\\r\\n      \\r\\n      vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        vec4 result = getImage2D(tex, texSize, texDim, z, y, x);\\r\\n        return vec3(result[0], result[1], result[2]);\\r\\n      }\\r\\n      \\r\\n      vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));\\r\\n        int vectorIndex = fieldIndex / 4;\\r\\n        int vectorOffset = fieldIndex - vectorIndex * 4;\\r\\n        int readY = vectorIndex / texSize.x;\\r\\n        int readX = vectorIndex - readY * texSize.x;\\r\\n        vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));\\r\\n      \\r\\n        if (vectorOffset == 0) {\\r\\n          return tex1.xyz;\\r\\n        } else if (vectorOffset == 1) {\\r\\n          return tex1.yzw;\\r\\n        } else {\\r\\n          readX++;\\r\\n          if (readX >= texSize.x) {\\r\\n            readX = 0;\\r\\n            readY++;\\r\\n          }\\r\\n          vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));\\r\\n          if (vectorOffset == 2) {\\r\\n            return vec3(tex1.z, tex1.w, tex2.x);\\r\\n          } else {\\r\\n            return vec3(tex1.w, tex2.x, tex2.y);\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        return getImage2D(tex, texSize, texDim, z, y, x);\\r\\n      }\\r\\n      \\r\\n      vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {\\r\\n        int index = x + texDim.x * (y + texDim.y * z);\\r\\n        int channel = integerMod(index, 2);\\r\\n        int w = texSize.x;\\r\\n        vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;\\r\\n        vec4 texel = texture(tex, st / vec2(texSize));\\r\\n        return vec4(texel.r, texel.g, texel.b, texel.a);\\r\\n      }\\r\\n      \\r\\n      vec4 actualColor;\\r\\n      void color(float r, float g, float b, float a) {\\r\\n        actualColor = vec4(r,g,b,a);\\r\\n      }\\r\\n      \\r\\n      void color(float r, float g, float b) {\\r\\n        color(r,g,b,1.0);\\r\\n      }\\r\\n      \\r\\n      float modulo(float number, float divisor) {\\r\\n        if (number < 0.0) {\\r\\n          number = abs(number);\\r\\n          if (divisor < 0.0) {\\r\\n            divisor = abs(divisor);\\r\\n          }\\r\\n          return -mod(number, divisor);\\r\\n        }\\r\\n        if (divisor < 0.0) {\\r\\n          divisor = abs(divisor);\\r\\n        }\\r\\n        return mod(number, divisor);\\r\\n      }\\r\\n      \\r\\n      __INJECTED_NATIVE__;\\r\\n      __MAIN_CONSTANTS__;\\r\\n      __MAIN_ARGUMENTS__;\\r\\n      __KERNEL__;\\r\\n      \\r\\n      void main(void) {\\r\\n        index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;\\r\\n        __MAIN_RESULT__;\\r\\n      }`;\\r\\n      \\r\\n      module.exports = {\\r\\n        fragmentShader\\r\\n      };\\r\\n      },{}],73:[function(require,module,exports){\\r\\n      const { utils } = require('../../utils');\\r\\n      const { WebGLFunctionNode } = require('../web-gl/function-node');\\r\\n      \\r\\n      class WebGL2FunctionNode extends WebGLFunctionNode {\\r\\n      \\r\\n        astIdentifierExpression(idtNode, retArr) {\\r\\n          if (idtNode.type !== 'Identifier') {\\r\\n            throw this.astErrorOutput(\\r\\n              'IdentifierExpression - not an Identifier',\\r\\n              idtNode\\r\\n            );\\r\\n          }\\r\\n      \\r\\n          const type = this.getType(idtNode);\\r\\n      \\r\\n          const name = utils.sanitizeName(idtNode.name);\\r\\n          if (idtNode.name === 'Infinity') {\\r\\n            retArr.push('intBitsToFloat(2139095039)');\\r\\n          } else if (type === 'Boolean') {\\r\\n            if (this.argumentNames.indexOf(name) > -1) {\\r\\n              retArr.push(`bool(user_${name})`);\\r\\n            } else {\\r\\n              retArr.push(`user_${name}`);\\r\\n            }\\r\\n          } else {\\r\\n            retArr.push(`user_${name}`);\\r\\n          }\\r\\n      \\r\\n          return retArr;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2FunctionNode\\r\\n      };\\r\\n      },{\\\"../../utils\\\":114,\\\"../web-gl/function-node\\\":38}],74:[function(require,module,exports){\\r\\n      const { WebGL2KernelValueBoolean } = require('./kernel-value/boolean');\\r\\n      const { WebGL2KernelValueFloat } = require('./kernel-value/float');\\r\\n      const { WebGL2KernelValueInteger } = require('./kernel-value/integer');\\r\\n      \\r\\n      const { WebGL2KernelValueHTMLImage } = require('./kernel-value/html-image');\\r\\n      const { WebGL2KernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');\\r\\n      \\r\\n      const { WebGL2KernelValueHTMLImageArray } = require('./kernel-value/html-image-array');\\r\\n      const { WebGL2KernelValueDynamicHTMLImageArray } = require('./kernel-value/dynamic-html-image-array');\\r\\n      \\r\\n      const { WebGL2KernelValueHTMLVideo } = require('./kernel-value/html-video');\\r\\n      const { WebGL2KernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');\\r\\n      \\r\\n      const { WebGL2KernelValueSingleInput } = require('./kernel-value/single-input');\\r\\n      const { WebGL2KernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');\\r\\n      \\r\\n      const { WebGL2KernelValueUnsignedInput } = require('./kernel-value/unsigned-input');\\r\\n      const { WebGL2KernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');\\r\\n      \\r\\n      const { WebGL2KernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');\\r\\n      const { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');\\r\\n      \\r\\n      const { WebGL2KernelValueNumberTexture } = require('./kernel-value/number-texture');\\r\\n      const { WebGL2KernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');\\r\\n      \\r\\n      const { WebGL2KernelValueSingleArray } = require('./kernel-value/single-array');\\r\\n      const { WebGL2KernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');\\r\\n      \\r\\n      const { WebGL2KernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');\\r\\n      const { WebGL2KernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');\\r\\n      \\r\\n      const { WebGL2KernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');\\r\\n      const { WebGL2KernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');\\r\\n      \\r\\n      const { WebGL2KernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');\\r\\n      const { WebGL2KernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');\\r\\n      \\r\\n      const { WebGL2KernelValueSingleArray2 } = require('./kernel-value/single-array2');\\r\\n      const { WebGL2KernelValueSingleArray3 } = require('./kernel-value/single-array3');\\r\\n      const { WebGL2KernelValueSingleArray4 } = require('./kernel-value/single-array4');\\r\\n      \\r\\n      const { WebGL2KernelValueUnsignedArray } = require('./kernel-value/unsigned-array');\\r\\n      const { WebGL2KernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');\\r\\n      \\r\\n      const kernelValueMaps = {\\r\\n        unsigned: {\\r\\n          dynamic: {\\r\\n            'Boolean': WebGL2KernelValueBoolean,\\r\\n            'Integer': WebGL2KernelValueInteger,\\r\\n            'Float': WebGL2KernelValueFloat,\\r\\n            'Array': WebGL2KernelValueDynamicUnsignedArray,\\r\\n            'Array(2)': false,\\r\\n            'Array(3)': false,\\r\\n            'Array(4)': false,\\r\\n            'Array1D(2)': false,\\r\\n            'Array1D(3)': false,\\r\\n            'Array1D(4)': false,\\r\\n            'Array2D(2)': false,\\r\\n            'Array2D(3)': false,\\r\\n            'Array2D(4)': false,\\r\\n            'Array3D(2)': false,\\r\\n            'Array3D(3)': false,\\r\\n            'Array3D(4)': false,\\r\\n            'Input': WebGL2KernelValueDynamicUnsignedInput,\\r\\n            'NumberTexture': WebGL2KernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,\\r\\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,\\r\\n            'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,\\r\\n            'HTMLImage': WebGL2KernelValueDynamicHTMLImage,\\r\\n            'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,\\r\\n            'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,\\r\\n          },\\r\\n          static: {\\r\\n            'Boolean': WebGL2KernelValueBoolean,\\r\\n            'Float': WebGL2KernelValueFloat,\\r\\n            'Integer': WebGL2KernelValueInteger,\\r\\n            'Array': WebGL2KernelValueUnsignedArray,\\r\\n            'Array(2)': false,\\r\\n            'Array(3)': false,\\r\\n            'Array(4)': false,\\r\\n            'Array1D(2)': false,\\r\\n            'Array1D(3)': false,\\r\\n            'Array1D(4)': false,\\r\\n            'Array2D(2)': false,\\r\\n            'Array2D(3)': false,\\r\\n            'Array2D(4)': false,\\r\\n            'Array3D(2)': false,\\r\\n            'Array3D(3)': false,\\r\\n            'Array3D(4)': false,\\r\\n            'Input': WebGL2KernelValueUnsignedInput,\\r\\n            'NumberTexture': WebGL2KernelValueNumberTexture,\\r\\n            'ArrayTexture(1)': WebGL2KernelValueNumberTexture,\\r\\n            'ArrayTexture(2)': WebGL2KernelValueNumberTexture,\\r\\n            'ArrayTexture(3)': WebGL2KernelValueNumberTexture,\\r\\n            'ArrayTexture(4)': WebGL2KernelValueNumberTexture,\\r\\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,\\r\\n            'HTMLCanvas': WebGL2KernelValueHTMLImage,\\r\\n            'HTMLImage': WebGL2KernelValueHTMLImage,\\r\\n            'HTMLImageArray': WebGL2KernelValueHTMLImageArray,\\r\\n            'HTMLVideo': WebGL2KernelValueHTMLVideo,\\r\\n          }\\r\\n        },\\r\\n        single: {\\r\\n          dynamic: {\\r\\n            'Boolean': WebGL2KernelValueBoolean,\\r\\n            'Integer': WebGL2KernelValueInteger,\\r\\n            'Float': WebGL2KernelValueFloat,\\r\\n            'Array': WebGL2KernelValueDynamicSingleArray,\\r\\n            'Array(2)': WebGL2KernelValueSingleArray2,\\r\\n            'Array(3)': WebGL2KernelValueSingleArray3,\\r\\n            'Array(4)': WebGL2KernelValueSingleArray4,\\r\\n            'Array1D(2)': WebGL2KernelValueDynamicSingleArray1DI,\\r\\n            'Array1D(3)': WebGL2KernelValueDynamicSingleArray1DI,\\r\\n            'Array1D(4)': WebGL2KernelValueDynamicSingleArray1DI,\\r\\n            'Array2D(2)': WebGL2KernelValueDynamicSingleArray2DI,\\r\\n            'Array2D(3)': WebGL2KernelValueDynamicSingleArray2DI,\\r\\n            'Array2D(4)': WebGL2KernelValueDynamicSingleArray2DI,\\r\\n            'Array3D(2)': WebGL2KernelValueDynamicSingleArray3DI,\\r\\n            'Array3D(3)': WebGL2KernelValueDynamicSingleArray3DI,\\r\\n            'Array3D(4)': WebGL2KernelValueDynamicSingleArray3DI,\\r\\n            'Input': WebGL2KernelValueDynamicSingleInput,\\r\\n            'NumberTexture': WebGL2KernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,\\r\\n            'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,\\r\\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,\\r\\n            'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,\\r\\n            'HTMLImage': WebGL2KernelValueDynamicHTMLImage,\\r\\n            'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,\\r\\n            'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,\\r\\n          },\\r\\n          static: {\\r\\n            'Boolean': WebGL2KernelValueBoolean,\\r\\n            'Float': WebGL2KernelValueFloat,\\r\\n            'Integer': WebGL2KernelValueInteger,\\r\\n            'Array': WebGL2KernelValueSingleArray,\\r\\n            'Array(2)': WebGL2KernelValueSingleArray2,\\r\\n            'Array(3)': WebGL2KernelValueSingleArray3,\\r\\n            'Array(4)': WebGL2KernelValueSingleArray4,\\r\\n            'Array1D(2)': WebGL2KernelValueSingleArray1DI,\\r\\n            'Array1D(3)': WebGL2KernelValueSingleArray1DI,\\r\\n            'Array1D(4)': WebGL2KernelValueSingleArray1DI,\\r\\n            'Array2D(2)': WebGL2KernelValueSingleArray2DI,\\r\\n            'Array2D(3)': WebGL2KernelValueSingleArray2DI,\\r\\n            'Array2D(4)': WebGL2KernelValueSingleArray2DI,\\r\\n            'Array3D(2)': WebGL2KernelValueSingleArray3DI,\\r\\n            'Array3D(3)': WebGL2KernelValueSingleArray3DI,\\r\\n            'Array3D(4)': WebGL2KernelValueSingleArray3DI,\\r\\n            'Input': WebGL2KernelValueSingleInput,\\r\\n            'NumberTexture': WebGL2KernelValueNumberTexture,\\r\\n            'ArrayTexture(1)': WebGL2KernelValueNumberTexture,\\r\\n            'ArrayTexture(2)': WebGL2KernelValueNumberTexture,\\r\\n            'ArrayTexture(3)': WebGL2KernelValueNumberTexture,\\r\\n            'ArrayTexture(4)': WebGL2KernelValueNumberTexture,\\r\\n            'MemoryOptimizedNumberTexture': WebGL2KernelValueMemoryOptimizedNumberTexture,\\r\\n            'HTMLCanvas': WebGL2KernelValueHTMLImage,\\r\\n            'HTMLImage': WebGL2KernelValueHTMLImage,\\r\\n            'HTMLImageArray': WebGL2KernelValueHTMLImageArray,\\r\\n            'HTMLVideo': WebGL2KernelValueHTMLVideo,\\r\\n          }\\r\\n        },\\r\\n      };\\r\\n      \\r\\n      function lookupKernelValueType(type, dynamic, precision, value) {\\r\\n        if (!type) {\\r\\n          throw new Error('type missing');\\r\\n        }\\r\\n        if (!dynamic) {\\r\\n          throw new Error('dynamic missing');\\r\\n        }\\r\\n        if (!precision) {\\r\\n          throw new Error('precision missing');\\r\\n        }\\r\\n        if (value.type) {\\r\\n          type = value.type;\\r\\n        }\\r\\n        const types = kernelValueMaps[precision][dynamic];\\r\\n        if (types[type] === false) {\\r\\n          return null;\\r\\n        } else if (types[type] === undefined) {\\r\\n          throw new Error(`Could not find a KernelValue for ${ type }`);\\r\\n        }\\r\\n        return types[type];\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        kernelValueMaps,\\r\\n        lookupKernelValueType\\r\\n      };\\r\\n      },{\\\"./kernel-value/boolean\\\":75,\\\"./kernel-value/dynamic-html-image\\\":77,\\\"./kernel-value/dynamic-html-image-array\\\":76,\\\"./kernel-value/dynamic-html-video\\\":78,\\\"./kernel-value/dynamic-memory-optimized-number-texture\\\":79,\\\"./kernel-value/dynamic-number-texture\\\":80,\\\"./kernel-value/dynamic-single-array\\\":81,\\\"./kernel-value/dynamic-single-array1d-i\\\":82,\\\"./kernel-value/dynamic-single-array2d-i\\\":83,\\\"./kernel-value/dynamic-single-array3d-i\\\":84,\\\"./kernel-value/dynamic-single-input\\\":85,\\\"./kernel-value/dynamic-unsigned-array\\\":86,\\\"./kernel-value/dynamic-unsigned-input\\\":87,\\\"./kernel-value/float\\\":88,\\\"./kernel-value/html-image\\\":90,\\\"./kernel-value/html-image-array\\\":89,\\\"./kernel-value/html-video\\\":91,\\\"./kernel-value/integer\\\":92,\\\"./kernel-value/memory-optimized-number-texture\\\":93,\\\"./kernel-value/number-texture\\\":94,\\\"./kernel-value/single-array\\\":95,\\\"./kernel-value/single-array1d-i\\\":96,\\\"./kernel-value/single-array2\\\":97,\\\"./kernel-value/single-array2d-i\\\":98,\\\"./kernel-value/single-array3\\\":99,\\\"./kernel-value/single-array3d-i\\\":100,\\\"./kernel-value/single-array4\\\":101,\\\"./kernel-value/single-input\\\":102,\\\"./kernel-value/unsigned-array\\\":103,\\\"./kernel-value/unsigned-input\\\":104}],75:[function(require,module,exports){\\r\\n      const { WebGLKernelValueBoolean } = require('../../web-gl/kernel-value/boolean');\\r\\n      \\r\\n      class WebGL2KernelValueBoolean extends WebGLKernelValueBoolean {}\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueBoolean\\r\\n      };\\r\\n      },{\\\"../../web-gl/kernel-value/boolean\\\":41}],76:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGL2KernelValueHTMLImageArray } = require('./html-image-array');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicHTMLImageArray extends WebGL2KernelValueHTMLImageArray {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2DArray ${this.id}`,\\r\\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\\r\\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(images) {\\r\\n          const { width, height } = images[0];\\r\\n          this.checkSize(width, height);\\r\\n          this.dimensions = [width, height, images.length];\\r\\n          this.textureSize = [width, height];\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(images);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicHTMLImageArray\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./html-image-array\\\":89}],77:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueDynamicHTMLImage } = require('../../web-gl/kernel-value/dynamic-html-image');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicHTMLImage extends WebGLKernelValueDynamicHTMLImage {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\\r\\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicHTMLImage\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/dynamic-html-image\\\":42}],78:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGL2KernelValueDynamicHTMLImage } = require('./dynamic-html-image');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicHTMLVideo extends WebGL2KernelValueDynamicHTMLImage {}\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicHTMLVideo\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./dynamic-html-image\\\":77}],79:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/dynamic-memory-optimized-number-texture');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueDynamicMemoryOptimizedNumberTexture {\\r\\n        getSource() {\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${this.id}`,\\r\\n            `uniform ivec2 ${this.sizeId}`,\\r\\n            `uniform ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicMemoryOptimizedNumberTexture\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture\\\":44}],80:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueDynamicNumberTexture } = require('../../web-gl/kernel-value/dynamic-number-texture');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicNumberTexture extends WebGLKernelValueDynamicNumberTexture {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\\r\\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicNumberTexture\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/dynamic-number-texture\\\":45}],81:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGL2KernelValueSingleArray } = require('../../web-gl2/kernel-value/single-array');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicSingleArray extends WebGL2KernelValueSingleArray {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\\r\\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          this.dimensions = utils.getDimensions(value, true);\\r\\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicSingleArray\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl2/kernel-value/single-array\\\":95}],82:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGL2KernelValueSingleArray1DI } = require('../../web-gl2/kernel-value/single-array1d-i');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicSingleArray1DI extends WebGL2KernelValueSingleArray1DI {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\\r\\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          this.setShape(value);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicSingleArray1DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl2/kernel-value/single-array1d-i\\\":96}],83:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGL2KernelValueSingleArray2DI } = require('../../web-gl2/kernel-value/single-array2d-i');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicSingleArray2DI extends WebGL2KernelValueSingleArray2DI {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\\r\\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          this.setShape(value);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicSingleArray2DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl2/kernel-value/single-array2d-i\\\":98}],84:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGL2KernelValueSingleArray3DI } = require('../../web-gl2/kernel-value/single-array3d-i');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicSingleArray3DI extends WebGL2KernelValueSingleArray3DI {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\\r\\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          this.setShape(value);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicSingleArray3DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl2/kernel-value/single-array3d-i\\\":100}],85:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGL2KernelValueSingleInput } = require('../../web-gl2/kernel-value/single-input');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicSingleInput extends WebGL2KernelValueSingleInput {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\\r\\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          let [w, h, d] = value.size;\\r\\n          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);\\r\\n          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);\\r\\n          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;\\r\\n          this.checkSize(this.textureSize[0], this.textureSize[1]);\\r\\n          this.uploadValue = new Float32Array(this.uploadArrayLength);\\r\\n          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);\\r\\n          this.kernel.setUniform2iv(this.sizeId, this.textureSize);\\r\\n          super.updateValue(value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicSingleInput\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl2/kernel-value/single-input\\\":102}],86:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueDynamicUnsignedArray } = require('../../web-gl/kernel-value/dynamic-unsigned-array');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicUnsignedArray extends WebGLKernelValueDynamicUnsignedArray {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\\r\\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicUnsignedArray\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/dynamic-unsigned-array\\\":51}],87:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueDynamicUnsignedInput } = require('../../web-gl/kernel-value/dynamic-unsigned-input');\\r\\n      \\r\\n      class WebGL2KernelValueDynamicUnsignedInput extends WebGLKernelValueDynamicUnsignedInput {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,\\r\\n            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,\\r\\n          ]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueDynamicUnsignedInput\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/dynamic-unsigned-input\\\":52}],88:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueFloat } = require('../../web-gl/kernel-value/float');\\r\\n      \\r\\n      class WebGL2KernelValueFloat extends WebGLKernelValueFloat {}\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueFloat\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/float\\\":53}],89:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelArray } = require('../../web-gl/kernel-value/array');\\r\\n      \\r\\n      class WebGL2KernelValueHTMLImageArray extends WebGLKernelArray {\\r\\n        constructor(value, settings) {\\r\\n          super(value, settings);\\r\\n          this.checkSize(value[0].width, value[0].height);\\r\\n          this.dimensions = [value[0].width, value[0].height, value.length];\\r\\n          this.textureSize = [value[0].width, value[0].height];\\r\\n        }\\r\\n        defineTexture() {\\r\\n          const { context: gl } = this;\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);\\r\\n          gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\r\\n          gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\r\\n        }\\r\\n      \\r\\n        getStringValueHandler() {\\r\\n          return `const uploadValue_${this.name} = ${this.varName};\\\\n`;\\r\\n        }\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2DArray ${this.id}`,\\r\\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(images) {\\r\\n          const { context: gl } = this;\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\\r\\n          gl.texImage3D(\\r\\n            gl.TEXTURE_2D_ARRAY,\\r\\n            0,\\r\\n            gl.RGBA,\\r\\n            images[0].width,\\r\\n            images[0].height,\\r\\n            images.length,\\r\\n            0,\\r\\n            gl.RGBA,\\r\\n            gl.UNSIGNED_BYTE,\\r\\n            null\\r\\n          );\\r\\n          for (let i = 0; i < images.length; i++) {\\r\\n            const xOffset = 0;\\r\\n            const yOffset = 0;\\r\\n            const imageDepth = 1;\\r\\n            gl.texSubImage3D(\\r\\n              gl.TEXTURE_2D_ARRAY,\\r\\n              0,\\r\\n              xOffset,\\r\\n              yOffset,\\r\\n              i,\\r\\n              images[i].width,\\r\\n              images[i].height,\\r\\n              imageDepth,\\r\\n              gl.RGBA,\\r\\n              gl.UNSIGNED_BYTE,\\r\\n              this.uploadValue = images[i]\\r\\n            );\\r\\n          }\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueHTMLImageArray\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/array\\\":40}],90:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueHTMLImage } = require('../../web-gl/kernel-value/html-image');\\r\\n      \\r\\n      class WebGL2KernelValueHTMLImage extends WebGLKernelValueHTMLImage {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueHTMLImage\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/html-image\\\":54}],91:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGL2KernelValueHTMLImage } = require('./html-image');\\r\\n      \\r\\n      class WebGL2KernelValueHTMLVideo extends WebGL2KernelValueHTMLImage {}\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueHTMLVideo\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"./html-image\\\":90}],92:[function(require,module,exports){\\r\\n      const { WebGLKernelValueInteger } = require('../../web-gl/kernel-value/integer');\\r\\n      \\r\\n      class WebGL2KernelValueInteger extends WebGLKernelValueInteger {\\r\\n        getSource(value) {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          if (this.origin === 'constants') {\\r\\n            return `const ${ variablePrecision } int ${this.id} = ${ parseInt(value) };\\\\n`;\\r\\n          }\\r\\n          return `uniform ${ variablePrecision } int ${this.id};\\\\n`;\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (this.origin === 'constants') return;\\r\\n          this.kernel.setUniform1i(this.id, this.uploadValue = value);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueInteger\\r\\n      };\\r\\n      },{\\\"../../web-gl/kernel-value/integer\\\":57}],93:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/memory-optimized-number-texture');\\r\\n      \\r\\n      class WebGL2KernelValueMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {\\r\\n        getSource() {\\r\\n          const { id, sizeId, textureSize, dimensionsId, dimensions } = this;\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform sampler2D ${id}`,\\r\\n            `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,\\r\\n            `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueMemoryOptimizedNumberTexture\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/memory-optimized-number-texture\\\":58}],94:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueNumberTexture } = require('../../web-gl/kernel-value/number-texture');\\r\\n      \\r\\n      class WebGL2KernelValueNumberTexture extends WebGLKernelValueNumberTexture {\\r\\n        getSource() {\\r\\n          const { id, sizeId, textureSize, dimensionsId, dimensions } = this;\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${id}`,\\r\\n            `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,\\r\\n            `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueNumberTexture\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/number-texture\\\":59}],95:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueSingleArray } = require('../../web-gl/kernel-value/single-array');\\r\\n      \\r\\n      class WebGL2KernelValueSingleArray extends WebGLKernelValueSingleArray {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(value) {\\r\\n          if (value.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(value.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          utils.flattenTo(value, this.uploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueSingleArray\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/single-array\\\":60}],96:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueSingleArray1DI } = require('../../web-gl/kernel-value/single-array1d-i');\\r\\n      \\r\\n      class WebGL2KernelValueSingleArray1DI extends WebGLKernelValueSingleArray1DI {\\r\\n        updateValue(value) {\\r\\n          if (value.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(value.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          utils.flattenTo(value, this.uploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueSingleArray1DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/single-array1d-i\\\":61}],97:[function(require,module,exports){\\r\\n      const { WebGLKernelValueSingleArray2 } = require('../../web-gl/kernel-value/single-array2');\\r\\n      \\r\\n      class WebGL2KernelValueSingleArray2 extends WebGLKernelValueSingleArray2 {}\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueSingleArray2\\r\\n      };\\r\\n      },{\\\"../../web-gl/kernel-value/single-array2\\\":62}],98:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueSingleArray2DI } = require('../../web-gl/kernel-value/single-array2d-i');\\r\\n      \\r\\n      class WebGL2KernelValueSingleArray2DI extends WebGLKernelValueSingleArray2DI {\\r\\n        updateValue(value) {\\r\\n          if (value.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(value.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          utils.flattenTo(value, this.uploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueSingleArray2DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/single-array2d-i\\\":63}],99:[function(require,module,exports){\\r\\n      const { WebGLKernelValueSingleArray3 } = require('../../web-gl/kernel-value/single-array3');\\r\\n      \\r\\n      class WebGL2KernelValueSingleArray3 extends WebGLKernelValueSingleArray3 {}\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueSingleArray3\\r\\n      };\\r\\n      },{\\\"../../web-gl/kernel-value/single-array3\\\":64}],100:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueSingleArray3DI } = require('../../web-gl/kernel-value/single-array3d-i');\\r\\n      \\r\\n      class WebGL2KernelValueSingleArray3DI extends WebGLKernelValueSingleArray3DI {\\r\\n        updateValue(value) {\\r\\n          if (value.constructor !== this.initialValueConstructor) {\\r\\n            this.onUpdateValueMismatch(value.constructor);\\r\\n            return;\\r\\n          }\\r\\n          const { context: gl } = this;\\r\\n          utils.flattenTo(value, this.uploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueSingleArray3DI\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/single-array3d-i\\\":65}],101:[function(require,module,exports){\\r\\n      const { WebGLKernelValueSingleArray4 } = require('../../web-gl/kernel-value/single-array4');\\r\\n      \\r\\n      class WebGL2KernelValueSingleArray4 extends WebGLKernelValueSingleArray4 {}\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueSingleArray4\\r\\n      };\\r\\n      },{\\\"../../web-gl/kernel-value/single-array4\\\":66}],102:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueSingleInput } = require('../../web-gl/kernel-value/single-input');\\r\\n      \\r\\n      class WebGL2KernelValueSingleInput extends WebGLKernelValueSingleInput {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        updateValue(input) {\\r\\n          const { context: gl } = this;\\r\\n          utils.flattenTo(input.value, this.uploadValue);\\r\\n          gl.activeTexture(this.contextHandle);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\\r\\n          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\\r\\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);\\r\\n          this.kernel.setUniform1i(this.id, this.index);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueSingleInput\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/single-input\\\":67}],103:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueUnsignedArray } = require('../../web-gl/kernel-value/unsigned-array');\\r\\n      \\r\\n      class WebGL2KernelValueUnsignedArray extends WebGLKernelValueUnsignedArray {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueUnsignedArray\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/unsigned-array\\\":68}],104:[function(require,module,exports){\\r\\n      const { utils } = require('../../../utils');\\r\\n      const { WebGLKernelValueUnsignedInput } = require('../../web-gl/kernel-value/unsigned-input');\\r\\n      \\r\\n      class WebGL2KernelValueUnsignedInput extends WebGLKernelValueUnsignedInput {\\r\\n        getSource() {\\r\\n          const variablePrecision = this.getVariablePrecisionString();\\r\\n          return utils.linesToString([\\r\\n            `uniform ${ variablePrecision } sampler2D ${this.id}`,\\r\\n            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,\\r\\n            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,\\r\\n          ]);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2KernelValueUnsignedInput\\r\\n      };\\r\\n      },{\\\"../../../utils\\\":114,\\\"../../web-gl/kernel-value/unsigned-input\\\":69}],105:[function(require,module,exports){\\r\\n      const { WebGLKernel } = require('../web-gl/kernel');\\r\\n      const { WebGL2FunctionNode } = require('./function-node');\\r\\n      const { FunctionBuilder } = require('../function-builder');\\r\\n      const { utils } = require('../../utils');\\r\\n      const { fragmentShader } = require('./fragment-shader');\\r\\n      const { vertexShader } = require('./vertex-shader');\\r\\n      const { lookupKernelValueType } = require('./kernel-value-maps');\\r\\n      \\r\\n      let isSupported = null;\\r\\n      let testCanvas = null;\\r\\n      let testContext = null;\\r\\n      let testExtensions = null;\\r\\n      \\r\\n      let features = null;\\r\\n      \\r\\n      class WebGL2Kernel extends WebGLKernel {\\r\\n        static get isSupported() {\\r\\n          if (isSupported !== null) {\\r\\n            return isSupported;\\r\\n          }\\r\\n          this.setupFeatureChecks();\\r\\n          isSupported = this.isContextMatch(testContext);\\r\\n          return isSupported;\\r\\n        }\\r\\n      \\r\\n        static setupFeatureChecks() {\\r\\n          if (typeof document !== 'undefined') {\\r\\n            testCanvas = document.createElement('canvas');\\r\\n          } else if (typeof OffscreenCanvas !== 'undefined') {\\r\\n            testCanvas = new OffscreenCanvas(0, 0);\\r\\n          }\\r\\n          if (!testCanvas) return;\\r\\n          testContext = testCanvas.getContext('webgl2');\\r\\n          if (!testContext || !testContext.getExtension) return;\\r\\n          testExtensions = {\\r\\n            EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),\\r\\n            OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),\\r\\n          };\\r\\n          features = this.getFeatures();\\r\\n        }\\r\\n      \\r\\n        static isContextMatch(context) {\\r\\n          if (typeof WebGL2RenderingContext !== 'undefined') {\\r\\n            return context instanceof WebGL2RenderingContext;\\r\\n          }\\r\\n          return false;\\r\\n        }\\r\\n      \\r\\n        static getFeatures() {\\r\\n          const gl = this.testContext;\\r\\n          return Object.freeze({\\r\\n            isFloatRead: this.getIsFloatRead(),\\r\\n            isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),\\r\\n            isSpeedTacticSupported: this.getIsSpeedTacticSupported(),\\r\\n            kernelMap: true,\\r\\n            isTextureFloat: true,\\r\\n            isDrawBuffers: true,\\r\\n            channelCount: this.getChannelCount(),\\r\\n            maxTextureSize: this.getMaxTextureSize(),\\r\\n            lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),\\r\\n            lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),\\r\\n            mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),\\r\\n            mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),\\r\\n            highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),\\r\\n            highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),\\r\\n          });\\r\\n        }\\r\\n      \\r\\n        static getIsTextureFloat() {\\r\\n          return true;\\r\\n        }\\r\\n      \\r\\n        static getChannelCount() {\\r\\n          return testContext.getParameter(testContext.MAX_DRAW_BUFFERS);\\r\\n        }\\r\\n      \\r\\n        static getMaxTextureSize() {\\r\\n          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);\\r\\n        }\\r\\n      \\r\\n        static lookupKernelValueType(type, dynamic, precision, value) {\\r\\n          return lookupKernelValueType(type, dynamic, precision, value);\\r\\n        }\\r\\n      \\r\\n        static get testCanvas() {\\r\\n          return testCanvas;\\r\\n        }\\r\\n      \\r\\n        static get testContext() {\\r\\n          return testContext;\\r\\n        }\\r\\n      \\r\\n        static get features() {\\r\\n          return features;\\r\\n        }\\r\\n      \\r\\n        static get fragmentShader() {\\r\\n          return fragmentShader;\\r\\n        }\\r\\n        static get vertexShader() {\\r\\n          return vertexShader;\\r\\n        }\\r\\n      \\r\\n        initContext() {\\r\\n          const settings = {\\r\\n            alpha: false,\\r\\n            depth: false,\\r\\n            antialias: false\\r\\n          };\\r\\n          return this.canvas.getContext('webgl2', settings);\\r\\n        }\\r\\n      \\r\\n        initExtensions() {\\r\\n          this.extensions = {\\r\\n            EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),\\r\\n            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),\\r\\n          };\\r\\n        }\\r\\n      \\r\\n        validateSettings(args) {\\r\\n          if (!this.validate) {\\r\\n            this.texSize = utils.getKernelTextureSize({\\r\\n              optimizeFloatMemory: this.optimizeFloatMemory,\\r\\n              precision: this.precision,\\r\\n            }, this.output);\\r\\n            return;\\r\\n          }\\r\\n      \\r\\n          const { features } = this.constructor;\\r\\n          if (this.precision === 'single' && !features.isFloatRead) {\\r\\n            throw new Error('Float texture outputs are not supported');\\r\\n          } else if (!this.graphical && this.precision === null) {\\r\\n            this.precision = features.isFloatRead ? 'single' : 'unsigned';\\r\\n          }\\r\\n      \\r\\n          if (this.fixIntegerDivisionAccuracy === null) {\\r\\n            this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;\\r\\n          } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {\\r\\n            this.fixIntegerDivisionAccuracy = false;\\r\\n          }\\r\\n      \\r\\n          this.checkOutput();\\r\\n      \\r\\n          if (!this.output || this.output.length === 0) {\\r\\n            if (args.length !== 1) {\\r\\n              throw new Error('Auto output only supported for kernels with only one input');\\r\\n            }\\r\\n      \\r\\n            const argType = utils.getVariableType(args[0], this.strictIntegers);\\r\\n            switch (argType) {\\r\\n              case 'Array':\\r\\n                this.output = utils.getDimensions(argType);\\r\\n                break;\\r\\n              case 'NumberTexture':\\r\\n              case 'MemoryOptimizedNumberTexture':\\r\\n              case 'ArrayTexture(1)':\\r\\n              case 'ArrayTexture(2)':\\r\\n              case 'ArrayTexture(3)':\\r\\n              case 'ArrayTexture(4)':\\r\\n                this.output = args[0].output;\\r\\n                break;\\r\\n              default:\\r\\n                throw new Error('Auto output not supported for input type: ' + argType);\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          if (this.graphical) {\\r\\n            if (this.output.length !== 2) {\\r\\n              throw new Error('Output must have 2 dimensions on graphical mode');\\r\\n            }\\r\\n      \\r\\n            if (this.precision === 'single') {\\r\\n              console.warn('Cannot use graphical mode and single precision at the same time');\\r\\n              this.precision = 'unsigned';\\r\\n            }\\r\\n      \\r\\n            this.texSize = utils.clone(this.output);\\r\\n            return;\\r\\n          } else if (!this.graphical && this.precision === null && features.isTextureFloat) {\\r\\n            this.precision = 'single';\\r\\n          }\\r\\n      \\r\\n          this.texSize = utils.getKernelTextureSize({\\r\\n            optimizeFloatMemory: this.optimizeFloatMemory,\\r\\n            precision: this.precision,\\r\\n          }, this.output);\\r\\n      \\r\\n          this.checkTextureSize();\\r\\n        }\\r\\n      \\r\\n        translateSource() {\\r\\n          const functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {\\r\\n            fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy\\r\\n          });\\r\\n          this.translatedSource = functionBuilder.getPrototypeString('kernel');\\r\\n          this.setupReturnTypes(functionBuilder);\\r\\n        }\\r\\n      \\r\\n        drawBuffers() {\\r\\n          this.context.drawBuffers(this.drawBuffersMap);\\r\\n        }\\r\\n      \\r\\n        getTextureFormat() {\\r\\n          const { context: gl } = this;\\r\\n          switch (this.getInternalFormat()) {\\r\\n            case gl.R32F:\\r\\n              return gl.RED;\\r\\n            case gl.RG32F:\\r\\n              return gl.RG;\\r\\n            case gl.RGBA32F:\\r\\n              return gl.RGBA;\\r\\n            case gl.RGBA:\\r\\n              return gl.RGBA;\\r\\n            default:\\r\\n              throw new Error('Unknown internal format');\\r\\n          }\\r\\n        }\\r\\n        getInternalFormat() {\\r\\n          const { context: gl } = this;\\r\\n      \\r\\n          if (this.precision === 'single') {\\r\\n            if (this.pipeline) {\\r\\n              switch (this.returnType) {\\r\\n                case 'Number':\\r\\n                case 'Float':\\r\\n                case 'Integer':\\r\\n                  if (this.optimizeFloatMemory) {\\r\\n                    return gl.RGBA32F;\\r\\n                  } else {\\r\\n                    return gl.R32F;\\r\\n                  }\\r\\n                  case 'Array(2)':\\r\\n                    return gl.RG32F;\\r\\n                  case 'Array(3)': \\r\\n                  case 'Array(4)':\\r\\n                    return gl.RGBA32F;\\r\\n                  default:\\r\\n                    throw new Error('Unhandled return type');\\r\\n              }\\r\\n            }\\r\\n            return gl.RGBA32F;\\r\\n          }\\r\\n          return gl.RGBA;\\r\\n        }\\r\\n      \\r\\n        _setupOutputTexture() {\\r\\n          const gl = this.context;\\r\\n          if (this.texture) {\\r\\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);\\r\\n            return;\\r\\n          }\\r\\n          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);\\r\\n          const texture = gl.createTexture();\\r\\n          const texSize = this.texSize;\\r\\n          gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);\\r\\n          gl.bindTexture(gl.TEXTURE_2D, texture);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\r\\n          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\r\\n          const format = this.getInternalFormat();\\r\\n          if (this.precision === 'single') {\\r\\n            gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);\\r\\n          } else {\\r\\n            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);\\r\\n          }\\r\\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\\r\\n          this.texture = new this.TextureConstructor({\\r\\n            texture,\\r\\n            size: texSize,\\r\\n            dimensions: this.threadDim,\\r\\n            output: this.output,\\r\\n            context: this.context,\\r\\n            internalFormat: this.getInternalFormat(),\\r\\n            textureFormat: this.getTextureFormat(),\\r\\n            kernel: this,\\r\\n          });\\r\\n        }\\r\\n      \\r\\n        _setupSubOutputTextures() {\\r\\n          const gl = this.context;\\r\\n          if (this.mappedTextures) {\\r\\n            for (let i = 0; i < this.subKernels.length; i++) {\\r\\n              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);\\r\\n            }\\r\\n            return;\\r\\n          }\\r\\n          const texSize = this.texSize;\\r\\n          this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];\\r\\n          this.mappedTextures = [];\\r\\n          for (let i = 0; i < this.subKernels.length; i++) {\\r\\n            const texture = this.createTexture();\\r\\n            this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);\\r\\n            gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);\\r\\n            gl.bindTexture(gl.TEXTURE_2D, texture);\\r\\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\\r\\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\\r\\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\\r\\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\\r\\n            const format = this.getInternalFormat();\\r\\n            if (this.precision === 'single') {\\r\\n              gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);\\r\\n            } else {\\r\\n              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\\r\\n            }\\r\\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);\\r\\n      \\r\\n            this.mappedTextures.push(new this.TextureConstructor({\\r\\n              texture,\\r\\n              size: texSize,\\r\\n              dimensions: this.threadDim,\\r\\n              output: this.output,\\r\\n              context: this.context,\\r\\n              internalFormat: this.getInternalFormat(),\\r\\n              textureFormat: this.getTextureFormat(),\\r\\n              kernel: this,\\r\\n            }));\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        _getHeaderString() {\\r\\n          return '';\\r\\n        }\\r\\n      \\r\\n        _getTextureCoordinate() {\\r\\n          const subKernels = this.subKernels;\\r\\n          const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);\\r\\n          if (subKernels === null || subKernels.length < 1) {\\r\\n            return `in ${ variablePrecision } vec2 vTexCoord;\\\\n`;\\r\\n          } else {\\r\\n            return `out ${ variablePrecision } vec2 vTexCoord;\\\\n`;\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        _getMainArgumentsString(args) {\\r\\n          const result = [];\\r\\n          const argumentNames = this.argumentNames;\\r\\n          for (let i = 0; i < argumentNames.length; i++) {\\r\\n            result.push(this.kernelArguments[i].getSource(args[i]));\\r\\n          }\\r\\n          return result.join('');\\r\\n        }\\r\\n      \\r\\n        getKernelString() {\\r\\n          const result = [this.getKernelResultDeclaration()];\\r\\n          const subKernels = this.subKernels;\\r\\n          if (subKernels !== null) {\\r\\n            result.push(\\r\\n              'layout(location = 0) out vec4 data0'\\r\\n            );\\r\\n            switch (this.returnType) {\\r\\n              case 'Number':\\r\\n              case 'Float':\\r\\n              case 'Integer':\\r\\n                for (let i = 0; i < subKernels.length; i++) {\\r\\n                  const subKernel = subKernels[i];\\r\\n                  result.push(\\r\\n                    subKernel.returnType === 'Integer' ?\\r\\n                    `int subKernelResult_${ subKernel.name } = 0` :\\r\\n                    `float subKernelResult_${ subKernel.name } = 0.0`,\\r\\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\\r\\n                  );\\r\\n                }\\r\\n                break;\\r\\n              case 'Array(2)':\\r\\n                for (let i = 0; i < subKernels.length; i++) {\\r\\n                  result.push(\\r\\n                    `vec2 subKernelResult_${ subKernels[i].name }`,\\r\\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\\r\\n                  );\\r\\n                }\\r\\n                break;\\r\\n              case 'Array(3)':\\r\\n                for (let i = 0; i < subKernels.length; i++) {\\r\\n                  result.push(\\r\\n                    `vec3 subKernelResult_${ subKernels[i].name }`,\\r\\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\\r\\n                  );\\r\\n                }\\r\\n                break;\\r\\n              case 'Array(4)':\\r\\n                for (let i = 0; i < subKernels.length; i++) {\\r\\n                  result.push(\\r\\n                    `vec4 subKernelResult_${ subKernels[i].name }`,\\r\\n                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`\\r\\n                  );\\r\\n                }\\r\\n                break;\\r\\n            }\\r\\n          } else {\\r\\n            result.push(\\r\\n              'out vec4 data0'\\r\\n            );\\r\\n          }\\r\\n      \\r\\n          return utils.linesToString(result) + this.translatedSource;\\r\\n        }\\r\\n      \\r\\n        getMainResultGraphical() {\\r\\n          return utils.linesToString([\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            '  data0 = actualColor',\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        getMainResultPackedPixels() {\\r\\n          switch (this.returnType) {\\r\\n            case 'LiteralInteger':\\r\\n            case 'Number':\\r\\n            case 'Integer':\\r\\n            case 'Float':\\r\\n              return this.getMainResultKernelPackedPixels() +\\r\\n                this.getMainResultSubKernelPackedPixels();\\r\\n            default:\\r\\n              throw new Error(`packed output only usable with Numbers, \\\"${this.returnType}\\\" specified`);\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelPackedPixels() {\\r\\n          return utils.linesToString([\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            `  data0 = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`\\r\\n          ]);\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelPackedPixels() {\\r\\n          const result = [];\\r\\n          if (!this.subKernels) return '';\\r\\n          for (let i = 0; i < this.subKernels.length; i++) {\\r\\n            const subKernel = this.subKernels[i];\\r\\n            if (subKernel.returnType === 'Integer') {\\r\\n              result.push(\\r\\n                `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`\\r\\n              );\\r\\n            } else {\\r\\n              result.push(\\r\\n                `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`\\r\\n              );\\r\\n            }\\r\\n          }\\r\\n          return utils.linesToString(result);\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelMemoryOptimizedFloats(result, channel) {\\r\\n          result.push(\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            `  data0.${channel} = kernelResult`\\r\\n          );\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelMemoryOptimizedFloats(result, channel) {\\r\\n          if (!this.subKernels) return result;\\r\\n          for (let i = 0; i < this.subKernels.length; i++) {\\r\\n            const subKernel = this.subKernels[i];\\r\\n            if (subKernel.returnType === 'Integer') {\\r\\n              result.push(\\r\\n                `  data${i + 1}.${channel} = float(subKernelResult_${subKernel.name})`\\r\\n              );\\r\\n            } else {\\r\\n              result.push(\\r\\n                `  data${i + 1}.${channel} = subKernelResult_${subKernel.name}`\\r\\n              );\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelNumberTexture() {\\r\\n          return [\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            '  data0[0] = kernelResult',\\r\\n          ];\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelNumberTexture() {\\r\\n          const result = [];\\r\\n          if (!this.subKernels) return result;\\r\\n          for (let i = 0; i < this.subKernels.length; ++i) {\\r\\n            const subKernel = this.subKernels[i];\\r\\n            if (subKernel.returnType === 'Integer') {\\r\\n              result.push(\\r\\n                `  data${i + 1}[0] = float(subKernelResult_${subKernel.name})`\\r\\n              );\\r\\n            } else {\\r\\n              result.push(\\r\\n                `  data${i + 1}[0] = subKernelResult_${subKernel.name}`\\r\\n              );\\r\\n            }\\r\\n          }\\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelArray2Texture() {\\r\\n          return [\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            '  data0[0] = kernelResult[0]',\\r\\n            '  data0[1] = kernelResult[1]',\\r\\n          ];\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelArray2Texture() {\\r\\n          const result = [];\\r\\n          if (!this.subKernels) return result;\\r\\n          for (let i = 0; i < this.subKernels.length; ++i) {\\r\\n            const subKernel = this.subKernels[i];\\r\\n            result.push(\\r\\n              `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,\\r\\n              `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`\\r\\n            );\\r\\n          }\\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelArray3Texture() {\\r\\n          return [\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            '  data0[0] = kernelResult[0]',\\r\\n            '  data0[1] = kernelResult[1]',\\r\\n            '  data0[2] = kernelResult[2]',\\r\\n          ];\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelArray3Texture() {\\r\\n          const result = [];\\r\\n          if (!this.subKernels) return result;\\r\\n          for (let i = 0; i < this.subKernels.length; ++i) {\\r\\n            const subKernel = this.subKernels[i];\\r\\n            result.push(\\r\\n              `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,\\r\\n              `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,\\r\\n              `  data${i + 1}[2] = subKernelResult_${subKernel.name}[2]`\\r\\n            );\\r\\n          }\\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        getMainResultKernelArray4Texture() {\\r\\n          return [\\r\\n            '  threadId = indexTo3D(index, uOutputDim)',\\r\\n            '  kernel()',\\r\\n            '  data0 = kernelResult',\\r\\n          ];\\r\\n        }\\r\\n      \\r\\n        getMainResultSubKernelArray4Texture() {\\r\\n          const result = [];\\r\\n          if (!this.subKernels) return result;\\r\\n          for (let i = 0; i < this.subKernels.length; ++i) {\\r\\n            result.push(\\r\\n              `  data${i + 1} = subKernelResult_${this.subKernels[i].name}`\\r\\n            );\\r\\n          }\\r\\n          return result;\\r\\n        }\\r\\n      \\r\\n        destroyExtensions() {\\r\\n          this.extensions.EXT_color_buffer_float = null;\\r\\n          this.extensions.OES_texture_float_linear = null;\\r\\n        }\\r\\n      \\r\\n        toJSON() {\\r\\n          const json = super.toJSON();\\r\\n          json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();\\r\\n          json.settings.threadDim = this.threadDim;\\r\\n          return json;\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        WebGL2Kernel\\r\\n      };\\r\\n      },{\\\"../../utils\\\":114,\\\"../function-builder\\\":9,\\\"../web-gl/kernel\\\":70,\\\"./fragment-shader\\\":72,\\\"./function-node\\\":73,\\\"./kernel-value-maps\\\":74,\\\"./vertex-shader\\\":106}],106:[function(require,module,exports){\\r\\n      const vertexShader = `#version 300 es\\r\\n      __FLOAT_TACTIC_DECLARATION__;\\r\\n      __INT_TACTIC_DECLARATION__;\\r\\n      __SAMPLER_2D_TACTIC_DECLARATION__;\\r\\n      \\r\\n      in vec2 aPos;\\r\\n      in vec2 aTexCoord;\\r\\n      \\r\\n      out vec2 vTexCoord;\\r\\n      uniform vec2 ratio;\\r\\n      \\r\\n      void main(void) {\\r\\n        gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);\\r\\n        vTexCoord = aTexCoord;\\r\\n      }`;\\r\\n      \\r\\n      module.exports = {\\r\\n        vertexShader\\r\\n      };\\r\\n      },{}],107:[function(require,module,exports){\\r\\n      const lib = require('./index');\\r\\n      const GPU = lib.GPU;\\r\\n      for (const p in lib) {\\r\\n        if (!lib.hasOwnProperty(p)) continue;\\r\\n        if (p === 'GPU') continue; \\r\\n        GPU[p] = lib[p];\\r\\n      }\\r\\n      \\r\\n      if (typeof window !== 'undefined') {\\r\\n        bindTo(window);\\r\\n      }\\r\\n      if (typeof self !== 'undefined') {\\r\\n        bindTo(self);\\r\\n      }\\r\\n      \\r\\n      function bindTo(target) {\\r\\n        if (target.GPU) return;\\r\\n        Object.defineProperty(target, 'GPU', {\\r\\n          get() {\\r\\n            return GPU;\\r\\n          }\\r\\n        });\\r\\n      }\\r\\n      \\r\\n      module.exports = lib;\\r\\n      },{\\\"./index\\\":109}],108:[function(require,module,exports){\\r\\n      const { gpuMock } = require('gpu-mock.js');\\r\\n      const { utils } = require('./utils');\\r\\n      const { Kernel } = require('./backend/kernel');\\r\\n      const { CPUKernel } = require('./backend/cpu/kernel');\\r\\n      const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');\\r\\n      const { WebGL2Kernel } = require('./backend/web-gl2/kernel');\\r\\n      const { WebGLKernel } = require('./backend/web-gl/kernel');\\r\\n      const { kernelRunShortcut } = require('./kernel-run-shortcut');\\r\\n      \\r\\n      \\r\\n      const kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];\\r\\n      \\r\\n      const kernelTypes = ['gpu', 'cpu'];\\r\\n      \\r\\n      const internalKernels = {\\r\\n        'headlessgl': HeadlessGLKernel,\\r\\n        'webgl2': WebGL2Kernel,\\r\\n        'webgl': WebGLKernel,\\r\\n      };\\r\\n      \\r\\n      let validate = true;\\r\\n      \\r\\n      class GPU {\\r\\n        static disableValidation() {\\r\\n          validate = false;\\r\\n        }\\r\\n      \\r\\n        static enableValidation() {\\r\\n          validate = true;\\r\\n        }\\r\\n      \\r\\n        static get isGPUSupported() {\\r\\n          return kernelOrder.some(Kernel => Kernel.isSupported);\\r\\n        }\\r\\n      \\r\\n        static get isKernelMapSupported() {\\r\\n          return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.kernelMap);\\r\\n        }\\r\\n      \\r\\n        static get isOffscreenCanvasSupported() {\\r\\n          return (typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined') || typeof importScripts !== 'undefined';\\r\\n        }\\r\\n      \\r\\n        static get isWebGLSupported() {\\r\\n          return WebGLKernel.isSupported;\\r\\n        }\\r\\n      \\r\\n        static get isWebGL2Supported() {\\r\\n          return WebGL2Kernel.isSupported;\\r\\n        }\\r\\n      \\r\\n        static get isHeadlessGLSupported() {\\r\\n          return HeadlessGLKernel.isSupported;\\r\\n        }\\r\\n      \\r\\n        static get isCanvasSupported() {\\r\\n          return typeof HTMLCanvasElement !== 'undefined';\\r\\n        }\\r\\n      \\r\\n        static get isGPUHTMLImageArraySupported() {\\r\\n          return WebGL2Kernel.isSupported;\\r\\n        }\\r\\n      \\r\\n        static get isSinglePrecisionSupported() {\\r\\n          return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat);\\r\\n        }\\r\\n      \\r\\n        constructor(settings) {\\r\\n          settings = settings || {};\\r\\n          this.canvas = settings.canvas || null;\\r\\n          this.context = settings.context || null;\\r\\n          this.mode = settings.mode;\\r\\n          this.Kernel = null;\\r\\n          this.kernels = [];\\r\\n          this.functions = [];\\r\\n          this.nativeFunctions = [];\\r\\n          this.injectedNative = null;\\r\\n          if (this.mode === 'dev') return;\\r\\n          this.chooseKernel();\\r\\n          if (settings.functions) {\\r\\n            for (let i = 0; i < settings.functions.length; i++) {\\r\\n              this.addFunction(settings.functions[i]);\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          if (settings.nativeFunctions) {\\r\\n            for (const p in settings.nativeFunctions) {\\r\\n              if (!settings.nativeFunctions.hasOwnProperty(p)) continue;\\r\\n              const s = settings.nativeFunctions[p];\\r\\n              const { name, source } = s;\\r\\n              this.addNativeFunction(name, source, s);\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      \\r\\n        chooseKernel() {\\r\\n          if (this.Kernel) return;\\r\\n      \\r\\n          let Kernel = null;\\r\\n      \\r\\n          if (this.context) {\\r\\n            for (let i = 0; i < kernelOrder.length; i++) {\\r\\n              const ExternalKernel = kernelOrder[i];\\r\\n              if (ExternalKernel.isContextMatch(this.context)) {\\r\\n                if (!ExternalKernel.isSupported) {\\r\\n                  throw new Error(`Kernel type ${ExternalKernel.name} not supported`);\\r\\n                }\\r\\n                Kernel = ExternalKernel;\\r\\n                break;\\r\\n              }\\r\\n            }\\r\\n            if (Kernel === null) {\\r\\n              throw new Error('unknown Context');\\r\\n            }\\r\\n          } else if (this.mode) {\\r\\n            if (this.mode in internalKernels) {\\r\\n              if (!validate || internalKernels[this.mode].isSupported) {\\r\\n                Kernel = internalKernels[this.mode];\\r\\n              }\\r\\n            } else if (this.mode === 'gpu') {\\r\\n              for (let i = 0; i < kernelOrder.length; i++) {\\r\\n                if (kernelOrder[i].isSupported) {\\r\\n                  Kernel = kernelOrder[i];\\r\\n                  break;\\r\\n                }\\r\\n              }\\r\\n            } else if (this.mode === 'cpu') {\\r\\n              Kernel = CPUKernel;\\r\\n            }\\r\\n            if (!Kernel) {\\r\\n              throw new Error(`A requested mode of \\\"${this.mode}\\\" and is not supported`);\\r\\n            }\\r\\n          } else {\\r\\n            for (let i = 0; i < kernelOrder.length; i++) {\\r\\n              if (kernelOrder[i].isSupported) {\\r\\n                Kernel = kernelOrder[i];\\r\\n                break;\\r\\n              }\\r\\n            }\\r\\n            if (!Kernel) {\\r\\n              Kernel = CPUKernel;\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          if (!this.mode) {\\r\\n            this.mode = Kernel.mode;\\r\\n          }\\r\\n          this.Kernel = Kernel;\\r\\n        }\\r\\n      \\r\\n        createKernel(source, settings) {\\r\\n          if (typeof source === 'undefined') {\\r\\n            throw new Error('Missing source parameter');\\r\\n          }\\r\\n          if (typeof source !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {\\r\\n            throw new Error('source parameter not a function');\\r\\n          }\\r\\n      \\r\\n          const kernels = this.kernels;\\r\\n          if (this.mode === 'dev') {\\r\\n            const devKernel = gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));\\r\\n            kernels.push(devKernel);\\r\\n            return devKernel;\\r\\n          }\\r\\n      \\r\\n          source = typeof source === 'function' ? source.toString() : source;\\r\\n          const switchableKernels = {};\\r\\n          const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings) || {};\\r\\n          if (settings && typeof settings.argumentTypes === 'object') {\\r\\n            settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);\\r\\n          }\\r\\n      \\r\\n          function onRequestFallback(args) {\\r\\n            console.warn('Falling back to CPU');\\r\\n            const fallbackKernel = new CPUKernel(source, {\\r\\n              argumentTypes: kernelRun.argumentTypes,\\r\\n              constantTypes: kernelRun.constantTypes,\\r\\n              graphical: kernelRun.graphical,\\r\\n              loopMaxIterations: kernelRun.loopMaxIterations,\\r\\n              constants: kernelRun.constants,\\r\\n              dynamicOutput: kernelRun.dynamicOutput,\\r\\n              dynamicArgument: kernelRun.dynamicArguments,\\r\\n              output: kernelRun.output,\\r\\n              precision: kernelRun.precision,\\r\\n              pipeline: kernelRun.pipeline,\\r\\n              immutable: kernelRun.immutable,\\r\\n              optimizeFloatMemory: kernelRun.optimizeFloatMemory,\\r\\n              fixIntegerDivisionAccuracy: kernelRun.fixIntegerDivisionAccuracy,\\r\\n              functions: kernelRun.functions,\\r\\n              nativeFunctions: kernelRun.nativeFunctions,\\r\\n              injectedNative: kernelRun.injectedNative,\\r\\n              subKernels: kernelRun.subKernels,\\r\\n              strictIntegers: kernelRun.strictIntegers,\\r\\n              debug: kernelRun.debug,\\r\\n            });\\r\\n            fallbackKernel.build.apply(fallbackKernel, args);\\r\\n            const result = fallbackKernel.run.apply(fallbackKernel, args);\\r\\n            kernelRun.replaceKernel(fallbackKernel);\\r\\n            return result;\\r\\n          }\\r\\n      \\r\\n          function onRequestSwitchKernel(reasons, args, _kernel) {\\r\\n            if (_kernel.debug) {\\r\\n              console.warn('Switching kernels');\\r\\n            }\\r\\n            let newOutput = null;\\r\\n            if (_kernel.signature && !switchableKernels[_kernel.signature]) {\\r\\n              switchableKernels[_kernel.signature] = _kernel;\\r\\n            }\\r\\n            if (_kernel.dynamicOutput) {\\r\\n              for (let i = reasons.length - 1; i >= 0; i--) {\\r\\n                const reason = reasons[i];\\r\\n                if (reason.type === 'outputPrecisionMismatch') {\\r\\n                  newOutput = reason.needed;\\r\\n                }\\r\\n              }\\r\\n            }\\r\\n      \\r\\n            const Constructor = _kernel.constructor;\\r\\n            const argumentTypes = Constructor.getArgumentTypes(_kernel, args);\\r\\n            const signature = Constructor.getSignature(_kernel, argumentTypes);\\r\\n            const existingKernel = switchableKernels[signature];\\r\\n            if (existingKernel) {\\r\\n              existingKernel.onActivate(_kernel);\\r\\n              return existingKernel;\\r\\n            }\\r\\n      \\r\\n            const newKernel = switchableKernels[signature] = new Constructor(source, {\\r\\n              argumentTypes,\\r\\n              constantTypes: _kernel.constantTypes,\\r\\n              graphical: _kernel.graphical,\\r\\n              loopMaxIterations: _kernel.loopMaxIterations,\\r\\n              constants: _kernel.constants,\\r\\n              dynamicOutput: _kernel.dynamicOutput,\\r\\n              dynamicArgument: _kernel.dynamicArguments,\\r\\n              context: _kernel.context,\\r\\n              canvas: _kernel.canvas,\\r\\n              output: newOutput || _kernel.output,\\r\\n              precision: _kernel.precision,\\r\\n              pipeline: _kernel.pipeline,\\r\\n              immutable: _kernel.immutable,\\r\\n              optimizeFloatMemory: _kernel.optimizeFloatMemory,\\r\\n              fixIntegerDivisionAccuracy: _kernel.fixIntegerDivisionAccuracy,\\r\\n              functions: _kernel.functions,\\r\\n              nativeFunctions: _kernel.nativeFunctions,\\r\\n              injectedNative: _kernel.injectedNative,\\r\\n              subKernels: _kernel.subKernels,\\r\\n              strictIntegers: _kernel.strictIntegers,\\r\\n              debug: _kernel.debug,\\r\\n              gpu: _kernel.gpu,\\r\\n              validate,\\r\\n              returnType: _kernel.returnType,\\r\\n              tactic: _kernel.tactic,\\r\\n              onRequestFallback,\\r\\n              onRequestSwitchKernel,\\r\\n              texture: _kernel.texture,\\r\\n              mappedTextures: _kernel.mappedTextures,\\r\\n              drawBuffersMap: _kernel.drawBuffersMap,\\r\\n            });\\r\\n            newKernel.build.apply(newKernel, args);\\r\\n            kernelRun.replaceKernel(newKernel);\\r\\n            kernels.push(newKernel);\\r\\n            return newKernel;\\r\\n          }\\r\\n          const mergedSettings = Object.assign({\\r\\n            context: this.context,\\r\\n            canvas: this.canvas,\\r\\n            functions: this.functions,\\r\\n            nativeFunctions: this.nativeFunctions,\\r\\n            injectedNative: this.injectedNative,\\r\\n            gpu: this,\\r\\n            validate,\\r\\n            onRequestFallback,\\r\\n            onRequestSwitchKernel\\r\\n          }, settingsCopy);\\r\\n      \\r\\n          const kernel = new this.Kernel(source, mergedSettings);\\r\\n          const kernelRun = kernelRunShortcut(kernel);\\r\\n      \\r\\n          if (!this.canvas) {\\r\\n            this.canvas = kernel.canvas;\\r\\n          }\\r\\n      \\r\\n          if (!this.context) {\\r\\n            this.context = kernel.context;\\r\\n          }\\r\\n      \\r\\n          kernels.push(kernel);\\r\\n      \\r\\n          return kernelRun;\\r\\n        }\\r\\n      \\r\\n        createKernelMap() {\\r\\n          let fn;\\r\\n          let settings;\\r\\n          const argument2Type = typeof arguments[arguments.length - 2];\\r\\n          if (argument2Type === 'function' || argument2Type === 'string') {\\r\\n            fn = arguments[arguments.length - 2];\\r\\n            settings = arguments[arguments.length - 1];\\r\\n          } else {\\r\\n            fn = arguments[arguments.length - 1];\\r\\n          }\\r\\n      \\r\\n          if (this.mode !== 'dev') {\\r\\n            if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {\\r\\n              if (this.mode && kernelTypes.indexOf(this.mode) < 0) {\\r\\n                throw new Error(`kernelMap not supported on ${this.Kernel.name}`);\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings);\\r\\n          if (settings && typeof settings.argumentTypes === 'object') {\\r\\n            settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);\\r\\n          }\\r\\n      \\r\\n          if (Array.isArray(arguments[0])) {\\r\\n            settingsCopy.subKernels = [];\\r\\n            const functions = arguments[0];\\r\\n            for (let i = 0; i < functions.length; i++) {\\r\\n              const source = functions[i].toString();\\r\\n              const name = utils.getFunctionNameFromString(source);\\r\\n              settingsCopy.subKernels.push({\\r\\n                name,\\r\\n                source,\\r\\n                property: i,\\r\\n              });\\r\\n            }\\r\\n          } else {\\r\\n            settingsCopy.subKernels = [];\\r\\n            const functions = arguments[0];\\r\\n            for (let p in functions) {\\r\\n              if (!functions.hasOwnProperty(p)) continue;\\r\\n              const source = functions[p].toString();\\r\\n              const name = utils.getFunctionNameFromString(source);\\r\\n              settingsCopy.subKernels.push({\\r\\n                name: name || p,\\r\\n                source,\\r\\n                property: p,\\r\\n              });\\r\\n            }\\r\\n          }\\r\\n          return this.createKernel(fn, settingsCopy);\\r\\n        }\\r\\n      \\r\\n        combineKernels() {\\r\\n          const firstKernel = arguments[0];\\r\\n          const combinedKernel = arguments[arguments.length - 1];\\r\\n          if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;\\r\\n          const canvas = arguments[0].canvas;\\r\\n          const context = arguments[0].context;\\r\\n          const max = arguments.length - 1;\\r\\n          for (let i = 0; i < max; i++) {\\r\\n            arguments[i]\\r\\n              .setCanvas(canvas)\\r\\n              .setContext(context)\\r\\n              .setPipeline(true);\\r\\n          }\\r\\n      \\r\\n          return function() {\\r\\n            const texture = combinedKernel.apply(this, arguments);\\r\\n            if (texture.toArray) {\\r\\n              return texture.toArray();\\r\\n            }\\r\\n            return texture;\\r\\n          };\\r\\n        }\\r\\n      \\r\\n        setFunctions(functions) {\\r\\n          this.functions = functions;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        setNativeFunctions(nativeFunctions) {\\r\\n          this.nativeFunctions = nativeFunctions;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        addFunction(source, settings) {\\r\\n          this.functions.push({ source, settings });\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        addNativeFunction(name, source, settings) {\\r\\n          if (this.kernels.length > 0) {\\r\\n            throw new Error('Cannot call \\\"addNativeFunction\\\" after \\\"createKernels\\\" has been called.');\\r\\n          }\\r\\n          this.nativeFunctions.push(Object.assign({ name, source }, settings));\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        injectNative(source) {\\r\\n          this.injectedNative = source;\\r\\n          return this;\\r\\n        }\\r\\n      \\r\\n        destroy() {\\r\\n          return new Promise((resolve, reject) => {\\r\\n            if (!this.kernels) {\\r\\n              resolve();\\r\\n            }\\r\\n            setTimeout(() => {\\r\\n              try {\\r\\n                for (let i = 0; i < this.kernels.length; i++) {\\r\\n                  this.kernels[i].destroy(true); \\r\\n                }\\r\\n                let firstKernel = this.kernels[0];\\r\\n                if (firstKernel) {\\r\\n                  if (firstKernel.kernel) {\\r\\n                    firstKernel = firstKernel.kernel;\\r\\n                  }\\r\\n                  if (firstKernel.constructor.destroyContext) {\\r\\n                    firstKernel.constructor.destroyContext(this.context);\\r\\n                  }\\r\\n                }\\r\\n              } catch (e) {\\r\\n                reject(e);\\r\\n              }\\r\\n              resolve();\\r\\n            }, 0);\\r\\n          });\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      \\r\\n      function upgradeDeprecatedCreateKernelSettings(settings) {\\r\\n        if (!settings) {\\r\\n          return {};\\r\\n        }\\r\\n        const upgradedSettings = Object.assign({}, settings);\\r\\n      \\r\\n        if (settings.hasOwnProperty('floatOutput')) {\\r\\n          utils.warnDeprecated('setting', 'floatOutput', 'precision');\\r\\n          upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';\\r\\n        }\\r\\n        if (settings.hasOwnProperty('outputToTexture')) {\\r\\n          utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');\\r\\n          upgradedSettings.pipeline = Boolean(settings.outputToTexture);\\r\\n        }\\r\\n        if (settings.hasOwnProperty('outputImmutable')) {\\r\\n          utils.warnDeprecated('setting', 'outputImmutable', 'immutable');\\r\\n          upgradedSettings.immutable = Boolean(settings.outputImmutable);\\r\\n        }\\r\\n        if (settings.hasOwnProperty('floatTextures')) {\\r\\n          utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');\\r\\n          upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);\\r\\n        }\\r\\n        return upgradedSettings;\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        GPU,\\r\\n        kernelOrder,\\r\\n        kernelTypes\\r\\n      };\\r\\n      },{\\\"./backend/cpu/kernel\\\":8,\\\"./backend/headless-gl/kernel\\\":34,\\\"./backend/kernel\\\":36,\\\"./backend/web-gl/kernel\\\":70,\\\"./backend/web-gl2/kernel\\\":105,\\\"./kernel-run-shortcut\\\":111,\\\"./utils\\\":114,\\\"gpu-mock.js\\\":4}],109:[function(require,module,exports){\\r\\n      const { GPU } = require('./gpu');\\r\\n      const { alias } = require('./alias');\\r\\n      const { utils } = require('./utils');\\r\\n      const { Input, input } = require('./input');\\r\\n      const { Texture } = require('./texture');\\r\\n      const { FunctionBuilder } = require('./backend/function-builder');\\r\\n      const { FunctionNode } = require('./backend/function-node');\\r\\n      const { CPUFunctionNode } = require('./backend/cpu/function-node');\\r\\n      const { CPUKernel } = require('./backend/cpu/kernel');\\r\\n      \\r\\n      const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');\\r\\n      \\r\\n      const { WebGLFunctionNode } = require('./backend/web-gl/function-node');\\r\\n      const { WebGLKernel } = require('./backend/web-gl/kernel');\\r\\n      const { kernelValueMaps: webGLKernelValueMaps } = require('./backend/web-gl/kernel-value-maps');\\r\\n      \\r\\n      const { WebGL2FunctionNode } = require('./backend/web-gl2/function-node');\\r\\n      const { WebGL2Kernel } = require('./backend/web-gl2/kernel');\\r\\n      const { kernelValueMaps: webGL2KernelValueMaps } = require('./backend/web-gl2/kernel-value-maps');\\r\\n      \\r\\n      const { GLKernel } = require('./backend/gl/kernel');\\r\\n      \\r\\n      const { Kernel } = require('./backend/kernel');\\r\\n      \\r\\n      const { FunctionTracer } = require('./backend/function-tracer');\\r\\n      \\r\\n      const mathRandom = require('./plugins/math-random-uniformly-distributed');\\r\\n      \\r\\n      module.exports = {\\r\\n        alias,\\r\\n        CPUFunctionNode,\\r\\n        CPUKernel,\\r\\n        GPU,\\r\\n        FunctionBuilder,\\r\\n        FunctionNode,\\r\\n        HeadlessGLKernel,\\r\\n        Input,\\r\\n        input,\\r\\n        Texture,\\r\\n        utils,\\r\\n      \\r\\n        WebGL2FunctionNode,\\r\\n        WebGL2Kernel,\\r\\n        webGL2KernelValueMaps,\\r\\n      \\r\\n        WebGLFunctionNode,\\r\\n        WebGLKernel,\\r\\n        webGLKernelValueMaps,\\r\\n      \\r\\n        GLKernel,\\r\\n        Kernel,\\r\\n        FunctionTracer,\\r\\n      \\r\\n        plugins: {\\r\\n          mathRandom\\r\\n        }\\r\\n      };\\r\\n      },{\\\"./alias\\\":5,\\\"./backend/cpu/function-node\\\":6,\\\"./backend/cpu/kernel\\\":8,\\\"./backend/function-builder\\\":9,\\\"./backend/function-node\\\":10,\\\"./backend/function-tracer\\\":11,\\\"./backend/gl/kernel\\\":13,\\\"./backend/headless-gl/kernel\\\":34,\\\"./backend/kernel\\\":36,\\\"./backend/web-gl/function-node\\\":38,\\\"./backend/web-gl/kernel\\\":70,\\\"./backend/web-gl/kernel-value-maps\\\":39,\\\"./backend/web-gl2/function-node\\\":73,\\\"./backend/web-gl2/kernel\\\":105,\\\"./backend/web-gl2/kernel-value-maps\\\":74,\\\"./gpu\\\":108,\\\"./input\\\":110,\\\"./plugins/math-random-uniformly-distributed\\\":112,\\\"./texture\\\":113,\\\"./utils\\\":114}],110:[function(require,module,exports){\\r\\n      class Input {\\r\\n        constructor(value, size) {\\r\\n          this.value = value;\\r\\n          if (Array.isArray(size)) {\\r\\n            this.size = size;\\r\\n          } else {\\r\\n            this.size = new Int32Array(3);\\r\\n            if (size.z) {\\r\\n              this.size = new Int32Array([size.x, size.y, size.z]);\\r\\n            } else if (size.y) {\\r\\n              this.size = new Int32Array([size.x, size.y]);\\r\\n            } else {\\r\\n              this.size = new Int32Array([size.x]);\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          const [w, h, d] = this.size;\\r\\n          if (d) {\\r\\n            if (this.value.length !== (w * h * d)) {\\r\\n              throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} * ${d} = ${(h * w * d)}`);\\r\\n            }\\r\\n          } else if (h) {\\r\\n            if (this.value.length !== (w * h)) {\\r\\n              throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} = ${(h * w)}`);\\r\\n            }\\r\\n          } else {\\r\\n            if (this.value.length !== w) {\\r\\n              throw new Error(`Input size ${this.value.length} does not match ${w}`);\\r\\n            }\\r\\n          }\\r\\n      \\r\\n        }\\r\\n      \\r\\n        toArray() {\\r\\n          const { utils } = require('./utils');\\r\\n          const [w, h, d] = this.size;\\r\\n          if (d) {\\r\\n            return utils.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h, d);\\r\\n          } else if (h) {\\r\\n            return utils.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h);\\r\\n          } else {\\r\\n            return this.value;\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      function input(value, size) {\\r\\n        return new Input(value, size);\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        Input,\\r\\n        input\\r\\n      };\\r\\n      },{\\\"./utils\\\":114}],111:[function(require,module,exports){\\r\\n      const { utils } = require('./utils');\\r\\n      \\r\\n      function kernelRunShortcut(kernel) {\\r\\n        let run = function() {\\r\\n          kernel.build.apply(kernel, arguments);\\r\\n          run = function() {\\r\\n            let result = kernel.run.apply(kernel, arguments);\\r\\n            if (kernel.switchingKernels) {\\r\\n              const reasons = kernel.resetSwitchingKernels();\\r\\n              const newKernel = kernel.onRequestSwitchKernel(reasons, arguments, kernel);\\r\\n              shortcut.kernel = kernel = newKernel;\\r\\n              result = newKernel.run.apply(newKernel, arguments);\\r\\n            }\\r\\n            if (kernel.renderKernels) {\\r\\n              return kernel.renderKernels();\\r\\n            } else if (kernel.renderOutput) {\\r\\n              return kernel.renderOutput();\\r\\n            } else {\\r\\n              return result;\\r\\n            }\\r\\n          };\\r\\n          return run.apply(kernel, arguments);\\r\\n        };\\r\\n        const shortcut = function() {\\r\\n          return run.apply(kernel, arguments);\\r\\n        };\\r\\n        shortcut.exec = function() {\\r\\n          return new Promise((accept, reject) => {\\r\\n            try {\\r\\n              accept(run.apply(this, arguments));\\r\\n            } catch (e) {\\r\\n              reject(e);\\r\\n            }\\r\\n          });\\r\\n        };\\r\\n        shortcut.replaceKernel = function(replacementKernel) {\\r\\n          kernel = replacementKernel;\\r\\n          bindKernelToShortcut(kernel, shortcut);\\r\\n        };\\r\\n      \\r\\n        bindKernelToShortcut(kernel, shortcut);\\r\\n        return shortcut;\\r\\n      }\\r\\n      \\r\\n      function bindKernelToShortcut(kernel, shortcut) {\\r\\n        if (shortcut.kernel) {\\r\\n          shortcut.kernel = kernel;\\r\\n          return;\\r\\n        }\\r\\n        const properties = utils.allPropertiesOf(kernel);\\r\\n        for (let i = 0; i < properties.length; i++) {\\r\\n          const property = properties[i];\\r\\n          if (property[0] === '_' && property[1] === '_') continue;\\r\\n          if (typeof kernel[property] === 'function') {\\r\\n            if (property.substring(0, 3) === 'add' || property.substring(0, 3) === 'set') {\\r\\n              shortcut[property] = function() {\\r\\n                shortcut.kernel[property].apply(shortcut.kernel, arguments);\\r\\n                return shortcut;\\r\\n              };\\r\\n            } else {\\r\\n              shortcut[property] = function() {\\r\\n                return shortcut.kernel[property].apply(shortcut.kernel, arguments);\\r\\n              };\\r\\n            }\\r\\n          } else {\\r\\n            shortcut.__defineGetter__(property, () => shortcut.kernel[property]);\\r\\n            shortcut.__defineSetter__(property, (value) => {\\r\\n              shortcut.kernel[property] = value;\\r\\n            });\\r\\n          }\\r\\n        }\\r\\n        shortcut.kernel = kernel;\\r\\n      }\\r\\n      module.exports = {\\r\\n        kernelRunShortcut\\r\\n      };\\r\\n      },{\\\"./utils\\\":114}],112:[function(require,module,exports){\\r\\n      const source = `// https://www.shadertoy.com/view/4t2SDh\\r\\n      //note: uniformly distributed, normalized rand, [0,1]\\r\\n      highp float randomSeedShift = 1.0;\\r\\n      highp float slide = 1.0;\\r\\n      uniform highp float randomSeed1;\\r\\n      uniform highp float randomSeed2;\\r\\n      \\r\\n      highp float nrand(highp vec2 n) {\\r\\n        highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);\\r\\n        randomSeedShift = result;\\r\\n        if (randomSeedShift > 0.5) {\\r\\n          slide += 0.00009; \\r\\n        } else {\\r\\n          slide += 0.0009;\\r\\n        }\\r\\n        return result;\\r\\n      }`;\\r\\n      \\r\\n      const name = 'math-random-uniformly-distributed';\\r\\n      \\r\\n      const functionMatch = `Math.random()`;\\r\\n      \\r\\n      const functionReplace = `nrand(vTexCoord)`;\\r\\n      \\r\\n      const functionReturnType = 'Number';\\r\\n      const onBeforeRun = (kernel) => {\\r\\n        kernel.setUniform1f('randomSeed1', Math.random());\\r\\n        kernel.setUniform1f('randomSeed2', Math.random());\\r\\n      };\\r\\n      \\r\\n      const plugin = {\\r\\n        name,\\r\\n        onBeforeRun,\\r\\n        functionMatch,\\r\\n        functionReplace,\\r\\n        functionReturnType,\\r\\n        source\\r\\n      };\\r\\n      \\r\\n      module.exports = plugin;\\r\\n      },{}],113:[function(require,module,exports){\\r\\n      class Texture {\\r\\n        constructor(settings) {\\r\\n          const {\\r\\n            texture,\\r\\n            size,\\r\\n            dimensions,\\r\\n            output,\\r\\n            context,\\r\\n            type = 'NumberTexture',\\r\\n            kernel,\\r\\n            internalFormat,\\r\\n            textureFormat\\r\\n          } = settings;\\r\\n          if (!output) throw new Error('settings property \\\"output\\\" required.');\\r\\n          if (!context) throw new Error('settings property \\\"context\\\" required.');\\r\\n          if (!texture) throw new Error('settings property \\\"texture\\\" required.');\\r\\n          if (!kernel) throw new Error('settings property \\\"kernel\\\" required.');\\r\\n          this.texture = texture;\\r\\n          if (texture._refs) {\\r\\n            texture._refs++;\\r\\n          } else {\\r\\n            texture._refs = 1;\\r\\n          }\\r\\n          this.size = size;\\r\\n          this.dimensions = dimensions;\\r\\n          this.output = output;\\r\\n          this.context = context;\\r\\n          this.kernel = kernel;\\r\\n          this.type = type;\\r\\n          this._deleted = false;\\r\\n          this.internalFormat = internalFormat;\\r\\n          this.textureFormat = textureFormat;\\r\\n        }\\r\\n      \\r\\n        toArray() {\\r\\n          throw new Error(`Not implemented on ${this.constructor.name}`);\\r\\n        }\\r\\n      \\r\\n        clone() {\\r\\n          throw new Error(`Not implemented on ${this.constructor.name}`);\\r\\n        }\\r\\n      \\r\\n        delete() {\\r\\n          throw new Error(`Not implemented on ${this.constructor.name}`);\\r\\n        }\\r\\n      \\r\\n        clear() {\\r\\n          throw new Error(`Not implemented on ${this.constructor.name}`);\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      module.exports = {\\r\\n        Texture\\r\\n      };\\r\\n      },{}],114:[function(require,module,exports){\\r\\n      const acorn = require('acorn');\\r\\n      const { Input } = require('./input');\\r\\n      const { Texture } = require('./texture');\\r\\n      \\r\\n      const FUNCTION_NAME = /function ([^(]*)/;\\r\\n      const STRIP_COMMENTS = /((\\\\/\\\\/.*$)|(\\\\/\\\\*[\\\\s\\\\S]*?\\\\*\\\\/))/mg;\\r\\n      const ARGUMENT_NAMES = /([^\\\\s,]+)/g;\\r\\n      \\r\\n      const utils = {\\r\\n        systemEndianness() {\\r\\n          return _systemEndianness;\\r\\n        },\\r\\n        getSystemEndianness() {\\r\\n          const b = new ArrayBuffer(4);\\r\\n          const a = new Uint32Array(b);\\r\\n          const c = new Uint8Array(b);\\r\\n          a[0] = 0xdeadbeef;\\r\\n          if (c[0] === 0xef) return 'LE';\\r\\n          if (c[0] === 0xde) return 'BE';\\r\\n          throw new Error('unknown endianness');\\r\\n        },\\r\\n      \\r\\n        isFunction(funcObj) {\\r\\n          return typeof(funcObj) === 'function';\\r\\n        },\\r\\n      \\r\\n        isFunctionString(fn) {\\r\\n          if (typeof fn === 'string') {\\r\\n            return (fn\\r\\n              .slice(0, 'function'.length)\\r\\n              .toLowerCase() === 'function');\\r\\n          }\\r\\n          return false;\\r\\n        },\\r\\n      \\r\\n        getFunctionNameFromString(funcStr) {\\r\\n          const result = FUNCTION_NAME.exec(funcStr);\\r\\n          if (!result || result.length === 0) return null;\\r\\n          return result[1].trim();\\r\\n        },\\r\\n      \\r\\n        getFunctionBodyFromString(funcStr) {\\r\\n          return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));\\r\\n        },\\r\\n      \\r\\n        getArgumentNamesFromString(fn) {\\r\\n          const fnStr = fn.replace(STRIP_COMMENTS, '');\\r\\n          let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\\r\\n          if (result === null) {\\r\\n            result = [];\\r\\n          }\\r\\n          return result;\\r\\n        },\\r\\n      \\r\\n        clone(obj) {\\r\\n          if (obj === null || typeof obj !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;\\r\\n      \\r\\n          const temp = obj.constructor(); \\r\\n      \\r\\n          for (let key in obj) {\\r\\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\\r\\n              obj.isActiveClone = null;\\r\\n              temp[key] = utils.clone(obj[key]);\\r\\n              delete obj.isActiveClone;\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          return temp;\\r\\n        },\\r\\n      \\r\\n        isArray(array) {\\r\\n          return !isNaN(array.length);\\r\\n        },\\r\\n      \\r\\n        getVariableType(value, strictIntegers) {\\r\\n          if (utils.isArray(value)) {\\r\\n            if (value.length > 0 && value[0].nodeName === 'IMG') {\\r\\n              return 'HTMLImageArray';\\r\\n            }\\r\\n            return 'Array';\\r\\n          }\\r\\n      \\r\\n          switch (value.constructor) {\\r\\n            case Boolean:\\r\\n              return 'Boolean';\\r\\n            case Number:\\r\\n              if (strictIntegers && Number.isInteger(value)) {\\r\\n                return 'Integer';\\r\\n              }\\r\\n              return 'Float';\\r\\n            case Texture:\\r\\n              return value.type;\\r\\n            case Input:\\r\\n              return 'Input';\\r\\n          }\\r\\n          switch (value.nodeName) {\\r\\n            case 'IMG':\\r\\n              return 'HTMLImage';\\r\\n            case 'CANVAS':\\r\\n              return 'HTMLImage';\\r\\n            case 'VIDEO':\\r\\n              return 'HTMLVideo';\\r\\n          }\\r\\n          if (value.hasOwnProperty('type')) {\\r\\n            return value.type;\\r\\n          }\\r\\n          return 'Unknown';\\r\\n        },\\r\\n      \\r\\n        getKernelTextureSize(settings, dimensions) {\\r\\n          let [w, h, d] = dimensions;\\r\\n          let texelCount = (w || 1) * (h || 1) * (d || 1);\\r\\n      \\r\\n          if (settings.optimizeFloatMemory && settings.precision === 'single') {\\r\\n            w = texelCount = Math.ceil(texelCount / 4);\\r\\n          }\\r\\n          if (h > 1 && w * h === texelCount) {\\r\\n            return new Int32Array([w, h]);\\r\\n          }\\r\\n          return utils.closestSquareDimensions(texelCount);\\r\\n        },\\r\\n      \\r\\n        closestSquareDimensions(length) {\\r\\n          const sqrt = Math.sqrt(length);\\r\\n          let high = Math.ceil(sqrt);\\r\\n          let low = Math.floor(sqrt);\\r\\n          while (high * low < length) {\\r\\n            high--;\\r\\n            low = Math.ceil(length / high);\\r\\n          }\\r\\n          return new Int32Array([low, Math.ceil(length / low)]);\\r\\n        },\\r\\n      \\r\\n        getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {\\r\\n          const totalArea = utils.roundTo((dimensions[0] || 1) * (dimensions[1] || 1) * (dimensions[2] || 1) * (dimensions[3] || 1), 4);\\r\\n          const texelCount = totalArea / bitRatio;\\r\\n          return utils.closestSquareDimensions(texelCount);\\r\\n        },\\r\\n      \\r\\n        getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {\\r\\n          const [w, h, d] = dimensions;\\r\\n          const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);\\r\\n          const texelCount = totalArea / (4 / bitRatio);\\r\\n          return utils.closestSquareDimensions(texelCount);\\r\\n        },\\r\\n      \\r\\n        roundTo(n, d) {\\r\\n          return Math.floor((n + d - 1) / d) * d;\\r\\n        },\\r\\n        getDimensions(x, pad) {\\r\\n          let ret;\\r\\n          if (utils.isArray(x)) {\\r\\n            const dim = [];\\r\\n            let temp = x;\\r\\n            while (utils.isArray(temp)) {\\r\\n              dim.push(temp.length);\\r\\n              temp = temp[0];\\r\\n            }\\r\\n            ret = dim.reverse();\\r\\n          } else if (x instanceof Texture) {\\r\\n            ret = x.output;\\r\\n          } else if (x instanceof Input) {\\r\\n            ret = x.size;\\r\\n          } else {\\r\\n            throw new Error(`Unknown dimensions of ${x}`);\\r\\n          }\\r\\n      \\r\\n          if (pad) {\\r\\n            ret = Array.from(ret);\\r\\n            while (ret.length < 3) {\\r\\n              ret.push(1);\\r\\n            }\\r\\n          }\\r\\n      \\r\\n          return new Int32Array(ret);\\r\\n        },\\r\\n      \\r\\n        flatten2dArrayTo(array, target) {\\r\\n          let offset = 0;\\r\\n          for (let y = 0; y < array.length; y++) {\\r\\n            target.set(array[y], offset);\\r\\n            offset += array[y].length;\\r\\n          }\\r\\n        },\\r\\n      \\r\\n        flatten3dArrayTo(array, target) {\\r\\n          let offset = 0;\\r\\n          for (let z = 0; z < array.length; z++) {\\r\\n            for (let y = 0; y < array[z].length; y++) {\\r\\n              target.set(array[z][y], offset);\\r\\n              offset += array[z][y].length;\\r\\n            }\\r\\n          }\\r\\n        },\\r\\n      \\r\\n        flatten4dArrayTo(array, target) {\\r\\n          let offset = 0;\\r\\n          for (let l = 0; l < array.length; l++) {\\r\\n            for (let z = 0; z < array[l].length; z++) {\\r\\n              for (let y = 0; y < array[l][z].length; y++) {\\r\\n                target.set(array[l][z][y], offset);\\r\\n                offset += array[l][z][y].length;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n        },\\r\\n      \\r\\n        flattenTo(array, target) {\\r\\n          if (utils.isArray(array[0])) {\\r\\n            if (utils.isArray(array[0][0])) {\\r\\n              if (utils.isArray(array[0][0][0])) {\\r\\n                utils.flatten4dArrayTo(array, target);\\r\\n              } else {\\r\\n                utils.flatten3dArrayTo(array, target);\\r\\n              }\\r\\n            } else {\\r\\n              utils.flatten2dArrayTo(array, target);\\r\\n            }\\r\\n          } else {\\r\\n            target.set(array);\\r\\n          }\\r\\n        },\\r\\n      \\r\\n        splitArray(array, part) {\\r\\n          const result = [];\\r\\n          for (let i = 0; i < array.length; i += part) {\\r\\n            result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));\\r\\n          }\\r\\n          return result;\\r\\n        },\\r\\n      \\r\\n        getAstString(source, ast) {\\r\\n          const lines = Array.isArray(source) ? source : source.split(/\\\\r?\\\\n/g);\\r\\n          const start = ast.loc.start;\\r\\n          const end = ast.loc.end;\\r\\n          const result = [];\\r\\n          if (start.line === end.line) {\\r\\n            result.push(lines[start.line - 1].substring(start.column, end.column));\\r\\n          } else {\\r\\n            result.push(lines[start.line - 1].slice(start.column));\\r\\n            for (let i = start.line; i < end.line; i++) {\\r\\n              result.push(lines[i]);\\r\\n            }\\r\\n            result.push(lines[end.line - 1].slice(0, end.column));\\r\\n          }\\r\\n          return result.join('\\\\n');\\r\\n        },\\r\\n      \\r\\n        allPropertiesOf(obj) {\\r\\n          const props = [];\\r\\n      \\r\\n          do {\\r\\n            props.push.apply(props, Object.getOwnPropertyNames(obj));\\r\\n          } while (obj = Object.getPrototypeOf(obj));\\r\\n      \\r\\n          return props;\\r\\n        },\\r\\n      \\r\\n        linesToString(lines) {\\r\\n          if (lines.length > 0) {\\r\\n            return lines.join(';\\\\n') + ';\\\\n';\\r\\n          } else {\\r\\n            return '\\\\n';\\r\\n          }\\r\\n        },\\r\\n        warnDeprecated(type, oldName, newName) {\\r\\n          if (newName) {\\r\\n            console.warn(`You are using a deprecated ${ type } \\\"${ oldName }\\\". It has been replaced with \\\"${ newName }\\\". Fixing, but please upgrade as it will soon be removed.`);\\r\\n          } else {\\r\\n            console.warn(`You are using a deprecated ${ type } \\\"${ oldName }\\\". It has been removed. Fixing, but please upgrade as it will soon be removed.`);\\r\\n          }\\r\\n        },\\r\\n        flipPixels: (pixels, width, height) => {\\r\\n          const halfHeight = height / 2 | 0; \\r\\n          const bytesPerRow = width * 4;\\r\\n          const temp = new Uint8ClampedArray(width * 4);\\r\\n          const result = pixels.slice(0);\\r\\n          for (let y = 0; y < halfHeight; ++y) {\\r\\n            const topOffset = y * bytesPerRow;\\r\\n            const bottomOffset = (height - y - 1) * bytesPerRow;\\r\\n      \\r\\n            temp.set(result.subarray(topOffset, topOffset + bytesPerRow));\\r\\n      \\r\\n            result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);\\r\\n      \\r\\n            result.set(temp, bottomOffset);\\r\\n          }\\r\\n          return result;\\r\\n        },\\r\\n        erectPackedFloat: (array, width) => {\\r\\n          return array.subarray(0, width);\\r\\n        },\\r\\n        erect2DPackedFloat: (array, width, height) => {\\r\\n          const yResults = new Array(height);\\r\\n          for (let y = 0; y < height; y++) {\\r\\n            const xStart = y * width;\\r\\n            const xEnd = xStart + width;\\r\\n            yResults[y] = array.subarray(xStart, xEnd);\\r\\n          }\\r\\n          return yResults;\\r\\n        },\\r\\n        erect3DPackedFloat: (array, width, height, depth) => {\\r\\n          const zResults = new Array(depth);\\r\\n          for (let z = 0; z < depth; z++) {\\r\\n            const yResults = new Array(height);\\r\\n            for (let y = 0; y < height; y++) {\\r\\n              const xStart = (z * height * width) + y * width;\\r\\n              const xEnd = xStart + width;\\r\\n              yResults[y] = array.subarray(xStart, xEnd);\\r\\n            }\\r\\n            zResults[z] = yResults;\\r\\n          }\\r\\n          return zResults;\\r\\n        },\\r\\n        erectMemoryOptimizedFloat: (array, width) => {\\r\\n          return array.subarray(0, width);\\r\\n        },\\r\\n        erectMemoryOptimized2DFloat: (array, width, height) => {\\r\\n          const yResults = new Array(height);\\r\\n          for (let y = 0; y < height; y++) {\\r\\n            const offset = y * width;\\r\\n            yResults[y] = array.subarray(offset, offset + width);\\r\\n          }\\r\\n          return yResults;\\r\\n        },\\r\\n        erectMemoryOptimized3DFloat: (array, width, height, depth) => {\\r\\n          const zResults = new Array(depth);\\r\\n          for (let z = 0; z < depth; z++) {\\r\\n            const yResults = new Array(height);\\r\\n            for (let y = 0; y < height; y++) {\\r\\n              const offset = (z * height * width) + (y * width);\\r\\n              yResults[y] = array.subarray(offset, offset + width);\\r\\n            }\\r\\n            zResults[z] = yResults;\\r\\n          }\\r\\n          return zResults;\\r\\n        },\\r\\n        erectFloat: (array, width) => {\\r\\n          const xResults = new Float32Array(width);\\r\\n          let i = 0;\\r\\n          for (let x = 0; x < width; x++) {\\r\\n            xResults[x] = array[i];\\r\\n            i += 4;\\r\\n          }\\r\\n          return xResults;\\r\\n        },\\r\\n        erect2DFloat: (array, width, height) => {\\r\\n          const yResults = new Array(height);\\r\\n          let i = 0;\\r\\n          for (let y = 0; y < height; y++) {\\r\\n            const xResults = new Float32Array(width);\\r\\n            for (let x = 0; x < width; x++) {\\r\\n              xResults[x] = array[i];\\r\\n              i += 4;\\r\\n            }\\r\\n            yResults[y] = xResults;\\r\\n          }\\r\\n          return yResults;\\r\\n        },\\r\\n        erect3DFloat: (array, width, height, depth) => {\\r\\n          const zResults = new Array(depth);\\r\\n          let i = 0;\\r\\n          for (let z = 0; z < depth; z++) {\\r\\n            const yResults = new Array(height);\\r\\n            for (let y = 0; y < height; y++) {\\r\\n              const xResults = new Float32Array(width);\\r\\n              for (let x = 0; x < width; x++) {\\r\\n                xResults[x] = array[i];\\r\\n                i += 4;\\r\\n              }\\r\\n              yResults[y] = xResults;\\r\\n            }\\r\\n            zResults[z] = yResults;\\r\\n          }\\r\\n          return zResults;\\r\\n        },\\r\\n        erectArray2: (array, width) => {\\r\\n          const xResults = new Array(width);\\r\\n          const xResultsMax = width * 4;\\r\\n          let i = 0;\\r\\n          for (let x = 0; x < xResultsMax; x += 4) {\\r\\n            xResults[i++] = array.subarray(x, x + 2);\\r\\n          }\\r\\n          return xResults;\\r\\n        },\\r\\n        erect2DArray2: (array, width, height) => {\\r\\n          const yResults = new Array(height);\\r\\n          const XResultsMax = width * 4;\\r\\n          for (let y = 0; y < height; y++) {\\r\\n            const xResults = new Array(width);\\r\\n            const offset = y * XResultsMax;\\r\\n            let i = 0;\\r\\n            for (let x = 0; x < XResultsMax; x += 4) {\\r\\n              xResults[i++] = array.subarray(x + offset, x + offset + 2);\\r\\n            }\\r\\n            yResults[y] = xResults;\\r\\n          }\\r\\n          return yResults;\\r\\n        },\\r\\n        erect3DArray2: (array, width, height, depth) => {\\r\\n          const xResultsMax = width * 4;\\r\\n          const zResults = new Array(depth);\\r\\n          for (let z = 0; z < depth; z++) {\\r\\n            const yResults = new Array(height);\\r\\n            for (let y = 0; y < height; y++) {\\r\\n              const xResults = new Array(width);\\r\\n              const offset = (z * xResultsMax * height) + (y * xResultsMax);\\r\\n              let i = 0;\\r\\n              for (let x = 0; x < xResultsMax; x += 4) {\\r\\n                xResults[i++] = array.subarray(x + offset, x + offset + 2);\\r\\n              }\\r\\n              yResults[y] = xResults;\\r\\n            }\\r\\n            zResults[z] = yResults;\\r\\n          }\\r\\n          return zResults;\\r\\n        },\\r\\n        erectArray3: (array, width) => {\\r\\n          const xResults = new Array(width);\\r\\n          const xResultsMax = width * 4;\\r\\n          let i = 0;\\r\\n          for (let x = 0; x < xResultsMax; x += 4) {\\r\\n            xResults[i++] = array.subarray(x, x + 3);\\r\\n          }\\r\\n          return xResults;\\r\\n        },\\r\\n        erect2DArray3: (array, width, height) => {\\r\\n          const xResultsMax = width * 4;\\r\\n          const yResults = new Array(height);\\r\\n          for (let y = 0; y < height; y++) {\\r\\n            const xResults = new Array(width);\\r\\n            const offset = y * xResultsMax;\\r\\n            let i = 0;\\r\\n            for (let x = 0; x < xResultsMax; x += 4) {\\r\\n              xResults[i++] = array.subarray(x + offset, x + offset + 3);\\r\\n            }\\r\\n            yResults[y] = xResults;\\r\\n          }\\r\\n          return yResults;\\r\\n        },\\r\\n        erect3DArray3: (array, width, height, depth) => {\\r\\n          const xResultsMax = width * 4;\\r\\n          const zResults = new Array(depth);\\r\\n          for (let z = 0; z < depth; z++) {\\r\\n            const yResults = new Array(height);\\r\\n            for (let y = 0; y < height; y++) {\\r\\n              const xResults = new Array(width);\\r\\n              const offset = (z * xResultsMax * height) + (y * xResultsMax);\\r\\n              let i = 0;\\r\\n              for (let x = 0; x < xResultsMax; x += 4) {\\r\\n                xResults[i++] = array.subarray(x + offset, x + offset + 3);\\r\\n              }\\r\\n              yResults[y] = xResults;\\r\\n            }\\r\\n            zResults[z] = yResults;\\r\\n          }\\r\\n          return zResults;\\r\\n        },\\r\\n        erectArray4: (array, width) => {\\r\\n          const xResults = new Array(array);\\r\\n          const xResultsMax = width * 4;\\r\\n          let i = 0;\\r\\n          for (let x = 0; x < xResultsMax; x += 4) {\\r\\n            xResults[i++] = array.subarray(x, x + 4);\\r\\n          }\\r\\n          return xResults;\\r\\n        },\\r\\n        erect2DArray4: (array, width, height) => {\\r\\n          const xResultsMax = width * 4;\\r\\n          const yResults = new Array(height);\\r\\n          for (let y = 0; y < height; y++) {\\r\\n            const xResults = new Array(width);\\r\\n            const offset = y * xResultsMax;\\r\\n            let i = 0;\\r\\n            for (let x = 0; x < xResultsMax; x += 4) {\\r\\n              xResults[i++] = array.subarray(x + offset, x + offset + 4);\\r\\n            }\\r\\n            yResults[y] = xResults;\\r\\n          }\\r\\n          return yResults;\\r\\n        },\\r\\n        erect3DArray4: (array, width, height, depth) => {\\r\\n          const xResultsMax = width * 4;\\r\\n          const zResults = new Array(depth);\\r\\n          for (let z = 0; z < depth; z++) {\\r\\n            const yResults = new Array(height);\\r\\n            for (let y = 0; y < height; y++) {\\r\\n              const xResults = new Array(width);\\r\\n              const offset = (z * xResultsMax * height) + (y * xResultsMax);\\r\\n              let i = 0;\\r\\n              for (let x = 0; x < xResultsMax; x += 4) {\\r\\n                xResults[i++] = array.subarray(x + offset, x + offset + 4);\\r\\n              }\\r\\n              yResults[y] = xResults;\\r\\n            }\\r\\n            zResults[z] = yResults;\\r\\n          }\\r\\n          return zResults;\\r\\n        },\\r\\n      \\r\\n        flattenFunctionToString: (source, settings) => {\\r\\n          const { findDependency, thisLookup, doNotDefine } = settings;\\r\\n          let flattened = settings.flattened;\\r\\n          if (!flattened) {\\r\\n            flattened = settings.flattened = {};\\r\\n          }\\r\\n          const ast = acorn.parse(source);\\r\\n          const functionDependencies = [];\\r\\n          let indent = 0;\\r\\n      \\r\\n          function flatten(ast) {\\r\\n            if (Array.isArray(ast)) {\\r\\n              const results = [];\\r\\n              for (let i = 0; i < ast.length; i++) {\\r\\n                results.push(flatten(ast[i]));\\r\\n              }\\r\\n              return results.join('');\\r\\n            }\\r\\n            switch (ast.type) {\\r\\n              case 'Program':\\r\\n                return flatten(ast.body) + (ast.body[0].type === 'VariableDeclaration' ? ';' : '');\\r\\n              case 'FunctionDeclaration':\\r\\n                return `function ${ast.id.name}(${ast.params.map(flatten).join(', ')}) ${ flatten(ast.body) }`;\\r\\n              case 'BlockStatement': {\\r\\n                const result = [];\\r\\n                indent += 2;\\r\\n                for (let i = 0; i < ast.body.length; i++) {\\r\\n                  const flat = flatten(ast.body[i]);\\r\\n                  if (flat) {\\r\\n                    result.push(' '.repeat(indent) + flat, ';\\\\n');\\r\\n                  }\\r\\n                }\\r\\n                indent -= 2;\\r\\n                return `{\\\\n${result.join('')}}`;\\r\\n              }\\r\\n              case 'VariableDeclaration':\\r\\n                const declarations = utils.normalizeDeclarations(ast)\\r\\n                  .map(flatten)\\r\\n                  .filter(r => r !== null);\\r\\n                if (declarations.length < 1) {\\r\\n                  return '';\\r\\n                } else {\\r\\n                  return `${ast.kind} ${declarations.join(',')}`;\\r\\n                }\\r\\n                case 'VariableDeclarator':\\r\\n                  if (ast.init.object && ast.init.object.type === 'ThisExpression') {\\r\\n                    const lookup = thisLookup(ast.init.property.name, true);\\r\\n                    if (lookup) {\\r\\n                      return `${ast.id.name} = ${flatten(ast.init)}`;\\r\\n                    } else {\\r\\n                      return null;\\r\\n                    }\\r\\n                  } else {\\r\\n                    return `${ast.id.name} = ${flatten(ast.init)}`;\\r\\n                  }\\r\\n                  case 'CallExpression': {\\r\\n                    if (ast.callee.property.name === 'subarray') {\\r\\n                      return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\\r\\n                    }\\r\\n                    if (ast.callee.object.name === 'gl' || ast.callee.object.name === 'context') {\\r\\n                      return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\\r\\n                    }\\r\\n                    if (ast.callee.object.type === 'ThisExpression') {\\r\\n                      functionDependencies.push(findDependency('this', ast.callee.property.name));\\r\\n                      return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\\r\\n                    } else if (ast.callee.object.name) {\\r\\n                      const foundSource = findDependency(ast.callee.object.name, ast.callee.property.name);\\r\\n                      if (foundSource === null) {\\r\\n                        return `${ast.callee.object.name}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\\r\\n                      } else {\\r\\n                        functionDependencies.push(foundSource);\\r\\n                        return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\\r\\n                      }\\r\\n                    } else if (ast.callee.object.type === 'MemberExpression') {\\r\\n                      return `${flatten(ast.callee.object)}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\\r\\n                    } else {\\r\\n                      throw new Error('unknown ast.callee');\\r\\n                    }\\r\\n                  }\\r\\n                  case 'ReturnStatement':\\r\\n                    return `return ${flatten(ast.argument)}`;\\r\\n                  case 'BinaryExpression':\\r\\n                    return `(${flatten(ast.left)}${ast.operator}${flatten(ast.right)})`;\\r\\n                  case 'UnaryExpression':\\r\\n                    if (ast.prefix) {\\r\\n                      return `${ast.operator} ${flatten(ast.argument)}`;\\r\\n                    } else {\\r\\n                      return `${flatten(ast.argument)} ${ast.operator}`;\\r\\n                    }\\r\\n                    case 'ExpressionStatement':\\r\\n                      return `${flatten(ast.expression)}`;\\r\\n                    case 'SequenceExpression':\\r\\n                      return `(${flatten(ast.expressions)})`;\\r\\n                    case 'ArrowFunctionExpression':\\r\\n                      return `(${ast.params.map(flatten).join(', ')}) => ${flatten(ast.body)}`;\\r\\n                    case 'Literal':\\r\\n                      return ast.raw;\\r\\n                    case 'Identifier':\\r\\n                      return ast.name;\\r\\n                    case 'MemberExpression':\\r\\n                      if (ast.object.type === 'ThisExpression') {\\r\\n                        return thisLookup(ast.property.name);\\r\\n                      }\\r\\n                      if (ast.computed) {\\r\\n                        return `${flatten(ast.object)}[${flatten(ast.property)}]`;\\r\\n                      }\\r\\n                      return flatten(ast.object) + '.' + flatten(ast.property);\\r\\n                    case 'ThisExpression':\\r\\n                      return 'this';\\r\\n                    case 'NewExpression':\\r\\n                      return `new ${flatten(ast.callee)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;\\r\\n                    case 'ForStatement':\\r\\n                      return `for (${flatten(ast.init)};${flatten(ast.test)};${flatten(ast.update)}) ${flatten(ast.body)}`;\\r\\n                    case 'AssignmentExpression':\\r\\n                      return `${flatten(ast.left)}${ast.operator}${flatten(ast.right)}`;\\r\\n                    case 'UpdateExpression':\\r\\n                      return `${flatten(ast.argument)}${ast.operator}`;\\r\\n                    case 'IfStatement':\\r\\n                      return `if (${flatten(ast.test)}) ${flatten(ast.consequent)}`;\\r\\n                    case 'ThrowStatement':\\r\\n                      return `throw ${flatten(ast.argument)}`;\\r\\n                    case 'ObjectPattern':\\r\\n                      return ast.properties.map(flatten).join(', ');\\r\\n                    case 'ArrayPattern':\\r\\n                      return ast.elements.map(flatten).join(', ');\\r\\n                    case 'DebuggerStatement':\\r\\n                      return 'debugger;';\\r\\n                    case 'ConditionalExpression':\\r\\n                      return `${flatten(ast.test)}?${flatten(ast.consequent)}:${flatten(ast.alternate)}`;\\r\\n                    case 'Property':\\r\\n                      if (ast.kind === 'init') {\\r\\n                        return flatten(ast.key);\\r\\n                      }\\r\\n            }\\r\\n            throw new Error(`unhandled ast.type of ${ ast.type }`);\\r\\n          }\\r\\n          const result = flatten(ast);\\r\\n          if (functionDependencies.length > 0) {\\r\\n            const flattenedFunctionDependencies = [];\\r\\n            for (let i = 0; i < functionDependencies.length; i++) {\\r\\n              const functionDependency = functionDependencies[i];\\r\\n              if (!flattened[functionDependency]) {\\r\\n                flattened[functionDependency] = true;\\r\\n              }\\r\\n              functionDependency ? flattenedFunctionDependencies.push(utils.flattenFunctionToString(functionDependency, settings) + '\\\\n') : '';\\r\\n            }\\r\\n            return flattenedFunctionDependencies.join('') + result;\\r\\n          }\\r\\n          return result;\\r\\n        },\\r\\n      \\r\\n        normalizeDeclarations: (ast) => {\\r\\n          if (ast.type !== 'VariableDeclaration') throw new Error('Ast is not of type \\\"VariableDeclaration\\\"');\\r\\n          const normalizedDeclarations = [];\\r\\n          for (let declarationIndex = 0; declarationIndex < ast.declarations.length; declarationIndex++) {\\r\\n            const declaration = ast.declarations[declarationIndex];\\r\\n            if (declaration.id && declaration.id.type === 'ObjectPattern' && declaration.id.properties) {\\r\\n              const { properties } = declaration.id;\\r\\n              for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {\\r\\n                const property = properties[propertyIndex];\\r\\n                if (property.value.type === 'ObjectPattern' && property.value.properties) {\\r\\n                  for (let subPropertyIndex = 0; subPropertyIndex < property.value.properties.length; subPropertyIndex++) {\\r\\n                    const subProperty = property.value.properties[subPropertyIndex];\\r\\n                    if (subProperty.type === 'Property') {\\r\\n                      normalizedDeclarations.push({\\r\\n                        type: 'VariableDeclarator',\\r\\n                        id: {\\r\\n                          type: 'Identifier',\\r\\n                          name: subProperty.key.name\\r\\n                        },\\r\\n                        init: {\\r\\n                          type: 'MemberExpression',\\r\\n                          object: {\\r\\n                            type: 'MemberExpression',\\r\\n                            object: declaration.init,\\r\\n                            property: {\\r\\n                              type: 'Identifier',\\r\\n                              name: property.key.name\\r\\n                            },\\r\\n                            computed: false\\r\\n                          },\\r\\n                          property: {\\r\\n                            type: 'Identifier',\\r\\n                            name: subProperty.key.name\\r\\n                          },\\r\\n                          computed: false\\r\\n                        }\\r\\n                      });\\r\\n                    } else {\\r\\n                      throw new Error('unexpected state');\\r\\n                    }\\r\\n                  }\\r\\n                } else if (property.value.type === 'Identifier') {\\r\\n                  normalizedDeclarations.push({\\r\\n                    type: 'VariableDeclarator',\\r\\n                    id: {\\r\\n                      type: 'Identifier',\\r\\n                      name: property.value && property.value.name ? property.value.name : property.key.name\\r\\n                    },\\r\\n                    init: {\\r\\n                      type: 'MemberExpression',\\r\\n                      object: declaration.init,\\r\\n                      property: {\\r\\n                        type: 'Identifier',\\r\\n                        name: property.key.name\\r\\n                      },\\r\\n                      computed: false\\r\\n                    }\\r\\n                  });\\r\\n                } else {\\r\\n                  throw new Error('unexpected state');\\r\\n                }\\r\\n              }\\r\\n            } else if (declaration.id && declaration.id.type === 'ArrayPattern' && declaration.id.elements) {\\r\\n              const { elements } = declaration.id;\\r\\n              for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {\\r\\n                const element = elements[elementIndex];\\r\\n                if (element.type === 'Identifier') {\\r\\n                  normalizedDeclarations.push({\\r\\n                    type: 'VariableDeclarator',\\r\\n                    id: {\\r\\n                      type: 'Identifier',\\r\\n                      name: element.name\\r\\n                    },\\r\\n                    init: {\\r\\n                      type: 'MemberExpression',\\r\\n                      object: declaration.init,\\r\\n                      property: {\\r\\n                        type: 'Literal',\\r\\n                        value: elementIndex,\\r\\n                        raw: elementIndex.toString(),\\r\\n                        start: element.start,\\r\\n                        end: element.end\\r\\n                      },\\r\\n                      computed: true\\r\\n                    }\\r\\n                  });\\r\\n                } else {\\r\\n                  throw new Error('unexpected state');\\r\\n                }\\r\\n              }\\r\\n            } else {\\r\\n              normalizedDeclarations.push(declaration);\\r\\n            }\\r\\n          }\\r\\n          return normalizedDeclarations;\\r\\n        },\\r\\n      \\r\\n        splitHTMLImageToRGB: (gpu, image) => {\\r\\n          const rKernel = gpu.createKernel(function(a) {\\r\\n            const pixel = a[this.thread.y][this.thread.x];\\r\\n            return pixel.r * 255;\\r\\n          }, {\\r\\n            output: [image.width, image.height],\\r\\n            precision: 'unsigned',\\r\\n            argumentTypes: { a: 'HTMLImage' },\\r\\n          });\\r\\n          const gKernel = gpu.createKernel(function(a) {\\r\\n            const pixel = a[this.thread.y][this.thread.x];\\r\\n            return pixel.g * 255;\\r\\n          }, {\\r\\n            output: [image.width, image.height],\\r\\n            precision: 'unsigned',\\r\\n            argumentTypes: { a: 'HTMLImage' },\\r\\n          });\\r\\n          const bKernel = gpu.createKernel(function(a) {\\r\\n            const pixel = a[this.thread.y][this.thread.x];\\r\\n            return pixel.b * 255;\\r\\n          }, {\\r\\n            output: [image.width, image.height],\\r\\n            precision: 'unsigned',\\r\\n            argumentTypes: { a: 'HTMLImage' },\\r\\n          });\\r\\n          const aKernel = gpu.createKernel(function(a) {\\r\\n            const pixel = a[this.thread.y][this.thread.x];\\r\\n            return pixel.a * 255;\\r\\n          }, {\\r\\n            output: [image.width, image.height],\\r\\n            precision: 'unsigned',\\r\\n            argumentTypes: { a: 'HTMLImage' },\\r\\n          });\\r\\n          const result = [\\r\\n            rKernel(image),\\r\\n            gKernel(image),\\r\\n            bKernel(image),\\r\\n            aKernel(image),\\r\\n          ];\\r\\n          result.rKernel = rKernel;\\r\\n          result.gKernel = gKernel;\\r\\n          result.bKernel = bKernel;\\r\\n          result.aKernel = aKernel;\\r\\n          result.gpu = gpu;\\r\\n          return result;\\r\\n        },\\r\\n      \\r\\n        splitRGBAToCanvases: (gpu, rgba, width, height) => {\\r\\n          const visualKernelR = gpu.createKernel(function(v) {\\r\\n            const pixel = v[this.thread.y][this.thread.x];\\r\\n            this.color(pixel.r / 255, 0, 0, 255);\\r\\n          }, {\\r\\n            output: [width, height],\\r\\n            graphical: true,\\r\\n            argumentTypes: { v: 'Array2D(4)' }\\r\\n          });\\r\\n          visualKernelR(rgba);\\r\\n      \\r\\n          const visualKernelG = gpu.createKernel(function(v) {\\r\\n            const pixel = v[this.thread.y][this.thread.x];\\r\\n            this.color(0, pixel.g / 255, 0, 255);\\r\\n          }, {\\r\\n            output: [width, height],\\r\\n            graphical: true,\\r\\n            argumentTypes: { v: 'Array2D(4)' }\\r\\n          });\\r\\n          visualKernelG(rgba);\\r\\n      \\r\\n          const visualKernelB = gpu.createKernel(function(v) {\\r\\n            const pixel = v[this.thread.y][this.thread.x];\\r\\n            this.color(0, 0, pixel.b / 255, 255);\\r\\n          }, {\\r\\n            output: [width, height],\\r\\n            graphical: true,\\r\\n            argumentTypes: { v: 'Array2D(4)' }\\r\\n          });\\r\\n          visualKernelB(rgba);\\r\\n      \\r\\n          const visualKernelA = gpu.createKernel(function(v) {\\r\\n            const pixel = v[this.thread.y][this.thread.x];\\r\\n            this.color(255, 255, 255, pixel.a / 255);\\r\\n          }, {\\r\\n            output: [width, height],\\r\\n            graphical: true,\\r\\n            argumentTypes: { v: 'Array2D(4)' }\\r\\n          });\\r\\n          visualKernelA(rgba);\\r\\n          return [\\r\\n            visualKernelR.canvas,\\r\\n            visualKernelG.canvas,\\r\\n            visualKernelB.canvas,\\r\\n            visualKernelA.canvas,\\r\\n          ];\\r\\n        },\\r\\n      \\r\\n        getMinifySafeName: (fn) => {\\r\\n          try {\\r\\n            const ast = acorn.parse(`const value = ${fn.toString()}`);\\r\\n            const { init } = ast.body[0].declarations[0];\\r\\n            return init.body.name || init.body.body[0].argument.name;\\r\\n          } catch (e) {\\r\\n            throw new Error('Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }');\\r\\n          }\\r\\n        },\\r\\n        sanitizeName: function(name) {\\r\\n          if (dollarSign.test(name)) {\\r\\n            name = name.replace(dollarSign, 'S_S');\\r\\n          }\\r\\n          if (doubleUnderscore.test(name)) {\\r\\n            name = name.replace(doubleUnderscore, 'U_U');\\r\\n          } else if (singleUnderscore.test(name)) {\\r\\n            name = name.replace(singleUnderscore, 'u_u');\\r\\n          }\\r\\n          return name;\\r\\n        }\\r\\n      };\\r\\n      \\r\\n      const dollarSign = /\\\\$/;\\r\\n      const doubleUnderscore = /__/;\\r\\n      const singleUnderscore = /_/;\\r\\n      \\r\\n      const _systemEndianness = utils.getSystemEndianness();\\r\\n      \\r\\n      module.exports = {\\r\\n        utils\\r\\n      };\\r\\n      },{\\\"./input\\\":110,\\\"./texture\\\":113,\\\"acorn\\\":1}]},{},[107])(107)\\r\\n      });\\n\\n/***/ }),\\n\\n/***/ 526:\\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\\n\\n\\\"use strict\\\";\\n\\n// EXPORTS\\n__webpack_require__.d(__webpack_exports__, {\\n  \\\"T9\\\": () => (/* binding */ gpuUtils)\\n});\\n\\n// UNUSED EXPORTS: makeCanvasKrnl, makeKrnl\\n\\n// EXTERNAL MODULE: ./node_modules/gpujsutils/src/gpu-browser.min.js\\nvar gpu_browser_min = __webpack_require__(759);\\n;// CONCATENATED MODULE: ./node_modules/gpujsutils/src/gpuUtils-functs.js\\n//By Joshua Brewster, Dovydas Stirpeika (AGPL v3.0 License)\\r\\n//------------------------------------\\r\\n//---------GPU Utility Funcs---------- (gpu.addFunction())\\r\\n//------------------------------------\\r\\n\\r\\n\\r\\nfunction add(a, b) { return a + b; }\\r\\nfunction sub(a, b) { return a - b; }\\r\\nfunction mul(a, b) { return a * b; }\\r\\nfunction div(a, b) { return a / b; }\\r\\n\\r\\nfunction cadd(a_real, a_imag, b_real, b_imag) {\\r\\n    return [a_real + b_real, a_imag + b_imag];\\r\\n}\\r\\n\\r\\nfunction csub(a_real, a_imag, b_real, b_imag) {\\r\\n    return [a_real - b_real, a_imag - b_imag];\\r\\n}\\r\\n\\r\\nfunction cmul(a_real, a_imag, b_real, b_imag) {\\r\\n    return [a_real*b_real - a_imag*b_imag, a_real*b_imag + a_imag*b_real];\\r\\n}\\r\\n\\r\\nfunction cexp(a_real, a_imag) {\\r\\n    const er = Math.exp(a_real);\\r\\n    return [er * Math.cos(a_imag), er * Math.sin(a_imag)];\\r\\n}\\r\\n\\r\\nfunction mag(a, b) { // Returns magnitude\\r\\n    return Math.sqrt(a*a + b*b);\\r\\n}\\r\\n\\r\\nfunction conj(imag) { //Complex conjugate of x + iy is x - iy\\r\\n    return 0 - imag;\\r\\n}\\r\\n\\r\\nfunction lof(n) { //Lowest odd factor\\r\\n    const sqrt_n = Math.sqrt(n);\\r\\n    var factor = 3;\\r\\n\\r\\n    while(factor <= sqrt_n) {\\r\\n        if (n % factor === 0) return factor;\\r\\n        factor += 2;\\r\\n    }\\r\\n}\\r\\n\\r\\nfunction mean(arr, len) {\\r\\n    var mean = 0;\\r\\n    for (var i = 0; i < len; i++) {\\r\\n        mean += arr[i];\\r\\n    }\\r\\n    return mean/len;\\r\\n}\\r\\n\\r\\nfunction est(arr, mean, len) {\\r\\n    var est = 0;\\r\\n    for (var i=0; i<len;i++){\\r\\n        est += (arr[i]-mean)*(arr[i]-mean);\\r\\n    }\\r\\n    return Math.sqrt(est);\\r\\n}\\r\\n\\r\\nfunction mse(arr, mean, len) { //mean squared error\\r\\n    var est = 0;\\r\\n    var vari = 0;\\r\\n    for (var i = 0; i < len; i++) {\\r\\n        vari = arr[i]-mean;\\r\\n        est += vari*vari;\\r\\n    }\\r\\n    return est/len;\\r\\n}\\r\\n\\r\\nfunction rms(arr, mean, len) { //root mean square error\\r\\n    var est = 0;\\r\\n    var vari = 0;\\r\\n    for (var i = 0; i < len; i++) {\\r\\n        vari = arr[i]-mean;\\r\\n        est += vari*vari;\\r\\n    }\\r\\n    return Math.sqrt(est/len);\\r\\n}\\r\\n\\r\\nfunction xcor(arr1, arr1mean, arr1Est, arr2, arr2mean, arr2Est, len, delay) { //performs a single pass of a cross correlation equation, see correlogramsKern\\r\\n    var correlation = 0;\\r\\n    for (var i = 0; i < len; i++)  {\\r\\n        var j = i+delay;\\r\\n        var k = 0;\\r\\n        if(j < len) { k = arr2[j]; }\\r\\n        correlation += (arr1[i]-arr1mean)*(k-arr2mean);\\r\\n    }\\r\\n    return correlation/(arr1Est*arr2Est);\\r\\n}\\r\\n\\r\\nfunction softmax(array, len, i) { // Returns a single array value for a 1d softmax function.\\r\\n    var esum = 0;\\r\\n    for(var j = 0; j < len; j++){\\r\\n        esum+= Math.exp(array[j]);\\r\\n    }\\r\\n    return Math.exp(array[i])/esum;\\r\\n}\\r\\n\\r\\nfunction DFT(signal, len, freq){ //Extract a particular frequency\\r\\n    var real = 0;\\r\\n    var imag = 0;\\r\\n    var _len = 1/len;\\r\\n    var shared = 6.28318530718*freq*_len;\\r\\n\\r\\n    for(var i = 0; i<len; i++){\\r\\n      var sharedi = shared*i; //this.thread.x is the target frequency\\r\\n      real = real+signal[i]*Math.cos(sharedi);\\r\\n      imag = imag-signal[i]*Math.sin(sharedi);\\r\\n    }\\r\\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\\r\\n    return [real*_len,imag*_len]; //mag(real,imag)\\r\\n}\\r\\n\\r\\nfunction DFTlist(signals, len, freq, n) { //Extract a particular frequency\\r\\n    var real = 0;\\r\\n    var imag = 0;\\r\\n    var _len = 1/len;\\r\\n    var shared = 6.28318530718*freq*_len;\\r\\n    for(var i = 0; i<len; i++){\\r\\n      var sharedi = shared*i; //this.thread.x is the target frequency\\r\\n      real = real+signals[i+(len-1)*n]*Math.cos(sharedi);\\r\\n      imag = imag-signals[i+(len-1)*n]*Math.sin(sharedi);  \\r\\n    }\\r\\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\\r\\n    return [real*_len,imag*_len]; //mag(real,imag)\\r\\n}\\r\\n\\r\\n//FFT, simply implements a nyquist frequency based index skip for frequencies <= sampleRate*.25.\\r\\n//Other optimization: could do 4 loops per thread and return a vec4, this is what you see in some other ultrafast libs\\r\\nfunction FFT(signal, len, freq, sr){ //Extract a particular frequency\\r\\n    var real = 0;\\r\\n    var imag = 0;\\r\\n    var _len = 1/len;\\r\\n    var shared = 6.28318530718*freq*_len;\\r\\n\\r\\n    var skip = 1;\\r\\n    var N = 0;\\r\\n    var factor = sr*.25;\\r\\n    if(freq <= factor){\\r\\n        while(freq <= factor){\\r\\n            factor=factor*.5;\\r\\n            skip+=1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    for(var i = 0; i<len; i+=skip){\\r\\n      var j = i;\\r\\n      if(j > len) { j = len; }\\r\\n      var sharedi = shared*j; //this.thread.x is the target frequency\\r\\n      real = real+signal[j]*Math.cos(sharedi);\\r\\n      imag = imag-signal[j]*Math.sin(sharedi);\\r\\n      N += 1;\\r\\n    }\\r\\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\\r\\n    return [real/N,imag/N]; //mag(real,imag)\\r\\n}\\r\\n\\r\\nfunction FFTlist(signals, len, freq, n, sr) { //Extract a particular frequency from a 1D list of equal sized signal arrays. Uses less samples for lower frequencies closer to nyquist threshold\\r\\n    var real = 0;\\r\\n    var imag = 0;\\r\\n    var _len = 1/len;\\r\\n    var shared = 6.28318530718*freq*_len;\\r\\n\\r\\n    var skip = 1;\\r\\n    var N = 0;\\r\\n    var factor = sr*.25;\\r\\n    if(freq <= factor){\\r\\n        while(freq <= factor){\\r\\n            factor=factor*.5;\\r\\n            skip+=1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    for(var i = 0; i<len; i+=skip){\\r\\n        var j = i;\\r\\n      if(j > len) { j = len; }\\r\\n      var sharedi = shared*j; //this.thread.x is the target frequency\\r\\n      real = real+signals[j+(len-1)*n]*Math.cos(sharedi);\\r\\n      imag = imag-signals[j+(len-1)*n]*Math.sin(sharedi);\\r\\n      N += 1;  \\r\\n    }\\r\\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\\r\\n    return [real/N,imag/N]; //mag(real,imag)\\r\\n}\\r\\n\\r\\n//Conjugated real and imaginary parts for iDFT (need to test still)\\r\\nfunction iDFT(fft, len, freq){ //inverse DFT to return time domain\\r\\n    var real = 0;\\r\\n    var imag = 0;\\r\\n    var _len = 1/len;\\r\\n    var shared = 6.28318530718*freq*_len;\\r\\n\\r\\n    for(var i = 0; i<len; i++){\\r\\n      var sharedi = shared*i; //this.thread.x is the target frequency\\r\\n      real = real+fft[i]*Math.cos(sharedi);\\r\\n      imag = fft[i]*Math.sin(sharedi)-imag;  \\r\\n    }\\r\\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\\r\\n    return [real*_len,imag*_len]; //mag(real,imag)\\r\\n}\\r\\n\\r\\nfunction iDFTlist(fft,len,freq,n){ //inverse DFT to return time domain \\r\\n    var real = 0;\\r\\n    var imag = 0;\\r\\n    var _len = 1/len;\\r\\n    var shared = 6.28318530718*freq*_len\\r\\n    for (var i = 0; i<len; i++) {\\r\\n      var sharedi = shared*i; //this.thread.x is the target frequency\\r\\n      real = real+fft[i+(len-1)*n]*Math.cos(sharedi);\\r\\n      imag = fft[i+(len-1)*n]*Math.sin(sharedi)-imag;  \\r\\n    }\\r\\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\\r\\n    return [real*_len,imag*_len]; //mag(real,imag)\\r\\n}\\r\\n\\r\\nfunction iFFT(fft, len, freq, sr){ //inverse FFT to return time domain\\r\\n    var real = 0;\\r\\n    var imag = 0;\\r\\n    var _len = 1/len;\\r\\n    var shared = 6.28318530718*freq*_len;\\r\\n\\r\\n    var skip = 1;\\r\\n    var N = 0;\\r\\n    var factor = sr*.25;\\r\\n    if(freq <= factor){\\r\\n        while(freq <= factor){\\r\\n            factor=factor*.5;\\r\\n            skip+=1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    for(var i = 0; i<len; i+=skip){\\r\\n      var j = i;\\r\\n      if(j > len) { j = len; }\\r\\n      var sharedi = shared*j; //this.thread.x is the target frequency\\r\\n      real = real+fft[j]*Math.cos(sharedi);\\r\\n      imag = fft[j]*Math.sin(sharedi)-imag;  \\r\\n      N += 1;\\r\\n    }\\r\\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\\r\\n    return [real/N,imag/N]; //mag(real,imag)\\r\\n}\\r\\n\\r\\nfunction iFFTlist(signals, len, freq, n, sr) { //Extract a particular frequency from a 1D list of equal sized signal arrays. Uses less samples for lower frequencies closer to nyquist threshold\\r\\n    var real = 0;\\r\\n    var imag = 0;\\r\\n    var _len = 1/len;\\r\\n    var shared = 6.28318530718*freq*_len;\\r\\n\\r\\n    var skip = 1;\\r\\n    var N = 0;\\r\\n    var factor = sr*.25;\\r\\n    if(freq <= factor){\\r\\n        while(freq <= factor){\\r\\n            factor=factor*.5;\\r\\n            skip+=1;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    for(var i = 0; i<len; i+=skip){\\r\\n        var j = i;\\r\\n      if(j > len) { j = len; }\\r\\n      var sharedi = shared*j; //this.thread.x is the target frequency\\r\\n      real = real+signals[j+(len-1)*n]*Math.cos(sharedi);\\r\\n      imag = signals[j+(len-1)*n]*Math.sin(sharedi)-imag;\\r\\n      N += 1;  \\r\\n    }\\r\\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\\r\\n    return [real/N,imag/N]; //mag(real,imag)\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n//------------------------------------\\r\\n//---------Kernel functions----------- (gpu.createKernel(func))\\r\\n//------------------------------------\\r\\n\\r\\n\\r\\nfunction correlogramsKern(arrays, len) { //Computes cross correlations of each pair of arrays given to the function. so xcor[0,1],xcor[2,3],etc\\r\\n\\r\\n    var k = Math.floor(this.thread.x/len)*2;\\r\\n    var delay = this.thread.x - Math.floor(this.thread.x/len)*len;\\r\\n    var arr1mean = mean(arrays[k],len);\\r\\n    var arr2mean = mean(arrays[k+1],len);\\r\\n    var arr1Est = est(arrays[k],arr1mean,len);\\r\\n    var arr2Est = est(arrays[k+1],arr2mean,len);\\r\\n\\r\\n    var y_x = xcor(arrays[k],arr1mean,arr1Est,arrays[k+1],arr2mean,arr2Est,len,delay);\\r\\n\\r\\n    return y_x;\\r\\n}\\r\\n\\r\\n//Computes cross correlations of each pair of arrays given to the function. so xcor[0,1],xcor[2,3],etc\\r\\n//Takes precomputed averages and estimators for each array for efficiency\\r\\nfunction correlogramsPCKern(arrays, len, means, estimators) { \\r\\n    var k = Math.floor(this.thread.x/len)*2;\\r\\n    var delay = this.thread.x - Math.floor(this.thread.x/len)*len;\\r\\n    var arr1mean = means[k];\\r\\n    var arr2mean = means[k+1];\\r\\n    var arr1Est = estimators[k];\\r\\n    var arr2Est = estimators[k+1];\\r\\n\\r\\n    var y_x = xcor(arrays[k],arr1mean,arr1Est,arrays[k+1],arr2mean,arr2Est,len,delay);\\r\\n\\r\\n    return y_x;\\r\\n}\\r\\n\\r\\n\\r\\n//Return frequency domain based on DFT\\r\\nfunction dftKern(signal, len, scalar) {\\r\\n    var result = DFT(signal,len, this.thread.x);\\r\\n    return mag(result[0], result[1])*scalar;\\r\\n}\\r\\n\\r\\nfunction idftKern(amplitudes, len, scalar) {\\r\\n    var result = iDFT(amplitudes, len, this.thread.x);\\r\\n    return mag(result[0], result[1])*scalar;\\r\\n}\\r\\n\\r\\nfunction fftKern(signal, len, scalar, sampleRate) {\\r\\n    var result = FFT(signal,len, this.thread.x, sampleRate);\\r\\n    return mag(result[0], result[1])*scalar;\\r\\n}\\r\\n\\r\\nfunction ifftKern(amplitudes, len, scalar, sampleRate) {\\r\\n    var result = iFFT(amplitudes, len, this.thread.x, sampleRate);\\r\\n    return mag(result[0], result[1])*scalar;\\r\\n}\\r\\n\\r\\n// Takes a 2D array input [signal1[],signal2[],signal3[]]; does not work atm\\r\\nfunction listdft2DKern(signals, scalar) {\\r\\n    var len = this.output.x;\\r\\n    var result = DFT(signals[this.thread.y],len,this.thread.x);\\r\\n    //var mag = Math.sqrt(real[k]*real[k]+imag[k]*imag[k]);\\r\\n    return mag(result[0],result[1])*scalar; //mag(real,imag)\\r\\n}\\r\\n\\r\\n// [[signals1][signals2]]\\r\\n\\r\\n// More like a vertex buffer list to chunk through lists of signals\\r\\nfunction listdft1DKern(signals, len, scalar) {\\r\\n    var result = [0, 0];\\r\\n    if (this.thread.x <= len) {\\r\\n      result = DFT(signals,len,this.thread.x);\\r\\n    } else {\\r\\n      var n = Math.floor(this.thread.x/len);\\r\\n      result = DFTlist(signals,len,this.thread.x-n*len,n);\\r\\n    }\\r\\n\\r\\n    return mag(result[0],result[1])*scalar;\\r\\n} // [signals1,signasl2]\\r\\n\\r\\n// More like a vertex buffer list to chunk through lists of signals\\r\\nfunction listfft1DKern(signals, len, scalar, sps) {\\r\\n    var result = [0, 0];\\r\\n    if (this.thread.x <= len) {\\r\\n      result = FFT(signals,len,this.thread.x,sps);\\r\\n    } else {\\r\\n      var n = Math.floor(this.thread.x/len);\\r\\n      result = FFTlist(signals,len,this.thread.x-n*len,n,sps);\\r\\n    }\\r\\n\\r\\n    return mag(result[0],result[1])*scalar;\\r\\n} // [signals1,signasl2]\\r\\n\\r\\nfunction dft_windowedKern(signal, sampleRate, freqStart, freqEnd, scalar) {\\r\\n    var result = [0,0];\\r\\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n    result = DFT(signal,sampleRate,freq);\\r\\n\\r\\n    return mag(result[0],result[1])*scalar;\\r\\n} \\r\\n\\r\\n\\r\\n//windowed functions should use a 1 second window for these hacky DFTs/FFTs to work right.\\r\\n\\r\\nfunction fft_windowedKern(signal, sampleRate, freqStart, freqEnd, scalar) {\\r\\n    var result = [0,0];\\r\\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n    result = FFT(signal,sampleRate,freq);\\r\\n\\r\\n    return mag(result[0],result[1])*scalar;\\r\\n}\\r\\n\\r\\nfunction idft_windowedKern(amplitudes, sampleRate, freqStart, freqEnd, scalar) {\\r\\n    var result = [0,0];\\r\\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n    result = iDFT(amplitudes,sampleRate,freq);\\r\\n\\r\\n    return mag(result[0],result[1])*scalar;\\r\\n}\\r\\n\\r\\nfunction ifft_windowedKern(amplitudes, sampleRate, freqStart, freqEnd, scalar) {\\r\\n    var result = [0,0];\\r\\n    var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n    result = iFFT(amplitudes,sampleRate,freq);\\r\\n\\r\\n    return mag(result[0],result[1])*scalar;\\r\\n}\\r\\n\\r\\nfunction listdft1D_windowedKern(signals, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\\r\\n    var result = [0, 0];\\r\\n    if (this.thread.x < sampleRate) {\\r\\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n      result = DFT(signals,sampleRate,freq);\\r\\n    } else {\\r\\n      var n = Math.floor(this.thread.x/sampleRate);\\r\\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n      result = DFTlist(signals,sampleRate,freq-n*sampleRate,n);\\r\\n    }\\r\\n    //var mags = mag(result[0],result[1]);\\r\\n\\r\\n    return mag(result[0],result[1])*scalar; \\r\\n}\\r\\n\\r\\nfunction listfft1D_windowedKern(signals, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\\r\\n    var result = [0, 0];\\r\\n    if (this.thread.x < sampleRate) {\\r\\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n      result = FFT(signals,sampleRate,freq,sampleRate);\\r\\n    } else {\\r\\n      var n = Math.floor(this.thread.x/sampleRate);\\r\\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n      result = FFTlist(signals,sampleRate,freq-n*sampleRate,n,sampleRate);\\r\\n    }\\r\\n    //var mags = mag(result[0],result[1]);\\r\\n\\r\\n    return mag(result[0],result[1])*scalar; \\r\\n}\\r\\n\\r\\nfunction listidft1D_windowedKern(ffts, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\\r\\n    var result = [0, 0];\\r\\n    if (this.thread.x < sampleRate) {\\r\\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n      result = iDFT(ffts,sampleRate,freq);\\r\\n    } else {\\r\\n      var n = Math.floor(this.thread.x/sampleRate);\\r\\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n      result = iDFTlist(ffts,sampleRate,freq-n*sampleRate,n);\\r\\n    }\\r\\n    //var mags = mag(result[0],result[1]);\\r\\n\\r\\n    return mag(result[0]*2,result[1]*2)*scalar; //Multiply result by 2 since we are only getting the positive results and want to estimate the actual amplitudes (positive = half power, reflected in the negative axis)\\r\\n}\\r\\n\\r\\nfunction listifft1D_windowedKern(ffts, sampleRate, freqStart, freqEnd, scalar) { //Will make a higher resolution DFT for a smaller frequency window.\\r\\n    var result = [0, 0];\\r\\n    if (this.thread.x < sampleRate) {\\r\\n      var freq = ( (this.thread.x/sampleRate) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n      result = iFFT(ffts,sampleRate,freq);\\r\\n    } else {\\r\\n      var n = Math.floor(this.thread.x/sampleRate);\\r\\n      var freq = ( ( ( this.thread.x - n * sampleRate) / sampleRate ) * ( freqEnd - freqStart ) ) + freqStart;\\r\\n      result = iFFTlist(ffts,sampleRate,freq-n*sampleRate,n);\\r\\n    }\\r\\n    //var mags = mag(result[0],result[1]);\\r\\n\\r\\n    return mag(result[0]*2,result[1]*2)*scalar; //Multiply result by 2 since we are only getting the positive results and want to estimate the actual amplitudes (positive = half power, reflected in the negative axis)\\r\\n}\\r\\n\\r\\n//e.g. arrays = [[arr1],[arr2],[arr3],[arr4],[arr5],[arr6]], len = 10, n = 2, scalar=1... return results of [arr1*arr2], [arr3*arr4], [arr5*arr6] as one long array that needs to be split\\r\\nfunction bulkArrayMulKern(arrays, len, n, scalar) {\\r\\n    var i = n*Math.floor(this.thread.x/len); //Jump forward in array buffer\\r\\n    var product = arrays[i][this.thread.x];\\r\\n    for (var j = 0; j < n; j++) {\\r\\n      product *= arrays[j][this.thread.x];\\r\\n    }\\r\\n    return product*scalar;\\r\\n}\\r\\n\\r\\nfunction ImgConv2DKern(img, width, height, kernel, kernelLength) {\\r\\n    let kernelRadius = (Math.sqrt(kernelLength) - 1) / 2;\\r\\n    const kSize = 2 * kernelRadius + 1;\\r\\n    let r = 0, g = 0, b = 0;\\r\\n\\r\\n    let i = -kernelRadius;\\r\\n    let kernelOffset = 0;\\r\\n    while (i <= kernelRadius) {\\r\\n        if (this.thread.x + i < 0 || this.thread.x + i >= width) {\\r\\n            i++;\\r\\n            continue;\\r\\n        }\\r\\n\\r\\n        let j = -kernelRadius;\\r\\n        while (j <= kernelRadius) {\\r\\n            if (this.thread.y + j < 0 || this.thread.y + j >= height) {\\r\\n                j++;\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            kernelOffset = (j + kernelRadius) * kSize + i + kernelRadius;\\r\\n            const weights = kernel[kernelOffset];\\r\\n            const pixel = img[this.thread.y + i][this.thread.x + j];\\r\\n            r += pixel.r * weights;\\r\\n            g += pixel.g * weights;\\r\\n            b += pixel.b * weights;\\r\\n            j++;\\r\\n        }\\r\\n        i++;\\r\\n    }\\r\\n\\r\\n    this.color(r, g, b);\\r\\n}\\r\\n\\r\\nfunction multiImgConv2DKern(img, width, height, kernels, kernelLengths, nKernels) {\\r\\n    \\r\\n    let r = 0, g = 0, b = 0;\\r\\n    for(var i = 0; i < nKernels; i++){\\r\\n\\r\\n        let kernelLength = kernelLengths[i];            \\r\\n        let kernelRadius = (Math.sqrt(kernelLength) - 1) / 2;\\r\\n        //(src, width, height, kernel, kernelRadius)\\r\\n        const kSize = 2 * kernelRadius + 1;\\r\\n        \\r\\n        let k = -kernelRadius;\\r\\n        let kernelOffset = 0;\\r\\n        while (k <= kernelRadius) {\\r\\n            if (this.thread.x + k < 0 || this.thread.x + k >= width) {\\r\\n                k++;\\r\\n                continue;\\r\\n            }\\r\\n\\r\\n            let j = -kernelRadius;\\r\\n            while (j <= kernelRadius) {\\r\\n                if (this.thread.y + j < 0 || this.thread.y + j >= height) {\\r\\n                j++;\\r\\n                continue;\\r\\n                }\\r\\n\\r\\n                kernelOffset = (j + kernelRadius) * kSize + k + kernelRadius;\\r\\n                const weights = kernels[i][kernelOffset];\\r\\n                const pixel = img[this.thread.y + k][this.thread.x + j];\\r\\n    \\r\\n                r += pixel.r * weights;\\r\\n                g += pixel.g * weights;\\r\\n                b += pixel.b * weights;\\r\\n            \\r\\n                //img[this.thread.y + k][this.thread.x + j] = pixel;      \\r\\n                    \\r\\n                j++;\\r\\n            }\\r\\n            k++;\\r\\n        }\\r\\n    }\\r\\n    this.color(r,g,b);\\r\\n}\\r\\n\\r\\nfunction transpose2DKern(mat2) { //Transpose a 2D matrix, meant to be combined\\r\\n    return mat2[this.thread.y][this.thread.x];\\r\\n}\\r\\n\\r\\n\\r\\n//function deferredPass(vPos, vNorm, vAlbedo, vDepth, vSpec) {  } //project geometry, light geometry\\r\\n\\r\\n/*\\r\\nScene drawing:\\r\\n(With depth testing enabled)\\r\\n1. Project object local spaces to world space based on geometry and world coordinates\\r\\n1.5 do some occlusion culling for which texture data to send to the gpu, requires last camera matrix\\r\\n2. Now send to lighting pass, with coloring properties defined by different texture maps. \\r\\n3. Project result to camera space based on camera position and aperture.\\r\\n4. Draw result\\r\\n*/\\r\\n\\r\\n\\r\\n//Note on pixel operations in gpujs: create kernel with setGraphical(true), render() to offscreencanvas, get render.getPixels() on each frame for pixel values which can be stored math operations\\r\\n\\r\\n\\r\\n//Exports\\r\\n\\r\\nconst createGpuKernels = {\\r\\n    correlogramsKern, correlogramsPCKern, dftKern, idftKern, fftKern, ifftKern,\\r\\n    dft_windowedKern, idft_windowedKern, fft_windowedKern, ifft_windowedKern, \\r\\n    listdft2DKern, listdft1DKern, listfft1DKern, listfft1D_windowedKern, listdft1D_windowedKern, listidft1D_windowedKern, listifft1D_windowedKern,\\r\\n    bulkArrayMulKern, fftKern, ifftKern, multiImgConv2DKern,\\r\\n    ImgConv2DKern\\r\\n}\\r\\n\\r\\nconst addGpuFunctions = [\\r\\n    add, sub, mul, div, cadd, csub,\\r\\n    cmul, cexp, mag, conj, lof, mean, est,\\r\\n    mse, rms, xcor, softmax, DFT, DFTlist,\\r\\n    iDFT, iDFTlist, FFT, iFFT, iFFTlist\\r\\n];\\n;// CONCATENATED MODULE: ./node_modules/gpujsutils/src/gpuUtils.js\\n // becomes a window variable\\r\\n\\r\\n\\r\\n//By Joshua Brewster, Dovydas Stirpeika (AGPL v3.0 License)\\r\\n\\r\\nfunction makeKrnl(gpu, f, opts = {\\r\\n  setDynamicOutput: true,\\r\\n  setDynamicArguments: true,\\r\\n  setPipeline: true,\\r\\n  setImmutable: true,\\r\\n  setGraphical: false\\r\\n}) {\\r\\n\\r\\n  const k = gpu.createKernel(f);\\r\\n\\r\\n  if (opts.setDynamicOutput)    k.setDynamicOutput(true);\\r\\n  if (opts.output)              k.setOutput(opts.output);\\r\\n  if (opts.setDynamicArguments) k.setDynamicArguments(true);\\r\\n  if (opts.setPipeline)         k.setPipeline(true);\\r\\n  if (opts.setImmutable)        k.setImmutable(true);\\r\\n  if (opts.setGraphical)        k.setGraphical(true);\\r\\n\\r\\n  //.setOutput([signal.length]) //Call before running the kernel\\r\\n  //.setLoopMaxIterations(signal.length);\\r\\n\\r\\n  return k;\\r\\n}\\r\\n\\r\\nfunction makeCanvasKrnl(toAppend, gpu, f, opts = {\\r\\n  output: [300,300],\\r\\n  setDynamicArguments: true,\\r\\n  setDynamicOutput: true,\\r\\n  setPipeline: false,\\r\\n  setImmutable: true,\\r\\n  setGraphical: true\\r\\n}) {\\r\\n\\r\\n  const k = makeKrnl(gpu,f,opts);\\r\\n\\r\\n  //k();\\r\\n\\r\\n  const canvas = k.canvas; \\r\\n\\r\\n  if (typeof toAppend === 'string') document.getElementById(toAppend).appendChild(canvas);\\r\\n  else toAppend.appendChild(canvas);\\r\\n\\r\\n  return k; //run k() with the input arguments in an animation loop, get graphical output.\\r\\n}\\r\\n\\r\\nclass gpuUtils {\\r\\n  \\r\\n  constructor(gpu = new GPU()) {\\r\\n    this.gpu = gpu;\\r\\n    this.kernels = []; // {name:\\\"\\\",f:foo(){}}\\r\\n\\r\\n    this.kernel;\\r\\n    this.PI = 3.141592653589793;\\r\\n    this.SQRT1_2 = 0.7071067811865476\\r\\n\\r\\n    this.addFunctions();\\r\\n\\r\\n    this.imgkernels = {\\r\\n      edgeDetection: [\\r\\n        -1, -1, -1,\\r\\n        -1,  8, -1,\\r\\n        -1, -1, -1\\r\\n      ], boxBlur: [\\r\\n        1/9, 1/9, 1/9,\\r\\n        1/9, 1/9, 1/9,\\r\\n        1/9, 1/9, 1/9\\r\\n      ], sobelLeft: [\\r\\n        1,  0, -1,\\r\\n        2,  0, -2,\\r\\n        1,  0, -1\\r\\n      ], sobelRight: [\\r\\n        -1, 0, 1,\\r\\n        -2, 0, 2,\\r\\n        -1, 0, 1\\r\\n      ], sobelTop: [\\r\\n        1,  2,  1,\\r\\n        0,  0,  0,\\r\\n        -1, -2, -1  \\r\\n      ], sobelBottom: [\\r\\n        -1, 2, 1,\\r\\n        0, 0, 0,\\r\\n        1, 2, 1\\r\\n      ], identity: [\\r\\n        0, 0, 0, \\r\\n        0, 1, 0, \\r\\n        0, 0, 0\\r\\n      ], gaussian3x3: [\\r\\n        1,  2,  1, \\r\\n        2,  4,  2, \\r\\n        1,  2,  1\\r\\n      ], guassian7x7: [\\r\\n        0, 0,  0,   5,   0,   0,  0,\\r\\n        0, 5,  18,  32,  18,  5,  0,\\r\\n        0, 18, 64,  100, 64,  18, 0,\\r\\n        5, 32, 100, 100, 100, 32, 5,\\r\\n        0, 18, 64,  100, 64,  18, 0,\\r\\n        0, 5,  18,  32,  18,  5,  0,\\r\\n        0, 0,  0,   5,   0,   0,  0,\\r\\n      ], emboss: [\\r\\n        -2, -1,  0, \\r\\n        -1,  1,  1, \\r\\n        0,  1,  2\\r\\n      ], sharpen: [\\r\\n        0, -1,  0,\\r\\n        -1,  5, -1,\\r\\n        0, -1,  0\\r\\n      ]\\r\\n    };\\r\\n  }\\r\\n\\r\\n  //adds math functions to use per-thread\\r\\n  addFunction(func = function f(){}) {\\r\\n    this.gpu.addFunction(func);\\r\\n  }\\r\\n\\r\\n  //add kernels to run based on input data. Input/Output sizes are dynamically allocated, functions are saved on the gpu to improve runtimes\\r\\n  addKernel(name=\\\"\\\", krnl=function foo(){}) {\\r\\n    let found = this.kernels.find((o)=> {\\r\\n      if(o.name === name) {\\r\\n        return true;\\r\\n      }\\r\\n    });\\r\\n    if(!found) {\\r\\n      this.kernels.push({name:name, krnl:makeKrnl(this.gpu,krnl)});\\r\\n      return true;\\r\\n    } else { \\r\\n      console.error('Kernel already exists'); \\r\\n      return false;\\r\\n    }\\r\\n    \\r\\n  }\\r\\n\\r\\n  addCanvasKernel(name, f, toAppend, opts) {\\r\\n    let found = this.kernels.find((o)=> {\\r\\n      if(o.name === name) {\\r\\n        return true;\\r\\n      }\\r\\n    });\\r\\n    if(!found) {\\r\\n      let krnl = makeCanvasKrnl(toAppend,this.gpu,f, opts)\\r\\n      this.kernels.push({name,krnl});\\r\\n      return krnl;\\r\\n    } else { \\r\\n      console.error('Kernel already exists'); \\r\\n      return false;\\r\\n    }\\r\\n    \\r\\n  }\\r\\n\\r\\n  //combine two or more kernels into a single function, this lets you run multiple kernels on the GPU (with appropriately varying inputs/output sizes) before returning to the CPU.\\r\\n  //Discount compute shaders\\r\\n  combineKernels(name, fs=[], ckrnl=function foo() {}) {\\r\\n    let found = this.kernels.find((o)=> {\\r\\n      if(o.name === name) {\\r\\n        return true;\\r\\n      }\\r\\n    });\\r\\n    if(!found) {\\r\\n      fs.forEach((f,i)=>{\\r\\n        if(typeof f === 'string') {\\r\\n          let found2 = this.krnl.find((o)=> {\\r\\n            if(o.name === name) {\\r\\n              return true;\\r\\n            }\\r\\n          });\\r\\n          if(found2) fs[i] = found2.kernel;\\r\\n          else return false;\\r\\n        } else if (typeof f === 'function') {\\r\\n          if(this[f.name]) {\\r\\n            //cool\\r\\n          } else {\\r\\n            this.addKernel(f.name, f);\\r\\n          }\\r\\n        }\\r\\n      });\\r\\n      this.kernels.push({name:name, krnl:this.gpu.combineKernels(...fs,ckrnl)});\\r\\n      return true;\\r\\n    } else { \\r\\n      console.error('Kernel already exists'); \\r\\n      return false;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  callKernel(name=\\\"\\\",args=[]) {\\r\\n    let result;\\r\\n    let found = this.kernels.find((o)=> {\\r\\n      if(o.name === name) {\\r\\n        //console.log(o.krnl,args)\\r\\n        result = o.krnl(...args);\\r\\n        return true;\\r\\n      }\\r\\n    });\\r\\n    if(!found) {\\r\\n      console.error('Kernel not found');\\r\\n      return false;\\r\\n    } else return result;\\r\\n  }\\r\\n\\r\\n  callCanvasKernel(name=\\\"\\\",args=[],outputDims=[]) {\\r\\n    let result;\\r\\n    let found = this.kernels.find((o)=> {\\r\\n      if(o.name === name) {\\r\\n        //console.log(o.krnl,args)\\r\\n        if (outputDims.length === 2) o.krnl.setOutput(outputDims);\\r\\n        result = o.krnl(...args);\\r\\n        return true;\\r\\n      }\\r\\n    });\\r\\n    if(!found) {\\r\\n      console.error('Kernel not found');\\r\\n      return false;\\r\\n    } else return result;\\r\\n  }\\r\\n\\r\\n  hasKernel(name=\\\"\\\") {\\r\\n    let found = this.kernels.find((o)=> {\\r\\n      if(o.name === name) {\\r\\n        return true;\\r\\n      }\\r\\n    });\\r\\n    if(!found) {\\r\\n      return false;\\r\\n    } else return true;\\r\\n  }\\r\\n\\r\\n  addFunctions() { \\r\\n    addGpuFunctions.forEach(f => this.gpu.addFunction(f));\\r\\n\\r\\n    this.correlograms = makeKrnl(this.gpu, createGpuKernels.correlogramsKern);\\r\\n    this.correlogramsPC = makeKrnl(this.gpu, createGpuKernels.correlogramsKern);\\r\\n    this.dft = makeKrnl(this.gpu, createGpuKernels.dftKern);\\r\\n    this.idft = makeKrnl(this.gpu, createGpuKernels.idftKern);\\r\\n    this.dft_windowed = makeKrnl(this.gpu, createGpuKernels.dft_windowedKern);\\r\\n    this.idft_windowed = makeKrnl(this.gpu, createGpuKernels.idft_windowedKern);\\r\\n    this.fft = makeKrnl(this.gpu, createGpuKernels.fftKern);\\r\\n    this.ifft = makeKrnl(this.gpu, createGpuKernels.ifftKern);\\r\\n    this.fft_windowed = makeKrnl(this.gpu, createGpuKernels.fft_windowedKern);\\r\\n    this.ifft_windowed = makeKrnl(this.gpu, createGpuKernels.ifft_windowedKern);\\r\\n    this.listdft2D = makeKrnl(this.gpu, createGpuKernels.listdft2DKern);\\r\\n    this.listdft1D = makeKrnl(this.gpu, createGpuKernels.listdft1DKern);\\r\\n    this.listdft1D_windowed = makeKrnl(this.gpu, createGpuKernels.listdft1D_windowedKern);\\r\\n    this.listfft1D = makeKrnl(this.gpu, createGpuKernels.listfft1DKern);\\r\\n    this.listfft1D_windowed = makeKrnl(this.gpu, createGpuKernels.listfft1D_windowedKern);\\r\\n    this.listidft1D_windowed = makeKrnl(this.gpu, createGpuKernels.listidft1D_windowedKern);\\r\\n    this.listifft1D_windowed = makeKrnl(this.gpu, createGpuKernels.listifft1D_windowedKern);\\r\\n    this.bulkArrayMul = makeKrnl(this.gpu, createGpuKernels.bulkArrayMulKern);\\r\\n\\r\\n    this.kernels.push(\\r\\n      {name:\\\"correlograms\\\", krnl:this.correlograms},\\r\\n      {name:\\\"correlogramsPC\\\", krnl: this.correlogramsPC},\\r\\n      {name:\\\"dft\\\", krnl:this.dft},\\r\\n      {name:\\\"idft\\\", krnl:this.idft},\\r\\n      {name:\\\"dft_windowed\\\", krnl:this.idft_windowed},\\r\\n      {name:\\\"fft\\\", krnl:this.fft},\\r\\n      {name:\\\"ifft\\\", krnl:this.ifft},\\r\\n      {name:\\\"fft_windowed\\\", krnl:this.fft_windowed},\\r\\n      {name:\\\"ifft_windowed\\\", krnl:this.ifft_windowed},\\r\\n      {name:\\\"listdft2D\\\", krnl:this.listdft2D},\\r\\n      {name:\\\"listdft1D\\\", krnl:this.listdft1D},\\r\\n      {name:\\\"listdft1D_windowed\\\", krnl:this.listdft1D_windowed},\\r\\n      {name:\\\"listfft1D\\\", krnl:this.listfft1D},\\r\\n      {name:\\\"listfft1D_windowed\\\", krnl:this.listfft1D_windowed},\\r\\n      {name:\\\"listidft1D_windowed\\\", krnl:this.listidft1D_windowed},\\r\\n      {name:\\\"listifft1D_windowed\\\", krnl:this.listifft1D_windowed},\\r\\n      {name:\\\"bulkArrayMul\\\", krnl:this.bulkArrayMul}\\r\\n      );\\r\\n    \\r\\n    //----------------------------------- Easy gpu pipelining\\r\\n    //------------Combine Kernels-------- gpu.combineKernels(f1,f2,function(a,b,c) { f1(f2(a,b),c); });\\r\\n    //----------------------------------- TODO: Make this actually work (weird error)\\r\\n\\r\\n    //Bandpass FFT+iFFT to return a cleaned up waveform\\r\\n    const signalBandpass = (signal, sampleRate, freqStart, freqEnd, scalar) => { //Returns the signal wave with the bandpass filter applied\\r\\n      var dft = this.fft_windowed(signal, sampleRate, freqStart, freqEnd, scalar, 0);\\r\\n      var filtered_signal = this.ifft_windowed(dft, sampleRate, freqStart, freqEnd, scalar); \\r\\n      return filtered_signal;\\r\\n    }\\r\\n\\r\\n    //this.signalBandpass = this.gpu.combineKernels(this.dft_windowedKern,this.idft_windowedKern, signalBandpass);\\r\\n    \\r\\n    const signalBandpassMulti = (signals, sampleRate, freqStart, freqEnd, scalar) => {\\r\\n      var dfts = this.listdft1D_windowed(signals,sampleRate,freqStart,freqEnd,scalar, new Array(Math.ceil(signals/sampleRate)).fill(0));\\r\\n      var filtered_signals = this.listifft1D_windowed(dfts,sampleRate,freqStart,freqEnd,scalar);\\r\\n      return filtered_signals;\\r\\n    }\\r\\n\\r\\n    //this.signalBandpassMulti = this.gpu.combineKernels(this.listdft1D_windowed,this.listidft1D_windowed, signalBandpassMulti);\\r\\n\\r\\n    //TODO: automatic auto/cross correlation and ordering.\\r\\n    //Input signals like this : [signal1,signal2,autocor1,autocor2,crosscor,...repeat for desired coherence calculations] or any order of that.\\r\\n    this.gpuCoherence = (signals, sampleRate, freqStart, freqEnd, scalar) => { //Take FFTs of the signals, their autocorrelations, and cross correlation (5 FFTs per coherence), then multiply.\\r\\n      var xcors = this.correlograms(signals);\\r\\n      var dfts = this.listfft1D_windowed(xcors, sampleRate, freqStart, freqEnd, scalar, new Array(Math.ceil(signals/sampleRate)).fill(0) );\\r\\n      var products = this.bulkArrayMul(dfts, sampleRate, 5, 1);\\r\\n      return products;\\r\\n    }\\r\\n\\r\\n    //Need to get this working to be MUCH faster, the above method returns to the CPU each call, the below does not.\\r\\n    //this.gpuCoherence = this.gpu.combineKernels(this.listdft1D_windowedKern, this.bulkArrayMulKern, this.correlogramsKern, function gpuCoherence(signals,sampleRate,freqStart,freqEnd,scalar) {\\r\\n    //  var xcors = this.correlograms(signals);\\r\\n    //  var dfts = this.listdft1D_windowed(xcors, sampleRate, freqStart, freqEnd, scalar, new Array(Math.ceil(signals/sampleRate)).fill(0) );\\r\\n    //  var products = this.bulkArrayMul(dfts, sampleRate, 5, 1);\\r\\n    //  return products;\\r\\n    //});\\r\\n\\r\\n  }\\r\\n\\r\\n  gpuXCors(arrays, precompute=false, texOut = false) { //gpu implementation for bulk cross/auto correlations, outputs [[0:0],[0:1],...,[1:1],...[n:n]]\\r\\n \\r\\n    var outputTex;\\r\\n   \\r\\n    if(precompute === true) { //Precompute the means and estimators rather than in every single thread\\r\\n      var means = [];\\r\\n      var ests = [];\\r\\n      arrays.forEach((arr,i) => {\\r\\n        means.push(arr.reduce((prev,curr)=> curr += prev)/arr.length);\\r\\n        ests.push(Math.sqrt(means[i].reduce((sum,item) => sum += Math.pow(item-mean1,2))));\\r\\n      });\\r\\n\\r\\n      var meansbuf = [];\\r\\n      var estsbuf = [];\\r\\n      var buffer = [];\\r\\n      for(var i = 0; i < arrays.length; i++) {\\r\\n        for(var j = i; j < arrays.length; j++){\\r\\n          buffer.push(...arrays[i],...arrays[j]);\\r\\n          meansbuf.push(means[i],means[j]);\\r\\n          estsbuf.push(ests[i],ests[j]);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      this.correlogramsPC.setOutput([buffer.length]);\\r\\n      this.correlogramsPC.setLoopMaxIterations(arrays[0].length*2);\\r\\n      outputTex = this.correlogramsPC(buffer, arrays[0].length, meansbuf, estsbuf)\\r\\n    }\\r\\n    else{\\r\\n      var buffer = [];\\r\\n      for(var i = 0; i < arrays.length; i++) {\\r\\n        for(var j = i; j < arrays.length; j++){\\r\\n          buffer.push(...arrays[i],...arrays[j]);\\r\\n        }\\r\\n      }\\r\\n\\r\\n      this.correlograms.setOutput([buffer.length]);\\r\\n      this.correlograms.setLoopMaxIterations(arrays[0].length*2);\\r\\n\\r\\n      outputTex = this.correlograms(buffer, arrays[0].length);\\r\\n    }\\r\\n\\r\\n    if(texOut === true) { return outputTex; }\\r\\n    var outputbuf = outputTex.toArray();\\r\\n    outputTex.delete();\\r\\n    var outputarrs = [];\\r\\n\\r\\n    for(var i = 0; i < arrays.length; i++){\\r\\n      outputarrs.push(outputbuf.splice(0, arrays[0].length));\\r\\n    }\\r\\n\\r\\n    return outputarrs;\\r\\n\\r\\n  } \\r\\n\\r\\n  //Input array buffer and the number of seconds of data\\r\\n  gpuDFT(signalBuffer, nSeconds, scalar=1, texOut = false){\\r\\n\\r\\n    var nSamples = signalBuffer.length;\\r\\n    var sampleRate = nSamples/nSeconds;\\r\\n\\r\\n    this.dft.setOutput([signalBuffer.length]);\\r\\n    this.dft.setLoopMaxIterations(nSamples);\\r\\n\\r\\n    var outputTex = this.dft(signalBuffer, nSamples, scalar);\\r\\n    var output = null;\\r\\n    if(texOut === false){\\r\\n      var freqDist = this.makeFrequencyDistribution(nSamples, sampleRate);\\r\\n      var signalBufferProcessed = outputTex.toArray();\\r\\n      //console.log(signalBufferProcessed);\\r\\n      outputTex.delete();\\r\\n      return [freqDist,this.orderMagnitudes(signalBufferProcessed)]; //Returns x (frequencies) and y axis (magnitudes)\\r\\n    }\\r\\n    else {\\r\\n      var tex = outputTex; \\r\\n      outputTex.delete(); \\r\\n      return tex;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  //Input array of array buffers of the same length and the number of seconds recorded\\r\\n  MultiChannelDFT(signalBuffer, nSeconds, scalar=1, texOut=false) {\\r\\n    \\r\\n    var signalBufferProcessed = [];\\r\\n      \\r\\n    signalBuffer.forEach((row) => {\\r\\n      signalBufferProcessed.push(...row);\\r\\n    });\\r\\n    //console.log(signalBufferProcessed);\\r\\n  \\r\\n    var nSamplesPerChannel = signalBuffer[0].length;\\r\\n    var sampleRate = nSamplesPerChannel/nSeconds\\r\\n\\r\\n    this.listdft1D.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\\r\\n    this.listdft1D.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\\r\\n        \\r\\n    var outputTex = this.listdft1D(signalBufferProcessed,nSamplesPerChannel, scalar);\\r\\n    if(texOut === false){\\r\\n      var orderedMagsList = [];\\r\\n\\r\\n      var freqDist = this.makeFrequencyDistribution(nSamplesPerChannel, sampleRate);\\r\\n      signalBufferProcessed = outputTex.toArray();\\r\\n      //console.log(signalBufferProcessed);\\r\\n\\r\\n      for(var i = 0; i < signalBufferProcessed.length; i+=nSamplesPerChannel){\\r\\n        orderedMagsList.push(this.orderMagnitudes([...signalBufferProcessed.slice(i,i+nSamplesPerChannel)]));\\r\\n      }\\r\\n      //Now slice up the big buffer into individual arrays for each signal\\r\\n\\r\\n      outputTex.delete();\\r\\n      return [freqDist,orderedMagsList]; //Returns x (frequencies) and y axis (magnitudes)\\r\\n    }\\r\\n    else {\\r\\n      var tex = outputTex; \\r\\n      outputTex.delete(); \\r\\n      return tex;\\r\\n    }\\r\\n  }\\r\\n\\r\\n      \\r\\n  //Input buffer of signals [[channel 0],[channel 1],...,[channel n]] with the same number of samples for each signal. Returns arrays of the positive DFT results in the given window.\\r\\n  MultiChannelDFT_Bandpass(signalBuffer=[],nSeconds,freqStart,freqEnd, scalar=1, texOut = false) {\\r\\n\\r\\n    var signalBufferProcessed = [];\\r\\n      \\r\\n    signalBuffer.forEach((row) => {\\r\\n      signalBufferProcessed.push(...row);\\r\\n    });\\r\\n    //console.log(signalBufferProcessed);\\r\\n\\r\\n    var freqEnd_nyquist = freqEnd*2;\\r\\n    var nSamplesPerChannel = signalBuffer[0].length;\\r\\n    var sampleRate = nSamplesPerChannel/nSeconds;\\r\\n    \\r\\n    this.listdft1D_windowed.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\\r\\n    this.listdft1D_windowed.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\\r\\n        \\r\\n    var outputTex = this.listdft1D_windowed(signalBufferProcessed,sampleRate,freqStart,freqEnd_nyquist, scalar);\\r\\n    if(texOut === true) { return outputTex; }\\r\\n    \\r\\n    signalBufferProcessed = outputTex.toArray();\\r\\n    outputTex.delete();\\r\\n\\r\\n    //console.log(signalBufferProcessed)\\r\\n    //TODO: Optimize for SPEEEEEEED.. or just pass it str8 to a shader\\r\\n    var freqDist = this.bandPassWindow(freqStart,freqEnd,sampleRate);\\r\\n    return [freqDist, this.orderBPMagnitudes(signalBufferProcessed,nSeconds,sampleRate,nSamplesPerChannel)]; //Returns x (frequencies) and y axis (magnitudes)\\r\\n  \\r\\n  }\\r\\n\\r\\n  \\r\\n  //Input array buffer and the number of seconds of data\\r\\n  gpuFFT(signalBuffer, nSeconds, scalar=1, sampleRate, texOut = false){\\r\\n\\r\\n    var nSamples = signalBuffer.length;\\r\\n    var sampleRate = nSamples/nSeconds;\\r\\n\\r\\n    this.fft.setOutput([signalBuffer.length]);\\r\\n    this.fft.setLoopMaxIterations(nSamples);\\r\\n\\r\\n    var outputTex = this.fft(signalBuffer, nSamples, scalar, sampleRate);\\r\\n    var output = null;\\r\\n    if(texOut === false){\\r\\n      var freqDist = this.makeFrequencyDistribution(nSamples, sampleRate);\\r\\n      var signalBufferProcessed = outputTex.toArray();\\r\\n      //console.log(signalBufferProcessed);\\r\\n      outputTex.delete();\\r\\n      return [freqDist,this.orderMagnitudes(signalBufferProcessed)]; //Returns x (frequencies) and y axis (magnitudes)\\r\\n    }\\r\\n    else {\\r\\n      var tex = outputTex; \\r\\n      outputTex.delete(); \\r\\n      return tex;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  //Input array of array buffers of the same length and the number of seconds recorded\\r\\n  MultiChannelFFT(signalBuffer, nSeconds, scalar=1, texOut=false) {\\r\\n    \\r\\n    var signalBufferProcessed = [];\\r\\n      \\r\\n    signalBuffer.forEach((row) => {\\r\\n      signalBufferProcessed.push(...row);\\r\\n    });\\r\\n    //console.log(signalBufferProcessed);\\r\\n  \\r\\n    var nSamplesPerChannel = signalBuffer[0].length;\\r\\n    var sampleRate = nSamplesPerChannel/nSeconds\\r\\n\\r\\n    this.listfft1D.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\\r\\n    this.listfft1D.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\\r\\n        \\r\\n    var outputTex = this.listfft1D(signalBufferProcessed,nSamplesPerChannel, scalar, sampleRate);\\r\\n    if(texOut === false){\\r\\n      var orderedMagsList = [];\\r\\n\\r\\n      var freqDist = this.makeFrequencyDistribution(nSamplesPerChannel, sampleRate);\\r\\n      signalBufferProcessed = outputTex.toArray();\\r\\n      //console.log(signalBufferProcessed);\\r\\n\\r\\n      for(var i = 0; i < signalBufferProcessed.length; i+=nSamplesPerChannel){\\r\\n        orderedMagsList.push(this.orderMagnitudes([...signalBufferProcessed.slice(i,i+nSamplesPerChannel)]));\\r\\n      }\\r\\n      //Now slice up the big buffer into individual arrays for each signal\\r\\n\\r\\n      outputTex.delete();\\r\\n      return [freqDist,orderedMagsList]; //Returns x (frequencies) and y axis (magnitudes)\\r\\n    }\\r\\n    else {\\r\\n      var tex = outputTex; \\r\\n      outputTex.delete(); \\r\\n      return tex;\\r\\n    }\\r\\n  }\\r\\n\\r\\n      \\r\\n  //Input buffer of signals [[channel 0],[channel 1],...,[channel n]] with the same number of samples for each signal. Returns arrays of the positive DFT results in the given window.\\r\\n  MultiChannelFFT_Bandpass(signalBuffer=[],nSeconds,freqStart,freqEnd, scalar=1, texOut = false) {\\r\\n\\r\\n    var signalBufferProcessed = [];\\r\\n      \\r\\n    signalBuffer.forEach((row) => {\\r\\n      signalBufferProcessed.push(...row);\\r\\n    });\\r\\n    //console.log(signalBufferProcessed);\\r\\n\\r\\n    var freqEnd_nyquist = freqEnd*2;\\r\\n    var nSamplesPerChannel = signalBuffer[0].length;\\r\\n    var sampleRate = nSamplesPerChannel/nSeconds;\\r\\n    \\r\\n    this.listfft1D_windowed.setOutput([signalBufferProcessed.length]); //Set output to length of list of signals\\r\\n    this.listfft1D_windowed.setLoopMaxIterations(nSamplesPerChannel); //Set loop size to the length of one signal (assuming all are uniform length)\\r\\n        \\r\\n    var outputTex = this.listfft1D_windowed(signalBufferProcessed,sampleRate,freqStart,freqEnd_nyquist, scalar);\\r\\n    if(texOut === true) { return outputTex; }\\r\\n    \\r\\n    signalBufferProcessed = outputTex.toArray();\\r\\n    outputTex.delete();\\r\\n\\r\\n    //console.log(signalBufferProcessed)\\r\\n    //TODO: Optimize for SPEEEEEEED.. or just pass it str8 to a shader\\r\\n    var freqDist = this.bandPassWindow(freqStart,freqEnd,sampleRate);\\r\\n    return [freqDist, this.orderBPMagnitudes(signalBufferProcessed,nSeconds,sampleRate,nSamplesPerChannel)]; //Returns x (frequencies) and y axis (magnitudes)\\r\\n  \\r\\n  }\\r\\n\\r\\n  orderMagnitudes(unorderedMags){\\r\\n    return [...unorderedMags.slice(Math.ceil(unorderedMags.length*.5),unorderedMags.length),...unorderedMags.slice(0,Math.ceil(unorderedMags.length*.5))];  \\r\\n  }\\r\\n\\r\\n  makeFrequencyDistribution(FFTlength, sampleRate) {\\r\\n    var N = FFTlength; // FFT size\\r\\n    var df = sampleRate/N; // frequency resolution\\r\\n    \\r\\n    var freqDist = [];\\r\\n    for(var i=(-N/2); i<(N/2); i++) {\\r\\n      var freq = i*df;\\r\\n      freqDist.push(freq);\\r\\n    }\\r\\n    return freqDist;\\r\\n  }\\r\\n\\r\\n  //Order and sum positive magnitudes from bandpass DFT\\r\\n  orderBPMagnitudes(signalBufferProcessed,nSeconds,sampleRate,nSamplesPerChannel) {\\r\\n    var magList = [];\\r\\n\\r\\n      for(var i = 0; i < signalBufferProcessed.length; i+=nSamplesPerChannel){\\r\\n        magList.push([...signalBufferProcessed.slice(i,Math.ceil(nSamplesPerChannel*.5+i))]);\\r\\n      }\\r\\n\\r\\n\\r\\n    var summedMags = [];\\r\\n    var _sampleRate = 1/sampleRate;\\r\\n    if(nSeconds > 1) { //Need to sum results when sample time > 1 sec\\r\\n      magList.forEach((row, k) => {\\r\\n        summedMags.push([]);\\r\\n        var _max = 1/Math.max(...row); //uhh\\r\\n        for(var i = 0; i < row.length; i++ ){\\r\\n          if(i == 0){\\r\\n              summedMags[k]=row.slice(i,Math.floor(sampleRate));\\r\\n              i = Math.floor(sampleRate);\\r\\n          }\\r\\n          else {\\r\\n              var j = i-Math.floor(Math.floor(i*_sampleRate)*sampleRate)-1; //console.log(j);\\r\\n              summedMags[k][j] = summedMags[k][j] * row[i-1]*_max; \\r\\n          }\\r\\n        }\\r\\n        summedMags[k] = [...summedMags[k].slice(0,Math.ceil(summedMags[k].length*0.5))]\\r\\n\\r\\n      });\\r\\n      //console.log(summedMags);\\r\\n      return summedMags;  \\r\\n    }\\r\\n    \\r\\n    else {return magList;}\\r\\n  }\\r\\n\\r\\n  //Returns the x axis (frequencies) for the bandpass filter amplitudes. The window gets stretched or squeezed between the chosen frequencies based on the sample rate in my implementation.\\r\\n  bandPassWindow(freqStart,freqEnd,nSteps,posOnly=true) {\\r\\n \\r\\n    var freqEnd_nyquist = freqEnd*2;\\r\\n    let increment = (freqEnd_nyquist - freqStart)/nSteps;\\r\\n\\r\\n    var fftwindow = [];\\r\\n    if(posOnly === true){\\r\\n      for (var i = 0; i < Math.ceil(0.5*nSteps); i+=increment){\\r\\n          fftwindow.push(freqStart + (freqEnd_nyquist-freqStart)*i/(nSteps));\\r\\n      }\\r\\n    }\\r\\n    else{\\r\\n      for (var i = -Math.ceil(0.5*nSteps); i < Math.ceil(0.5*nSteps); i+=increment){\\r\\n        fftwindow.push(freqStart + (freqEnd_nyquist-freqStart)*i/(nSteps));\\r\\n      }\\r\\n    }\\r\\n    return fftwindow;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\nvar mandebrotFrag = \\r\\n(/* unused pure expression or super */ null && (`\\r\\nuniform sampler1D tex;\\r\\nuniform vec2 center;\\r\\nuniform float scale;\\r\\nuniform int iter;\\r\\n\\r\\nvoid main() {\\r\\n    vec2 z, c;\\r\\n\\r\\n    c.x = 1.3333 * (gl_TexCoord[0].x - 0.5) * scale - center.x;\\r\\n    c.y = (gl_TexCoord[0].y - 0.5) * scale - center.y;\\r\\n\\r\\n    int i;\\r\\n    z = c;\\r\\n    for(i=0; i<iter; i++) {\\r\\n        float x = (z.x * z.x - z.y * z.y) + c.x;\\r\\n        float y = (z.y * z.x + z.x * z.y) + c.y;\\r\\n\\r\\n        if((x * x + y * y) > 4.0) break;\\r\\n        z.x = x;\\r\\n        z.y = y;\\r\\n    }\\r\\n\\r\\n    gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);\\r\\n}\\r\\n`));\\r\\n\\r\\nvar juliaSetFrag =\\r\\n(/* unused pure expression or super */ null && (`\\r\\nuniform sampler1D tex;\\r\\nuniform vec2 c;\\r\\nuniform int iter;\\r\\n\\r\\nvoid main() {\\r\\n    vec2 z;\\r\\n    z.x = 3.0 * (gl_TexCoord[0].x - 0.5);\\r\\n    z.y = 2.0 * (gl_TexCoord[0].y - 0.5);\\r\\n\\r\\n    int i;\\r\\n    for(i=0; i<iter; i++) {\\r\\n        float x = (z.x * z.x - z.y * z.y) + c.x;\\r\\n        float y = (z.y * z.x + z.x * z.y) + c.y;\\r\\n\\r\\n        if((x * x + y * y) > 4.0) break;\\r\\n        z.x = x;\\r\\n        z.y = y;\\r\\n    }\\r\\n\\r\\n    gl_FragColor = texture1D(tex, (i == iter ? 0.0 : float(i)) / 100.0);\\r\\n}\\r\\n`));\\r\\n\\n\\n/***/ }),\\n\\n/***/ 776:\\n/***/ ((module) => {\\n\\nfunction webpackEmptyAsyncContext(req) {\\n\\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\\n\\t// uncaught exception popping up in devtools\\n\\treturn Promise.resolve().then(() => {\\n\\t\\tvar e = new Error(\\\"Cannot find module '\\\" + req + \\\"'\\\");\\n\\t\\te.code = 'MODULE_NOT_FOUND';\\n\\t\\tthrow e;\\n\\t});\\n}\\nwebpackEmptyAsyncContext.keys = () => ([]);\\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\\nwebpackEmptyAsyncContext.id = 776;\\nmodule.exports = webpackEmptyAsyncContext;\\n\\n/***/ })\\n\\n/******/ \\t});\\n/************************************************************************/\\n/******/ \\t// The module cache\\n/******/ \\tvar __webpack_module_cache__ = {};\\n/******/ \\t\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tvar cachedModule = __webpack_module_cache__[moduleId];\\n/******/ \\t\\tif (cachedModule !== undefined) {\\n/******/ \\t\\t\\treturn cachedModule.exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = __webpack_module_cache__[moduleId] = {\\n/******/ \\t\\t\\t// no module.id needed\\n/******/ \\t\\t\\t// no module.loaded needed\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/ \\t\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\\n/******/ \\t\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/ \\t\\n/************************************************************************/\\n/******/ \\t/* webpack/runtime/define property getters */\\n/******/ \\t(() => {\\n/******/ \\t\\t// define getter functions for harmony exports\\n/******/ \\t\\t__webpack_require__.d = (exports, definition) => {\\n/******/ \\t\\t\\tfor(var key in definition) {\\n/******/ \\t\\t\\t\\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\\n/******/ \\t\\t\\t\\t\\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\\n/******/ \\t\\t\\t\\t}\\n/******/ \\t\\t\\t}\\n/******/ \\t\\t};\\n/******/ \\t})();\\n/******/ \\t\\n/******/ \\t/* webpack/runtime/hasOwnProperty shorthand */\\n/******/ \\t(() => {\\n/******/ \\t\\t__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\\n/******/ \\t})();\\n/******/ \\t\\n/************************************************************************/\\nvar __webpack_exports__ = {};\\n// This entry need to be wrapped in an IIFE because it need to be in strict mode.\\n(() => {\\n\\\"use strict\\\";\\n/* harmony import */ var _lib_workerCallbacks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(521);\\n\\nlet manager = new _lib_workerCallbacks_js__WEBPACK_IMPORTED_MODULE_0__/* .CallbackManager */ .Y();\\nlet id = `worker_${Math.floor(Math.random() * 10000000000)}`;\\nlet counter = 0;\\n\\nself.onmessage = async event => {\\n  let input;\\n  if (event.data.output) input = event.data.output; //from events\\n  else input = event.data; //console.log(input)\\n\\n  let dict;\\n  let output = undefined;\\n\\n  if (event.data?.eventName) {\\n    //pipe events to the event manager system\\n    manager.EVENTS.callback(event.data);\\n  } else if (typeof input === 'object') {\\n    if (input.canvas !== undefined) {\\n      //if a new canvas is sent (event.data.canvas = htmlCanvasElement.transferControlToOffscreen()).\\n      manager.canvas = input.canvas;\\n    }\\n\\n    if (input.context !== undefined) {\\n      //set the context\\n      manager.ctx = manager.canvas.getContext(input.context);\\n      manager.context = manager.ctx;\\n    }\\n\\n    let eventSetting = manager.checkEvents(input.foo, input.origin); //console.log(event)\\n\\n    output = await manager.checkCallbacks(event); // output some results!\\n\\n    counter++; //just tracks the number of calls made to the worker\\n    //we are gonna assume typedarrays are to be transferred for speed so throw those all into the transfer array\\n\\n    let transfer = undefined;\\n\\n    if (output) {\\n      if (output.__proto__?.__proto__?.constructor.name === 'TypedArray') {\\n        transfer = [output.buffer];\\n      } else if (output.constructor?.name === 'Object') {\\n        for (const key in output) {\\n          if (output[key].__proto__?.__proto__?.constructor.name === 'TypedArray') {\\n            if (!transfer) transfer = output[key].buffer;else transfer.push(output[key].buffer);\\n          }\\n        }\\n      }\\n    } //if(input.foo === 'particleStep') console.log(eventSetting);\\n\\n\\n    dict = {\\n      output: output,\\n      foo: input.foo,\\n      origin: input.origin,\\n      callbackId: input.callbackId,\\n      counter: counter\\n    };\\n\\n    if (eventSetting) {\\n      manager.EVENTS.emit(eventSetting.eventName, dict, undefined, transfer, eventSetting.port);\\n    } //if the origin and foo match an event setting on the thread, this emits output as an event\\n    else if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\\n      self.postMessage(dict, transfer); // TODO: Correct proper transfer syntax\\n    }\\n  }\\n  /*\\r\\n    now run \\\"addfunc\\\" to render something in the linked canvas from the worker thread\\r\\n    e.g. workers.postToWorker('addfunc',['offscreenrender',`(args)=>{\\r\\n      ctx.clearRect(0,0,canvas.width,canvas.height); //or this.offscreenctx\\r\\n      ctx.fillRect(25, 25, 100, 100);\\r\\n      ctx.clearRect(45, 45, 60, 60);\\r\\n      ctx.strokeRect(50, 50, 50, 50);\\r\\n    }`]);\\r\\n  */\\n  // console.timeEnd(\\\"worker\\\");\\n\\n\\n  return dict;\\n};\\n\\nmanager.EVENTS.emit('newWorker', id);\\n/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = (self);\\n})();\\n\\n/******/ })()\\n;\\n//# sourceMappingURL=magic.worker.worker.js.map\", \"Worker\", undefined, __webpack_public_path__ + \"magic.worker.worker.js\");\n}\n","//from UI thread\r\n\r\n/////////////https://threejsfundamentals.org/threejs/lessons/threejs-offscreencanvas.html\r\nimport { WorkerManager } from \"../WorkerManager\";\r\n  \r\n\r\nfunction noop() {\r\n}\r\n\r\nexport class ProxyElement {\r\n  constructor(element, origin, workerId, eventHandlers, manager) {\r\n    this.id = 'proxy'+Math.floor(Math.random()*10000);\r\n    this.eventHandlers = eventHandlers;\r\n    this.origin = origin;\r\n    this.workerId = workerId;\r\n    this.manager = (manager instanceof WorkerManager) ? manager : new WorkerManager();\r\n\r\n    const sendEvent = (data) => {\r\n        this.manager.runWorkerFunction(\r\n            'proxyHandler',\r\n            {type:'event',id:this.id,data:data},\r\n            this.workerId,\r\n            this.origin\r\n        );\r\n    };\r\n\r\n    // register an id\r\n    this.manager.runWorkerFunction(\r\n        'proxyHandler',\r\n        {type:'makeProxy',id:this.id},\r\n        this.workerId,\r\n        this.origin\r\n    );\r\n\r\n\r\n    for (const [eventName, handler] of Object.entries(this.eventHandlers)) {\r\n      element.addEventListener(eventName, function(event) {\r\n        handler(event, sendEvent);\r\n      });\r\n    }\r\n\r\n    const sendSize = () => {\r\n      \r\n        const rect = element.getBoundingClientRect();\r\n        sendEvent({\r\n          type: 'size',\r\n          left: rect.left,\r\n          top: rect.top,\r\n          width: element.clientWidth,\r\n          height: element.clientHeight,\r\n        });\r\n    }\r\n\r\n    sendSize();\r\n    // really need to use ResizeObserver\r\n    window.addEventListener('resize', sendSize);\r\n  }\r\n}\r\n\r\nconst mouseEventHandler = makeSendPropertiesHandler([\r\n    'ctrlKey',\r\n    'metaKey',\r\n    'shiftKey',\r\n    'button',\r\n    'pointerType',\r\n    'clientX',\r\n    'clientY',\r\n    'pageX',\r\n    'pageY',\r\n  ]);\r\n  const wheelEventHandlerImpl = makeSendPropertiesHandler([\r\n    'deltaX',\r\n    'deltaY',\r\n  ]);\r\n  const keydownEventHandler = makeSendPropertiesHandler([\r\n    'ctrlKey',\r\n    'metaKey',\r\n    'shiftKey',\r\n    'keyCode',\r\n  ]);\r\n  \r\n  function wheelEventHandler(event, sendFn) {\r\n    event.preventDefault();\r\n    wheelEventHandlerImpl(event, sendFn);\r\n  }\r\n  \r\n  function preventDefaultHandler(event) {\r\n    event.preventDefault();\r\n  }\r\n  \r\n  function copyProperties(src, properties, dst) {\r\n    for (const name of properties) {\r\n        dst[name] = src[name];\r\n    }\r\n  }\r\n  \r\n  function makeSendPropertiesHandler(properties) {\r\n    return function sendProperties(event, sendFn) {\r\n      const data = {type: event.type};\r\n      copyProperties(event, properties, data);\r\n      sendFn(data);\r\n    };\r\n  }\r\n  \r\n  function touchEventHandler(event, sendFn) {\r\n    const touches = [];\r\n    const data = {type: event.type, touches};\r\n    for (let i = 0; i < event.touches.length; ++i) {\r\n      const touch = event.touches[i];\r\n      touches.push({\r\n        pageX: touch.pageX,\r\n        pageY: touch.pageY,\r\n      });\r\n    }\r\n    sendFn(data);\r\n  }\r\n  \r\n  // The four arrow keys\r\n  const orbitKeys = {\r\n    '37': true,  // left\r\n    '38': true,  // up\r\n    '39': true,  // right\r\n    '40': true,  // down\r\n  };\r\n\r\n  function filteredKeydownEventHandler(event, sendFn) {\r\n    const {keyCode} = event;\r\n    if (orbitKeys[keyCode]) {\r\n      event.preventDefault();\r\n      keydownEventHandler(event, sendFn);\r\n    }\r\n  }\r\n\r\n  //do this on main thread\r\n  export function initProxyElement(element, workerId, origin) {\r\n\r\n    const eventHandlers = {\r\n        contextmenu: preventDefaultHandler,\r\n        mousedown: mouseEventHandler,\r\n        mousemove: mouseEventHandler,\r\n        mouseup: mouseEventHandler,\r\n        pointerdown: mouseEventHandler,\r\n        pointermove: mouseEventHandler,\r\n        pointerup: mouseEventHandler,\r\n        touchstart: touchEventHandler,\r\n        touchmove: touchEventHandler,\r\n        touchend: touchEventHandler,\r\n        wheel: wheelEventHandler,\r\n        keydown: filteredKeydownEventHandler,\r\n    };\r\n    \r\n    const proxy = new ProxyElement(\r\n      element, origin, workerId, eventHandlers, this\r\n    );\r\n\r\n    return proxy;\r\n\r\n  }\r\n\r\n\r\n\r\n","import { WorkerManager } from \"../WorkerManager\"\r\n\r\n//The animation should probably be an arrow function\r\nexport class ThreadedCanvas {\r\n    constructor(manager, canvas, context=undefined, drawFunction=undefined, setValues=undefined, workerId=undefined, origin= `canvas_${Math.round(Math.random()*100000)}`, transfer=undefined) { \r\n        if(!canvas) throw new Error('Input a canvas element or Id')\r\n        this.origin = origin;\r\n        this.workerId = workerId;\r\n        this.manager = manager;\r\n        if(!manager) return false;\r\n        \r\n        if(typeof canvas === 'string') canvas = document.getElementById(canvas);\r\n        this.canvas = canvas;\r\n        this.context = context;\r\n        this.offscreen;\r\n\r\n        if(!this.workerId) this.initWorker();\r\n        \r\n        if(typeof setValues === 'object') this.manager.postToWorker({foo:'setValues',args:setValues,origin:this.origin},this.workerId,transfer);\r\n        if(canvas) {\r\n            this.setCanvas(canvas);\r\n        }\r\n        if(context) { \r\n            this.setContext(context);\r\n        }\r\n        if(drawFunction) {\r\n            this.setAnimation(drawFunction);\r\n        }\r\n        \r\n    }\r\n\r\n    setContext(context=this.context){\r\n        this.context = context;\r\n        this.manager.postToWorker({context:context, origin:this.origin},this.workerId);\r\n    }\r\n\r\n    setCanvas(canvas=this.canvas) {\r\n        this.canvas = canvas;\r\n        this.offscreen = canvas.transferControlToOffscreen();\r\n        this.manager.postToWorker({canvas: this.offscreen, origin:this.origin, foo:null},this.workerId,[this.offscreen]);\r\n    }\r\n\r\n    // {x:3, y:['a','b','c']} etc\r\n    setValues(valObject=undefined,transfer=undefined) {\r\n        if(typeof setValues === 'object') this.manager.postToWorker({foo:'setValues',input:valObject,origin:this.origin},this.workerId,transfer);\r\n    }\r\n\r\n    //you can reference canvas/this.canvas and context/this.context in the function \r\n    //Set values then reference this.x etc as well, to have controllable values\r\n    setAnimation(animationFunction) {\r\n        let fstring = animationFunction;\r\n        if(typeof animationFunction === 'function') fstring = animationFunction.toString();\r\n        else if(typeof animationFunction !== 'string') return false;\r\n        //console.log(fstring)\r\n        this.manager.postToWorker({origin:this.origin,foo:'setAnimation',input:[fstring]},this.workerId)\r\n    }\r\n\r\n    addSetup(setupFunction) {\r\n        let fstring = setupFunction\r\n        if(typeof setupFunction === 'function') fstring = setupFunction.toString();\r\n        this.manager.postToWorker({origin:this.origin,foo:'addFunc',input:['setupAnim',fstring]},this.workerId)\r\n    }\r\n\r\n    setThreeAnimation(setupFunction, drawFunction) {\r\n        this.manager.postToWorker({origin:this.origin,foo:'initThree',input:[setupFunction.toString(),drawFunction.toString()]})\r\n    }\r\n\r\n    startThreeAnimation() {\r\n        this.manager.postToWorker({origin:this.origin,foo:'startThree',input:[]},this.workerId);\r\n    }\r\n\r\n    clearThreeAnimation() {\r\n        this.manager.postToWorker({origin:this.origin,foo:'clearThree',input:[]},this.workerId);\r\n    }\r\n\r\n    setValues(values={},transfer=[]) {\r\n        if(typeof values === 'object') {\r\n            this.manager.postToWorker({origin:this.origin,foo:'setValues',input:values},this.workerId,transfer);\r\n        }\r\n    }\r\n\r\n    startAnimation() {\r\n        this.manager.postToWorker({origin:this.origin,foo:'startAnimation',input:[]},this.workerId);\r\n    }\r\n\r\n    stopAnimation() {\r\n        this.manager.postToWorker({origin:this.origin,foo:'stopAnimation',input:[]},this.workerId);\r\n    }\r\n\r\n    setCanvasSize(w=this.canvas.width,h=this.canvas.height) {\r\n        this.manager.postToWorker({origin:this.origin,foo:'resizecanvas',input:[w,h]},this.workerId);\r\n    }\r\n\r\n    initWorker() {\r\n        if(!this.workerId) {\r\n            if (this.manager == null){\r\n                this.manager = new WorkerManager()\r\n            }\r\n\r\n            this.workerId = this.manager.addWorker(); // add a worker for this DataAtlas analyzer instance\r\n            this.manager.workerResponses.push(this.workeronmessage);\r\n        }\r\n        this.setCanvas();\r\n        this.setContext();\r\n    }\r\n\r\n    init(drawFunction) {\r\n        if(!this.workerId) this.initWorker();\r\n        this.setCanvas();\r\n        this.setContext();\r\n        if(drawFunction) this.setAnimation(drawFunction);\r\n    }\r\n\r\n    deinit() {\r\n        this.manager.terminate(this.workerId);\r\n    }\r\n\r\n    workeronmessage = (msg) => {\r\n        if(msg.origin === this.origin) { \r\n            console.log(\"Result: \", msg);\r\n        }\r\n    }\r\n\r\n    test(id='testcanvas') {\r\n        let canvas = document.getElementById(id)\r\n        if(!canvas) {\r\n            canvas = document.createElement('canvas');\r\n            canvas.id = id;\r\n            document.body.insertAdjacentElement('beforeend',canvas);\r\n        }\r\n        this.canvas = canvas;\r\n        this.context = '2d';\r\n\r\n        this.init();\r\n\r\n        this.setValues({x:1,y:2,z:3});\r\n\r\n        function drawFunc(self, args, origin) {\r\n            if(!self.x) {\r\n                self.x = 1;\r\n                self.y = 2;\r\n                self.z = 3;\r\n            }\r\n            self.ctx.font = '10px serif';\r\n            self.ctx.fillText(`${self.x} + ${self.y} + ${self.z} = ${self.x+self.y+self.z}`,10,50);\r\n        \r\n            self.x++;\r\n            self.z+=2;\r\n        }\r\n\r\n        this.setAnimation(drawFunc);\r\n\r\n        setTimeout(()=>{this.stopAnimation();},10000);\r\n\r\n    }\r\n}","\r\nimport {CallbackManager} from './lib/workerCallbacks' \r\n\r\nimport worker from './magic.worker.js' // internal worker\r\n\r\nimport { Events } from './lib/Event';\r\nimport { ProxyElement, initProxyElement } from './lib/ProxyElement';\r\nimport { ThreadedCanvas } from './lib/ThreadedCanvas';\r\n\r\nexport class WorkerManager {\r\n    url;\r\n    responses = [];\r\n    workers = [];\r\n    threads = 0;\r\n    threadrot = 0;\r\n    events;\r\n    subEvent;\r\n    unsubEvent;\r\n    addEvent;\r\n    toResolve = {};\r\n    ProxyElement = ProxyElement;\r\n    initProxyElement = initProxyElement;\r\n    ThreadedCanvas = ThreadedCanvas; //class reference\r\n\r\n    constructor(url, nThreads=1){\r\n      this.url = url;\r\n      this.responses = [];\r\n      this.workers = [];\r\n      this.threads = nThreads;\r\n      this.threadrot = 0;\r\n\r\n      this.EVENTS = new Events(this);\r\n      this.subEvent = (eventName, result=(_)=>{})=>{this.EVENTS.subEvent(eventName,result);}\r\n      this.unsubEvent = (eventName, sub) => {this.EVENTS.unsubEvent(eventName,sub)};\r\n      this.addEvent = async (eventName, origin, foo, id) => {return await this.EVENTS.addEvent(eventName, origin, foo, id)};\r\n\r\n      let i = 0;\r\n\r\n      while(i < nThreads){\r\n        this.addWorker(); \r\n        i++;\r\n      }\r\n\r\n    }\r\n\r\n    //return the worker by id, or the first worker (e.g. the default one)\r\n    getWorker(id) {\r\n      if(id) return this.workers.find((o) => {if(o.id === id) return true}).worker;\r\n      else return this.workers[0].worker;\r\n    }\r\n\r\n    addWorker = (url=this.url, type = 'module') => {\r\n\r\n        let newWorker;\r\n        try {\r\n          if (url == null) newWorker = worker()\r\n          else {\r\n            if (!(url instanceof URL)) url = new URL(url, import.meta.url)\r\n            newWorker = new Worker(url, {name:'worker_'+this.workers.length, type})\r\n          }\r\n        } catch (err) {\r\n            console.log(\"Error, creating dummy worker (WARNING: Single Threaded). ERROR:\", err);\r\n            newWorker =  new DummyWorker(this.responses)\r\n        }\r\n        finally {\r\n          if (newWorker){\r\n\r\n          let id = \"worker_\"+Math.floor(Math.random()*10000000000);\r\n            \r\n          this.workers.push({worker:newWorker, id:id});\r\n\r\n          newWorker.onmessage = (ev) => {\r\n\r\n              var msg = ev.data;\r\n\r\n              // Resolve \r\n              let toResolve = this.toResolve[ev.data.callbackId];\r\n              if (toResolve) {\r\n                toResolve(msg.output);\r\n                delete this.toResolve[ev.data.callbackId]\r\n              }\r\n\r\n              // Run Response Callbacks\r\n              this.responses.forEach((foo,_) => {\r\n                if(typeof foo === 'object') foo.callback(msg);\r\n                else if (typeof foo === 'function') foo(msg);\r\n              });\r\n          };\r\n\r\n          newWorker.onerror = (e) => {\r\n            console.error(e)\r\n          }\r\n\r\n          console.log(\"magic threads: \", this.workers.length)\r\n          return id; //worker id\r\n        } else return\r\n      }\r\n    }\r\n\r\n    //automated responses\r\n    addCallback(name='',callback=(result)=>{}) {\r\n      if(name.length > 0 && !this.responses.find((o)=>{if(typeof o === 'object') {if(o.name === name) return true;} return})) {\r\n        this.responses.push({name:name,callback:callback});\r\n      }\r\n    }\r\n\r\n    //remove automated response by name\r\n    removeCallback(nameOrIdx='') {\r\n      if(nameOrIdx.length > 0) {\r\n        let idx;\r\n        if(this.responses.find((o,i)=>{if(typeof o === 'object') {if(o.name === nameOrIdx) { idx = i; return true;}}  return})) {\r\n          if (idx) this.responses.splice(idx,1);\r\n        }\r\n      } else if (typeof nameOrIdx === 'number') {\r\n        this.responses.splice(nameOrIdx,1);\r\n      }\r\n    }\r\n\r\n    //add a callback to a worker\r\n    async addFunction(functionName,fstring,workerId,origin,callback=(result)=>{}) {\r\n      if(functionName && fstring) {\r\n        if(typeof fstring === 'function') fstring = fstring.toString();\r\n        let dict = {foo:'addfunc',args:[functionName,fstring],origin:origin}; //post to the specific worker\r\n        if(!workerId) {\r\n          this.workers.forEach((w) => {this.post(dict,w.id,callback);});\r\n          return true;\r\n        } //post to all of the workers\r\n        else return await this.post(dict,workerId,callback);\r\n      }\r\n    }\r\n\r\n    //alias\r\n    addWorkerFunction = this.addFunction\r\n\r\n    //run from the list of callbacks on an available worker\r\n    async run(functionName,args,workerId,origin,transfer,callback=(result)=>{}) {\r\n        if(functionName) {\r\n          if(functionName === 'transferClassObject') {\r\n            if(typeof args === 'object' && !Array.isArray(args)) {\r\n              for(const prop in args) {\r\n                if(typeof args[prop] === 'object' && !Array.isArray(args[prop])) args[prop] = args[prop].toString();\r\n              }\r\n            }\r\n          }\r\n          let dict = {foo:functionName, args:args, origin:origin};\r\n          return await this.post(dict,workerId,transfer,callback);\r\n        }\r\n    }\r\n\r\n    //aliases\r\n    runWorkerFunction = this.run\r\n    runFunction = this.run\r\n\r\n    //a way to set variables on a thread\r\n    async setValues(values={},id,origin,transfer) {\r\n      if(id)\r\n        return await this.run('setValues',values,id,origin,transfer);\r\n      else {\r\n        this.workers.forEach((w) => {\r\n          this.run('setValues',values,w.id,origin,transfer);\r\n        })\r\n      }\r\n    }\r\n\r\n    //this creates a message port so particular event outputs can directly message another worker and save overhead on the main thread\r\n    establishMessageChannel(\r\n      eventName,\r\n      worker1Id,\r\n      worker2Id,\r\n      worker2Response, //onEvent=(self,args,origin)=>{} //args will be the output\r\n      functionName, \r\n      origin) \r\n    {\r\n      let channel = new MessageChannel();\r\n      let port1 = channel.port1;\r\n      let port2 = channel.port2;\r\n\r\n      this.run(\r\n        'addevent',\r\n        [\r\n          eventName,\r\n          functionName,\r\n          port1\r\n        ],\r\n        worker1Id,\r\n        origin,\r\n        [port1]\r\n      );\r\n\r\n      this.run(\r\n        'addevent',\r\n        [\r\n          eventName,\r\n          eventName,\r\n          port2\r\n        ],\r\n        worker2Id,\r\n        origin,\r\n        [port2]\r\n      );\r\n\r\n      if(typeof worker2Response === 'function')\r\n        this.run(\r\n          'subevent',\r\n          [\r\n            eventName,\r\n            worker2Response.toString()\r\n          ],\r\n          worker2Id,\r\n          origin\r\n        );\r\n\r\n    }\r\n\r\n    post = (input, workerId, transfer, callback=(result)=>{}) => {\r\n\r\n      return new Promise(resolve => {\r\n        //console.log('posting',input,id);\r\n        if (Array.isArray(input.input)){\r\n        input.input = input.input.map((v) => {\r\n          if (typeof v === 'function') return v.toString();\r\n          else return v;\r\n        })} \r\n\r\n        const resolver = (res) => \r\n          {    \r\n              if (callback) {\r\n                  callback(res);\r\n              }\r\n              resolve(res);\r\n          }\r\n\r\n        input.callbackId = Math.floor(1000000 * Math.random());\r\n        this.toResolve[input.callbackId] = resolver;\r\n\r\n        if(workerId == null) {\r\n            const worker = this.workers?.[this.threadrot]?.worker\r\n            if (worker){\r\n              worker.postMessage(input,transfer);\r\n              if(this.threads > 1){\r\n                  this.threadrot++;\r\n                  if(this.threadrot >= this.threads){\r\n                      this.threadrot = 0;\r\n                  }\r\n              }\r\n            }\r\n        }\r\n        else{\r\n            this.workers.find((o)=>{\r\n                if(o.id === workerId) {\r\n                    o.worker.postMessage(input,transfer); \r\n                    return true;\r\n                  } else return;\r\n            });\r\n        }\r\n\r\n      })\r\n    }\r\n\r\n    postToWorker = this.post\r\n\r\n    terminate(workerId) {\r\n      if(!workerId) {\r\n        this.workers.forEach((o) => o.worker.terminate()); //terminate all\r\n      }\r\n      else {\r\n        let idx;\r\n        let found = this.workers.find((o,i)=>{\r\n            if(o.id === workerId) {\r\n                idx=i;\r\n                o.worker.terminate();\r\n                return true;\r\n            } else return\r\n        });\r\n        if(found && idx) {\r\n            this.workers.splice(idx,1);\r\n            return true;\r\n        } else return false;\r\n      }\r\n    }\r\n\r\n    close = this.terminate\r\n\r\n}\r\n\r\n\r\n\r\n\r\n//for single threaded applications\r\n\r\nclass DummyWorker {\r\n\r\n  responses\r\n  manager\r\n\r\n    constructor(responses) {\r\n        this.responses = responses;\r\n\r\n        this.manager = new CallbackManager()\r\n\r\n    }\r\n\r\n    postMessage=(input)=>{\r\n        let result = this.onmessage({data:input}); \r\n        this.responses.forEach((foo,_) => {\r\n            foo(result);\r\n        });\r\n    }\r\n\r\n    terminate(){}\r\n\r\n    onerror = () => {}\r\n\r\n    onmessage = (event) => {\r\n      // define gpu instance\r\n      //console.log(\"worker executing...\")\r\n      console.time(\"worker\");\r\n      let output = \"function not defined\";\r\n    \r\n      this.manager.callbacks.find((o,_)=>{\r\n        if(o.case === event.data.foo) {\r\n          output = o.callback(event.data.input);\r\n          return true;\r\n        } else return\r\n      });\r\n\r\n      // output some results!\r\n      console.timeEnd(\"worker\");\r\n    \r\n      return {output: output, foo: event.data.foo, origin: event.data.origin};\r\n    \r\n    }\r\n  }","import {WorkerManager} from './WorkerManager'\r\nexport default new WorkerManager(undefined, 1);"],"names":["StateManager","Events","constructor","manager","undefined","state","found","responses","find","foo","name","addCallback","callback","subEvent","eventName","response","output","console","log","subscribeTrigger","unsubEvent","sub","unsubscribeTrigger","addEvent","workerId","functionName","origin","setState","post","input","workers","forEach","w","id","removeEmitter","unsubscribeAllTriggers","emit","transfer","port","WorkerGlobalScope","self","postMessage","msg","export","Math2","TWO_PI","Math","PI","C","G","h","R","Ra","H","kbar","kB","ke","me","mp","mn","P0","T0","p0","Na","y","M0","g0","Re","B","S","Sigma","imgkernels","edgeDetection","boxBlur","sobelLeft","sobelRight","sobelTop","sobelBottom","identity","gaussian3x3","guassian7x7","emboss","sharpen","genSineWave","freq","peakAmp","nSec","fs","freq2","peakAmp2","sineWave","t","increment","ti","amplitude","sin","push","getSineAmplitude","frequency","peakAmplitude","tOffset","mean","arr","sum","reduce","prev","curr","length","mode","sort","a","b","filter","v","pop","std","avg","summed","i","subbed","sqrt","relError","actual","forecast","abs","Error","d","j","dd","informationEntropy","probabilities","entropy","len","ent","isNaN","zscore","z","variance","dot","vec1","vec2","cross3D","magnitude","vec","sqrd","c","distance","point1","point2","dsqrd","normalize","norm","vecn","quadraticFormula","bbmac4","_a2","nb","newtonsMethod","x","pow","start","end","precision","attempts","roots","seedx","random","guess","guess2","slope","xn","step","xn1","idx","f","root","integral","func","range","stepx","area","dintegral","stepy","volume","tintegral","stepz","k","pintegral","y0","yi","makeVec","transpose","mat","map","_","colIndex","row","matmul","aNumRows","aNumCols","bNumRows","bNumCols","m","Array","r","matscale","scalar","matadd","matsub","histogram","binSize","nBins","copy","binStart","min","binEnd","max","binx","biny","binidx","binmin","binmid","normalDistribution","samples","cutoff","vari","nSamples","denom","_variance","px","exp","_sum","expectedValue","item","originMoment","order","centralMoment","linearDiscriminantAnalysis","classifier","meank","covariance","cov1d","probs","dk","log10","conv1D","kern","pad","floor","result","_n","pads","fill","acc","conv2D","ceil","mat_t","kern_t","startr","startl","endr","endl","iters","cov2d","mattransposed","matproducts","rowmeans","colmeans","col","matproductstransposed","arr1","arr2","cov3d","covNd","dimensionalData","eigens2x2","det","eig1","eig2","eigenvectors2x2","eigens","v1","v2","fastpca2d","xarr","yarr","eigs","reverse","evs","crosscorrelation","arr2buf","mean1","mean2","arr1Est","arr2Est","_arrEstsMul","correlations","delay","autocorrelation","delaybuf","_arr1estsqrd","correlograms","dat","row1","row2","sma","window","smaArr","arrslice","slice","previous","current","reduceArrByFactor","factor","element","index","makeArr","startValue","stopValue","nSteps","interpolateArray","data","fitCount","linearInterpolate","before","after","atPoint","newData","springFactor","Number","tmp","toFixed","isExtrema","critical","ref","pass","val","isCriticalPoint","peakDetect","smoothedArray","type","mid","peaks","isPeak","getPeakThreshold","peakIndices","thresholdVar","threshold","filtered","o","indexOf","column","flatten_vector","v_new","squared_difference","shift_deflate","eigenvalue","eigenvector","U","delta","M_new","eigenvalue_of_vector","ev","power_iteration","tolerance","max_iterations","rank","epsilon","iter","old_eigenvalue","JSON","parse","stringify","Mv","eigenvalues","eigenvectors","pca","dims","p","espilon","tp","p_length","t_new","pp","components","p300","event_timestamps","raw_signal","signal_timestamps","sps","smoothingstep","smoothed","p_idx","candidates","tempi","tempcandidates","peakvals","tc","maxi","event_timestamp","event_index","peak_timestamp","signal_index","signal_amplitude","noop","EventDispatcher","addEventListener","listener","_listeners","listeners","hasEventListener","removeEventListener","listenerArray","splice","dispatchEvent","event","target","array","l","call","ElementProxyReceiver","style","clientWidth","width","clientHeight","height","setPointerCapture","releasePointerCapture","getBoundingClientRect","left","top","right","bottom","handleEvent","preventDefault","stopPropagation","focus","ProxyManager","targets","bind","makeProxy","proxy","getProxy","gpuUtils","dynamicImport","url","module","getFunctionBody","methodString","toString","replace","getFunctionHead","fnstring","buildNewFunction","head","body","newFunc","eval","isFunction","string","regex","RegExp","substring","includes","arrow","test","parseFunctionFromText","method","startindex","newFuncHead","newFuncBody","varName","split","Function","CallbackManager","ctx","context","gpu","EVENTS","EVENTSETTINGS","canvas","OffscreenCanvas","ANIMATION","ANIMATIONFUNC","ANIMATING","ANIMFRAMETIME","performance","now","threeUtil","PROXYMANAGER","ID","err","document","callbacks","case","args","list","obj","newCallback","findIndex","Object","keys","key","isArray","__proto__","from","addFunction","addKernel","callKernel","onmessage","eventSetting","checkEvents","ownerDocument","cancelAnimationFrame","THREE","runCallback","setup","draw","clear","animationFunc","anim","emitevent","dict","requestAnimationFrame","setTimeout","time","tselfhis","gpuDFT","MultiChannelDFT","MultiChannelDFT_Bandpass","gpuFFT","MultiChannelFFT","MultiChannelFFT_Bandpass","gpuCoherence","buffer","dfts","cordfts","coherenceResults","nChannels","temp","autoFFTproducts","dft","newdft","amp","removeCallback","foundidx","Promise","all","aliases","user","checkCallbacks","WorkerManager","ProxyElement","eventHandlers","sendEvent","runWorkerFunction","handler","entries","sendSize","rect","mouseEventHandler","makeSendPropertiesHandler","wheelEventHandlerImpl","keydownEventHandler","wheelEventHandler","sendFn","preventDefaultHandler","copyProperties","src","properties","dst","sendProperties","touchEventHandler","touches","touch","pageX","pageY","orbitKeys","filteredKeydownEventHandler","keyCode","initProxyElement","contextmenu","mousedown","mousemove","mouseup","pointerdown","pointermove","pointerup","touchstart","touchmove","touchend","wheel","keydown","ThreadedCanvas","drawFunction","setValues","round","getElementById","offscreen","initWorker","postToWorker","setCanvas","setContext","setAnimation","transferControlToOffscreen","valObject","animationFunction","fstring","addSetup","setupFunction","setThreeAnimation","startThreeAnimation","clearThreeAnimation","values","startAnimation","stopAnimation","setCanvasSize","addWorker","workerResponses","workeronmessage","init","deinit","terminate","createElement","insertAdjacentElement","drawFunc","font","fillText","worker","threads","threadrot","events","toResolve","nThreads","getWorker","newWorker","URL","import","meta","Worker","DummyWorker","callbackId","onerror","e","error","nameOrIdx","addWorkerFunction","run","prop","runFunction","establishMessageChannel","worker1Id","worker2Id","worker2Response","channel","MessageChannel","port1","port2","resolve","resolver","res","close","timeEnd"],"sourceRoot":""}